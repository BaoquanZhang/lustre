Index: iam/fs/ext3/namei.c
===================================================================
--- iam.orig/fs/ext3/namei.c
+++ iam/fs/ext3/namei.c
@@ -82,13 +82,16 @@
  *
  * Entries in index node are sorted by their key value.
  *
+ * Format of leaf node:
  *
- *
- *
- *
- *
- *
- *
+ * +-----+-------+-------+-------+------+-------+------------+
+ * |     | count |       |       |      |       |            |
+ * | gap |   /   | leaf  | leaf  | .... | leaf  | free space |
+ * |     | limit |       |       |      |       |            |
+ * +-----+-------+-------+-------+------+-------+------------+
+
+ *       leaf          For leaf entry: consists of a rec immediately followd by 
+ *                     a key. size of a key and size of a rec depends on container.  
  *
  *
  *
@@ -96,6 +99,7 @@
  *
  */
 
+#include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 #include <linux/jbd.h>
@@ -111,7 +115,7 @@
 #include "xattr.h"
 #include "iopen.h"
 #include "acl.h"
-
+#include <linux/lustre_iam.h>
 /*
  * define how far ahead to read directories while searching them.
  */
@@ -120,13 +124,6 @@
 #define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)
 #define NAMEI_RA_INDEX(c,b)  (((c) * NAMEI_RA_BLOCKS) + (b))
 
-/*
- * Maximal number of non-leaf levels in htree. In the stock ext3 this is 2.
- */
-enum {
-	DX_MAX_TREE_HEIGHT = 5,
-	DX_SCRATCH_KEYS    = 2
-};
 
 static struct buffer_head *ext3_append(handle_t *handle,
 					struct inode *inode,
@@ -205,194 +202,6 @@ struct dx_map_entry
 	u32 offs;
 };
 
-/*
- * Entry within index tree node. Consists of a key immediately followed
- * (without padding) by a pointer to the child node.
- *
- * Both key and pointer are of variable size, hence incomplete type.
- */
-struct iam_entry;
-
-struct iam_entry_compat {
-	__le32 hash;
-	__le32 block;
-};
-
-/*
- * Incomplete type used to refer to keys in iam container.
- *
- * As key size can be different from container to container, iam has to use
- * incomplete type. Clients cast pointer to iam_key to real key type and back.
- */
-struct iam_key;
-
-/* Incomplete type use to refer to the records stored in iam containers. */
-struct iam_rec;
-
-typedef __u64 iam_ptr_t;
-
-/*
- * Index node traversed during tree lookup.
- */
-struct iam_frame {
-	struct buffer_head *bh;    /* buffer holding node data */
-	struct iam_entry *entries; /* array of entries */
-	struct iam_entry *at;      /* target entry, found by binary search */
-};
-
-/* leaf node reached by tree lookup */
-struct iam_leaf {
-	struct buffer_head *bh;
-	struct iam_leaf_entry *entries;
-	struct iam_leaf_entry *at;
-};
-
-struct iam_path;
-struct iam_container;
-
-/*
- * Parameters, describing a flavor of iam container.
- */
-struct iam_descr {
-	/*
-	 * Size of a key in this container, in bytes.
-	 */
- 	size_t       id_key_size;
-	/*
-	 * Size of a pointer to the next level (stored in index nodes), in
-	 * bytes.
-	 */
-	size_t       id_ptr_size;
-	/*
-	 * Size of a record (stored in leaf nodes), in bytes.
-	 */
-	size_t       id_rec_size;
-	/*
-	 * Size of unused (by iam) space at the beginning of every non-root
-	 * node, in bytes. Used for compatibility with ext3.
-	 */
-	size_t       id_node_gap;
-	/*
-	 * Size of unused (by iam) space at the beginning of root node, in
-	 * bytes. Used for compatibility with ext3.
-	 */
-	size_t       id_root_gap;
-
-	/*
-	 * Returns pointer (in the same sense as pointer in index entry) to
-	 * the root node.
-	 */
-	__u32 (*id_root_ptr)(struct iam_container *c);
-
-	/*
-	 * Check validity and consistency of index node. This is called when
-	 * iam just loaded new node into frame.
-	 */
-	int (*id_node_check)(struct iam_path *path, struct iam_frame *frame);
-	/*
-	 * Initialize new node (stored in @bh) that is going to be added into
-	 * tree.
-	 */
-	int (*id_node_init)(struct iam_container *c,
-			    struct buffer_head *bh, int root);
-	int (*id_node_read)(struct iam_container *c, iam_ptr_t ptr,
-			    handle_t *h, struct buffer_head **bh);
-	/*
-	 * Key comparison function. Returns -1, 0, +1.
-	 */
-	int (*id_keycmp)(struct iam_container *c,
-			 struct iam_key *k1, struct iam_key *k2);
-	/*
-	 * Create new container.
-	 *
-	 * Newly created container has a root node and a single leaf. Leaf
-	 * contains single record with the smallest possible key.
-	 */
-	int (*id_create)(struct iam_container *c);
-	struct {
-		/*
-		 * leaf operations.
-		 */
-		/*
-		 * returns true iff leaf is positioned at the last entry.
-		 */
-		int (*at_end)(struct iam_container *c, struct iam_leaf *l);
-		/* position leaf at the first entry */
-		void (*start)(struct iam_container *c, struct iam_leaf *l);
-		/* more leaf to the next entry. */
-		void (*next)(struct iam_container *c, struct iam_leaf *l);
-		/* return key of current leaf record in @k */
-		void (*key)(struct iam_container *c, struct iam_leaf *l,
-			    struct iam_key *k);
-		/* return pointer to entry body */
-		struct iam_rec *(*rec)(struct iam_container *c,
-				       struct iam_leaf *l);
-	} id_leaf;
-};
-
-struct iam_container {
-	/*
-	 * Underlying flat file. IO against this object is issued to
-	 * read/write nodes.
-	 */
-	struct inode     *ic_object;
-	/*
-	 * container flavor.
-	 */
-	struct iam_descr *ic_descr;
-	/*
-	 * pointer to flavor-specific per-container data.
-	 */
-	void             *ic_descr_data;
-};
-
-/*
- * Structure to keep track of a path drilled through htree.
- */
-struct iam_path {
-	/*
-	 * Parent container.
-	 */
-	struct iam_container  *ip_container;
-	/*
-	 * Number of index levels minus one.
-	 */
-	int                    ip_indirect;
-	/*
-	 * Nodes that top-to-bottom traversal passed through.
-	 */
-	struct iam_frame       ip_frames[DX_MAX_TREE_HEIGHT];
-	/*
-	 * Last filled frame in ->ip_frames. Refers to the 'twig' node (one
-	 * immediately above leaf).
-	 */
-	struct iam_frame      *ip_frame;
-	/*
-	 * Leaf node: a child of ->ip_frame.
-	 */
-	struct iam_leaf       *ip_leaf;
-	/*
-	 * Key searched for.
-	 */
-	struct iam_key        *ip_key_target;
-	/*
-	 * Scratch-pad area for temporary keys.
-	 */
-	struct iam_key        *ip_key_scratch[DX_SCRATCH_KEYS];
-	/*
-	 * pointer to flavor-specific per-container data.
-	 */
-	void                  *ip_descr_data;
-};
-
-/*
- * Helper structure for legacy htrees.
- */
-struct iam_path_compat {
-	struct iam_path      ipc_path;
-	struct iam_container ipc_container;
-	__u32                ipc_scrach[DX_SCRATCH_KEYS];
-};
 
 static u32 htree_root_ptr(struct iam_container *c);
 static int htree_node_check(struct iam_path *path, struct iam_frame *frame);
@@ -427,58 +236,7 @@ struct iam_descr;
 struct iam_container;
 struct iam_path;
 
-/*
- * Initialize container @c, acquires additional reference on @inode.
- */
-int iam_container_init(struct iam_container *c,
-		       struct iam_descr *descr, struct inode *inode);
-/*
- * Finalize container @c, release all resources.
- */
-void iam_container_fini(struct iam_container *c);
 
-/*
- * Search container @c for record with key @k. If record is found, its data
- * are moved into @r.
- *
- *
- *
- * Return values: +ve: found, 0: not-found, -ve: error
- */
-int iam_lookup(struct iam_container *c, struct iam_key *k, struct iam_rec *r);
-/*
- * Insert new record @r with key @k into container @c (within context of
- * transaction @h.
- *
- * Return values: 0: success, -ve: error, including -EEXIST when record with
- * given key is already present.
- *
- * postcondition: ergo(result == 0 || result == -EEXIST,
- *                                  iam_lookup(c, k, r2) > 0 &&
- *                                  !memcmp(r, r2, c->ic_descr->id_rec_size));
- */
-int iam_insert(handle_t *h, struct iam_container *c,
-	       struct iam_key *k, struct iam_rec *r);
-/*
- * Replace existing record with key @k, or insert new one. New record data are
- * in @r.
- *
- * Return values: 0: success, -ve: error.
- *
- * postcondition: ergo(result == 0, iam_lookup(c, k, r2) > 0 &&
- *                                  !memcmp(r, r2, c->ic_descr->id_rec_size));
- */
-int iam_update(handle_t *h, struct iam_container *c,
-	       struct iam_key *k, struct iam_rec *r);
-/*
- * Delete existing record with key @k.
- *
- * Return values: 0: success, -ENOENT: not-found, -ve: other error.
- *
- * postcondition: ergo(result == 0 || result == -ENOENT,
- *                                 !iam_lookup(c, k, *));
- */
-int iam_delete(handle_t *h, struct iam_container *c, struct iam_key *k);
 
 /*
  * iam cursor (iterator) api.
@@ -508,6 +266,11 @@ enum iam_it_state {
 	IAM_IT_ATTACHED
 };
 
+struct htree_cookie {
+	struct dx_hash_info *hinfo;
+	struct dentry       *dentry;
+};
+
 /*
  * Iterator.
  *
@@ -704,7 +467,7 @@ static int ext3_dx_add_entry(handle_t *h
 			     struct inode *inode);
 
 static inline void iam_path_init(struct iam_path *path,
-				 struct iam_container *c);
+				 struct iam_container *c, struct htree_cookie *hc);
 static inline void iam_path_fini(struct iam_path *path);
 
 
@@ -865,11 +628,6 @@ static u32 htree_root_ptr(struct iam_con
 	return 0;
 }
 
-struct htree_cookie {
-	struct dx_hash_info *hinfo;
-	struct dentry       *dentry;
-};
-
 static int htree_node_check(struct iam_path *path, struct iam_frame *frame)
 {
 	void *data;
@@ -1171,11 +929,13 @@ void iam_container_fini(struct iam_conta
 	}
 }
 
-static inline void iam_path_init(struct iam_path *path, struct iam_container *c)
+static inline void iam_path_init(struct iam_path *path, struct iam_container *c, 
+				 struct htree_cookie *hc)
 {
 	memset(path, 0, sizeof *path);
 	path->ip_container = c;
 	path->ip_frame = path->ip_frames;
+	path->ip_descr_data = hc;
 }
 
 static inline void iam_path_fini(struct iam_path *path)
@@ -1201,7 +961,7 @@ static void iam_path_compat_init(struct 
 	 * iam_path_fini().
 	 */
 	iput(inode);
-	iam_path_init(&path->ipc_path, &path->ipc_container);
+	iam_path_init(&path->ipc_path, &path->ipc_container, NULL);
 	for (i = 0; i < ARRAY_SIZE(path->ipc_path.ip_key_scratch); ++i)
 		path->ipc_path.ip_key_scratch[i] =
 			(struct iam_key *)&path->ipc_scrach[i];
@@ -1213,6 +973,425 @@ static void iam_path_compat_fini(struct 
 	iam_container_fini(&path->ipc_container);
 }
 
+static int iam_leaf_init(struct iam_path *path, struct iam_leaf *leaf)
+{
+	int block, err;
+	struct buffer_head *bh;
+	
+	block = dx_get_block(path, path->ip_frame->at);
+	err = path_descr(path)->id_node_read(path->ip_container, block, 
+				             NULL, &bh);
+	if (err)
+		return err;
+
+	leaf->bh = bh;
+	leaf->entries = (struct iam_leaf_entry *)bh->b_data;
+	return 0;
+}
+
+static void iam_leaf_fini(struct iam_leaf *leaf)
+{
+	if (leaf->bh)
+		brelse(leaf->bh);
+}
+
+/*
+ * Search container @c for record with key @k. If record is found, its data
+ * are moved into @r.
+ *
+ *
+ *
+ * Return values: +ve: found, 0: not-found, -ve: error
+ */
+
+int iam_lookup(struct iam_container *c, struct iam_key *k, struct iam_rec *r)
+{
+	struct dx_hash_info	hinfo;
+	struct iam_path_compat cpath;
+	struct iam_path *path = &cpath.ipc_path;
+	struct htree_cookie hc = {
+		.hinfo  = &hinfo
+	};
+	int err, i;
+
+	iam_path_init(path, c, &hc);
+	for (i = 0; i < ARRAY_SIZE(path->ip_key_scratch); ++i)
+		path->ip_key_scratch[i] =
+			(struct iam_key *)&cpath.ipc_scrach[i];
+	err = dx_lookup(path);
+	do {
+		struct iam_leaf leaf;
+		err = iam_leaf_init(path, &leaf);
+		if (err)
+			goto errout;
+
+		for (path_descr(path)->id_leaf.start(c, &leaf);
+		     !path_descr(path)->id_leaf.at_end(c, &leaf);
+		     path_descr(path)->id_leaf.next(c, &leaf)) {
+			struct iam_key *key;
+
+			key = kmalloc(path_descr(path)->id_key_size, GFP_KERNEL);
+			path_descr(path)->id_leaf.key(c, &leaf, key);
+			if (keycmp(c, k, key) == 0) {
+				memcpy(r, path_descr(path)->id_leaf.rec(c, &leaf),
+				       path_descr(path)->id_rec_size);
+				iam_path_fini(path);
+				iam_leaf_fini(&leaf);
+				return 0;
+			}
+		}
+
+		iam_leaf_fini(&leaf);
+		/* Check to see if we should continue to search */
+		err = ext3_htree_next_block(c->ic_object, hinfo.hash, path, NULL);
+		if (err < 0)
+			goto errout;
+	} while (err == 1);
+errout:
+	iam_path_fini(path);
+	return(err);
+}
+EXPORT_SYMBOL(iam_lookup);
+
+static inline size_t iam_leaf_entry_size(struct iam_path *p)
+{
+	return path_descr(p)->id_rec_size + path_descr(p)->id_key_size;
+}
+
+static inline ptrdiff_t iam_leaf_entry_diff(struct iam_path *p,
+				      struct iam_leaf_entry *e1, struct iam_leaf_entry *e2)
+{
+	ptrdiff_t diff;
+
+	diff = (void *)e1 - (void *)e2;
+	assert(diff / iam_leaf_entry_size(p) * iam_leaf_entry_size(p) == diff);
+	return diff / iam_leaf_entry_size(p);
+}
+
+static inline struct iam_leaf_entry* 
+iam_leaf_entry_shift(struct iam_path *p, struct iam_leaf_entry *entry, int shift)
+{
+	void *e = entry;
+	return e + shift * iam_leaf_entry_size(p);
+}
+
+static inline struct iam_key *
+dx_leaf_get_key(struct iam_path *p, struct iam_leaf_entry *e, struct iam_key *key)
+{
+	memcpy(key, e, path_descr(p)->id_key_size);
+	return key;
+}
+
+static inline struct iam_key *
+iam_leaf_key_at(struct iam_path *p, struct iam_leaf_entry *entry)
+{
+	void *e = entry;
+	return e + path_descr(p)->id_rec_size;
+}
+static inline struct iam_leaf_entry *
+iam_leaf_entry_at(struct iam_path *p, struct iam_leaf_entry *entry)
+{
+	return entry; 
+}
+
+static int iam_leaf_lookup(struct iam_path *path, struct iam_leaf *leaf, 
+			   struct iam_key *k)
+{
+	struct iam_leaf_entry *p, *q, *m;
+	struct iam_leaf_entry *entries = leaf->entries;
+	int count = dx_get_count((struct iam_entry *)entries);
+	
+	p = iam_leaf_entry_shift(path, entries, 1);
+	q = iam_leaf_entry_shift(path, entries, count - 1);
+	while (p <= q) {
+		m = iam_leaf_entry_shift(path,
+				   p, iam_leaf_entry_diff(path, q, p) / 2);
+		dxtrace(printk("."));
+		if (keycmp(path->ip_container, iam_leaf_key_at(path, m),
+			   path->ip_key_target) > 0)
+			q = iam_leaf_entry_shift(path, m, -1);
+		else
+			p = iam_leaf_entry_shift(path, m, +1);
+	}
+	leaf->at = q; 
+	return 0;
+}
+
+/*XXX what kind of lock should this entry be locked: WangDi */
+static int iam_leaf_insert(handle_t *handle, struct iam_path *path, 
+			   struct iam_key *k, struct iam_rec *r)
+{
+	struct iam_leaf leaf;
+	struct iam_leaf_entry *p, *q;
+	int err, count;
+
+	err = iam_leaf_init(path, &leaf);
+	if (err)
+		goto errout;
+	path_descr(path)->id_leaf.start(path->ip_container, &leaf);
+	count = dx_get_count((struct iam_entry *)leaf.entries);
+	if (dx_get_count((struct iam_entry *)leaf.entries) >= 
+	    dx_get_limit((struct iam_entry *)leaf.entries)){
+		err = -ENOSPC;
+		goto errout;
+	}
+
+	err = iam_leaf_lookup(path, &leaf, k);
+	if (err)
+		goto errout;
+	
+	/*insert the k/r to leaf entries*/
+	p = iam_leaf_entry_shift(path, leaf.at, 1);
+	q = iam_leaf_entry_shift(path, leaf.entries, count - 1);
+	while (q < p) {
+		memcpy(iam_leaf_entry_shift(path, q, 1), q, iam_leaf_entry_size(path));
+		q = iam_leaf_entry_shift(path, q, -1); 	
+	}
+	memcpy(iam_leaf_entry_at(path, p), r, path_descr(path)->id_rec_size);
+	memcpy(iam_leaf_key_at(path, p), k, path_descr(path)->id_key_size);
+
+	dx_set_count((struct iam_entry*)leaf.entries, count + 1);
+	err = ext3_journal_dirty_metadata(handle, leaf.bh);
+	if (err)
+		ext3_std_error(path->ip_container->ic_object->i_sb, err);
+errout:	
+	iam_leaf_fini(&leaf);
+	return err;
+} 
+
+static int split_leaf_node(handle_t *handle, struct iam_path *path)
+{
+	struct inode *dir = path_obj(path);
+	unsigned continued = 0;
+	struct buffer_head *bh2;
+	u32 newblock, hash_split;
+	char *data2;
+	struct iam_leaf leaf;
+	unsigned split;
+	int	err;
+
+	bh2 = ext3_append (handle, dir, &newblock, &err);
+	if (!(bh2)) {
+		err = -ENOSPC;
+		goto errout;
+	}
+	err = iam_leaf_init(path, &leaf);
+	if (err)
+		goto errout;
+
+	BUFFER_TRACE(leaf.bh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, leaf.bh);
+	if (err) {
+	journal_error:
+		iam_leaf_fini(&leaf);
+		brelse(bh2);
+		ext3_std_error(dir->i_sb, err);
+		err = -EIO;
+		goto errout;
+	}
+	data2 = bh2->b_data;
+	split = dx_get_count((struct iam_entry*)leaf.entries)/2;
+	hash_split = *(__u32*)iam_leaf_key_at(path, iam_leaf_entry_shift(path, leaf.entries, split));
+	if (keycmp(path->ip_container, iam_leaf_key_at(path, iam_leaf_entry_shift(path, leaf.entries, split)),
+		   iam_leaf_key_at(path, iam_leaf_entry_shift(path, leaf.entries, split -1))) == 0)
+		continued = 1;
+
+	memcpy(iam_leaf_entry_shift(path, (struct iam_leaf_entry *)data2, 1),
+	       iam_leaf_entry_shift(path, leaf.entries, split),
+	       split * iam_leaf_entry_size(path));
+ 
+	/* Which block gets the new entry? */
+	dx_insert_block(path, path->ip_frame, hash_split + continued, newblock);
+	err = ext3_journal_dirty_metadata (handle, bh2);
+	if (err)
+		goto journal_error;
+	err = ext3_journal_dirty_metadata (handle, leaf.bh);
+	if (err)
+		goto journal_error;
+	brelse (bh2);
+	iam_leaf_fini(&leaf);
+errout:
+	return err;
+}
+
+static int split_index_node(handle_t *handle, struct iam_path *path);
+/*
+ * Insert new record @r with key @k into container @c (within context of
+ * transaction @h.
+ *
+ * Return values: 0: success, -ve: error, including -EEXIST when record with
+ * given key is already present.
+ *
+ * postcondition: ergo(result == 0 || result == -EEXIST,
+ *                                  iam_lookup(c, k, r2) > 0 &&
+ *                                  !memcmp(r, r2, c->ic_descr->id_rec_size));
+ */
+int iam_insert(handle_t *handle, struct iam_container *c, struct iam_key *k, 
+	       struct iam_rec *r)
+{
+	struct dx_hash_info	hinfo;
+	struct iam_path_compat cpath;
+	struct iam_path *path = &cpath.ipc_path;
+	struct htree_cookie hc = {
+		.hinfo  = &hinfo
+	};
+	int err, i;
+
+	iam_path_init(path, c, &hc);
+	for (i = 0; i < ARRAY_SIZE(path->ip_key_scratch); ++i)
+		path->ip_key_scratch[i] =
+			(struct iam_key *)&cpath.ipc_scrach[i];
+	err = dx_lookup(path);
+	if (err)
+		goto errout; 
+
+	err = iam_leaf_insert(handle, path, k, r);
+	
+	if (err != -ENOSPC) 
+		goto errout;	
+
+	err = split_index_node(handle, path);
+	if (err)
+		goto errout;	
+
+	err = split_leaf_node(handle, path);
+	if (err)
+		goto errout;
+	
+	err = iam_leaf_insert(handle, path, k, r);
+errout:
+	iam_path_fini(path);
+	return(err);
+}
+
+EXPORT_SYMBOL(iam_insert);
+static int iam_leaf_delete(handle_t *handle, struct iam_path *path, 
+			   struct iam_key *k)
+{
+	struct iam_leaf leaf;
+	struct iam_leaf_entry *p, *q;
+	int err, count;
+
+	err = iam_leaf_init(path, &leaf);
+	if (err)
+		goto errout;
+	
+	err = iam_leaf_lookup(path, &leaf, k);
+	if (err)
+		goto errout;
+
+	count = dx_get_count((struct iam_entry*)leaf.entries);
+	/*delete the k to leaf entries*/
+	p = iam_leaf_entry_shift(path, leaf.at, 1);
+	q = iam_leaf_entry_shift(path, leaf.entries, count - 1);
+	while (p < q) {
+		memcpy(p, iam_leaf_entry_shift(path, p, 1), iam_leaf_entry_size(path));
+		p = iam_leaf_entry_shift(path, p, 1);
+	}
+	dx_set_count((struct iam_entry*)leaf.entries, count - 1);
+
+	err = ext3_journal_dirty_metadata(handle, leaf.bh);
+	if (err)
+		ext3_std_error(path_obj(path)->i_sb, err);
+errout:	
+	iam_leaf_fini(&leaf);
+	return err;
+}
+
+/*
+ * Delete existing record with key @k.
+ *
+ * Return values: 0: success, -ENOENT: not-found, -ve: other error.
+ *
+ * postcondition: ergo(result == 0 || result == -ENOENT,
+ *                                 !iam_lookup(c, k, *));
+ */
+int iam_delete(handle_t *h, struct iam_container *c, struct iam_key *k)
+{
+	struct dx_hash_info	hinfo;
+	struct iam_path_compat cpath;
+	struct iam_path *path = &cpath.ipc_path;
+	struct htree_cookie hc = {
+		.hinfo  = &hinfo
+	};
+	int err, i;
+
+	iam_path_init(path, c, &hc);
+	for (i = 0; i < ARRAY_SIZE(path->ip_key_scratch); ++i)
+		path->ip_key_scratch[i] =
+			(struct iam_key *)&cpath.ipc_scrach[i];
+	err = dx_lookup(path);
+	if (err)
+		goto errout; 
+
+	err = iam_leaf_delete(h, path, k);
+errout:
+	iam_path_fini(path);
+	return err;
+}
+
+EXPORT_SYMBOL(iam_delete);
+
+static int iam_leaf_update(handle_t *handle, struct iam_path *path, 
+			   struct iam_key *k, struct iam_rec *r)
+{
+	struct iam_leaf leaf;
+	int err;
+
+	err = iam_leaf_init(path, &leaf);
+	if (err)
+		goto errout;
+	
+	err = iam_leaf_lookup(path, &leaf, k);
+	if (err)
+		goto errout;
+
+	memcpy(iam_leaf_entry_at(path, leaf.at), r, path_descr(path)->id_rec_size);
+	memcpy(iam_leaf_key_at(path, leaf.at), k, path_descr(path)->id_key_size);
+
+	err = ext3_journal_dirty_metadata(handle, leaf.bh);
+	if (err)
+		ext3_std_error(path_obj(path)->i_sb, err);
+errout:	
+	iam_leaf_fini(&leaf);
+	return err;
+}
+/*
+ * Replace existing record with key @k, or insert new one. New record data are
+ * in @r.
+ *
+ * Return values: 0: success, -ve: error.
+ *
+ * postcondition: ergo(result == 0, iam_lookup(c, k, r2) > 0 &&
+ *                                  !memcmp(r, r2, c->ic_descr->id_rec_size));
+ */
+int iam_update(handle_t *h, struct iam_container *c,
+	       struct iam_key *k, struct iam_rec *r)
+{
+	struct dx_hash_info	hinfo;
+	struct iam_path_compat cpath;
+	struct iam_path *path = &cpath.ipc_path;
+	struct htree_cookie hc = {
+		.hinfo  = &hinfo
+	};
+	int err, i;
+	
+	iam_path_init(path, c, &hc);
+	for (i = 0; i < ARRAY_SIZE(path->ip_key_scratch); ++i)
+		path->ip_key_scratch[i] =
+			(struct iam_key *)&cpath.ipc_scrach[i];
+	err = dx_lookup(path);
+	if (err)
+		goto errout; 
+
+	err = iam_leaf_update(h, path, k, r);
+errout:
+	iam_path_fini(path);
+	return err;
+}
+
+EXPORT_SYMBOL(iam_update);
+
 /*
  * This function increments the frame pointer to search the next leaf
  * block, and reads in the necessary intervening nodes if the search
@@ -2245,59 +2424,21 @@ static int ext3_add_entry (handle_t *han
 }
 
 #ifdef CONFIG_EXT3_INDEX
-/*
- * Returns 0 for success, or a negative error value
- */
-static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,
-			     struct inode *inode)
+static int split_index_node(handle_t *handle, struct iam_path *path)
 {
-	struct iam_path_compat cpath;
-	struct iam_path *path = &cpath.ipc_path;
-	struct iam_descr *param;
-	struct iam_frame *frame, *safe;
+
 	struct iam_entry *entries;   /* old block contents */
 	struct iam_entry *entries2;  /* new block contents */
-	struct dx_hash_info hinfo;
-	struct buffer_head * bh;
+ 	struct iam_frame *frame, *safe;
 	struct buffer_head *bh_new[DX_MAX_TREE_HEIGHT] = {0};
-	struct inode *dir = dentry->d_parent->d_inode;
-	struct super_block * sb = dir->i_sb;
-	struct ext3_dir_entry_2 *de;
 	u32 newblock[DX_MAX_TREE_HEIGHT] = {0};
-	int err;
+	struct inode *dir = path_obj(path);
 	int nr_splet;
-	int i;
-	size_t isize;
-
-	iam_path_compat_init(&cpath, dir);
-	param = path_descr(path);
+	int i, err;
 
-	err = dx_probe(dentry, NULL, &hinfo, path);
-	if (err != 0)
-		return err;
 	frame = path->ip_frame;
 	entries = frame->entries;
 
-	/* XXX nikita: global serialization! */
-	isize = dir->i_size;
-
-	err = param->id_node_read(path->ip_container, 
-				  (iam_ptr_t)dx_get_block(path, 
-				  frame->at), handle, &bh);
-	if (err != 0)
-		goto cleanup;
-
-	BUFFER_TRACE(bh, "get_write_access");
-	err = ext3_journal_get_write_access(handle, bh);
-	if (err)
-		goto journal_error;
-
-	err = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
-	if (err != -ENOSPC) {
-		bh = NULL;
-		goto cleanup;
-	}
-
 	/*
 	 * Tall-tree handling: we might have to split multiple index blocks
 	 * all the way up to tree root. Tricky point here is error handling:
@@ -2320,7 +2461,7 @@ static int ext3_dx_add_entry(handle_t *h
 	     dx_get_count(frame->entries) == dx_get_limit(frame->entries);
 	     --frame, ++nr_splet) {
 		if (nr_splet == DX_MAX_TREE_HEIGHT) {
-			ext3_warning(sb, __FUNCTION__,
+			ext3_warning(dir->i_sb, __FUNCTION__,
 				     "Directory index full!\n");
 			err = -ENOSPC;
 			goto cleanup;
@@ -2333,7 +2474,7 @@ static int ext3_dx_add_entry(handle_t *h
 	for (frame = safe + 1, i = 0; i < nr_splet; ++i, ++frame) {
 		bh_new[i] = ext3_append (handle, dir, &newblock[i], &err);
 		if (!bh_new[i] ||
-		    param->id_node_init(path->ip_container, bh_new[i], 0) != 0)
+		    path_descr(path)->id_node_init(path->ip_container, bh_new[i], 0) != 0)
 			goto cleanup;
 		BUFFER_TRACE(frame->bh, "get_write_access");
 		err = ext3_journal_get_write_access(handle, frame->bh);
@@ -2439,9 +2580,71 @@ static int ext3_dx_add_entry(handle_t *h
 				goto journal_error;
 		}
 	}
+	goto cleanup;
+journal_error:
+	ext3_std_error(dir->i_sb, err);
+
+cleanup:
+	for (i = 0; i < ARRAY_SIZE(bh_new); ++i) {
+		if (bh_new[i] != NULL)
+			brelse(bh_new[i]);
+	}
+	return err;
+}
+
+/*
+ * Returns 0 for success, or a negative error value
+ */
+static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,
+			     struct inode *inode)
+{
+	struct iam_path_compat cpath;
+	struct iam_path *path = &cpath.ipc_path;
+	struct iam_descr *param;
+	struct iam_frame *frame;
+	struct dx_hash_info hinfo;
+	struct buffer_head * bh = NULL;
+	struct inode *dir = dentry->d_parent->d_inode;
+	struct ext3_dir_entry_2 *de;
+	int err;
+	size_t isize;
+
+	iam_path_compat_init(&cpath, dir);
+	param = path_descr(path);
+
+	err = dx_probe(dentry, NULL, &hinfo, path);
+	if (err != 0)
+		return err;
+	frame = path->ip_frame;
+
+	/* XXX nikita: global serialization! */
+	isize = dir->i_size;
+
+	err = param->id_node_read(path->ip_container, (iam_ptr_t)dx_get_block(path, frame->at), 
+				  handle, &bh);
+	if (err != 0)
+		goto cleanup;
+
+	BUFFER_TRACE(bh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, bh);
+	if (err)
+		goto journal_error;
+
+	err = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
+	if (err != -ENOSPC) {
+		bh = NULL;
+		goto cleanup;
+	}
+	
+	err = split_index_node(handle, path);
+	if (err)
+		goto cleanup;	
+
+	/*copy split inode too*/
 	de = do_split(handle, path, &bh, --frame, &hinfo, &err);
 	if (!de)
 		goto cleanup;
+
 	assert(dx_node_check(path, frame));
 	err = add_dirent_to_buf(handle, dentry, inode, de, bh);
 	goto cleanup2;
@@ -2452,10 +2655,6 @@ cleanup:
 	if (bh)
 		brelse(bh);
 cleanup2:
-	for (i = 0; i < ARRAY_SIZE(bh_new); ++i) {
-		if (bh_new[i] != NULL)
-			brelse(bh_new[i]);
-	}
 	if (err)
 		inode->i_size = isize;
 	iam_path_fini(path);
Index: iam/include/linux/lustre_iam.h
===================================================================
--- iam.orig/include/linux/lustre_iam.h
+++ iam/include/linux/lustre_iam.h
@@ -0,0 +1,212 @@
+/*
+ * Maximal number of non-leaf levels in htree. In the stock ext3 this is 2.
+ */
+enum {
+	DX_MAX_TREE_HEIGHT = 5,
+	DX_SCRATCH_KEYS    = 2
+};
+
+/*
+ * Entry within index tree node. Consists of a key immediately followed
+ * (without padding) by a pointer to the child node.
+ *
+ * Both key and pointer are of variable size, hence incomplete type.
+ */
+struct iam_entry;
+
+struct iam_entry_compat {
+	__le32 hash;
+	__le32 block;
+};
+
+/*
+ * Incomplete type used to refer to keys in iam container.
+ *
+ * As key size can be different from container to container, iam has to use
+ * incomplete type. Clients cast pointer to iam_key to real key type and back.
+ */
+struct iam_key;
+
+/* Incomplete type use to refer to the records stored in iam containers. */
+struct iam_rec;
+
+typedef __u64 iam_ptr_t;
+
+/*
+ * Index node traversed during tree lookup.
+ */
+struct iam_frame {
+	struct buffer_head *bh;    /* buffer holding node data */
+	struct iam_entry *entries; /* array of entries */
+	struct iam_entry *at;      /* target entry, found by binary search */
+};
+
+/* leaf node reached by tree lookup */
+#define iam_leaf_entry iam_rec
+struct iam_leaf {
+	struct buffer_head *bh;
+	struct iam_leaf_entry *entries;
+	struct iam_leaf_entry *at;
+};
+
+struct iam_path;
+struct iam_container;
+
+/*
+ * Parameters, describing a flavor of iam container.
+ */
+struct iam_descr {
+	/*
+	 * Size of a key in this container, in bytes.
+	 */
+ 	size_t       id_key_size;
+	/*
+	 * Size of a pointer to the next level (stored in index nodes), in
+	 * bytes.
+	 */
+	size_t       id_ptr_size;
+	/*
+	 * Size of a record (stored in leaf nodes), in bytes.
+	 */
+	size_t       id_rec_size;
+	/*
+	 * Size of unused (by iam) space at the beginning of every non-root
+	 * node, in bytes. Used for compatibility with ext3.
+	 */
+	size_t       id_node_gap;
+	/*
+	 * Size of unused (by iam) space at the beginning of root node, in
+	 * bytes. Used for compatibility with ext3.
+	 */
+	size_t       id_root_gap;
+
+	/*
+	 * Returns pointer (in the same sense as pointer in index entry) to
+	 * the root node.
+	 */
+	__u32 (*id_root_ptr)(struct iam_container *c);
+
+	/*
+	 * Check validity and consistency of index node. This is called when
+	 * iam just loaded new node into frame.
+	 */
+	int (*id_node_check)(struct iam_path *path, struct iam_frame *frame);
+	/*
+	 * Initialize new node (stored in @bh) that is going to be added into
+	 * tree.
+	 */
+	int (*id_node_init)(struct iam_container *c,
+			    struct buffer_head *bh, int root);
+	int (*id_node_read)(struct iam_container *c, iam_ptr_t ptr,
+			    handle_t *h, struct buffer_head **bh);
+	/*
+	 * Key comparison function. Returns -1, 0, +1.
+	 */
+	int (*id_keycmp)(struct iam_container *c,
+			 struct iam_key *k1, struct iam_key *k2);
+	/*
+	 * Create new container.
+	 *
+	 * Newly created container has a root node and a single leaf. Leaf
+	 * contains single record with the smallest possible key.
+	 */
+	int (*id_create)(struct iam_container *c);
+	struct {
+		/*
+		 * leaf operations.
+		 */
+		/*
+		 * returns true iff leaf is positioned at the last entry.
+		 */
+		int (*at_end)(struct iam_container *c, struct iam_leaf *l);
+		/* position leaf at the first entry */
+		void (*start)(struct iam_container *c, struct iam_leaf *l);
+		/* more leaf to the next entry. */
+		void (*next)(struct iam_container *c, struct iam_leaf *l);
+		/* return key of current leaf record in @k */
+		void (*key)(struct iam_container *c, struct iam_leaf *l,
+			    struct iam_key *k);
+		/* return pointer to entry body */
+		struct iam_rec *(*rec)(struct iam_container *c,
+				       struct iam_leaf *l);
+	} id_leaf;
+};
+
+struct iam_container {
+	/*
+	 * Underlying flat file. IO against this object is issued to
+	 * read/write nodes.
+	 */
+	struct inode     *ic_object;
+	/*
+	 * container flavor.
+	 */
+	struct iam_descr *ic_descr;
+	/*
+	 * pointer to flavor-specific per-container data.
+	 */
+	void             *ic_descr_data;
+};
+
+/*
+ * Structure to keep track of a path drilled through htree.
+ */
+struct iam_path {
+	/*
+	 * Parent container.
+	 */
+	struct iam_container  *ip_container;
+	/*
+	 * Number of index levels minus one.
+	 */
+	int                    ip_indirect;
+	/*
+	 * Nodes that top-to-bottom traversal passed through.
+	 */
+	struct iam_frame       ip_frames[DX_MAX_TREE_HEIGHT];
+	/*
+	 * Last filled frame in ->ip_frames. Refers to the 'twig' node (one
+	 * immediately above leaf).
+	 */
+	struct iam_frame      *ip_frame;
+	/*
+	 * Leaf node: a child of ->ip_frame.
+	 */
+	struct iam_leaf       *ip_leaf;
+	/*
+	 * Key searched for.
+	 */
+	struct iam_key        *ip_key_target;
+	/*
+	 * Scratch-pad area for temporary keys.
+	 */
+	struct iam_key        *ip_key_scratch[DX_SCRATCH_KEYS];
+	/*
+	 * pointer to flavor-specific per-container data.
+	 */
+	void                  *ip_descr_data;
+};
+
+/*
+ * Helper structure for legacy htrees.
+ */
+struct iam_path_compat {
+	struct iam_path      ipc_path;
+	struct iam_container ipc_container;
+	__u32                ipc_scrach[DX_SCRATCH_KEYS];
+};
+
+int iam_lookup(struct iam_container *c, struct iam_key *k, struct iam_rec *r);
+int iam_delete(handle_t *h, struct iam_container *c, struct iam_key *k);
+int iam_update(handle_t *h, struct iam_container *c, struct iam_key *k, struct iam_rec *r);
+int iam_insert(handle_t *handle, struct iam_container *c, struct iam_key *k, struct iam_rec *r);
+/*
+ * Initialize container @c, acquires additional reference on @inode.
+ */
+int iam_container_init(struct iam_container *c,
+		       struct iam_descr *descr, struct inode *inode);
+/*
+ * Finalize container @c, release all resources.
+ */
+void iam_container_fini(struct iam_container *c);
+
