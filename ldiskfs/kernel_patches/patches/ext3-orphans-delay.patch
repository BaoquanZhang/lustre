Index: linux-stage/fs/ext3/super.c
===================================================================
--- linux-stage.orig/fs/ext3/super.c	2007-06-15 11:56:38.000000000 +0800
+++ linux-stage/fs/ext3/super.c	2007-06-15 12:00:50.000000000 +0800
@@ -148,6 +148,8 @@
 	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
 	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);
 
+	dump_stack();
+
 	if (sb->s_flags & MS_RDONLY)
 		return;
 
@@ -1262,7 +1264,7 @@
  * e2fsck was run on this filesystem, and it must have already done the orphan
  * inode cleanup for us, so we can safely abort without any further action.
  */
-static void ext3_orphan_cleanup (struct super_block * sb,
+void ext3_orphan_cleanup (struct super_block * sb,
 				 struct ext3_super_block * es)
 {
 	unsigned int s_flags = sb->s_flags;
@@ -1350,7 +1352,9 @@
 	}
 #endif
 	sb->s_flags = s_flags; /* Restore MS_RDONLY status */
+        EXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;
 }
+EXPORT_SYMBOL(ext3_orphan_cleanup);
 
 #define log2(n) ffz(~(n))
 
@@ -1804,8 +1808,7 @@
 	 * superblock lock.
 	 */
 	EXT3_SB(sb)->s_mount_state |= EXT3_ORPHAN_FS;
-	ext3_orphan_cleanup(sb, es);
-	EXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;
+
 	if (needs_recovery)
 		printk (KERN_INFO "EXT3-fs: recovery complete.\n");
 	ext3_mark_recovery_complete(sb, es);
Index: linux-2.6.18-128.1.1_new/include/linux/ext3_fs.h
===================================================================
--- linux-2.6.18-128.1.1_new/include/linux/ext3_fs.h	2009-07-03 15:55:16.000000000 +0530
+++ linux-2.6.18-128.1.1_new1/include/linux/ext3_fs.h	2009-07-03 15:57:50.000000000 +0530
@@ -1064,6 +1064,8 @@ extern struct proc_dir_entry *proc_root_
 extern int __init init_ext3_proc(void);
 extern void exit_ext3_proc(void);
 
+extern void ext3_orphan_cleanup (struct super_block * sb,
+				 struct ext3_super_block * es);
 extern void ext3_error (struct super_block *, const char *, const char *, ...)
 	__attribute__ ((format (printf, 3, 4)));
 extern void __ext3_std_error (struct super_block *, const char *, int);
