#!/bin/bash

# cluster name (all node names are this followed by the node number)
cluster=mdev

# client node numbers (individual numbers or inclusive ranges)
clients=(7-8)

# numbers of clients to survey
clients_lo=1
clients_hi=2
clients_iterator="+=1"

# numbers of tasks per client to survey
tasks_per_client_lo=1
tasks_per_client_hi=8
tasks_per_client_iterator="*=2"

# record sizes to survey
rsize_lo=1M
rsize_hi=1M
rsize_iterator="*=2"

## which tests to run (first must be write)
# remount)   not really a test; just remount to uncache everything
# *write*)   write
# *)         read
#tests=(write rewrite read reread rewrite_again)
tests=(write rewrite remount read reread)

# total # bytes written/read by any client node
min_per_client_size=4G
min_total_size=8G

# should each task do I/O to its own file?
file_per_task=1

# the binaries
IOR="/home/ericb/ior/src/C/IOR"
llmount=/home/ericb/lustre/utils/llmount
pdsh=pdsh

# the result file prefix (date/time + hostname makes unique)
#rslt=/home/ericb/ior_survey_`date +%F@%R`_`uname -n`
rslt=/home/ericb/ior_survey

# where lustre is mounted on the clients
lustre=/mnt/lustre

# basename of the test file(s)
testfile=${lustre}/ior_survey_testfile

# how to unmount and remount the F/S on a client (to clear the cache)
# change this depending on lustre config (network type, MDS etc)
remount="umount $lustre && $llmount -o nettype=elan mdev6:/ll_mds/client $lustre"

# pdsh args required to instantiate all instances of IOR in parallel
# the chosen module must support '-n <procs-per-node>'
# -R<module>, -f<fanout> etc
pdsh_mpiargs="-Rmqsh"

#don't spin for MPI completions
export LIBELAN_WAITTYPE=0

################################################################################
# dont change stuff below here unless you know what you're doing...

count_range() {
    echo $1 | awk '{ nvals=split($1, vals, "-");\
	             if (nvals == 1) print 1;\
	             else if (nvals == 2) printf "%d\n", vals[2] - vals[1] + 1;}'
}

base_range() {
    echo $1 | awk '{ split($1, vals, "-"); print vals[1]; }'
}

idx2nodenum() {
    local n=$1; shift
    while ((1)); do
	local range=$1; shift
	if [ -z "$range" ]; then
	    return
	fi
	chunk=`count_range $range`
	if ((chunk > n)); then
	    base=`base_range $range`
	    echo $((base + n))
	    return
	fi
	n=$((n-chunk))
    done
}

n2noderange() {
    local n=$1; shift
    sep=""
    nodes="["
    while ((n > 0)); do
	local range=$1; shift
	if [ -z "$range" ]; then
            return
	fi
	local base=`base_range $range`
	local chunk=`count_range $range`
	if ((chunk > n)); then chunk=n; fi
	local nodes="${nodes}${sep}${base}"; sep=","
	if ((chunk > 1)); then nodes="${nodes}-$((base+chunk-1))"; fi
	n=$((n-chunk))
    done
    echo "${nodes}]"
}

countnodes() {
    local radix=16384
    local n=0
    while ((radix > 0)); do
	local nodes=`n2noderange $((n+radix)) $@`
	if [ -n "$nodes" ]; then
	    n=$((n+radix))
        fi
	radix=$((radix/2))
    done
    echo $n
}

parse_number() {
    local str=$1
    case $str in
	*G|*g) n=`echo $str | sed 's/[gG]//'`; echo $((n*1024*1024*1024));;
	*M|*m) n=`echo $str | sed 's/[Mm]//'`; echo $((n*1024*1024));;
	*K|*k) n=`echo $str | sed 's/[Kk]//'`; echo $((n*1024));;
	*)     echo $1;;
    esac
}

pp_number() {
    local n=$1
    local G=$((1024*1024*1024))
    local M=$((1024*1024))
    local K=$((1024))
    if ((n%G == 0 && n >= G)); then
	echo "$((n/G))G"
    elif ((n%M == 0 && n >= M)); then
	echo "$((n/M))M"
    elif ((n%K == 0 && n >= K)); then
	echo "$((n/K))K"
    else
	echo $n
    fi
}

if [ ${#tests[@]} -eq 0 -o "${tests[0]}" != "write" ]; then
    echo "First test must be 'write'" 1>&2
    exit 1
fi

rsltf="${rslt}.summary"
workf="${rslt}.detail"
echo -n > $rsltf
echo -n > $workf

print_summary () {
    if [ "$1" = "-n" ]; then
	minusn=$1; shift
    else
	minusn=""
    fi
    echo $minusn "$*" >> $rsltf
    echo $minusn "$*"
}

# convert params to actual numbers
min_per_client_size=`parse_number $min_per_client_size`
min_total_size=`parse_number $min_total_size`

rsize_lo=`parse_number $rsize_lo`
rsize_hi=`parse_number $rsize_hi`

# check on actual numbers of client nodes
nclients=`countnodes ${clients[@]}`
if ((clients_hi > nclients)); then clients_hi=$nclients; fi

for ((rsize=rsize_lo; rsize<=rsize_hi; rsize$rsize_iterator)); do
    pp_rsize=`pp_number $rsize`

    for ((nclnt=clients_lo; nclnt<=clients_hi; nclnt$clients_iterator)); do
	test_clients="${cluster}`n2noderange $nclnt ${clients[@]}`"

	per_client_size=$((min_total_size/nclnt))
	if ((per_client_size < min_per_client_size)); then
	    per_client_size=$min_per_client_size
	fi

	for ((ntask=tasks_per_client_lo; ntask <= tasks_per_client_hi; ntask$tasks_per_client_iterator)); do
	    per_task_size=$((per_client_size/ntask))
	    if ((per_task_size%rsize != 0)); then
		per_task_size=$(((per_task_size/rsize + 1)*rsize))
	    fi
	    total_size=`pp_number $((per_task_size*nclnt*ntask))`
	    
	    hdrstr=`printf "Total: %5sB rsize: %4sB clients: %4d tasks: %3d: " \
		$total_size $pp_rsize $nclnt $ntask`
	    print_summary -n "$hdrstr"

	    for ((test_idx=0; test_idx < ${#tests[@]}; test_idx++)); do
	        test=${tests[$test_idx]}
		
		print_summary -n "$test "
		echo "===========> ${hdrstr} on $test_clients doing $test" >> $workf
		tmpf=${workf}_tmp
		echo -n > $tmpf

		if [ "$test" = "remount" ]; then
		    echo "=> $remount" >> $tmpf
		    $pdsh -S -b -w "$test_clients" >> $tmpf 2>&1 \
			"$remount"
		    status=$?
		    echo "Completion Status: $status" >> $tmpf

		    if ((status)); then
			result="ERROR"
		    else
			result="OK"
		    fi
		else
		    # check lustre is mounted everywhere it's needed
		    cmd="(mount -t lustre; mount -t lustre_lite) | grep $lustre"
		    echo "=> Mount Check: $cmd" >> $tmpf
		    $pdsh -S -b -w "$test_clients" >> $tmpf 2>&1 \
			"$cmd"
		    status=$?
		    echo "Completion Status: $status" >> $tmpf
		    if ((status)); then
			cat $tmpf >> $workf
			rm $tmpf
			print_summary "Lustre NOT mounted on $lustre somewhere"
			exit 1
		    fi

		    cmdline=(
		    $IOR                     # the command
		    -o${testfile}            # test file prefix
		    -b${per_task_size}       # bytes per task
		    -t${rsize}               # record size
		    -e                       # fsync before close
		    -q                       # quit on error
		    )

		    idx=${#cmdline[@]}

                    # keep the test file(s) unless this is the last test
		    ((test_idx < ${#tests[@]}-1)) && cmdline[$((idx++))]="-k"

		    # use the existing test file(s) unless this is the first test
		    ((test_idx > 0)) && cmdline[$((idx++))]="-E"

		    # file-per-task
		    ((file_per_task)) && cmdline[$((idx++))]="-F"

		    case "$test" in
		    *write*) cmdline[$((idx++))]="-w"
			     awkstr="Max Write";;
                    *)       cmdline[$((idx++))]="-r"
		             awkstr="Max Read";;
                    esac

		    echo "=> ${cmdline[@]}" >> $tmpf
	
		    $pdsh -S -b $pdsh_mpiargs -w "$test_clients" -n $ntask >> $tmpf 2>&1 \
			"${cmdline[@]}"
		    status=$?

		    echo "Completion Status: $status" >> $tmpf
	       
		    if ((status)); then
			result="ERROR"
		    else
			result=`awk < $tmpf "/$awkstr/ {print $ 3; found=1; exit}\
			                     END       {if (!found) print \"ERROR\"}"`
		    fi
		fi

		cat $tmpf >> $workf
		rm $tmpf

	        str=`printf "%8s" "$result"`
		print_summary -n "$str "
	    done
	    print_summary ""
	done
    done
done

