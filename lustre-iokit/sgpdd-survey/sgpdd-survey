#!/bin/bash

######################################################################
# customize per survey

# the SCSI devices to measure
scsidevs=${scsidevs:-"/dev/sde /dev/sdh"}

# result file prefix.  date/time+hostname makes unique
# NB ensure the path exists if it includes subdirs
rslt=${rslt:-"/tmp/sgpdd_survey_`date +%F@%R`_`uname -n`"}

# what to do (read or write)
actions="write read"

# total size per device (MBytes)
# NB bigger than device cache is good
size=8192

# record size (KBytes)
rszlo=1024
rszhi=1024

# Concurrent regions per device
crglo=${crglo:-1}
crghi=${crghi:-256}

# threads to share between concurrent regions per device
# NB survey skips over #thr < #regions and #thr/#regions > SG_MAX_QUEUE
thrlo=${thrlo:-1}
thrhi=${thrhi:-4096}

#####################################################################
# leave the rest of this alone unless you know what you're doing...

# sgp_dd's idea of disk sector size (Bytes)
bs=512
# and max # threads one instance will spawn
SG_MAX_QUEUE=16

# map given device names into SG device names
i=0
devs=()
for d in $scsidevs; do
    devs[$i]=`sg_map | awk "{if ($ 2 == \"$d\") print $ 1}"`
    if [ -z "${devs[$i]}" ]; then
	echo "Can't find SG device for $d"
	exit 1
    fi
    i=$((i+1))
done
ndevs=${#devs[@]}

rsltf=${rslt}.summary
workf=${rslt}.detail
echo -n > $rsltf
echo -n > $workf

print_summary () {
    if [ "$1" = "-n" ]; then
	minusn=$1; shift
    else
	minusn=""
    fi
    echo $minusn "$*" >> $rsltf
    echo $minusn "$*"
}

for ((rsz=$rszlo;rsz<=$rszhi;rsz*=2)); do
    for ((crg=$crglo;crg<=$crghi;crg*=2)); do 
	for ((thr=$thrlo;thr<=$thrhi;thr*=2)); do
	    if ((thr < crg || thr/crg > SG_MAX_QUEUE)); then
		continue
	    fi
	    # compute parameters
	    bpt=$((rsz*1024/bs))
	    blocks=$((size*((1024*1024)/bs)/crg))
	    count=$blocks
	    # show computed parameters
	    actual_rsz=$((bpt*bs/1024))
	    actual_size=$((bs*count*crg/1024))
	    str=`printf 'total_size %8dK rsz %4d crg %5d thr %5d ' \
		         $((actual_size*ndevs)) $actual_rsz $((crg*ndevs)) $((thr*ndevs))`
	    echo "==============> $str" >> $workf
	    print_summary -n "$str"
	    freemem=`awk < /proc/meminfo '/^MemTotal:/ {printf "%d\n", $2}'`
	    if (((actual_rsz*thr/crg + 64)*crg*ndevs > freemem)); then
		print_summary "ENOMEM"
		continue
	    fi
	    # run tests
	    for action in $actions; do
		print_summary -n "$action "
		echo "=====> $action" >> $workf
		tmpf=${workf}_tmp
                # start test
		t0=`date +%s.%N`
		for ((i=0;i<ndevs;i++)); do
		    dev=${devs[i]}
		    if [ $action = read ]; then
			inf="if=$dev"
			outf="of=/dev/null"
			skip=skip
		    else
			inf="if=/dev/zero"
			outf="of=$dev"
			skip=seek
		    fi
		    for ((j=0;j<crg;j++)); do 
			sgp_dd 2> ${tmpf}_${i}_${j} \
			    $inf $outf ${skip}=$((1024+j*blocks)) \
			    thr=$((thr/crg)) count=$count bs=$bs bpt=$bpt time=1&
		    done
		done 
		wait
		t1=`date +%s.%N`
	        # collect/check individual stats
		echo > $tmpf
		ok=0
		for ((i=0;i<ndevs;i++)); do
		    for ((j=0;j<crg;j++)); do
			rtmp=${tmpf}_${i}_${j}
			if grep 'time to transfer data' $rtmp > /dev/null 2>&1; then
			    ok=$((ok + 1))
			fi
			cat ${rtmp} >> $tmpf
			cat ${rtmp} >> $workf
			rm  ${rtmp}
		    done
		done
		if ((ok != ndevs*crg)); then
		    print_summary -n "$((ndevs*crg - ok)) failed "
		else
	            # compute MB/sec from elapsed
		    bw=`awk "BEGIN {printf \"%7.2f MB/s\", $actual_size * $ndevs / (( $t1 - $t0 ) * 1024); exit}"`
	            # compute MB/sec from nregions*slowest
		    check=`awk < $tmpf \
			'/time to transfer data/ {mb=$8/1.048576; if (n == 0 || mb < min) min = mb; n++}\
			END {printf "%5d x %6.2f = %7.2f MB/s", n, min, min * n}'`
		    print_summary -n "$bw $check "
		fi
		rm $tmpf
	    done
	    print_summary ""
	done
    done
done
