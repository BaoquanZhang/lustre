/* -*- mode: c; c-basic-offset: 8; indent-tabs-mode: nil; -*-
 * vim:expandtab:shiftwidth=8:tabstop=8:
 *
 *  Copyright (c) 2001-2003 Cluster File Systems, Inc.
 *
 *   This file is part of Lustre, http://www.sf.net/projects/lustre/
 *
 *   Lustre is free software; you can redistribute it and/or
 *   modify it under the terms of version 2 of the GNU General Public
 *   License as published by the Free Software Foundation.
 *
 *   Lustre is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Lustre; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#define DEBUG_SUBSYSTEM S_PORTALS
#include <portals/lib-p30.h>

int               ptl_init;                     /* PtlInit() flag */
struct list_head  ptl_nal_table;                /* registered NALs */
ptl_apini_t       ptl_apini;                    /* THE network interface (at the API) */

void ptl_assert_wire_constants (void)
{
        /* Wire protocol assertions generated by 'wirecheck'
         * running on Linux mdevi 2.4.21-p4smp-55chaos #1 SMP Tue Jun 8 14:38:44 PDT 2004 i686 i686 i
         * with gcc version 3.2.3 20030502 (Red Hat Linux 3.2.3-34) */


        /* Constants... */
        CLASSERT (PORTALS_PROTO_MAGIC == 0xeebc0ded);
        CLASSERT (PORTALS_PROTO_VERSION_MAJOR == 1);
        CLASSERT (PORTALS_PROTO_VERSION_MINOR == 0);
        CLASSERT (PTL_MSG_ACK == 0);
        CLASSERT (PTL_MSG_PUT == 1);
        CLASSERT (PTL_MSG_GET == 2);
        CLASSERT (PTL_MSG_REPLY == 3);
        CLASSERT (PTL_MSG_HELLO == 4);

        /* Checks for struct ptl_handle_wire_t */
        CLASSERT ((int)sizeof(ptl_handle_wire_t) == 16);
        CLASSERT ((int)offsetof(ptl_handle_wire_t, wh_interface_cookie) == 0);
        CLASSERT ((int)sizeof(((ptl_handle_wire_t *)0)->wh_interface_cookie) == 8);
        CLASSERT ((int)offsetof(ptl_handle_wire_t, wh_object_cookie) == 8);
        CLASSERT ((int)sizeof(((ptl_handle_wire_t *)0)->wh_object_cookie) == 8);

        /* Checks for struct ptl_magicversion_t */
        CLASSERT ((int)sizeof(ptl_magicversion_t) == 8);
        CLASSERT ((int)offsetof(ptl_magicversion_t, magic) == 0);
        CLASSERT ((int)sizeof(((ptl_magicversion_t *)0)->magic) == 4);
        CLASSERT ((int)offsetof(ptl_magicversion_t, version_major) == 4);
        CLASSERT ((int)sizeof(((ptl_magicversion_t *)0)->version_major) == 2);
        CLASSERT ((int)offsetof(ptl_magicversion_t, version_minor) == 6);
        CLASSERT ((int)sizeof(((ptl_magicversion_t *)0)->version_minor) == 2);

        /* Checks for struct ptl_hdr_t */
        CLASSERT ((int)sizeof(ptl_hdr_t) == 72);
        CLASSERT ((int)offsetof(ptl_hdr_t, dest_nid) == 0);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->dest_nid) == 8);
        CLASSERT ((int)offsetof(ptl_hdr_t, src_nid) == 8);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->src_nid) == 8);
        CLASSERT ((int)offsetof(ptl_hdr_t, dest_pid) == 16);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->dest_pid) == 4);
        CLASSERT ((int)offsetof(ptl_hdr_t, src_pid) == 20);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->src_pid) == 4);
        CLASSERT ((int)offsetof(ptl_hdr_t, type) == 24);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->type) == 4);
        CLASSERT ((int)offsetof(ptl_hdr_t, payload_length) == 28);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->payload_length) == 4);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg) == 32);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg) == 40);

        /* Ack */
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.ack.dst_wmd) == 32);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.ack.dst_wmd) == 16);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.ack.match_bits) == 48);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.ack.match_bits) == 8);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.ack.mlength) == 56);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.ack.mlength) == 4);

        /* Put */
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.put.ack_wmd) == 32);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.put.ack_wmd) == 16);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.put.match_bits) == 48);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.put.match_bits) == 8);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.put.hdr_data) == 56);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.put.hdr_data) == 8);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.put.ptl_index) == 64);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.put.ptl_index) == 4);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.put.offset) == 68);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.put.offset) == 4);

        /* Get */
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.get.return_wmd) == 32);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.get.return_wmd) == 16);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.get.match_bits) == 48);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.get.match_bits) == 8);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.get.ptl_index) == 56);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.get.ptl_index) == 4);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.get.src_offset) == 60);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.get.src_offset) == 4);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.get.sink_length) == 64);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.get.sink_length) == 4);

        /* Reply */
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.reply.dst_wmd) == 32);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.reply.dst_wmd) == 16);

        /* Hello */
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.hello.incarnation) == 32);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.hello.incarnation) == 8);
        CLASSERT ((int)offsetof(ptl_hdr_t, msg.hello.type) == 40);
        CLASSERT ((int)sizeof(((ptl_hdr_t *)0)->msg.hello.type) == 4);
}

#ifdef __KERNEL__
struct semaphore ptl_mutex ;

static void ptl_mutex_enter (void) 
{
        mutex_down (&ptl_mutex);
}

static void ptl_mutex_exit (void)
{
        mutex_up (&ptl_mutex);
}
#else
static void ptl_mutex_enter (void)
{
}

static void ptl_mutex_exit (void) 
{
}
#endif


ptl_nal_t *
ptl_find_nal_by_name (char *name) 
{
        ptl_nal_t          *nal;
        struct list_head   *tmp;

        /* holding mutex */
        list_for_each (tmp, &ptl_nal_table) {
                nal = list_entry(tmp, ptl_nal_t, nal_list);

                if (!strcmp (nal->nal_name, name))
                        return nal;
        }
        
        return NULL;
}


ptl_nal_t *
ptl_find_nal_by_type (int type) 
{
        ptl_nal_t          *nal;
        struct list_head   *tmp;

        /* holding mutex */
        list_for_each (tmp, &ptl_nal_table) {
                nal = list_entry(tmp, ptl_nal_t, nal_list);

                if (nal->nal_type == type)
                        return nal;
        }
        
        return NULL;
}


int 
ptl_register_nal (ptl_nal_t *nal)
{
        int    rc;
        
        ptl_mutex_enter();

        LASSERT (ptl_init);

        if (ptl_find_nal_by_name(nal->nal_name) != NULL ||
            ptl_find_nal_by_type(nal->nal_type) != NULL) {
                rc = PTL_IFACE_DUP;
        } else {
                list_add (&nal->nal_list, &ptl_nal_table);
                
                nal->nal_refcount = 0;
                rc = PTL_OK;
        }

        ptl_mutex_exit();
        return (rc);
}

void
ptl_unregister_nal (ptl_nal_t *nal)
{
        ptl_mutex_enter();

        LASSERT (ptl_init);
        LASSERT (ptl_find_nal_by_type(nal->nal_type) == nal);
        LASSERT (ptl_find_nal_by_name(nal->nal_name) == nal);
        LASSERT (nal->nal_refcount == 0);
        
        list_del (&nal->nal_list);

        ptl_mutex_exit();
}

#ifndef PTL_USE_LIB_FREELIST
int
ptl_descriptor_setup (ptl_ni_limits_t *requested_limits,
                      ptl_ni_limits_t *actual_limits)
{
        /* Ignore requested limits! */
        actual_limits->max_mes = INT_MAX;
        actual_limits->max_mds = INT_MAX;
        actual_limits->max_eqs = INT_MAX;

        return PTL_OK;
}

void
ptl_descriptor_cleanup (void)
{
}

#else

int
ptl_freelist_init (ptl_freelist_t *fl, int n, int size)
{
        char *space;

        LASSERT (n > 0);

        size += offsetof (ptl_freeobj_t, fo_contents);

        PORTAL_ALLOC(space, n * size);
        if (space == NULL)
                return (PTL_NO_SPACE);

        CFS_INIT_LIST_HEAD (&fl->fl_list);
        fl->fl_objs = space;
        fl->fl_nobjs = n;
        fl->fl_objsize = size;

        do
        {
                memset (space, 0, size);
                list_add ((struct list_head *)space, &fl->fl_list);
                space += size;
        } while (--n != 0);

        return (PTL_OK);
}

void
ptl_freelist_fini (ptl_freelist_t *fl)
{
        struct list_head *el;
        int               count;

        if (fl->fl_nobjs == 0)
                return;

        count = 0;
        for (el = fl->fl_list.next; el != &fl->fl_list; el = el->next)
                count++;

        LASSERT (count == fl->fl_nobjs);

        PORTAL_FREE(fl->fl_objs, fl->fl_nobjs * fl->fl_objsize);
        memset (fl, 0, sizeof (fl));
}

int
ptl_descriptor_setup (ptl_ni_limits_t *requested_limits,
                      ptl_ni_limits_t *actual_limits)
{
        /* NB on failure caller must still call ptl_descriptor_cleanup */
        /*               ******                                        */
        int        rc;

        memset (&ptl_apini.apini_free_mes,  0, sizeof (ptl_apini.apini_free_mes));
        memset (&ptl_apini.apini_free_msgs, 0, sizeof (ptl_apini.apini_free_msgs));
        memset (&ptl_apini.apini_free_mds,  0, sizeof (ptl_apini.apini_free_mds));
        memset (&ptl_apini.apini_free_eqs,  0, sizeof (ptl_apini.apini_free_eqs));

        /* Ignore requested limits! */
        actual_limits->max_mes = MAX_MES;
        actual_limits->max_mds = MAX_MDS;
        actual_limits->max_eqs = MAX_EQS;
        /* Hahahah what a load of bollocks.  There's nowhere to
         * specify the max # messages in-flight */

        rc = ptl_freelist_init (&ptl_apini.apini_free_mes,
                                MAX_MES, sizeof (ptl_me_t));
        if (rc != PTL_OK)
                return (rc);

        rc = ptl_freelist_init (&ptl_apini.apini_free_msgs,
                                MAX_MSGS, sizeof (ptl_msg_t));
        if (rc != PTL_OK)
                return (rc);

        rc = ptl_freelist_init (&ptl_apini.apini_free_mds,
                                MAX_MDS, sizeof (ptl_libmd_t));
        if (rc != PTL_OK)
                return (rc);

        rc = ptl_freelist_init (&ptl_apini.apini_free_eqs,
                                MAX_EQS, sizeof (ptl_eq_t));
        return (rc);
}

void
ptl_descriptor_cleanup (void)
{
        ptl_freelist_fini (&ptl_apini.apini_free_mes);
        ptl_freelist_fini (&ptl_apini.apini_free_msgs);
        ptl_freelist_fini (&ptl_apini.apini_free_mds);
        ptl_freelist_fini (&ptl_apini.apini_free_eqs);
}

#endif

__u64
ptl_create_interface_cookie (void)
{
        /* NB the interface cookie in wire handles guards against delayed
         * replies and ACKs appearing valid after reboot. Initialisation time,
         * even if it's only implemented to millisecond resolution is probably
         * easily good enough. */
        struct timeval tv;
        __u64          cookie;
#ifndef __KERNEL__
        int            rc = gettimeofday (&tv, NULL);
        LASSERT (rc == 0);
#else
	do_gettimeofday(&tv);
#endif
        cookie = tv.tv_sec;
        cookie *= 1000000;
        cookie += tv.tv_usec;
        return cookie;
}

int
ptl_setup_handle_hash (void) 
{
        int       i;
        
        /* Arbitrary choice of hash table size */
#ifdef __KERNEL__
        ptl_apini.apini_lh_hash_size = PAGE_SIZE / sizeof (struct list_head);
#else
        ptl_apini.apini_lh_hash_size = (MAX_MES + MAX_MDS + MAX_EQS)/4;
#endif
        PORTAL_ALLOC(ptl_apini.apini_lh_hash_table,
                     ptl_apini.apini_lh_hash_size * sizeof (struct list_head));
        if (ptl_apini.apini_lh_hash_table == NULL)
                return (PTL_NO_SPACE);
        
        for (i = 0; i < ptl_apini.apini_lh_hash_size; i++)
                CFS_INIT_LIST_HEAD (&ptl_apini.apini_lh_hash_table[i]);

        ptl_apini.apini_next_object_cookie = PTL_COOKIE_TYPES;
        
        return (PTL_OK);
}

void
ptl_cleanup_handle_hash (void)
{
        if (ptl_apini.apini_lh_hash_table == NULL)
                return;
        
        PORTAL_FREE(ptl_apini.apini_lh_hash_table,
                    ptl_apini.apini_lh_hash_size * sizeof (struct list_head));
}

ptl_libhandle_t *
ptl_lookup_cookie (__u64 cookie, int type) 
{
        /* ALWAYS called with PTL_LOCK held */
        struct list_head    *list;
        struct list_head    *el;
        unsigned int         hash;

        if ((cookie & (PTL_COOKIE_TYPES - 1)) != type)
                return (NULL);
        
        hash = ((unsigned int)cookie) % ptl_apini.apini_lh_hash_size;
        list = &ptl_apini.apini_lh_hash_table[hash];
        
        list_for_each (el, list) {
                ptl_libhandle_t *lh = list_entry (el, ptl_libhandle_t,
                                                  lh_hash_chain);
                
                if (lh->lh_cookie == cookie)
                        return (lh);
        }
        
        return (NULL);
}

void
ptl_initialise_handle (ptl_libhandle_t *lh, int type) 
{
        /* ALWAYS called with PTL_LOCK held */
        unsigned int    hash;

        LASSERT (type >= 0 && type < PTL_COOKIE_TYPES);
        lh->lh_cookie = ptl_apini.apini_next_object_cookie | type;
        ptl_apini.apini_next_object_cookie += PTL_COOKIE_TYPES;
        
        hash = ((unsigned int)lh->lh_cookie) % ptl_apini.apini_lh_hash_size;
        list_add (&lh->lh_hash_chain, &ptl_apini.apini_lh_hash_table[hash]);
}

void
ptl_invalidate_handle (ptl_libhandle_t *lh)
{
        /* ALWAYS called with PTL_LOCK held */
        list_del (&lh->lh_hash_chain);
}

int
ptl_startup_apini(ptl_pid_t requested_pid,
                  ptl_ni_limits_t *requested_limits,
                  ptl_ni_limits_t *actual_limits)
{
        int               rc = PTL_OK;
        int               ptl_size;
        int               i;
        ENTRY;

        LASSERT (ptl_apini.apini_refcount == 0);

        ptl_apini.apini_pid = requested_pid;

        rc = ptl_descriptor_setup (requested_limits, 
                                   &ptl_apini.apini_actual_limits);
        if (rc != PTL_OK)
                goto out;

        memset(&ptl_apini.apini_counters, 0, 
               sizeof(ptl_apini.apini_counters));

        CFS_INIT_LIST_HEAD (&ptl_apini.apini_active_msgs);
        CFS_INIT_LIST_HEAD (&ptl_apini.apini_active_mds);
        CFS_INIT_LIST_HEAD (&ptl_apini.apini_active_eqs);
        CFS_INIT_LIST_HEAD (&ptl_apini.apini_test_peers);
        CFS_INIT_LIST_HEAD (&ptl_apini.apini_nis);

#ifdef __KERNEL__
        spin_lock_init (&ptl_apini.apini_lock);
        cfs_waitq_init (&ptl_apini.apini_waitq);
#else
        pthread_mutex_init(&ptl_apini.apini_mutex, NULL);
        pthread_cond_init(&ptl_apini.apini_cond, NULL);
#endif

        ptl_apini.apini_interface_cookie = ptl_create_interface_cookie();

        rc = ptl_setup_handle_hash ();
        if (rc != PTL_OK)
                goto out;
        
        if (requested_limits != NULL)
                ptl_size = requested_limits->max_pt_index + 1;
        else
                ptl_size = 64;

        ptl_apini.apini_nportals = ptl_size;
        PORTAL_ALLOC(ptl_apini.apini_portals, 
                     ptl_size * sizeof(*ptl_apini.apini_portals));
        if (ptl_apini.apini_portals == NULL) {
                rc = PTL_NO_SPACE;
                goto out;
        }

        for (i = 0; i < ptl_size; i++)
                CFS_INIT_LIST_HEAD(&(ptl_apini.apini_portals[i]));

        /* max_{mes,mds,eqs} set in ptl_descriptor_setup */

        /* We don't have an access control table! */
        ptl_apini.apini_actual_limits.max_ac_index = -1;

        ptl_apini.apini_actual_limits.max_pt_index = ptl_size - 1;
        ptl_apini.apini_actual_limits.max_md_iovecs = PTL_MD_MAX_IOV;
        ptl_apini.apini_actual_limits.max_me_list = INT_MAX;

        /* We don't support PtlGetPut! */
        ptl_apini.apini_actual_limits.max_getput_md = 0;

        if (actual_limits != NULL)
                *actual_limits = ptl_apini.apini_actual_limits;
 out:
        if (rc != PTL_OK) {
                ptl_cleanup_handle_hash ();
                ptl_descriptor_cleanup ();
        }

        RETURN (rc);
}

int
ptl_shutdown_apini (void)
{
        int       idx;
        
        /* NB no PTL_LOCK since this is the last reference.  All NAL instances
         * have shut down already, so it is safe to unlink and free all
         * descriptors, even those that appear committed to a network op (eg MD
         * with non-zero pending count) */

        LASSERT (ptl_apini.apini_refcount == 0);
        LASSERT (list_empty(&ptl_apini.apini_nis));

        for (idx = 0; idx < ptl_apini.apini_nportals; idx++)
                while (!list_empty (&ptl_apini.apini_portals[idx])) {
                        ptl_me_t *me = list_entry (ptl_apini.apini_portals[idx].next,
                                                   ptl_me_t, me_list);

                        CERROR ("Active me %p on exit\n", me);
                        list_del (&me->me_list);
                        ptl_me_free (me);
                }

        while (!list_empty (&ptl_apini.apini_active_mds)) {
                ptl_libmd_t *md = list_entry (ptl_apini.apini_active_mds.next,
                                           ptl_libmd_t, md_list);

                CERROR ("Active md %p on exit\n", md);
                list_del (&md->md_list);
                ptl_md_free (md);
        }

        while (!list_empty (&ptl_apini.apini_active_eqs)) {
                ptl_eq_t *eq = list_entry (ptl_apini.apini_active_eqs.next,
                                           ptl_eq_t, eq_list);

                CERROR ("Active eq %p on exit\n", eq);
                list_del (&eq->eq_list);
                ptl_eq_free (eq);
        }

        while (!list_empty (&ptl_apini.apini_active_msgs)) {
                ptl_msg_t *msg = list_entry (ptl_apini.apini_active_msgs.next,
                                             ptl_msg_t, msg_list);

                CERROR ("Active msg %p on exit\n", msg);
                list_del (&msg->msg_list);
                ptl_msg_free (msg);
        }

        PORTAL_FREE(ptl_apini.apini_portals,  
                    ptl_apini.apini_nportals * sizeof(*ptl_apini.apini_portals));

        ptl_cleanup_handle_hash ();
        ptl_descriptor_cleanup ();

#ifndef __KERNEL__
        pthread_mutex_destroy(&ptl_apini.apini_mutex);
        pthread_cond_destroy(&ptl_apini.apini_cond);
#endif

        return (PTL_OK);
}

void
ptl_shutdown_nalnis (void)
{
        ptl_ni_t          *ni;
        struct list_head  *tmp;
        struct list_head  *nxt;

        /* All quiet on the API front */
        LASSERT (ptl_apini.apini_refcount == 0);
        
        list_for_each_safe (tmp, nxt, &ptl_apini.apini_nis) {
                ni = list_entry(tmp, ptl_ni_t, ni_list);

                (ni->ni_nal->nal_shutdown)(ni);
                ni->ni_nal->nal_refcount--;
                list_del (&ni->ni_list);

                PORTAL_FREE(ni, sizeof(*ni));
        }
}

ptl_err_t
ptl_startup_nalnis (void)
{
        ptl_nal_t         *nal;
        ptl_ni_t          *ni;
        struct list_head  *tmp;
        ptl_err_t          rc = PTL_OK;
        char              *interface = NULL;
        
        list_for_each (tmp, &ptl_nal_table) {
                nal = list_entry(tmp, ptl_nal_t, nal_list);

                PORTAL_ALLOC(ni, sizeof(*ni));
                if (ni == NULL) {
                        CERROR("Can't allocate NI for %s\n", 
                               nal->nal_name);
                        rc = PTL_FAIL;
                        break;
                }

                ni->ni_nal = nal;
                nal->nal_refcount++;

                rc = (nal->nal_startup)(ni, &interface);
                if (rc != PTL_OK) {
                        CERROR("Error %d staring up NI %s\n",
                               rc, nal->nal_name);
                        PORTAL_FREE(ni, sizeof(*ni));
                        nal->nal_refcount--;
                        break;
                }

                list_add(&ni->ni_list, &ptl_apini.apini_nis);
        }
 
        if (rc != PTL_OK)
                ptl_shutdown_nalnis();

        return rc;
}

ptl_err_t
PtlInit(int *max_interfaces)
{
        LASSERT(!strcmp(ptl_err_str[PTL_MAX_ERRNO], "PTL_MAX_ERRNO"));
        ptl_assert_wire_constants ();

        ptl_mutex_enter();

        LASSERT (!ptl_init);
        
        CFS_INIT_LIST_HEAD(&ptl_nal_table);
        ptl_apini.apini_refcount = 0;

#ifdef __KERNEL__
        /* process  */
        /* Kernel NALs register themselves when their module loads, and
         * unregister themselves when their module is unloaded.  Userspace NALs
         * are plugged in explicitly here... */
        {
                extern ptl_nal_t tcpnal_nal;

                ptl_register_nal (&tcpnal_nal);
        }
#endif
        ptl_init = 1;

        ptl_mutex_exit();
        
        if (max_interfaces != NULL)
                *max_interfaces = 1;

        return PTL_OK;
}

void
PtlFini(void)
{
        ptl_mutex_enter();

        LASSERT (ptl_init);
        LASSERT (list_empty(&ptl_nal_table));
        LASSERT (ptl_apini.apini_refcount == 0);
        ptl_init = 0;

        ptl_mutex_exit();
}

ptl_err_t
PtlNIInit(ptl_interface_t interface, ptl_pid_t requested_pid,
          ptl_ni_limits_t *requested_limits, ptl_ni_limits_t *actual_limits,
          ptl_handle_ni_t *handle)
{
        int         rc;

        ptl_mutex_enter ();

        LASSERT (ptl_init);
        CDEBUG(D_OTHER, "refs %d\n", ptl_apini.apini_refcount);

        if (ptl_apini.apini_refcount != 0) {
                rc = PTL_IFACE_DUP;
                ptl_apini.apini_refcount++;
                goto out;
        }

        rc = ptl_startup_apini(requested_pid, 
                               requested_limits, actual_limits);
        if (rc != PTL_OK)
                goto out;
        
        rc = ptl_startup_nalnis();
        if (rc != PTL_OK)
                goto out;

        memset (handle, 0, sizeof(*handle));
        LASSERT (!PtlHandleIsEqual(*handle, PTL_INVALID_HANDLE));
        /* Handle can be anything; PTL_INVALID_HANDLE isn't wise though :) */

 out:
        ptl_mutex_exit ();

        return rc;
}

ptl_err_t
PtlNIFini(ptl_handle_ni_t ni)
{
        ptl_mutex_enter ();

        LASSERT (ptl_init);
        LASSERT (ptl_apini.apini_refcount > 0);

        ptl_apini.apini_refcount--;
        if (ptl_apini.apini_refcount == 0) {
                ptl_shutdown_nalnis();
                ptl_shutdown_apini();
        }

        ptl_mutex_exit ();
        return PTL_OK;
}

ptl_err_t
PtlGetId(ptl_handle_ni_t ni_handle, ptl_process_id_t *id)
{
        ptl_ni_t      *ni;
        unsigned long  flags;

        LASSERT (ptl_init);
        LASSERT (ptl_apini.apini_refcount > 0);

        /* pretty useless; just return the NID of the first local interface */

        PTL_LOCK(flags);
        
        if (list_empty(&ptl_apini.apini_nis)) {
                PTL_UNLOCK(flags);
                return PTL_FAIL;
        }
        
        id->pid = ptl_apini.apini_pid;

        ni = list_entry(ptl_apini.apini_nis.next,
                        ptl_ni_t, ni_list);
        id->nid = ni->ni_nid;

        PTL_UNLOCK(flags);

        return PTL_OK;
}

ptl_err_t
PtlNIHandle(ptl_handle_any_t handle_in, ptl_handle_ni_t *ni_out)
{
        LASSERT (ptl_init);
        LASSERT (ptl_apini.apini_refcount > 0);

        *ni_out = handle_in;
        return PTL_OK;
}

void
PtlSnprintHandle(char *str, int len, ptl_handle_any_t h)
{
        snprintf(str, len, LPX64, h.cookie);
}

ptl_err_t
PtlGetUid(ptl_handle_ni_t ni_handle, ptl_uid_t *uid)
{
        LASSERT (ptl_init);
        LASSERT (ptl_apini.apini_refcount > 0);
        
        *uid = 0;                               /* fake it */
        return PTL_OK;
}

ptl_err_t
PtlNIDist(ptl_handle_ni_t interface_in, ptl_process_id_t process_in,
          unsigned long *distance_out)
{
        LASSERT (ptl_init);
        LASSERT (ptl_apini.apini_refcount > 0);

        return 1;                               /* fake it */
}

ptl_err_t 
PtlNIStatus(ptl_handle_ni_t interface_in, ptl_sr_index_t register_in,
            ptl_sr_value_t *status_out)
{
        LASSERT (ptl_init);
        LASSERT (ptl_apini.apini_refcount > 0);

        return PTL_FAIL;                        /* not supported */
}

ptl_err_t
PtlACEntry(ptl_handle_ni_t ni_in, ptl_ac_index_t index_in,
           ptl_process_id_t match_id_in, ptl_pt_index_t portal_in)
{
        LASSERT (ptl_init);
        LASSERT (ptl_apini.apini_refcount > 0);

        return PTL_FAIL;                        /* not supported */
}
