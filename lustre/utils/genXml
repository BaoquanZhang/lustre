#!/usr/bin/env python
# Copyright (C) 2002 Cluster File Systems, Inc.
# Author:  Ravindranadh Chowdary Sahukara <s-ravindranadh_chowdary@hp.com>

#   This file is part of Lustre, http://www.lustre.org.
#
#   Lustre is free software; you can redistribute it and/or
#   modify it under the terms of version 2 of the GNU General Public
#   License as published by the Free Software Foundation.
#
#   Lustre is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with Lustre; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

"""
genXml - lustre xml configurtion data  generator
 
 Basic plan for genXml  usage:
#generate xml file
./lmc --output config.xml --node <node-name> --ldapserver <server-name>
./lmc --merge config.xml --node <node-name> --ldapserver <server-name>

#This reads arguments from files in default locations and generate the xml file
./genConfig  

"""

import sys, os, getopt, string, socket
import xml.dom.minidom
from xml.dom.ext import PrettyPrint
from lutils import *

lustreNodes = {}
lustreNode = 0
lustreClient = 0
lustreMds = {}
lustreOst = {}
#lustreOsc = 0
tmpuuid = ""
ConnId = 0

# Determine full path to use for an external command
# searches dirname(argv[0]) first, then PATH
"""
def find_prog(cmd):
    syspath = string.split(os.environ['PATH'], ':')
    cmdpath = os.path.dirname(sys.argv[0])
    syspath.insert(0, cmdpath);
    syspath.insert(0, os.path.join(cmdpath, '../../portals/linux/utils/'))
    for d in syspath:
        prog = os.path.join(d,cmd)
        if os.access(prog, os.X_OK):
            return prog
    return ''
"""
# ============================================================
# handle lmc interface
class LMCInterface:
    """
    Manage communication with lmc
    """

    def __init__(self, cmd):
        """
        Initialize close by finding the lmc script.
        """
        self.lmc = find_prog(cmd)
        if not self.lmc:
                debug('! lmc not found')
                raise CommandError('lmc', "unable to find lmc script .")
                self.lmc = 'lmc'

    def run(self, cmds):
        """
        run lmc
        the cmds are written to stdin of lmc
        """
        debug("+", self.lmc, cmds)
        p = popen2.Popen3(self.lmc, 1)
        p.tochild.write(cmds + "\n")
        p.tochild.close()
        out = p.fromchild.readlines()
        err = p.childerr.readlines()
        ret = p.wait()
        if os.WIFEXITED(ret):
            rc = os.WEXITSTATUS(ret)
        else:
            rc = 0
        if rc or len(err):
            print err, rc
            raise CommandError(self.lmc, err, rc)
        return rc, out

    def runcmd(self, *args):
        """
        run lmc using the command line
        """
        cmd = string.join(map(str,args))
        debug("+", self.lmc, cmd)
        rc, out = run(self.lmc, cmd)
        if rc:
            raise CommandError(self.lmc, out, rc)
        return rc, out


def genXml(nodename, ldapserver, port, options):
   global ldlm_name 
   global ldlm_uuid 
   global lustreNode
   global lustreClient
   global lustreMds
   global lustreOst
   global ConnId
   lovs = []
   if options.has_key('output'):
	outFile = options['output']
   elif options.has_key('merge'):
	outFile = options['merge']
        
   LMC = LMCInterface('lmc')
   base = "fs=lustre"
   myCon=MyConn(ldapserver,port)
   myCon.open()
   ConnId=myCon.id
   lustreNode = LustreNode(nodename)
   if not options.has_key('add'):
        lustreNode.getEntry_from_ldap(ConnId,base)
        for i in range(len(lustreNode.netUUIDs)):
            NET = lustreNode.lustreNet[i]
	    if options.has_key('output'):
                  cmds =  """ --output %s --node %s --net %s  %s """ % (outFile, lustreNode.id, NET.id, NET.netType)
	    elif options.has_key('merge'):
                  cmds =  """ --merge %s --node %s --net %s  %s """ % (outFile, lustreNode.id, NET.netType)
            LMC.runcmd(cmds)



   mds_uuids = lustreNode.lustreNodeProfile.mdsUUIDs
   for tmpuuid in mds_uuids:
       lustreMds[tmpuuid]=LustreMds()
       lustreMds[tmpuuid].getEntry_from_ldap(ConnId,base,tmpuuid)
       MDS = lustreMds[tmpuuid]
       Dev = lustreMds[tmpuuid].lustreDev
       cmds =  """ --merge %s --node %s --mds %s  %s %s """ % (outFile, lustreNode.id, lustreMds[tmpuuid].devName,Dev.device,Dev.size)
       LMC.runcmd(cmds)
       LOV = lustreMds[tmpuuid].lustreLov
       lovs.append(LOV)
       cmds =  """ --merge %s --lov %s  %s %s %s %s""" % (outFile, LOV.devName, MDS.devName, LOV.stripeSize, LOV.stripeCount, LOV.pattern)
       LMC.runcmd(cmds)

   
   ost_uuids = lustreNode.lustreNodeProfile.ostUUIDs
   for tmpuuid in ost_uuids:
       lustreOst[tmpuuid] = LustreOst()
       lustreOst[tmpuuid].getEntry_from_ldap(ConnId,base,tmpuuid)
       OST = lustreOst[tmpuuid]
       DEV = OST.lustreObd.lustreDev
       for i in range(len(lovs)):
            for oscuuid in lovs[i].oscUUIDs:
		OSC = lovs[i].lustreOsc[oscuuid]
		if OST.ostUUID == OSC.ostUUID:
                   cmds =  """ --merge %s --node %s --lov %s  --ost %s %s """ % (outFile, lustreNode.id, LOV.devName, DEV.device, DEV.size)
                   LMC.runcmd(cmds)
                else:
		   pass
		   #print "not matched:", OSC.ostUUID
	
       
   if lustreNode.lustreNodeProfile.clientUUID:
     client_uuid = ""
     lustreClient = LustreClient(lustreNode)
     client_uuid = lustreNode.lustreNodeProfile.clientUUID
     lustreClient.getEntry_from_ldap(ConnId,base,str(client_uuid))
     for mnt_uuid in lustreClient.mountUUIDs:
       tmpuuid = mnt_uuid
       MTPT = lustreClient.lustreMount[mnt_uuid]
       MDS = MTPT.lustreMds
       LOV = MTPT.lustreLov
       cmds =  """ --merge %s --node %s --mtpt %s %s %s  """ % (outFile, lustreNode.id, MTPT.mountPath, MDS.devName, LOV.devName)
       LMC.runcmd(cmds)



############################################################
# Command line processing
#
def parse_cmdline(argv):
    short_opts = "ho:i:m:"
    long_opts = ["node=", "merge=", "output=", "ldapserver=", "port="]
    opts = []
    args = []
    options = {}
    try:
        opts, args = getopt.getopt(argv, short_opts, long_opts)
    except getopt.error:
        print "invalid opt"
        usage()

    for o, a in opts:
        # Commands to create new devices
        if o == "--node":
            options['node'] = a
        if o == "--ldapserver":
            options['ldapserver'] = a
        if o == "--port":
            options['port'] = a

        # Options for commands

        # lmc options
        if o in ("-h", "--help"):
            usage()
        if o in ("-o", "--output"):
            options['output'] = a
        if o in ("-m", "--merge"):
            options['merge'] = a
        if o  == "--add":
            options['add'] = a
            
    return options, args


program_name = ""
def main():
    global program_name
    arglist = string.split(sys.argv[0], '/')
    program_name = arglist[len(arglist)-1]
    if program_name != 'genConfig':
       options, args = parse_cmdline(sys.argv[1:])
       outFile = '-'
       if options.has_key('ldapserver'):
	   ldapserver = options['ldapserver']

	   if options.has_key('node'):
		nodename = options['node']
	   else:
		nodename = socket.gethostname()

	   if options.has_key('port'):
		port = int(options['port'])
	   else:
		port = 389

	   if options.has_key('add'):
		outFile = options['add']

           genXml(nodename,ldapserver,port,options)
    else:
       options = {}
       args = []
       outFile = '/etc/lustre/config.xml'
       fp=open("/etc/lustre/ldapserver","r")
       line=fp.readline()
       fp.close()
       ldapinfo=string.split(line,':')
       ldapserver=ldapinfo[0]
       port=ldapinfo[1]
       nodename = socket.gethostname()
       nodename = 'lustre4'
       genXml(nodename,ldapserver,port,options)

if __name__ == "__main__":
    main()

    
