#!/usr/bin/env python
#
#  Copyright (C) 2002 Cluster File Systems, Inc.
#   Author: Robert Read <rread@clusterfs.com>

#   This file is part of Lustre, http://www.lustre.org.
#
#   Lustre is free software; you can redistribute it and/or
#   modify it under the terms of version 2 of the GNU General Public
#   License as published by the Free Software Foundation.
#
#   Lustre is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with Lustre; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

# lmc - lustre configurtion data  manager
#
import sys, getopt
import xml.dom.minidom
from xml.dom.ext import PrettyPrint


def usage():
    print """usage: lmc [--ost | --mtpt | --lov] cmd args
Commands:
--ost "device" "host" [size]
   Creates an OBD/OST/OSC configuration triplet for a new device.
   When used on "host", the device will be initialized and the OST
   will be enabled. On client nodes, the OSC will be avaiable.

--osc "device" "host" [lov_name]
   Create an osc, and optionally add it to an lov.

--mtpt "mds" "ost/lov-name" /mnt/point
   Creates a client mount point.

--lov lov_name mdc_name stripe_sz stripe_off pattern
   Produces a logical volum striped over the OSTs found in all-ost.xml.

Options:
--merge="xml file"  Add the new objects to an existing file
--format            Format the partitions if unformated
--reformat          Reformat partitions (this should be an lconf arg,
                    I think)
(SCRIPT STILL UNDER DEVELOPMENT, MOST COMMANDS/OPTIONS UNIMPLEMENTED)
"""  

#
# manage names and uuids
# need to initialize this by walking tree to ensure
# no duplicate names or uuids are created.
# this are just place holders for now.
# consider changing this to be like OBD-dev-host
name_ctr = 1
def new_name(base):
    global name_ctr
    name = "%s_%d" % (base, name_ctr)
    name_ctr += 1
    return name

def get_uuid(name):
    return "%s_UUID" % (name)

def new_lustre(dom):
    """Create a new empty lustre document"""
    str = """<lustre> </lustre>"""
    return dom.parseString(str)


class GenConfig:
    doc = None
    dom = None
    def __init__(self, doc):
        self.doc = doc

    def ref(self, type, uuid):
        """ generate <[type]_ref uuidref="[uuid]"/> """
        tag = "%s_ref" % (type)
        ref = self.doc.createElement(tag)
        ref.setAttribute("uuidref", uuid)
        return ref
    
    def newService(self, tag, name, uuid):
        """ create a new  service elmement, which requires name and uuid attributes """
        new = self.doc.createElement(tag)
        new.setAttribute("name", name);
        new.setAttribute("uuid", uuid);
        return new
    
    def addText(self, node, str):
        txt = self.doc.createTextNode(str)
        node.appendChild(txt)

    def addElement(self, node, tag, str=None):
        """ create a new element and add it as a child to node. If str is passed,
            a text node is created for the new element"""
        new = self.doc.createElement(tag)
        if str:
            self.addText(new, str)
        node.appendChild(new)
        return new

    def network(self, name, uuid, net, hostname, port=0):
        """create <network> node"""
        network = self.newService("network", name, uuid)
        network.setAttribute("type", net);
        self.addElement(network, "server", hostname)
        if port:
            self.addElement(network, "port", "%d" %(port))
        return network

    def node(self, name, uuid):
        """ create a host """
        node = self.newService("node", name, uuid)
        return node

    def obd(self, name, uuid, fs, devname, format, dev_size=0, dev_file=""):
        obd = self.newService("obd", name, uuid)
        obd.setAttribute('type', 'obdfilter')
        self.addElement(obd, "fstype", fs)
        dev = self.addElement(obd, "device", devname)
        if (dev_size):
            dev.setAttribute("size", "%s" % (dev_size))
        self.addElement(obd, "autoformat", format)
        return obd

    def osc(self, name, uuid, obd_uuid, net_uuid):
        osc = self.newService("osc", name, uuid)
        osc.appendChild(self.ref("network", net_uuid))
        osc.appendChild(self.ref("obd", obd_uuid))
        return osc

    def ost(self, name, uuid, obd_uuid, net_uuid):
        ost = self.newService("ost", name, uuid)
        ost.appendChild(self.ref("network", net_uuid))
        ost.appendChild(self.ref("obd", obd_uuid))
        return ost

#
# Create a new obd, osc, and ost. Add them to the DOM.
#
def add_OST(doc, options, args):
    # XXX need some error checking
    gen = GenConfig(doc)
    devname = args[0]
    host = args[1]
    if len(args) > 2:
        size = args[2]
    else:
        size = 0

    lustre = doc.getElementsByTagName("lustre")[0]

    obdname = new_name("obd")
    oscname = new_name("osc")
    ostname = new_name("ost")
    node_uuid = get_uuid(host)
    net_uuid = get_uuid("net")
    obd_uuid = get_uuid(obdname)
    ost_uuid = get_uuid(ostname)
    osc_uuid = get_uuid(oscname)

    node = gen.node(host, node_uuid)
    node.appendChild(gen.network(host, net_uuid, "tcp", host, port=2436))
    obd = gen.obd(obdname, obd_uuid,  "extN", devname, "no", size)
    ost = gen.ost(ostname, ost_uuid, obd_uuid, net_uuid)
    osc = gen.osc(oscname, osc_uuid, obd_uuid, net_uuid)
    
    lustre.appendChild(node)
    lustre.appendChild(obd)
    lustre.appendChild(osc)
    lustre.appendChild(ost)
                   

#
# Command line processing
#

def parse_cmdline(argv):
    short_opts = "ho:"
    long_opts = ["ost", "mtpt", "lov",
                 "merge=", "format", "reformat", "output=",
                 "help"]
    opts = []
    args = []
    options = {}
    try:
        opts, args = getopt.getopt(argv, short_opts, long_opts)
    except getopt.GetoptError:
        print "invalid opt"
        usage()
        sys.exit(2)

    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        if o in ("-o", "--output"):
            options['output'] = a
        if o == "--ost":
            options['ost'] = 1
        if o == "--merge":
            options['merge'] = a
        if o == "--format":
            options['format'] = 1
        if o  == "--reformat":
            options['reformat'] = 1
            
    return options, args

def main():
    options, args = parse_cmdline(sys.argv[1:])
    outFile = '-'

    if options.has_key('merge'):
        outFile = options['merge']
        doc = xml.dom.minidom.parse(outFile)
    else:
        doc = new_lustre(xml.dom.minidom)

    if options.has_key('output'):
        outFile = options['output']

    if options.has_key('ost'):
        add_OST(doc, options, args)
    elif options.has_key('mtpt'):
        print "--mtpt not implemented"
    elif options.has_key('lov'):
        print "--lov not implemented"
    else:
        print "Missing command"
        usage()
        sys.exit(1)

    if outFile == '-':
        PrettyPrint(doc)
    else:
        PrettyPrint(doc, open(outFile,"w"))
if __name__ == "__main__":
    main()

    
