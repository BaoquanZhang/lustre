diff -u -r kernel-2.4.20/drivers/block/blkpg.c kernel-2.4.20-l15/drivers/block/blkpg.c
--- kernel-2.4.20/drivers/block/blkpg.c	Fri Aug  2 17:39:43 2002
+++ kernel-2.4.20-l15drivers/block/blkpg.c	Tue Apr  8 19:40:22 2003
@@ -296,3 +296,38 @@
 }
 
 EXPORT_SYMBOL(blk_ioctl);
+
+#define NUM_DEV_NO_WRITE 16
+static int dev_no_write[NUM_DEV_NO_WRITE];
+
+/*
+ * Debug code for turning block devices "read-only" (will discard writes
+ * silently).  This is for filesystem crash/recovery testing.
+ */
+void dev_set_rdonly(kdev_t dev, int no_write)
+{
+	if (dev) {
+		printk(KERN_WARNING "Turning device %s read-only\n",
+		       bdevname(dev));
+		dev_no_write[no_write] = 0xdead0000 + dev;
+	}
+}
+
+int dev_check_rdonly(kdev_t dev) {
+	int i;
+
+	for (i = 0; i < NUM_DEV_NO_WRITE; i++) {
+		if ((dev_no_write[i] & 0xffff0000) == 0xdead0000 &&
+		    dev == (dev_no_write[i] & 0xffff))
+			return 1;
+	}
+	return 0;
+}
+
+void dev_clear_rdonly(int no_write) {
+	dev_no_write[no_write] = 0;
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
diff -u -r kernel-2.4.20/drivers/block/loop.c kernel-2.4.20-l15/drivers/block/loop.c
--- kernel-2.4.20/drivers/block/loop.c	Thu Nov 28 15:53:12 2002
+++ kernel-2.4.20-l15/drivers/block/loop.c	Tue Apr  8 19:40:22 2003
@@ -474,6 +474,9 @@
 	spin_unlock_irq(&lo->lo_lock);
 
 	if (rw == WRITE) {
+		if (dev_check_rdonly(rbh->b_rdev))
+			goto err;
+
 		if (lo->lo_flags & LO_FLAGS_READ_ONLY)
 			goto err;
 	} else if (rw == READA) {
diff -u -r kernel-2.4.20/drivers/ide/ide-disk.c kernel-2.4.20-l15/drivers/ide/ide-disk.c
--- kernel-2.4.20/drivers/ide/ide-disk.c	Thu Nov 28 15:53:13 2002
+++ kernel-2.4.20-l15/drivers/ide/ide-disk.c	Tue Apr  8 19:42:09 2003
@@ -558,6 +558,10 @@
  */
 static ide_startstop_t do_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long block)
 {
+	if (rq->cmd == WRITE && dev_check_rdonly(rq->rq_dev)) {
+ 		ide_end_request(1, HWGROUP(drive));
+		return ide_stopped;
+	} 
 	if (IDE_CONTROL_REG)
 		OUT_BYTE(drive->ctl,IDE_CONTROL_REG);
 
 arch/ia64/mm/init.c  |    6 +++++
 include/linux/slab.h |    1 
 kernel/ksyms.c       |    1 
 mm/slab.c            |   53 +++++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 61 insertions(+)

--- linux-2.4.20/arch/ia64/mm/init.c~kmem_cache_validate_hp	2003-04-08 23:34:12.000000000 -0600
+++ linux-2.4.20-braam/arch/ia64/mm/init.c	2003-04-08 23:34:12.000000000 -0600
@@ -45,6 +45,12 @@ static struct page *vmem_map;
 static unsigned long num_dma_physpages;
 #endif
 
+struct page *check_get_page(unsigned long kaddr)
+{
+#warning FIXME: Lustre team, is this solid?
+	return virt_to_page(kaddr);
+}
+
 int
 do_check_pgt_cache (int low, int high)
 {
--- linux-2.4.20/include/linux/slab.h~kmem_cache_validate_hp	2003-04-08 23:34:12.000000000 -0600
+++ linux-2.4.20-braam/include/linux/slab.h	2003-04-08 23:34:12.000000000 -0600
@@ -56,6 +56,7 @@ extern kmem_cache_t *kmem_cache_create(c
 extern int kmem_cache_destroy(kmem_cache_t *);
 extern int kmem_cache_shrink(kmem_cache_t *);
 extern void *kmem_cache_alloc(kmem_cache_t *, int);
+extern int kmem_cache_validate(kmem_cache_t *cachep, void *objp);
 extern void kmem_cache_free(kmem_cache_t *, void *);
 extern unsigned int kmem_cache_size(kmem_cache_t *);
 
--- linux-2.4.20/kernel/ksyms.c~kmem_cache_validate_hp	2003-04-08 23:34:12.000000000 -0600
+++ linux-2.4.20-braam/kernel/ksyms.c	2003-04-08 23:34:12.000000000 -0600
@@ -103,6 +103,7 @@ EXPORT_SYMBOL(kmem_find_general_cachep);
 EXPORT_SYMBOL(kmem_cache_create);
 EXPORT_SYMBOL(kmem_cache_destroy);
 EXPORT_SYMBOL(kmem_cache_shrink);
+EXPORT_SYMBOL(kmem_cache_validate);
 EXPORT_SYMBOL(kmem_cache_alloc);
 EXPORT_SYMBOL(kmem_cache_free);
 EXPORT_SYMBOL(kmem_cache_size);
--- linux-2.4.20/mm/slab.c~kmem_cache_validate_hp	2003-04-08 23:34:12.000000000 -0600
+++ linux-2.4.20-braam/mm/slab.c	2003-04-08 23:34:12.000000000 -0600
@@ -1205,6 +1205,59 @@ failed:
  * Called with the cache-lock held.
  */
 
+extern struct page *check_get_page(unsigned long kaddr);
+struct page *page_mem_map(struct page *page);
+static int kmem_check_cache_obj (kmem_cache_t * cachep,
+				 slab_t *slabp, void * objp)
+{
+	int i;
+	unsigned int objnr;
+
+#if DEBUG
+	if (cachep->flags & SLAB_RED_ZONE) {
+		objp -= BYTES_PER_WORD;
+		if ( *(unsigned long *)objp != RED_MAGIC2)
+			/* Either write before start, or a double free. */
+			return 0;
+		if (*(unsigned long *)(objp+cachep->objsize -
+				BYTES_PER_WORD) != RED_MAGIC2)
+			/* Either write past end, or a double free. */
+			return 0;
+	}
+#endif
+
+	objnr = (objp-slabp->s_mem)/cachep->objsize;
+	if (objnr >= cachep->num)
+		return 0;
+	if (objp != slabp->s_mem + objnr*cachep->objsize)
+		return 0;
+
+	/* Check slab's freelist to see if this obj is there. */
+	for (i = slabp->free; i != BUFCTL_END; i = slab_bufctl(slabp)[i]) {
+		if (i == objnr)
+			return 0;
+	}
+	return 1;
+}
+
+
+int kmem_cache_validate(kmem_cache_t *cachep, void *objp)
+{
+	struct page *page = check_get_page((unsigned long)objp);
+
+	if (!VALID_PAGE(page))
+		return 0;
+
+	if (!PageSlab(page))
+		return 0;
+
+	/* XXX check for freed slab objects ? */
+	if (!kmem_check_cache_obj(cachep, GET_PAGE_SLAB(page), objp))
+		return 0;
+
+	return (cachep == GET_PAGE_CACHE(page));
+}
+
 #if DEBUG
 static int kmem_extra_free_checks (kmem_cache_t * cachep,
 			slab_t *slabp, void * objp)

_



 include/linux/lustre_version.h |    1 +
 1 files changed, 1 insertion(+)

--- /dev/null	Fri Aug 30 17:31:37 2002
+++ linux-2.4.18-18.8.0-l12-braam/include/linux/lustre_version.h	Thu Feb 13 07:58:33 2003
@@ -0,0 +1 @@
+#define LUSTRE_KERNEL_VERSION 16

_
 fs/dcache.c            |   20 ++
 fs/namei.c             |  356 +++++++++++++++++++++++++++++++++++++++++--------
 fs/nfsd/vfs.c          |    2 
 fs/open.c              |  126 ++++++++++++++---
 fs/stat.c              |   24 ++-
 include/linux/dcache.h |   28 +++
 include/linux/fs.h     |   31 +++-
 kernel/ksyms.c         |    1 
 8 files changed, 504 insertions(+), 84 deletions(-)

--- linux-2.4.20/fs/dcache.c~vfs_intent-2.4.20-vanilla	2003-04-08 23:34:29.000000000 -0600
+++ linux-2.4.20-braam/fs/dcache.c	2003-04-08 23:34:29.000000000 -0600
@@ -181,6 +181,13 @@ int d_invalidate(struct dentry * dentry)
 		spin_unlock(&dcache_lock);
 		return 0;
 	}
+
+	/* network invalidation by Lustre */
+	if (dentry->d_flags & DCACHE_LUSTRE_INVALID) {
+		spin_unlock(&dcache_lock);
+		return 0;
+	}
+
 	/*
 	 * Check whether to do a partial shrink_dcache
 	 * to get rid of unused child entries.
@@ -616,6 +623,7 @@ struct dentry * d_alloc(struct dentry * 
 	dentry->d_op = NULL;
 	dentry->d_fsdata = NULL;
 	dentry->d_mounted = 0;
+	dentry->d_it = NULL;
 	INIT_LIST_HEAD(&dentry->d_hash);
 	INIT_LIST_HEAD(&dentry->d_lru);
 	INIT_LIST_HEAD(&dentry->d_subdirs);
@@ -830,13 +838,19 @@ void d_delete(struct dentry * dentry)
  * Adds a dentry to the hash according to its name.
  */
  
-void d_rehash(struct dentry * entry)
+void __d_rehash(struct dentry * entry, int lock)
 {
 	struct list_head *list = d_hash(entry->d_parent, entry->d_name.hash);
 	if (!list_empty(&entry->d_hash)) BUG();
-	spin_lock(&dcache_lock);
+	if (lock) spin_lock(&dcache_lock);
 	list_add(&entry->d_hash, list);
-	spin_unlock(&dcache_lock);
+	if (lock) spin_unlock(&dcache_lock);
+}
+EXPORT_SYMBOL(__d_rehash);
+
+void d_rehash(struct dentry * entry)
+{
+	__d_rehash(entry, 1);
 }
 
 #define do_switch(x,y) do { \
--- linux-2.4.20/fs/namei.c~vfs_intent-2.4.20-vanilla	2003-04-08 23:34:29.000000000 -0600
+++ linux-2.4.20-braam/fs/namei.c	2003-04-08 23:34:29.000000000 -0600
@@ -94,6 +94,13 @@
  * XEmacs seems to be relying on it...
  */
 
+void intent_release(struct dentry *de, struct lookup_intent *it)
+{
+	if (it && de->d_op && de->d_op->d_intent_release)
+		de->d_op->d_intent_release(de, it);
+
+}
+
 /* In order to reduce some races, while at the same time doing additional
  * checking and hopefully speeding things up, we copy filenames to the
  * kernel data space before using them..
@@ -260,10 +267,19 @@ void path_release(struct nameidata *nd)
  * Internal lookup() using the new generic dcache.
  * SMP-safe
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry *cached_lookup(struct dentry *parent, struct qstr *name,
+				    int flags, struct lookup_intent *it)
 {
 	struct dentry * dentry = d_lookup(parent, name);
 
+	if (dentry && dentry->d_op && dentry->d_op->d_revalidate2) {
+		if (!dentry->d_op->d_revalidate2(dentry, flags, it) &&
+		    !d_invalidate(dentry)) {
+			dput(dentry);
+			dentry = NULL;
+		}
+		return dentry;
+	} else
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
@@ -281,11 +297,14 @@ static struct dentry * cached_lookup(str
  * make sure that nobody added the entry to the dcache in the meantime..
  * SMP-safe
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry *real_lookup(struct dentry *parent, struct qstr *name,
+				  int flags, struct lookup_intent *it)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
 
+again:
+
 	down(&dir->i_sem);
 	/*
 	 * First re-do the cached lookup just in case it was created
@@ -300,6 +319,9 @@ static struct dentry * real_lookup(struc
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
 			lock_kernel();
+			if (dir->i_op->lookup2)
+				result = dir->i_op->lookup2(dir, dentry, it);
+			else
 			result = dir->i_op->lookup(dir, dentry);
 			unlock_kernel();
 			if (result)
@@ -321,6 +343,12 @@ static struct dentry * real_lookup(struc
 			dput(result);
 			result = ERR_PTR(-ENOENT);
 		}
+	} else if (result->d_op && result->d_op->d_revalidate2) {
+		if (!result->d_op->d_revalidate2(result, flags, it) &&
+		    !d_invalidate(result)) {
+			dput(result);
+			goto again;
+		}
 	}
 	return result;
 }
@@ -332,7 +360,8 @@ static struct dentry * real_lookup(struc
  * Without that kind of total limit, nasty chains of consecutive
  * symlinks can cause almost arbitrarily long lookups. 
  */
-static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd)
+static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd,
+				 struct lookup_intent *it)
 {
 	int err;
 	if (current->link_count >= 5)
@@ -346,10 +375,14 @@ static inline int do_follow_link(struct 
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
-	err = dentry->d_inode->i_op->follow_link(dentry, nd);
+	if (dentry->d_inode->i_op->follow_link2)
+		err = dentry->d_inode->i_op->follow_link2(dentry, nd, it);
+	else
+		err = dentry->d_inode->i_op->follow_link(dentry, nd);
 	current->link_count--;
 	return err;
 loop:
+	intent_release(dentry, it);
 	path_release(nd);
 	return -ELOOP;
 }
@@ -379,15 +412,26 @@ int follow_up(struct vfsmount **mnt, str
 	return __follow_up(mnt, dentry);
 }
 
-static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry)
+static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry,
+				struct lookup_intent *it)
 {
 	struct vfsmount *mounted;
 
 	spin_lock(&dcache_lock);
 	mounted = lookup_mnt(*mnt, *dentry);
 	if (mounted) {
+		int opc = 0, mode = 0;
 		*mnt = mntget(mounted);
 		spin_unlock(&dcache_lock);
+		if (it) {
+			opc = it->it_op;
+			mode = it->it_mode;
+		}
+		intent_release(*dentry, it);
+		if (it) {
+			it->it_op = opc;
+			it->it_mode = mode;
+		}
 		dput(*dentry);
 		mntput(mounted->mnt_parent);
 		*dentry = dget(mounted->mnt_root);
@@ -399,7 +443,7 @@ static inline int __follow_down(struct v
 
 int follow_down(struct vfsmount **mnt, struct dentry **dentry)
 {
-	return __follow_down(mnt,dentry);
+	return __follow_down(mnt,dentry,NULL);
 }
  
 static inline void follow_dotdot(struct nameidata *nd)
@@ -435,7 +479,7 @@ static inline void follow_dotdot(struct 
 		mntput(nd->mnt);
 		nd->mnt = parent;
 	}
-	while (d_mountpoint(nd->dentry) && __follow_down(&nd->mnt, &nd->dentry))
+	while (d_mountpoint(nd->dentry) && __follow_down(&nd->mnt, &nd->dentry, NULL))
 		;
 }
 
@@ -447,7 +491,8 @@ static inline void follow_dotdot(struct 
  *
  * We expect 'base' to be positive and a directory.
  */
-int link_path_walk(const char * name, struct nameidata *nd)
+int link_path_walk_it(const char *name, struct nameidata *nd,
+		      struct lookup_intent *it)
 {
 	struct dentry *dentry;
 	struct inode *inode;
@@ -520,15 +565,15 @@ int link_path_walk(const char * name, st
 				break;
 		}
 		/* This does the actual lookups.. */
-		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE, NULL);
 		if (!dentry) {
-			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE, NULL);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
 		}
 		/* Check mountpoints.. */
-		while (d_mountpoint(dentry) && __follow_down(&nd->mnt, &dentry))
+		while (d_mountpoint(dentry) && __follow_down(&nd->mnt, &dentry, NULL))
 			;
 
 		err = -ENOENT;
@@ -539,8 +584,8 @@ int link_path_walk(const char * name, st
 		if (!inode->i_op)
 			goto out_dput;
 
-		if (inode->i_op->follow_link) {
-			err = do_follow_link(dentry, nd);
+		if (inode->i_op->follow_link || inode->i_op->follow_link2) {
+			err = do_follow_link(dentry, nd, NULL);
 			dput(dentry);
 			if (err)
 				goto return_err;
@@ -556,7 +601,7 @@ int link_path_walk(const char * name, st
 			nd->dentry = dentry;
 		}
 		err = -ENOTDIR; 
-		if (!inode->i_op->lookup)
+		if (!inode->i_op->lookup && !inode->i_op->lookup2)
 			break;
 		continue;
 		/* here ends the main loop */
@@ -583,19 +628,20 @@ last_component:
 			if (err < 0)
 				break;
 		}
-		dentry = cached_lookup(nd->dentry, &this, 0);
+		dentry = cached_lookup(nd->dentry, &this, 0, it);
 		if (!dentry) {
-			dentry = real_lookup(nd->dentry, &this, 0);
+			dentry = real_lookup(nd->dentry, &this, 0, it);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
 		}
-		while (d_mountpoint(dentry) && __follow_down(&nd->mnt, &dentry))
+		while (d_mountpoint(dentry) && __follow_down(&nd->mnt, &dentry, it))
 			;
 		inode = dentry->d_inode;
 		if ((lookup_flags & LOOKUP_FOLLOW)
-		    && inode && inode->i_op && inode->i_op->follow_link) {
-			err = do_follow_link(dentry, nd);
+		    && inode && inode->i_op &&
+		    (inode->i_op->follow_link || inode->i_op->follow_link2)) {
+			err = do_follow_link(dentry, nd, it);
 			dput(dentry);
 			if (err)
 				goto return_err;
@@ -609,7 +655,8 @@ last_component:
 			goto no_inode;
 		if (lookup_flags & LOOKUP_DIRECTORY) {
 			err = -ENOTDIR; 
-			if (!inode->i_op || !inode->i_op->lookup)
+			if (!inode->i_op ||
+			    (!inode->i_op->lookup && !inode->i_op->lookup2))
 				break;
 		}
 		goto return_base;
@@ -633,6 +680,23 @@ return_reval:
 		 * Check the cached dentry for staleness.
 		 */
 		dentry = nd->dentry;
+        revalidate_again:
+		if (dentry && dentry->d_op && dentry->d_op->d_revalidate2) {
+			err = -ESTALE;
+			if (!dentry->d_op->d_revalidate2(dentry, 0, it)) {
+                                struct dentry *new;
+                                err = permission(dentry->d_parent->d_inode, 
+                                                 MAY_EXEC);
+                                if (err)
+                                        break;
+                                new = real_lookup(dentry->d_parent,
+                                                  &dentry->d_name, 0, NULL);
+				d_invalidate(dentry);
+                                dput(dentry);
+                                dentry = new;
+                                goto revalidate_again;
+                        }
+		} else
 		if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 			err = -ESTALE;
 			if (!dentry->d_op->d_revalidate(dentry, 0)) {
@@ -646,15 +710,28 @@ out_dput:
 		dput(dentry);
 		break;
 	}
+	if (err)
+		intent_release(nd->dentry, it);
 	path_release(nd);
 return_err:
 	return err;
 }
 
+int link_path_walk(const char * name, struct nameidata *nd)
+{
+	return link_path_walk_it(name, nd, NULL);
+}
+
+int path_walk_it(const char * name, struct nameidata *nd, struct lookup_intent *it)
+{
+	current->total_link_count = 0;
+	return link_path_walk_it(name, nd, it);
+}
+
 int path_walk(const char * name, struct nameidata *nd)
 {
 	current->total_link_count = 0;
-	return link_path_walk(name, nd);
+	return link_path_walk_it(name, nd, NULL);
 }
 
 /* SMP-safe */
@@ -739,6 +816,17 @@ walk_init_root(const char *name, struct 
 }
 
 /* SMP-safe */
+int path_lookup_it(const char *path, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it)
+{
+	int error = 0;
+	if (path_init(path, flags, nd))
+		error = path_walk_it(path, nd, it);
+	return error;
+}
+
+
+/* SMP-safe */
 int path_lookup(const char *path, unsigned flags, struct nameidata *nd)
 {
 	int error = 0;
@@ -767,7 +855,8 @@ int path_init(const char *name, unsigned
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+struct dentry * lookup_hash_it(struct qstr *name, struct dentry * base,
+			       struct lookup_intent *it)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -790,13 +879,16 @@ struct dentry * lookup_hash(struct qstr 
 			goto out;
 	}
 
-	dentry = cached_lookup(base, name, 0);
+	dentry = cached_lookup(base, name, 0, it);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
 		lock_kernel();
+		if (inode->i_op->lookup2)
+			dentry = inode->i_op->lookup2(inode, new, it);
+		else
 		dentry = inode->i_op->lookup(inode, new);
 		unlock_kernel();
 		if (!dentry)
@@ -808,6 +900,12 @@ out:
 	return dentry;
 }
 
+struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+{
+	return lookup_hash_it(name, base, NULL);
+}
+
+
 /* SMP-safe */
 struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
 {
@@ -829,7 +927,7 @@ struct dentry * lookup_one_len(const cha
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return lookup_hash_it(&this, base, NULL);
 access:
 	return ERR_PTR(-EACCES);
 }
@@ -860,6 +958,23 @@ int __user_walk(const char *name, unsign
 	return err;
 }
 
+int __user_walk_it(const char *name, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it)
+{
+	char *tmp;
+	int err;
+
+	tmp = getname(name);
+	err = PTR_ERR(tmp);
+	if (!IS_ERR(tmp)) {
+		err = 0;
+		if (path_init(tmp, flags, nd))
+			err = path_walk_it(tmp, nd, it);
+		putname(tmp);
+	}
+	return err;
+}
+
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -996,7 +1111,8 @@ exit_lock:
  * for symlinks (where the permissions are checked later).
  * SMP-safe
  */
-int open_namei(const char * pathname, int flag, int mode, struct nameidata *nd)
+int open_namei_it(const char *pathname, int flag, int mode,
+		  struct nameidata *nd, struct lookup_intent *it)
 {
 	int acc_mode, error = 0;
 	struct inode *inode;
@@ -1010,7 +1126,7 @@ int open_namei(const char * pathname, in
 	 * The simplest case - just a plain lookup.
 	 */
 	if (!(flag & O_CREAT)) {
-		error = path_lookup(pathname, lookup_flags(flag), nd);
+		error = path_lookup_it(pathname, lookup_flags(flag), nd, it);
 		if (error)
 			return error;
 		dentry = nd->dentry;
@@ -1020,6 +1136,10 @@ int open_namei(const char * pathname, in
 	/*
 	 * Create - we need to know the parent.
 	 */
+ 	if (it) {
+ 		it->it_mode = mode;
+ 		it->it_op |= IT_CREAT;
+ 	}
 	error = path_lookup(pathname, LOOKUP_PARENT, nd);
 	if (error)
 		return error;
@@ -1035,7 +1155,7 @@ int open_namei(const char * pathname, in
 
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1044,6 +1164,7 @@ do_last:
 		goto exit;
 	}
 
+	it->it_mode = mode;
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		error = vfs_create(dir->d_inode, dentry,
@@ -1072,12 +1193,13 @@ do_last:
 		error = -ELOOP;
 		if (flag & O_NOFOLLOW)
 			goto exit_dput;
-		while (__follow_down(&nd->mnt,&dentry) && d_mountpoint(dentry));
+		while (__follow_down(&nd->mnt,&dentry,it) && d_mountpoint(dentry));
 	}
 	error = -ENOENT;
 	if (!dentry->d_inode)
 		goto exit_dput;
-	if (dentry->d_inode->i_op && dentry->d_inode->i_op->follow_link)
+	if (dentry->d_inode->i_op && (dentry->d_inode->i_op->follow_link ||
+				      dentry->d_inode->i_op->follow_link2))
 		goto do_link;
 
 	dput(nd->dentry);
@@ -1151,7 +1273,7 @@ ok:
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0);
+			error = do_truncate(dentry, 0, 1);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1163,8 +1285,10 @@ ok:
 	return 0;
 
 exit_dput:
+	intent_release(dentry, it);
 	dput(dentry);
 exit:
+	intent_release(nd->dentry, it);
 	path_release(nd);
 	return error;
 
@@ -1183,7 +1307,12 @@ do_link:
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
 	UPDATE_ATIME(dentry->d_inode);
-	error = dentry->d_inode->i_op->follow_link(dentry, nd);
+	if (dentry->d_inode->i_op->follow_link2)
+		error = dentry->d_inode->i_op->follow_link2(dentry, nd, it);
+	else
+		error = dentry->d_inode->i_op->follow_link(dentry, nd);
+	if (error)
+		intent_release(dentry, it);
 	dput(dentry);
 	if (error)
 		return error;
@@ -1205,13 +1334,20 @@ do_link:
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 	putname(nd->last.name);
 	goto do_last;
 }
 
+int open_namei(const char *pathname, int flag, int mode, struct nameidata *nd)
+{
+	return open_namei_it(pathname, flag, mode, nd, NULL);
+}
+
+
 /* SMP-safe */
-static struct dentry *lookup_create(struct nameidata *nd, int is_dir)
+static struct dentry *lookup_create(struct nameidata *nd, int is_dir,
+				    struct lookup_intent *it)
 {
 	struct dentry *dentry;
 
@@ -1219,7 +1355,7 @@ static struct dentry *lookup_create(stru
 	dentry = ERR_PTR(-EEXIST);
 	if (nd->last_type != LAST_NORM)
 		goto fail;
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 	if (IS_ERR(dentry))
 		goto fail;
 	if (!is_dir && nd->last.name[nd->last.len] && !dentry->d_inode)
@@ -1275,7 +1411,19 @@ asmlinkage long sys_mknod(const char * f
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
-	dentry = lookup_create(&nd, 0);
+
+	if (nd.dentry->d_inode->i_op->mknod2) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->mknod2(nd.dentry->d_inode,
+				   nd.last.name,
+				   nd.last.len,
+				   mode, dev);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out2;
+	}
+
+	dentry = lookup_create(&nd, 0, NULL);
 	error = PTR_ERR(dentry);
 
 	mode &= ~current->fs->umask;
@@ -1296,6 +1444,7 @@ asmlinkage long sys_mknod(const char * f
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
+out2:
 	path_release(&nd);
 out:
 	putname(tmp);
@@ -1343,7 +1492,17 @@ asmlinkage long sys_mkdir(const char * p
 		error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 1);
+ 		if (nd.dentry->d_inode->i_op->mkdir2) {
+ 			struct inode_operations *op = nd.dentry->d_inode->i_op;
+ 			error = op->mkdir2(nd.dentry->d_inode,
+ 					   nd.last.name,
+ 					   nd.last.len,
+ 					   mode);
+ 			/* the file system wants to use normal vfs path now */
+ 			if (error != -EOPNOTSUPP)
+ 				goto out2;
+ 		}
+		dentry = lookup_create(&nd, 1, NULL);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1351,6 +1510,7 @@ asmlinkage long sys_mkdir(const char * p
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 		putname(tmp);
@@ -1451,8 +1611,33 @@ asmlinkage long sys_rmdir(const char * p
 			error = -EBUSY;
 			goto exit1;
 	}
+	if (nd.dentry->d_inode->i_op->rmdir2) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		struct dentry *last;
+
+		down(&nd.dentry->d_inode->i_sem);
+		last = lookup_hash_it(&nd.last, nd.dentry, NULL);
+		up(&nd.dentry->d_inode->i_sem);
+		if (IS_ERR(last)) {
+			error = PTR_ERR(last);
+			goto exit1;
+		}
+		if (d_mountpoint(last)) {
+			dput(last);
+			error = -EBUSY;
+			goto exit1;
+		}
+		dput(last);
+
+		error = op->rmdir2(nd.dentry->d_inode,
+				   nd.last.name,
+				   nd.last.len);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, NULL);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1510,8 +1695,17 @@ asmlinkage long sys_unlink(const char * 
 	error = -EISDIR;
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
+	if (nd.dentry->d_inode->i_op->unlink2) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->unlink2(nd.dentry->d_inode,
+				    nd.last.name,
+				    nd.last.len);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, NULL);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -1578,15 +1772,26 @@ asmlinkage long sys_symlink(const char *
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 0);
+		if (nd.dentry->d_inode->i_op->symlink2) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->symlink2(nd.dentry->d_inode,
+					     nd.last.name,
+					     nd.last.len,
+					     from);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
+		dentry = lookup_create(&nd, 0, NULL);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+	out2:
 		path_release(&nd);
-out:
+	out:
 		putname(to);
 	}
 	putname(from);
@@ -1662,7 +1867,17 @@ asmlinkage long sys_link(const char * ol
 		error = -EXDEV;
 		if (old_nd.mnt != nd.mnt)
 			goto out_release;
-		new_dentry = lookup_create(&nd, 0);
+		if (nd.dentry->d_inode->i_op->link2) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->link2(old_nd.dentry->d_inode,
+					  nd.dentry->d_inode,
+					  nd.last.name,
+					  nd.last.len);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out_release;
+		}
+		new_dentry = lookup_create(&nd, 0, NULL);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -1706,7 +1921,8 @@ exit:
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		   struct inode *new_dir, struct dentry *new_dentry,
+		   struct lookup_intent *it)
 {
 	int error;
 	struct inode *target;
@@ -1764,6 +1980,7 @@ int vfs_rename_dir(struct inode *old_dir
 		error = -EBUSY;
 	else 
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry, it);
 	if (target) {
 		if (!error)
 			target->i_flags |= S_DEAD;
@@ -1785,7 +2002,8 @@ out_unlock:
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		     struct inode *new_dir, struct dentry *new_dentry,
+		     struct lookup_intent *it)
 {
 	int error;
 
@@ -1816,6 +2034,7 @@ int vfs_rename_other(struct inode *old_d
 		error = -EBUSY;
 	else
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry, it);
 	double_up(&old_dir->i_zombie, &new_dir->i_zombie);
 	if (error)
 		return error;
@@ -1827,13 +2046,14 @@ int vfs_rename_other(struct inode *old_d
 }
 
 int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry,
+	       struct lookup_intent *it)
 {
 	int error;
 	if (S_ISDIR(old_dentry->d_inode->i_mode))
-		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry,it);
 	else
-		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry,it);
 	if (!error) {
 		if (old_dir == new_dir)
 			inode_dir_notify(old_dir, DN_RENAME);
@@ -1875,7 +2095,7 @@ static inline int do_rename(const char *
 
 	double_lock(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = lookup_hash_it(&oldnd.last, old_dir, NULL);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -1891,16 +2111,37 @@ static inline int do_rename(const char *
 		if (newnd.last.name[newnd.last.len])
 			goto exit4;
 	}
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = lookup_hash_it(&newnd.last, new_dir, NULL);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
+	if (old_dir->d_inode->i_op->rename2) {
+		lock_kernel();
+		/* don't rename mount point. mds will take care of
+		 * the rest sanity checking */
+		if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry)) {
+			error = -EBUSY;
+			goto exit5;
+		}
+
+		error = old_dir->d_inode->i_op->rename2(old_dir->d_inode,
+							new_dir->d_inode,
+							oldnd.last.name,
+							oldnd.last.len,
+							newnd.last.name,
+							newnd.last.len);
+		unlock_kernel();
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit5;
+	}
+
 	lock_kernel();
 	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+				   new_dir->d_inode, new_dentry, NULL);
 	unlock_kernel();
-
+exit5:
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -1951,7 +2192,8 @@ out:
 }
 
 static inline int
-__vfs_follow_link(struct nameidata *nd, const char *link)
+__vfs_follow_link(struct nameidata *nd, const char *link,
+		  struct lookup_intent *it)
 {
 	int res = 0;
 	char *name;
@@ -1964,7 +2206,7 @@ __vfs_follow_link(struct nameidata *nd, 
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
-	res = link_path_walk(link, nd);
+	res = link_path_walk_it(link, nd, it);
 out:
 	if (current->link_count || res || nd->last_type!=LAST_NORM)
 		return res;
@@ -1986,7 +2228,13 @@ fail:
 
 int vfs_follow_link(struct nameidata *nd, const char *link)
 {
-	return __vfs_follow_link(nd, link);
+	return __vfs_follow_link(nd, link, NULL);
+}
+
+int vfs_follow_link_it(struct nameidata *nd, const char *link,
+		       struct lookup_intent *it)
+{
+	return __vfs_follow_link(nd, link, it);
 }
 
 /* get the link contents into pagecache */
@@ -2028,7 +2276,7 @@ int page_follow_link(struct dentry *dent
 {
 	struct page *page = NULL;
 	char *s = page_getlink(dentry, &page);
-	int res = __vfs_follow_link(nd, s);
+	int res = __vfs_follow_link(nd, s, NULL);
 	if (page) {
 		kunmap(page);
 		page_cache_release(page);
--- linux-2.4.20/fs/nfsd/vfs.c~vfs_intent-2.4.20-vanilla	2003-04-08 23:34:29.000000000 -0600
+++ linux-2.4.20-braam/fs/nfsd/vfs.c	2003-04-08 23:34:29.000000000 -0600
@@ -1291,7 +1291,7 @@ nfsd_rename(struct svc_rqst *rqstp, stru
 			err = nfserr_perm;
 	} else
 #endif
-	err = vfs_rename(fdir, odentry, tdir, ndentry);
+	err = vfs_rename(fdir, odentry, tdir, ndentry, NULL);
 	if (!err && EX_ISSYNC(tfhp->fh_export)) {
 		nfsd_sync_dir(tdentry);
 		nfsd_sync_dir(fdentry);
--- linux-2.4.20/fs/open.c~vfs_intent-2.4.20-vanilla	2003-04-08 23:34:29.000000000 -0600
+++ linux-2.4.20-braam/fs/open.c	2003-04-08 23:34:29.000000000 -0600
@@ -19,6 +19,8 @@
 #include <asm/uaccess.h>
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
+extern int path_walk_it(const char *name, struct nameidata *nd,
+			struct lookup_intent *it);
 
 int vfs_statfs(struct super_block *sb, struct statfs *buf)
 {
@@ -95,9 +97,10 @@ void fd_install(unsigned int fd, struct 
 	write_unlock(&files->file_lock);
 }
 
-int do_truncate(struct dentry *dentry, loff_t length)
+int do_truncate(struct dentry *dentry, loff_t length, int called_from_open)
 {
 	struct inode *inode = dentry->d_inode;
+	struct inode_operations *op = dentry->d_inode->i_op;
 	int error;
 	struct iattr newattrs;
 
@@ -108,7 +111,14 @@ int do_truncate(struct dentry *dentry, l
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-	error = notify_change(dentry, &newattrs);
+	if (called_from_open)
+		newattrs.ia_valid |= ATTR_FROM_OPEN;
+	if (op->setattr_raw) {
+		newattrs.ia_valid |= ATTR_RAW;
+		newattrs.ia_ctime = CURRENT_TIME;
+		error = op->setattr_raw(inode, &newattrs);
+	} else 
+		error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
 	return error;
 }
@@ -118,12 +128,13 @@ static inline long do_sys_truncate(const
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path_walk(path, &nd);
+	error = user_path_walk_it(path, &nd, &it);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
@@ -163,11 +174,13 @@ static inline long do_sys_truncate(const
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length);
+		intent_release(nd.dentry, &it);
+		error = do_truncate(nd.dentry, length, 0);
 	}
 	put_write_access(inode);
 
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -215,7 +228,7 @@ static inline long do_sys_ftruncate(unsi
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length);
+		error = do_truncate(dentry, length, 0);
 out_putf:
 	fput(file);
 out:
@@ -260,11 +273,13 @@ asmlinkage long sys_utime(char * filenam
 	struct inode * inode;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, NULL);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
 
+	/* this is safe without a Lustre lock because it only depends
+	   on the super block */
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
@@ -279,11 +294,29 @@ asmlinkage long sys_utime(char * filenam
 			goto dput_and_out;
 
 		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
-	} else {
+	}
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
+	error = -EROFS;
+	if (IS_RDONLY(inode))
+		goto dput_and_out;
+
+	error = -EPERM;
+	if (!times) {
 		if (current->fsuid != inode->i_uid &&
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
 	path_release(&nd);
@@ -304,12 +337,14 @@ asmlinkage long sys_utimes(char * filena
 	struct inode * inode;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, NULL);
 
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
 
+	/* this is safe without a Lustre lock because it only depends
+	   on the super block */
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
@@ -324,7 +359,20 @@ asmlinkage long sys_utimes(char * filena
 		newattrs.ia_atime = times[0].tv_sec;
 		newattrs.ia_mtime = times[1].tv_sec;
 		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
-	} else {
+	}
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
+	error = -EPERM;
+	if (!utimes) {
 		if (current->fsuid != inode->i_uid &&
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
@@ -347,6 +395,7 @@ asmlinkage long sys_access(const char * 
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -364,13 +413,14 @@ asmlinkage long sys_access(const char * 
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = user_path_walk(filename, &nd);
+	res = user_path_walk_it(filename, &nd, &it);
 	if (!res) {
 		res = permission(nd.dentry->d_inode, mode);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 
@@ -385,8 +435,9 @@ asmlinkage long sys_chdir(const char * f
 {
 	int error;
 	struct nameidata nd;
+ 	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = __user_walk(filename,LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,&nd);
+	error = __user_walk_it(filename,LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,&nd, &it);
 	if (error)
 		goto out;
 
@@ -397,6 +448,7 @@ asmlinkage long sys_chdir(const char * f
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -436,9 +488,10 @@ asmlinkage long sys_chroot(const char * 
 {
 	int error;
 	struct nameidata nd;
+ 	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = __user_walk(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
-		      LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
+	error = __user_walk_it(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
+		      LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd, &it);
 	if (error)
 		goto out;
 
@@ -454,6 +507,7 @@ asmlinkage long sys_chroot(const char * 
 	set_fs_altroot();
 	error = 0;
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -508,6 +562,18 @@ asmlinkage long sys_chmod(const char * f
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
 
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_mode = mode;
+		newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
@@ -538,6 +604,20 @@ static int chown_common(struct dentry * 
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto out;
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = dentry->d_inode->i_op;
+
+		newattrs.ia_uid = user;
+		newattrs.ia_gid = group;
+		newattrs.ia_valid = ATTR_UID | ATTR_GID;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			return error;
+	}
+
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
@@ -638,10 +718,12 @@ asmlinkage long sys_fchown(unsigned int 
  * for the internal routines (ie open_namei()/follow_link() etc). 00 is
  * used by symlinks.
  */
+
 struct file *filp_open(const char * filename, int flags, int mode)
 {
 	int namei_flags, error;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_OPEN, .it_flags = flags };
 
 	namei_flags = flags;
 	if ((namei_flags+1) & O_ACCMODE)
@@ -649,14 +731,15 @@ struct file *filp_open(const char * file
 	if (namei_flags & O_TRUNC)
 		namei_flags |= 2;
 
-	error = open_namei(filename, namei_flags, mode, &nd);
-	if (!error)
-		return dentry_open(nd.dentry, nd.mnt, flags);
+	error = open_namei_it(filename, namei_flags, mode, &nd, &it);
+	if (error)
+		return ERR_PTR(error);
 
-	return ERR_PTR(error);
+	return dentry_open_it(nd.dentry, nd.mnt, flags, &it);
 }
 
-struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+			    int flags, struct lookup_intent *it)
 {
 	struct file * f;
 	struct inode *inode;
@@ -699,6 +782,7 @@ struct file *dentry_open(struct dentry *
 	}
 	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);
 
+	intent_release(dentry, it);
 	return f;
 
 cleanup_all:
@@ -713,11 +797,17 @@ cleanup_all:
 cleanup_file:
 	put_filp(f);
 cleanup_dentry:
+	intent_release(dentry, it);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
 }
 
+struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+{
+	return dentry_open_it(dentry, mnt, flags, NULL);
+}
+
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
--- linux-2.4.20/fs/stat.c~vfs_intent-2.4.20-vanilla	2003-04-08 23:34:29.000000000 -0600
+++ linux-2.4.20-braam/fs/stat.c	2003-04-08 23:34:29.000000000 -0600
@@ -135,13 +135,15 @@ static int cp_new_stat(struct inode * in
 asmlinkage long sys_stat(char * filename, struct __old_kernel_stat * statbuf)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int error;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
 		if (!error)
 			error = cp_old_stat(nd.dentry->d_inode, statbuf);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -151,13 +153,15 @@ asmlinkage long sys_stat(char * filename
 asmlinkage long sys_newstat(char * filename, struct stat * statbuf)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int error;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
 		if (!error)
 			error = cp_new_stat(nd.dentry->d_inode, statbuf);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -172,13 +176,15 @@ asmlinkage long sys_newstat(char * filen
 asmlinkage long sys_lstat(char * filename, struct __old_kernel_stat * statbuf)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int error;
 
-	error = user_path_walk_link(filename, &nd);
+	error = user_path_walk_link_it(filename, &nd, &it);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
 		if (!error)
 			error = cp_old_stat(nd.dentry->d_inode, statbuf);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -189,13 +195,15 @@ asmlinkage long sys_lstat(char * filenam
 asmlinkage long sys_newlstat(char * filename, struct stat * statbuf)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int error;
 
-	error = user_path_walk_link(filename, &nd);
+	error = user_path_walk_link_it(filename, &nd, &it);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
 		if (!error)
 			error = cp_new_stat(nd.dentry->d_inode, statbuf);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -333,12 +341,14 @@ asmlinkage long sys_stat64(char * filena
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
 		if (!error)
 			error = cp_new_stat64(nd.dentry->d_inode, statbuf);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -348,12 +358,14 @@ asmlinkage long sys_lstat64(char * filen
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = user_path_walk_link(filename, &nd);
+	error = user_path_walk_link_it(filename, &nd, &it);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
 		if (!error)
 			error = cp_new_stat64(nd.dentry->d_inode, statbuf);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
--- linux-2.4.20/include/linux/dcache.h~vfs_intent-2.4.20-vanilla	2003-04-08 23:34:29.000000000 -0600
+++ linux-2.4.20-braam/include/linux/dcache.h	2003-04-08 23:34:29.000000000 -0600
@@ -7,6 +7,25 @@
 #include <linux/mount.h>
 #include <linux/kernel.h>
 
+#define IT_OPEN     (1)
+#define IT_CREAT    (1<<1)
+#define IT_READDIR  (1<<2)
+#define IT_GETATTR  (1<<3)
+#define IT_LOOKUP   (1<<4)
+#define IT_UNLINK   (1<<5)
+
+struct lookup_intent {
+	int it_op;
+	int it_mode;
+	int it_flags;
+	int it_disposition;
+	int it_status;
+	struct iattr *it_iattr;
+	__u64 it_lock_handle[2];
+	int it_lock_mode;
+	void *it_data;
+};
+
 /*
  * linux/include/linux/dcache.h
  *
@@ -79,6 +98,7 @@ struct dentry {
 	unsigned long d_time;		/* used by d_revalidate */
 	struct dentry_operations  *d_op;
 	struct super_block * d_sb;	/* The root of the dentry tree */
+	struct lookup_intent *d_it;
 	unsigned long d_vfs_flags;
 	void * d_fsdata;		/* fs-specific data */
 	unsigned char d_iname[DNAME_INLINE_LEN]; /* small names */
@@ -91,8 +111,15 @@ struct dentry_operations {
 	int (*d_delete)(struct dentry *);
 	void (*d_release)(struct dentry *);
 	void (*d_iput)(struct dentry *, struct inode *);
+	int (*d_revalidate2)(struct dentry *, int, struct lookup_intent *);
+	void (*d_intent_release)(struct dentry *, struct lookup_intent *);
 };
 
+/* defined in fs/namei.c */
+extern void intent_release(struct dentry *de, struct lookup_intent *it);
+/* defined in fs/dcache.c */
+extern void __d_rehash(struct dentry * entry, int lock);
+
 /* the dentry parameter passed to d_hash and d_compare is the parent
  * directory of the entries to be compared. It is used in case these
  * functions need any directory specific information for determining
@@ -124,6 +151,7 @@ d_iput:		no		no		yes
 					 * s_nfsd_free_path semaphore will be down
 					 */
 #define DCACHE_REFERENCED	0x0008  /* Recently used, don't discard. */
+#define DCACHE_LUSTRE_INVALID	0x0010  /* Lustre invalidated */
 
 extern spinlock_t dcache_lock;
 
--- linux-2.4.20/include/linux/fs.h~vfs_intent-2.4.20-vanilla	2003-04-08 23:34:29.000000000 -0600
+++ linux-2.4.20-braam/include/linux/fs.h	2003-04-08 23:34:29.000000000 -0600
@@ -338,6 +338,8 @@ extern void set_bh_page(struct buffer_he
 #define ATTR_MTIME_SET	256
 #define ATTR_FORCE	512	/* Not a change, but a change it */
 #define ATTR_ATTR_FLAG	1024
+#define ATTR_RAW	2048	/* file system, not vfs will massage attrs */
+#define ATTR_FROM_OPEN	4096	/* called from open path, ie O_TRUNC */
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -542,6 +544,7 @@ struct file {
 
 	/* needed for tty driver, and maybe others */
 	void			*private_data;
+	struct lookup_intent    *f_intent;
 
 	/* preallocated helper kiobuf to speedup O_DIRECT */
 	struct kiobuf		*f_iobuf;
@@ -794,7 +797,9 @@ extern int vfs_symlink(struct inode *, s
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		struct inode *new_dir, struct dentry *new_dentry,
+		struct lookup_intent *it);
 
 /*
  * File types
@@ -855,20 +860,33 @@ struct file_operations {
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
+	struct dentry * (*lookup2) (struct inode *,struct dentry *, struct lookup_intent *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*link2) (struct inode *,struct inode *, const char *, int);
 	int (*unlink) (struct inode *,struct dentry *);
+	int (*unlink2) (struct inode *, const char *, int);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*symlink2) (struct inode *, const char *, int, const char *);
 	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*mkdir2) (struct inode *, const char *, int,int);
 	int (*rmdir) (struct inode *,struct dentry *);
+	int (*rmdir2) (struct inode *, const char *, int);
 	int (*mknod) (struct inode *,struct dentry *,int,int);
+	int (*mknod2) (struct inode *, const char *, int,int,int);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename2) (struct inode *, struct inode *,
+			const char *oldname, int oldlen,
+			const char *newname, int newlen);
 	int (*readlink) (struct dentry *, char *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
+	int (*follow_link2) (struct dentry *, struct nameidata *,
+			     struct lookup_intent *it);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int);
 	int (*revalidate) (struct dentry *);
 	int (*setattr) (struct dentry *, struct iattr *);
+	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct dentry *, struct iattr *);
 	int (*setxattr) (struct dentry *, const char *, void *, size_t, int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
@@ -1070,10 +1088,14 @@ static inline int get_lease(struct inode
 
 asmlinkage long sys_open(const char *, int, int);
 asmlinkage long sys_close(unsigned int);	/* yes, it's really unsigned */
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, int called_from_open);
 
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern int open_namei_it(const char *filename, int namei_flags, int mode,
+			 struct nameidata *nd, struct lookup_intent *it);
+extern struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+			    int flags, struct lookup_intent *it);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char *);
 
@@ -1335,6 +1357,7 @@ typedef int (*read_actor_t)(read_descrip
 extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
 
 extern int FASTCALL(__user_walk(const char *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_it(const char *, unsigned, struct nameidata *, struct lookup_intent *it));
 extern int FASTCALL(path_init(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
@@ -1346,6 +1369,8 @@ extern struct dentry * lookup_one_len(co
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
 #define user_path_walk(name,nd)	 __user_walk(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd)
 #define user_path_walk_link(name,nd) __user_walk(name, LOOKUP_POSITIVE, nd)
+#define user_path_walk_it(name,nd,it)  __user_walk_it(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd, it)
+#define user_path_walk_link_it(name,nd,it) __user_walk_it(name, LOOKUP_POSITIVE, nd, it)
 
 extern void iput(struct inode *);
 extern void force_delete(struct inode *);
@@ -1455,6 +1480,8 @@ extern struct file_operations generic_ro
 
 extern int vfs_readlink(struct dentry *, char *, int, const char *);
 extern int vfs_follow_link(struct nameidata *, const char *);
+extern int vfs_follow_link_it(struct nameidata *, const char *,
+			      struct lookup_intent *it);
 extern int page_readlink(struct dentry *, char *, int);
 extern int page_follow_link(struct dentry *, struct nameidata *);
 extern struct inode_operations page_symlink_inode_operations;
--- linux-2.4.20/kernel/ksyms.c~vfs_intent-2.4.20-vanilla	2003-04-08 23:34:29.000000000 -0600
+++ linux-2.4.20-braam/kernel/ksyms.c	2003-04-08 23:34:29.000000000 -0600
@@ -269,6 +269,7 @@ EXPORT_SYMBOL(read_cache_page);
 EXPORT_SYMBOL(set_page_dirty);
 EXPORT_SYMBOL(vfs_readlink);
 EXPORT_SYMBOL(vfs_follow_link);
+EXPORT_SYMBOL(vfs_follow_link_it);
 EXPORT_SYMBOL(page_readlink);
 EXPORT_SYMBOL(page_follow_link);
 EXPORT_SYMBOL(page_symlink_inode_operations);

_



 fs/inode.c         |   21 ++++++++++++++-------
 fs/super.c         |    4 ++--
 include/linux/fs.h |    2 +-
 3 files changed, 17 insertions(+), 10 deletions(-)

--- linux-2.4.20/fs/inode.c~invalidate_show	2003-04-08 23:34:36.000000000 -0600
+++ linux-2.4.20-braam/fs/inode.c	2003-04-08 23:34:36.000000000 -0600
@@ -553,7 +553,8 @@ static void dispose_list(struct list_hea
 /*
  * Invalidate all inodes for a device.
  */
-static int invalidate_list(struct list_head *head, struct super_block * sb, struct list_head * dispose)
+static int invalidate_list(struct list_head *head, struct super_block * sb,
+			   struct list_head * dispose, int show)
 {
 	struct list_head *next;
 	int busy = 0, count = 0;
@@ -578,6 +579,11 @@ static int invalidate_list(struct list_h
 			count++;
 			continue;
 		}
+		if (show)
+			printk(KERN_ERR
+			       "inode busy: dev %s:%lu (%p) mode %o count %u\n",
+			       kdevname(sb->s_dev), inode->i_ino, inode,
+			       inode->i_mode, atomic_read(&inode->i_count));
 		busy = 1;
 	}
 	/* only unused inodes may be cached with i_count zero */
@@ -596,22 +602,23 @@ static int invalidate_list(struct list_h
 /**
  *	invalidate_inodes	- discard the inodes on a device
  *	@sb: superblock
+ *	@show: whether we should display any busy inodes found
  *
  *	Discard all of the inodes for a given superblock. If the discard
  *	fails because there are busy inodes then a non zero value is returned.
  *	If the discard is successful all the inodes have been discarded.
  */
  
-int invalidate_inodes(struct super_block * sb)
+int invalidate_inodes(struct super_block * sb, int show)
 {
 	int busy;
 	LIST_HEAD(throw_away);
 
 	spin_lock(&inode_lock);
-	busy = invalidate_list(&inode_in_use, sb, &throw_away);
-	busy |= invalidate_list(&inode_unused, sb, &throw_away);
-	busy |= invalidate_list(&sb->s_dirty, sb, &throw_away);
-	busy |= invalidate_list(&sb->s_locked_inodes, sb, &throw_away);
+	busy = invalidate_list(&inode_in_use, sb, &throw_away, show);
+	busy |= invalidate_list(&inode_unused, sb, &throw_away, show);
+	busy |= invalidate_list(&sb->s_dirty, sb, &throw_away, show);
+	busy |= invalidate_list(&sb->s_locked_inodes, sb, &throw_away, show);
 	spin_unlock(&inode_lock);
 
 	dispose_list(&throw_away);
@@ -637,7 +644,7 @@ int invalidate_device(kdev_t dev, int do
 		 * hold).
 		 */
 		shrink_dcache_sb(sb);
-		res = invalidate_inodes(sb);
+		res = invalidate_inodes(sb, 0);
 		drop_super(sb);
 	}
 	invalidate_buffers(dev);
--- linux-2.4.20/fs/super.c~invalidate_show	2003-04-08 23:34:36.000000000 -0600
+++ linux-2.4.20-braam/fs/super.c	2003-04-08 23:34:36.000000000 -0600
@@ -835,7 +835,7 @@ void kill_super(struct super_block *sb)
 	lock_super(sb);
 	lock_kernel();
 	sb->s_flags &= ~MS_ACTIVE;
-	invalidate_inodes(sb);	/* bad name - it should be evict_inodes() */
+	invalidate_inodes(sb, 0);  /* bad name - it should be evict_inodes() */
 	if (sop) {
 		if (sop->write_super && sb->s_dirt)
 			sop->write_super(sb);
@@ -844,7 +844,7 @@ void kill_super(struct super_block *sb)
 	}
 
 	/* Forget any remaining inodes */
-	if (invalidate_inodes(sb)) {
+	if (invalidate_inodes(sb, 1)) {
 		printk(KERN_ERR "VFS: Busy inodes after unmount. "
 			"Self-destruct in 5 seconds.  Have a nice day...\n");
 	}
--- linux-2.4.20/include/linux/fs.h~invalidate_show	2003-04-08 23:34:36.000000000 -0600
+++ linux-2.4.20-braam/include/linux/fs.h	2003-04-08 23:34:36.000000000 -0600
@@ -1237,7 +1237,7 @@ static inline void mark_buffer_dirty_ino
 extern void set_buffer_flushtime(struct buffer_head *);
 extern void balance_dirty(void);
 extern int check_disk_change(kdev_t);
-extern int invalidate_inodes(struct super_block *);
+extern int invalidate_inodes(struct super_block *, int);
 extern int invalidate_device(kdev_t, int);
 extern void invalidate_inode_pages(struct inode *);
 extern void invalidate_inode_pages2(struct address_space *);

_
 include/linux/mm.h |    1 +
 mm/filemap.c       |    3 ++-
 2 files changed, 3 insertions(+), 1 deletion(-)

--- linux-2.4.18-18/include/linux/mm.h~export-truncate	2003-04-05 02:54:55.000000000 -0700
+++ linux-2.4.18-18-braam/include/linux/mm.h	2003-04-09 17:37:46.000000000 -0600
@@ -650,6 +650,7 @@ struct zone_t;
 /* filemap.c */
 extern void remove_inode_page(struct page *);
 extern unsigned long page_unuse(struct page *);
+extern void truncate_complete_page(struct page *);
 extern void truncate_inode_pages(struct address_space *, loff_t);
 
 /* generic vm_area_ops exported for stackable file systems */
--- linux-2.4.18-18/mm/filemap.c~export-truncate	2003-04-05 02:54:55.000000000 -0700
+++ linux-2.4.18-18-braam/mm/filemap.c	2003-04-09 17:37:46.000000000 -0600
@@ -245,7 +245,7 @@ static inline void truncate_partial_page
 		do_flushpage(page, partial);
 }
 
-static void truncate_complete_page(struct page *page)
+void truncate_complete_page(struct page *page)
 {
 	/*
 	 * Leave it on the LRU if it gets converted into anonymous buffers
@@ -266,6 +266,7 @@ static void truncate_complete_page(struc
 	remove_inode_page(page);
 	page_cache_release(page);
 }
+EXPORT_SYMBOL_GPL(truncate_complete_page);
 
 static int FASTCALL(truncate_list_pages(struct list_head *, unsigned long, unsigned *));
 static int truncate_list_pages(struct list_head *head, unsigned long start, unsigned *partial)

_
 fs/Makefile     |    2 +-
 fs/inode.c      |    4 +++-
 mm/page_alloc.c |    1 +
 3 files changed, 5 insertions(+), 2 deletions(-)

--- linux/fs/inode.c~iod-stock-24-exports_hp	Wed Apr  9 10:44:54 2003
+++ linux-mmonroe/fs/inode.c	Wed Apr  9 10:49:50 2003
@@ -5,6 +5,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/string.h>
 #include <linux/mm.h>
@@ -66,7 +67,8 @@ static LIST_HEAD(anon_hash_chain); /* fo
  * NOTE! You also have to own the lock if you change
  * the i_state of an inode while it is in use..
  */
-static spinlock_t inode_lock = SPIN_LOCK_UNLOCKED;
+spinlock_t inode_lock = SPIN_LOCK_UNLOCKED;
+EXPORT_SYMBOL(inode_lock);
 
 /*
  * Statistics gathering..
--- linux/fs/Makefile~iod-stock-24-exports_hp	Wed Apr  9 10:26:08 2003
+++ linux-mmonroe/fs/Makefile	Wed Apr  9 10:49:50 2003
@@ -7,7 +7,7 @@
 
 O_TARGET := fs.o
 
-export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o
+export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o inode.o
 mod-subdirs :=	nls xfs
 
 obj-y :=	open.o read_write.o devices.o file_table.o buffer.o \
--- linux/mm/page_alloc.c~iod-stock-24-exports_hp	Wed Apr  9 10:26:14 2003
+++ linux-mmonroe/mm/page_alloc.c	Wed Apr  9 10:49:50 2003
@@ -28,6 +28,7 @@ int nr_inactive_pages;
 LIST_HEAD(inactive_list);
 LIST_HEAD(active_list);
 pg_data_t *pgdat_list;
+EXPORT_SYMBOL(pgdat_list);
 
 /*
  *

_
 fs/ext3/Makefile           |    2 
 fs/ext3/dir.c              |  299 +++++++++
 fs/ext3/file.c             |    3 
 fs/ext3/hash.c             |  215 ++++++
 fs/ext3/namei.c            | 1387 ++++++++++++++++++++++++++++++++++++++++-----
 fs/ext3/super.c            |    7 
 include/linux/ext3_fs.h    |   85 ++
 include/linux/ext3_fs_sb.h |    2 
 include/linux/ext3_jbd.h   |    2 
 include/linux/rbtree.h     |    2 
 lib/rbtree.c               |   42 +
 11 files changed, 1886 insertions(+), 160 deletions(-)

--- linux-2.4.20/fs/ext3/Makefile~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/fs/ext3/Makefile	Sat Apr  5 03:57:05 2003
@@ -12,7 +12,7 @@ O_TARGET := ext3.o
 export-objs :=	super.o inode.o
 
 obj-y    := balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o \
-		ioctl.o namei.o super.o symlink.o
+		ioctl.o namei.o super.o symlink.o hash.o
 obj-m    := $(O_TARGET)
 
 include $(TOPDIR)/Rules.make
--- linux-2.4.20/fs/ext3/dir.c~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/fs/ext3/dir.c	Sat Apr  5 03:56:31 2003
@@ -21,12 +21,16 @@
 #include <linux/fs.h>
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
+#include <linux/slab.h>
+#include <linux/rbtree.h>
 
 static unsigned char ext3_filetype_table[] = {
 	DT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK
 };
 
 static int ext3_readdir(struct file *, void *, filldir_t);
+static int ext3_dx_readdir(struct file * filp,
+			   void * dirent, filldir_t filldir);
 
 struct file_operations ext3_dir_operations = {
 	read:		generic_read_dir,
@@ -35,6 +39,17 @@ struct file_operations ext3_dir_operatio
 	fsync:		ext3_sync_file,		/* BKL held */
 };
 
+
+static unsigned char get_dtype(struct super_block *sb, int filetype)
+{
+	if (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||
+	    (filetype >= EXT3_FT_MAX))
+		return DT_UNKNOWN;
+
+	return (ext3_filetype_table[filetype]);
+}
+			       
+
 int ext3_check_dir_entry (const char * function, struct inode * dir,
 			  struct ext3_dir_entry_2 * de,
 			  struct buffer_head * bh,
@@ -79,6 +94,16 @@ static int ext3_readdir(struct file * fi
 
 	sb = inode->i_sb;
 
+	if (is_dx(inode)) {
+		err = ext3_dx_readdir(filp, dirent, filldir);
+		if (err != ERR_BAD_DX_DIR)
+			return err;
+		/*
+		 * We don't set the inode dirty flag since it's not
+		 * critical that it get flushed back to the disk.
+		 */
+		EXT3_I(filp->f_dentry->d_inode)->i_flags &= ~EXT3_INDEX_FL;
+	}
 	stored = 0;
 	bh = NULL;
 	offset = filp->f_pos & (sb->s_blocksize - 1);
@@ -162,18 +187,12 @@ revalidate:
 				 * during the copy operation.
 				 */
 				unsigned long version = filp->f_version;
-				unsigned char d_type = DT_UNKNOWN;
 
-				if (EXT3_HAS_INCOMPAT_FEATURE(sb,
-						EXT3_FEATURE_INCOMPAT_FILETYPE)
-						&& de->file_type < EXT3_FT_MAX)
-					d_type =
-					  ext3_filetype_table[de->file_type];
 				error = filldir(dirent, de->name,
 						de->name_len,
 						filp->f_pos,
 						le32_to_cpu(de->inode),
-						d_type);
+						get_dtype(sb, de->file_type));
 				if (error)
 					break;
 				if (version != filp->f_version)
@@ -188,3 +207,269 @@ revalidate:
 	UPDATE_ATIME(inode);
 	return 0;
 }
+
+#ifdef CONFIG_EXT3_INDEX
+/*
+ * These functions convert from the major/minor hash to an f_pos
+ * value.
+ * 
+ * Currently we only use major hash numer.  This is unfortunate, but
+ * on 32-bit machines, the same VFS interface is used for lseek and
+ * llseek, so if we use the 64 bit offset, then the 32-bit versions of
+ * lseek/telldir/seekdir will blow out spectacularly, and from within
+ * the ext2 low-level routine, we don't know if we're being called by
+ * a 64-bit version of the system call or the 32-bit version of the
+ * system call.  Worse yet, NFSv2 only allows for a 32-bit readdir
+ * cookie.  Sigh.
+ */
+#define hash2pos(major, minor)	(major >> 1)
+#define pos2maj_hash(pos)	((pos << 1) & 0xffffffff)
+#define pos2min_hash(pos)	(0)
+
+/*
+ * This structure holds the nodes of the red-black tree used to store
+ * the directory entry in hash order.
+ */
+struct fname {
+	__u32		hash;
+	__u32		minor_hash;
+	rb_node_t	rb_hash; 
+	struct fname	*next;
+	__u32		inode;
+	__u8		name_len;
+	__u8		file_type;
+	char		name[0];
+};
+
+/*
+ * This functoin implements a non-recursive way of freeing all of the
+ * nodes in the red-black tree.
+ */
+static void free_rb_tree_fname(rb_root_t *root)
+{
+	rb_node_t	*n = root->rb_node;
+	rb_node_t	*parent;
+	struct fname	*fname;
+
+	while (n) {
+		/* Do the node's children first */
+		if ((n)->rb_left) {
+			n = n->rb_left;
+			continue;
+		}
+		if (n->rb_right) {
+			n = n->rb_right;
+			continue;
+		}
+		/*
+		 * The node has no children; free it, and then zero
+		 * out parent's link to it.  Finally go to the
+		 * beginning of the loop and try to free the parent
+		 * node.
+		 */
+		parent = n->rb_parent;
+		fname = rb_entry(n, struct fname, rb_hash);
+		kfree(fname);
+		if (!parent)
+			root->rb_node = 0;
+		else if (parent->rb_left == n)
+			parent->rb_left = 0;
+		else if (parent->rb_right == n)
+			parent->rb_right = 0;
+		n = parent;
+	}
+	root->rb_node = 0;
+}
+
+
+struct dir_private_info *create_dir_info(loff_t pos)
+{
+	struct dir_private_info *p;
+
+	p = kmalloc(sizeof(struct dir_private_info), GFP_KERNEL);
+	if (!p)
+		return NULL;
+	p->root.rb_node = 0;
+	p->curr_node = 0;
+	p->extra_fname = 0;
+	p->last_pos = 0;
+	p->curr_hash = pos2maj_hash(pos);
+	p->curr_minor_hash = pos2min_hash(pos);
+	p->next_hash = 0;
+	return p;
+}
+
+void ext3_htree_free_dir_info(struct dir_private_info *p)
+{
+	free_rb_tree_fname(&p->root);
+	kfree(p);
+}
+		
+/*
+ * Given a directory entry, enter it into the fname rb tree.
+ */
+void ext3_htree_store_dirent(struct file *dir_file, __u32 hash,
+			     __u32 minor_hash,
+			     struct ext3_dir_entry_2 *dirent)
+{
+	rb_node_t **p, *parent = NULL;
+	struct fname * fname, *new_fn;
+	struct dir_private_info *info;
+	int len;
+
+	info = (struct dir_private_info *) dir_file->private_data;
+	p = &info->root.rb_node;
+
+	/* Create and allocate the fname structure */
+	len = sizeof(struct fname) + dirent->name_len + 1;
+	new_fn = kmalloc(len, GFP_KERNEL);
+	memset(new_fn, 0, len);
+	new_fn->hash = hash;
+	new_fn->minor_hash = minor_hash;
+	new_fn->inode = le32_to_cpu(dirent->inode);
+	new_fn->name_len = dirent->name_len;
+	new_fn->file_type = dirent->file_type;
+	memcpy(new_fn->name, dirent->name, dirent->name_len);
+	new_fn->name[dirent->name_len] = 0;
+	
+	while (*p) {
+		parent = *p;
+		fname = rb_entry(parent, struct fname, rb_hash);
+
+		/*
+		 * If the hash and minor hash match up, then we put
+		 * them on a linked list.  This rarely happens...
+		 */
+		if ((new_fn->hash == fname->hash) &&
+		    (new_fn->minor_hash == fname->minor_hash)) {
+			new_fn->next = fname->next;
+			fname->next = new_fn;
+			return;
+		}
+			
+		if (new_fn->hash < fname->hash)
+			p = &(*p)->rb_left;
+		else if (new_fn->hash > fname->hash)
+			p = &(*p)->rb_right;
+		else if (new_fn->minor_hash < fname->minor_hash)
+			p = &(*p)->rb_left;
+		else /* if (new_fn->minor_hash > fname->minor_hash) */
+			p = &(*p)->rb_right;
+	}
+
+	rb_link_node(&new_fn->rb_hash, parent, p);
+	rb_insert_color(&new_fn->rb_hash, &info->root);
+}
+
+
+
+/*
+ * This is a helper function for ext3_dx_readdir.  It calls filldir
+ * for all entres on the fname linked list.  (Normally there is only
+ * one entry on the linked list, unless there are 62 bit hash collisions.)
+ */
+static int call_filldir(struct file * filp, void * dirent,
+			filldir_t filldir, struct fname *fname)
+{
+	struct dir_private_info *info = filp->private_data;
+	loff_t	curr_pos;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct super_block * sb;
+	int error;
+
+	sb = inode->i_sb;
+	
+	if (!fname) {
+		printk("call_filldir: called with null fname?!?\n");
+		return 0;
+	}
+	curr_pos = hash2pos(fname->hash, fname->minor_hash);
+	while (fname) {
+		error = filldir(dirent, fname->name,
+				fname->name_len, curr_pos, 
+				fname->inode,
+				get_dtype(sb, fname->file_type));
+		if (error) {
+			filp->f_pos = curr_pos;
+			info->extra_fname = fname->next;
+			return error;
+		}
+		fname = fname->next;
+	}
+	return 0;
+}
+
+static int ext3_dx_readdir(struct file * filp,
+			 void * dirent, filldir_t filldir)
+{
+	struct dir_private_info *info = filp->private_data;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct fname *fname;
+	int	ret;
+
+	if (!info) {
+		info = create_dir_info(filp->f_pos);
+		if (!info)
+			return -ENOMEM;
+		filp->private_data = info;
+	}
+
+	/* Some one has messed with f_pos; reset the world */
+	if (info->last_pos != filp->f_pos) {
+		free_rb_tree_fname(&info->root);
+		info->curr_node = 0;
+		info->extra_fname = 0;
+		info->curr_hash = pos2maj_hash(filp->f_pos);
+		info->curr_minor_hash = pos2min_hash(filp->f_pos);
+	}
+
+	/*
+	 * If there are any leftover names on the hash collision
+	 * chain, return them first.
+	 */
+	if (info->extra_fname &&
+	    call_filldir(filp, dirent, filldir, info->extra_fname))
+		goto finished;
+
+	if (!info->curr_node)
+		info->curr_node = rb_get_first(&info->root);
+
+	while (1) {
+		/*
+		 * Fill the rbtree if we have no more entries,
+		 * or the inode has changed since we last read in the
+		 * cached entries. 
+		 */
+		if ((!info->curr_node) ||
+		    (filp->f_version != inode->i_version)) {
+			info->curr_node = 0;
+			free_rb_tree_fname(&info->root);
+			filp->f_version = inode->i_version;
+			ret = ext3_htree_fill_tree(filp, info->curr_hash,
+						   info->curr_minor_hash,
+						   &info->next_hash);
+			if (ret < 0)
+				return ret;
+			if (ret == 0)
+				break;
+			info->curr_node = rb_get_first(&info->root);
+		}
+
+		fname = rb_entry(info->curr_node, struct fname, rb_hash);
+		info->curr_hash = fname->hash;
+		info->curr_minor_hash = fname->minor_hash;
+		if (call_filldir(filp, dirent, filldir, fname))
+			break;
+
+		info->curr_node = rb_get_next(info->curr_node);
+		if (!info->curr_node) {
+			info->curr_hash = info->next_hash;
+			info->curr_minor_hash = 0;
+		}
+	}
+finished:
+	info->last_pos = filp->f_pos;
+	UPDATE_ATIME(inode);
+	return 0;
+}
+#endif
--- linux-2.4.20/fs/ext3/file.c~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/fs/ext3/file.c	Sat Apr  5 03:56:31 2003
@@ -35,6 +35,9 @@ static int ext3_release_file (struct ino
 {
 	if (filp->f_mode & FMODE_WRITE)
 		ext3_discard_prealloc (inode);
+	if (is_dx(inode) && filp->private_data)
+		ext3_htree_free_dir_info(filp->private_data);
+
 	return 0;
 }
 
--- /dev/null	Fri Aug 30 17:31:37 2002
+++ linux-2.4.20-braam/fs/ext3/hash.c	Sat Apr  5 03:56:31 2003
@@ -0,0 +1,215 @@
+/*
+ *  linux/fs/ext3/hash.c
+ *
+ * Copyright (C) 2002 by Theodore Ts'o
+ *
+ * This file is released under the GPL v2.
+ * 
+ * This file may be redistributed under the terms of the GNU Public
+ * License.
+ */
+
+#include <linux/fs.h>
+#include <linux/jbd.h>
+#include <linux/sched.h>
+#include <linux/ext3_fs.h>
+
+#define DELTA 0x9E3779B9
+
+static void TEA_transform(__u32 buf[4], __u32 const in[])
+{
+	__u32	sum = 0;
+	__u32	b0 = buf[0], b1 = buf[1];
+	__u32	a = in[0], b = in[1], c = in[2], d = in[3];
+	int	n = 16;
+
+	do {							
+		sum += DELTA;					
+		b0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);	
+		b1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);	
+	} while(--n);
+
+	buf[0] += b0;
+	buf[1] += b1;
+}
+
+/* F, G and H are basic MD4 functions: selection, majority, parity */
+#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
+#define G(x, y, z) (((x) & (y)) + (((x) ^ (y)) & (z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+
+/*
+ * The generic round function.  The application is so specific that
+ * we don't bother protecting all the arguments with parens, as is generally
+ * good macro practice, in favor of extra legibility.
+ * Rotation is separate from addition to prevent recomputation
+ */
+#define ROUND(f, a, b, c, d, x, s)	\
+	(a += f(b, c, d) + x, a = (a << s) | (a >> (32-s)))
+#define K1 0
+#define K2 013240474631UL
+#define K3 015666365641UL
+
+/*
+ * Basic cut-down MD4 transform.  Returns only 32 bits of result.
+ */
+static void halfMD4Transform (__u32 buf[4], __u32 const in[])
+{
+	__u32	a = buf[0], b = buf[1], c = buf[2], d = buf[3];
+
+	/* Round 1 */
+	ROUND(F, a, b, c, d, in[0] + K1,  3);
+	ROUND(F, d, a, b, c, in[1] + K1,  7);
+	ROUND(F, c, d, a, b, in[2] + K1, 11);
+	ROUND(F, b, c, d, a, in[3] + K1, 19);
+	ROUND(F, a, b, c, d, in[4] + K1,  3);
+	ROUND(F, d, a, b, c, in[5] + K1,  7);
+	ROUND(F, c, d, a, b, in[6] + K1, 11);
+	ROUND(F, b, c, d, a, in[7] + K1, 19);
+
+	/* Round 2 */
+	ROUND(G, a, b, c, d, in[1] + K2,  3);
+	ROUND(G, d, a, b, c, in[3] + K2,  5);
+	ROUND(G, c, d, a, b, in[5] + K2,  9);
+	ROUND(G, b, c, d, a, in[7] + K2, 13);
+	ROUND(G, a, b, c, d, in[0] + K2,  3);
+	ROUND(G, d, a, b, c, in[2] + K2,  5);
+	ROUND(G, c, d, a, b, in[4] + K2,  9);
+	ROUND(G, b, c, d, a, in[6] + K2, 13);
+
+	/* Round 3 */
+	ROUND(H, a, b, c, d, in[3] + K3,  3);
+	ROUND(H, d, a, b, c, in[7] + K3,  9);
+	ROUND(H, c, d, a, b, in[2] + K3, 11);
+	ROUND(H, b, c, d, a, in[6] + K3, 15);
+	ROUND(H, a, b, c, d, in[1] + K3,  3);
+	ROUND(H, d, a, b, c, in[5] + K3,  9);
+	ROUND(H, c, d, a, b, in[0] + K3, 11);
+	ROUND(H, b, c, d, a, in[4] + K3, 15);
+
+	buf[0] += a;
+	buf[1] += b;
+	buf[2] += c;
+	buf[3] += d;
+}
+
+#undef ROUND
+#undef F
+#undef G
+#undef H
+#undef K1
+#undef K2
+#undef K3
+
+/* The old legacy hash */
+static __u32 dx_hack_hash (const char *name, int len)
+{
+	__u32 hash0 = 0x12a3fe2d, hash1 = 0x37abe8f9;
+	while (len--) {
+		__u32 hash = hash1 + (hash0 ^ (*name++ * 7152373));
+		
+		if (hash & 0x80000000) hash -= 0x7fffffff;
+		hash1 = hash0;
+		hash0 = hash;
+	}
+	return (hash0 << 1);
+}
+
+static void str2hashbuf(const char *msg, int len, __u32 *buf, int num)
+{
+	__u32	pad, val;
+	int	i;
+
+	pad = (__u32)len | ((__u32)len << 8);
+	pad |= pad << 16;
+
+	val = pad;
+	if (len > num*4)
+		len = num * 4;
+	for (i=0; i < len; i++) {
+		if ((i % 4) == 0)
+			val = pad;
+		val = msg[i] + (val << 8);
+		if ((i % 4) == 3) {
+			*buf++ = val;
+			val = pad;
+			num--;
+		}
+	}
+	if (--num >= 0)
+		*buf++ = val;
+	while (--num >= 0)
+		*buf++ = pad;
+}
+
+/*
+ * Returns the hash of a filename.  If len is 0 and name is NULL, then
+ * this function can be used to test whether or not a hash version is
+ * supported.
+ * 
+ * The seed is an 4 longword (32 bits) "secret" which can be used to
+ * uniquify a hash.  If the seed is all zero's, then some default seed
+ * may be used.
+ * 
+ * A particular hash version specifies whether or not the seed is
+ * represented, and whether or not the returned hash is 32 bits or 64
+ * bits.  32 bit hashes will return 0 for the minor hash.
+ */
+int ext3fs_dirhash(const char *name, int len, struct dx_hash_info *hinfo)
+{
+	__u32	hash;
+	__u32	minor_hash = 0;
+	const char	*p;
+	int		i;
+	__u32 		in[8], buf[4];
+
+	/* Initialize the default seed for the hash checksum functions */
+	buf[0] = 0x67452301;
+	buf[1] = 0xefcdab89;
+	buf[2] = 0x98badcfe;
+	buf[3] = 0x10325476;
+
+	/* Check to see if the seed is all zero's */
+	if (hinfo->seed) {
+		for (i=0; i < 4; i++) {
+			if (hinfo->seed[i])
+				break;
+		}
+		if (i < 4)
+			memcpy(buf, hinfo->seed, sizeof(buf));
+	}
+		
+	switch (hinfo->hash_version) {
+	case DX_HASH_LEGACY:
+		hash = dx_hack_hash(name, len);
+		break;
+	case DX_HASH_HALF_MD4:
+		p = name;
+		while (len > 0) {
+			str2hashbuf(p, len, in, 8);
+			halfMD4Transform(buf, in);
+			len -= 32;
+			p += 32;
+		}
+		minor_hash = buf[2];
+		hash = buf[1];
+		break;
+	case DX_HASH_TEA:
+		p = name;
+		while (len > 0) {
+			str2hashbuf(p, len, in, 4);
+			TEA_transform(buf, in);
+			len -= 16;
+			p += 16;
+		}
+		hash = buf[0];
+		minor_hash = buf[1];
+		break;
+	default:
+		hinfo->hash = 0;
+		return -1;
+	}
+	hinfo->hash = hash & ~1;
+	hinfo->minor_hash = minor_hash;
+	return 0;
+}
--- linux-2.4.20/fs/ext3/namei.c~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/fs/ext3/namei.c	Sat Apr  5 03:56:31 2003
@@ -16,6 +16,12 @@
  *        David S. Miller (davem@caip.rutgers.edu), 1995
  *  Directory entry file type support and forward compatibility hooks
  *  	for B-tree directories by Theodore Ts'o (tytso@mit.edu), 1998
+ *  Hash Tree Directory indexing (c)
+ *  	Daniel Phillips, 2001
+ *  Hash Tree Directory indexing porting
+ *  	Christopher Li, 2002
+ *  Hash Tree Directory indexing cleanup
+ * 	Theodore Ts'o, 2002
  */
 
 #include <linux/fs.h>
@@ -38,6 +44,630 @@
 #define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)
 #define NAMEI_RA_INDEX(c,b)  (((c) * NAMEI_RA_BLOCKS) + (b))
 
+static struct buffer_head *ext3_append(handle_t *handle,
+					struct inode *inode,
+					u32 *block, int *err)
+{
+	struct buffer_head *bh;
+
+	*block = inode->i_size >> inode->i_sb->s_blocksize_bits;
+
+	if ((bh = ext3_bread(handle, inode, *block, 1, err))) {
+		inode->i_size += inode->i_sb->s_blocksize;
+		EXT3_I(inode)->i_disksize = inode->i_size;
+		ext3_journal_get_write_access(handle,bh);
+	}
+	return bh;
+}
+
+#ifndef assert
+#define assert(test) J_ASSERT(test)
+#endif
+
+#ifndef swap
+#define swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
+#endif
+
+typedef struct { u32 v; } le_u32;
+typedef struct { u16 v; } le_u16;
+
+#ifdef DX_DEBUG
+#define dxtrace(command) command
+#else
+#define dxtrace(command) 
+#endif
+
+struct fake_dirent
+{
+	/*le*/u32 inode;
+	/*le*/u16 rec_len;
+	u8 name_len;
+	u8 file_type;
+};
+
+struct dx_countlimit
+{
+	le_u16 limit;
+	le_u16 count;
+};
+
+struct dx_entry
+{
+	le_u32 hash;
+	le_u32 block;
+};
+
+/*
+ * dx_root_info is laid out so that if it should somehow get overlaid by a
+ * dirent the two low bits of the hash version will be zero.  Therefore, the
+ * hash version mod 4 should never be 0.  Sincerely, the paranoia department.
+ */
+
+struct dx_root
+{
+	struct fake_dirent dot;
+	char dot_name[4];
+	struct fake_dirent dotdot;
+	char dotdot_name[4];
+	struct dx_root_info
+	{
+		le_u32 reserved_zero;
+		u8 hash_version;
+		u8 info_length; /* 8 */
+		u8 indirect_levels;
+		u8 unused_flags;
+	}
+	info;
+	struct dx_entry	entries[0];
+};
+
+struct dx_node
+{
+	struct fake_dirent fake;
+	struct dx_entry	entries[0];
+};
+
+
+struct dx_frame
+{
+	struct buffer_head *bh;
+	struct dx_entry *entries;
+	struct dx_entry *at;
+};
+
+struct dx_map_entry
+{
+	u32 hash;
+	u32 offs;
+};
+
+#ifdef CONFIG_EXT3_INDEX
+static inline unsigned dx_get_block (struct dx_entry *entry);
+static void dx_set_block (struct dx_entry *entry, unsigned value);
+static inline unsigned dx_get_hash (struct dx_entry *entry);
+static void dx_set_hash (struct dx_entry *entry, unsigned value);
+static unsigned dx_get_count (struct dx_entry *entries);
+static unsigned dx_get_limit (struct dx_entry *entries);
+static void dx_set_count (struct dx_entry *entries, unsigned value);
+static void dx_set_limit (struct dx_entry *entries, unsigned value);
+static unsigned dx_root_limit (struct inode *dir, unsigned infosize);
+static unsigned dx_node_limit (struct inode *dir);
+static struct dx_frame *dx_probe(struct dentry *dentry,
+				 struct inode *dir,
+				 struct dx_hash_info *hinfo,
+				 struct dx_frame *frame,
+				 int *err);
+static void dx_release (struct dx_frame *frames);
+static int dx_make_map (struct ext3_dir_entry_2 *de, int size,
+			struct dx_hash_info *hinfo, struct dx_map_entry map[]);
+static void dx_sort_map(struct dx_map_entry *map, unsigned count);
+static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,
+		struct dx_map_entry *offsets, int count);
+static struct ext3_dir_entry_2* dx_pack_dirents (char *base, int size);
+static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);
+static int ext3_htree_next_block(struct inode *dir, __u32 hash,
+				 struct dx_frame *frame,
+				 struct dx_frame *frames, int *err,
+				 __u32 *start_hash);
+static struct buffer_head * ext3_dx_find_entry(struct dentry *dentry,
+		       struct ext3_dir_entry_2 **res_dir, int *err);
+static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,
+			     struct inode *inode);
+
+/*
+ * Future: use high four bits of block for coalesce-on-delete flags
+ * Mask them off for now.
+ */
+
+static inline unsigned dx_get_block (struct dx_entry *entry)
+{
+	return le32_to_cpu(entry->block.v) & 0x00ffffff;
+}
+
+static inline void dx_set_block (struct dx_entry *entry, unsigned value)
+{
+	entry->block.v = cpu_to_le32(value);
+}
+
+static inline unsigned dx_get_hash (struct dx_entry *entry)
+{
+	return le32_to_cpu(entry->hash.v);
+}
+
+static inline void dx_set_hash (struct dx_entry *entry, unsigned value)
+{
+	entry->hash.v = cpu_to_le32(value);
+}
+
+static inline unsigned dx_get_count (struct dx_entry *entries)
+{
+	return le16_to_cpu(((struct dx_countlimit *) entries)->count.v);
+}
+
+static inline unsigned dx_get_limit (struct dx_entry *entries)
+{
+	return le16_to_cpu(((struct dx_countlimit *) entries)->limit.v);
+}
+
+static inline void dx_set_count (struct dx_entry *entries, unsigned value)
+{
+	((struct dx_countlimit *) entries)->count.v = cpu_to_le16(value);
+}
+
+static inline void dx_set_limit (struct dx_entry *entries, unsigned value)
+{
+	((struct dx_countlimit *) entries)->limit.v = cpu_to_le16(value);
+}
+
+static inline unsigned dx_root_limit (struct inode *dir, unsigned infosize)
+{
+	unsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(1) -
+		EXT3_DIR_REC_LEN(2) - infosize;
+	return 0? 20: entry_space / sizeof(struct dx_entry);
+}
+
+static inline unsigned dx_node_limit (struct inode *dir)
+{
+	unsigned entry_space = dir->i_sb->s_blocksize - EXT3_DIR_REC_LEN(0);
+	return 0? 22: entry_space / sizeof(struct dx_entry);
+}
+
+/*
+ * Debug
+ */
+#ifdef DX_DEBUG
+struct stats
+{ 
+	unsigned names;
+	unsigned space;
+	unsigned bcount;
+};
+
+static struct stats dx_show_leaf(struct dx_hash_info *hinfo, struct ext3_dir_entry_2 *de,
+				 int size, int show_names)
+{
+	unsigned names = 0, space = 0;
+	char *base = (char *) de;
+	struct dx_hash_info h = *hinfo;
+	
+	printk("names: ");
+	while ((char *) de < base + size)
+	{
+		if (de->inode)
+		{
+			if (show_names)
+			{
+				int len = de->name_len;
+				char *name = de->name;
+				while (len--) printk("%c", *name++);
+				ext3fs_dirhash(de->name, de->name_len, &h);
+				printk(":%x.%u ", h.hash,
+				       ((char *) de - base));
+			}
+			space += EXT3_DIR_REC_LEN(de->name_len);
+	 		names++;
+		}
+		de = (struct ext3_dir_entry_2 *) ((char *) de + le16_to_cpu(de->rec_len));
+	}
+	printk("(%i)\n", names);
+	return (struct stats) { names, space, 1 };
+}
+
+struct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,
+			     struct dx_entry *entries, int levels)
+{
+	unsigned blocksize = dir->i_sb->s_blocksize;
+	unsigned count = dx_get_count (entries), names = 0, space = 0, i;
+	unsigned bcount = 0;
+	struct buffer_head *bh;
+	int err;
+	printk("%i indexed blocks...\n", count);
+	for (i = 0; i < count; i++, entries++)
+	{
+		u32 block = dx_get_block(entries), hash = i? dx_get_hash(entries): 0;
+		u32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;
+		struct stats stats;
+		printk("%s%3u:%03u hash %8x/%8x ",levels?"":"   ", i, block, hash, range);
+		if (!(bh = ext3_bread (NULL,dir, block, 0,&err))) continue;
+		stats = levels?
+		   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):
+		   dx_show_leaf(hinfo, (struct ext3_dir_entry_2 *) bh->b_data, blocksize, 0);
+		names += stats.names;
+		space += stats.space;
+		bcount += stats.bcount;
+		brelse (bh);
+	}
+	if (bcount)
+		printk("%snames %u, fullness %u (%u%%)\n", levels?"":"   ",
+			names, space/bcount,(space/bcount)*100/blocksize);
+	return (struct stats) { names, space, bcount};
+}
+#endif /* DX_DEBUG */
+
+/*
+ * Probe for a directory leaf block to search.
+ *
+ * dx_probe can return ERR_BAD_DX_DIR, which means there was a format
+ * error in the directory index, and the caller should fall back to
+ * searching the directory normally.  The callers of dx_probe **MUST**
+ * check for this error code, and make sure it never gets reflected
+ * back to userspace.
+ */
+static struct dx_frame *
+dx_probe(struct dentry *dentry, struct inode *dir,
+	 struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)
+{
+	unsigned count, indirect;
+	struct dx_entry *at, *entries, *p, *q, *m;
+	struct dx_root *root;
+	struct buffer_head *bh;
+	struct dx_frame *frame = frame_in;
+	u32 hash;
+
+	frame->bh = NULL;
+	if (dentry)
+		dir = dentry->d_parent->d_inode;
+	if (!(bh = ext3_bread (NULL,dir, 0, 0, err)))
+		goto fail;
+	root = (struct dx_root *) bh->b_data;
+	if (root->info.hash_version != DX_HASH_TEA &&
+	    root->info.hash_version != DX_HASH_HALF_MD4 &&
+	    root->info.hash_version != DX_HASH_LEGACY) {
+		ext3_warning(dir->i_sb, __FUNCTION__,
+			     "Unrecognised inode hash code %d",
+			     root->info.hash_version);
+		brelse(bh);
+		*err = ERR_BAD_DX_DIR;
+		goto fail;
+	}
+	hinfo->hash_version = root->info.hash_version;
+	hinfo->seed = dir->i_sb->u.ext3_sb.s_hash_seed;
+	if (dentry)
+		ext3fs_dirhash(dentry->d_name.name, dentry->d_name.len, hinfo);
+	hash = hinfo->hash;
+
+	if (root->info.unused_flags & 1) {
+		ext3_warning(dir->i_sb, __FUNCTION__,
+			     "Unimplemented inode hash flags: %#06x",
+			     root->info.unused_flags);
+		brelse(bh);
+		*err = ERR_BAD_DX_DIR;
+		goto fail;
+	}
+
+	if ((indirect = root->info.indirect_levels) > 1) {
+		ext3_warning(dir->i_sb, __FUNCTION__,
+			     "Unimplemented inode hash depth: %#06x",
+			     root->info.indirect_levels);
+		brelse(bh);
+		*err = ERR_BAD_DX_DIR;
+		goto fail;
+	}
+
+	entries = (struct dx_entry *) (((char *)&root->info) +
+				       root->info.info_length);
+	assert(dx_get_limit(entries) == dx_root_limit(dir,
+						      root->info.info_length));
+	dxtrace (printk("Look up %x", hash));
+	while (1)
+	{
+		count = dx_get_count(entries);
+		assert (count && count <= dx_get_limit(entries));
+		p = entries + 1;
+		q = entries + count - 1;
+		while (p <= q)
+		{
+			m = p + (q - p)/2;
+			dxtrace(printk("."));
+			if (dx_get_hash(m) > hash)
+				q = m - 1;
+			else
+				p = m + 1;
+		}
+
+		if (0) // linear search cross check
+		{
+			unsigned n = count - 1;
+			at = entries;
+			while (n--)
+			{
+				dxtrace(printk(","));
+				if (dx_get_hash(++at) > hash)
+				{
+					at--;
+					break;
+				}
+			}
+			assert (at == p - 1);
+		}
+
+		at = p - 1;
+		dxtrace(printk(" %x->%u\n", at == entries? 0: dx_get_hash(at), dx_get_block(at)));
+		frame->bh = bh;
+		frame->entries = entries;
+		frame->at = at;
+		if (!indirect--) return frame;
+		if (!(bh = ext3_bread (NULL,dir, dx_get_block(at), 0, err)))
+			goto fail2;
+		at = entries = ((struct dx_node *) bh->b_data)->entries;
+		assert (dx_get_limit(entries) == dx_node_limit (dir));
+		frame++;
+	}
+fail2:
+	while (frame >= frame_in) {
+		brelse(frame->bh);
+		frame--;
+	}
+fail:
+	return NULL;
+}
+
+static void dx_release (struct dx_frame *frames)
+{
+	if (frames[0].bh == NULL)
+		return;
+
+	if (((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels)
+		brelse(frames[1].bh);
+	brelse(frames[0].bh);
+}
+
+/*
+ * This function increments the frame pointer to search the next leaf
+ * block, and reads in the necessary intervening nodes if the search
+ * should be necessary.  Whether or not the search is necessary is
+ * controlled by the hash parameter.  If the hash value is even, then
+ * the search is only continued if the next block starts with that
+ * hash value.  This is used if we are searching for a specific file.
+ *
+ * If the hash value is HASH_NB_ALWAYS, then always go to the next block.
+ *
+ * This function returns 1 if the caller should continue to search,
+ * or 0 if it should not.  If there is an error reading one of the
+ * index blocks, it will return -1.
+ *
+ * If start_hash is non-null, it will be filled in with the starting
+ * hash of the next page.
+ */
+static int ext3_htree_next_block(struct inode *dir, __u32 hash,
+				 struct dx_frame *frame,
+				 struct dx_frame *frames, int *err,
+				 __u32 *start_hash)
+{
+	struct dx_frame *p;
+	struct buffer_head *bh;
+	int num_frames = 0;
+	__u32 bhash;
+
+	*err = ENOENT;
+	p = frame;
+	/*
+	 * Find the next leaf page by incrementing the frame pointer.
+	 * If we run out of entries in the interior node, loop around and
+	 * increment pointer in the parent node.  When we break out of
+	 * this loop, num_frames indicates the number of interior
+	 * nodes need to be read.
+	 */
+	while (1) {
+		if (++(p->at) < p->entries + dx_get_count(p->entries))
+			break;
+		if (p == frames)
+			return 0;
+		num_frames++;
+		p--;
+	}
+
+	/*
+	 * If the hash is 1, then continue only if the next page has a
+	 * continuation hash of any value.  This is used for readdir
+	 * handling.  Otherwise, check to see if the hash matches the
+	 * desired contiuation hash.  If it doesn't, return since
+	 * there's no point to read in the successive index pages.
+	 */
+	bhash = dx_get_hash(p->at);
+	if (start_hash)
+		*start_hash = bhash;
+	if ((hash & 1) == 0) {
+		if ((bhash & ~1) != hash)
+			return 0;
+	}
+	/*
+	 * If the hash is HASH_NB_ALWAYS, we always go to the next
+	 * block so no check is necessary
+	 */
+	while (num_frames--) {
+		if (!(bh = ext3_bread(NULL, dir, dx_get_block(p->at),
+				      0, err)))
+			return -1; /* Failure */
+		p++;
+		brelse (p->bh);
+		p->bh = bh;
+		p->at = p->entries = ((struct dx_node *) bh->b_data)->entries;
+	}
+	return 1;
+}
+
+
+/*
+ * p is at least 6 bytes before the end of page
+ */
+static inline struct ext3_dir_entry_2 *ext3_next_entry(struct ext3_dir_entry_2 *p)
+{
+	return (struct ext3_dir_entry_2 *)((char*)p + le16_to_cpu(p->rec_len));
+}
+
+/*
+ * This function fills a red-black tree with information from a
+ * directory.  We start scanning the directory in hash order, starting
+ * at start_hash and start_minor_hash.
+ *
+ * This function returns the number of entries inserted into the tree,
+ * or a negative error code.
+ */
+int ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,
+			 __u32 start_minor_hash, __u32 *next_hash)
+{
+	struct dx_hash_info hinfo;
+	struct buffer_head *bh;
+	struct ext3_dir_entry_2 *de, *top;
+	static struct dx_frame frames[2], *frame;
+	struct inode *dir;
+	int block, err;
+	int count = 0;
+	int ret;
+	__u32 hashval;
+	
+	dxtrace(printk("In htree_fill_tree, start hash: %x:%x\n", start_hash,
+		       start_minor_hash));
+	dir = dir_file->f_dentry->d_inode;
+	hinfo.hash = start_hash;
+	hinfo.minor_hash = 0;
+	frame = dx_probe(0, dir_file->f_dentry->d_inode, &hinfo, frames, &err);
+	if (!frame)
+		return err;
+
+	while (1) {
+		block = dx_get_block(frame->at);
+		dxtrace(printk("Reading block %d\n", block));
+		if (!(bh = ext3_bread (NULL, dir, block, 0, &err)))
+			goto errout;
+	
+		de = (struct ext3_dir_entry_2 *) bh->b_data;
+		top = (struct ext3_dir_entry_2 *) ((char *) de + dir->i_sb->s_blocksize -
+				       EXT3_DIR_REC_LEN(0));
+		for (; de < top; de = ext3_next_entry(de)) {
+			ext3fs_dirhash(de->name, de->name_len, &hinfo);
+			if ((hinfo.hash < start_hash) ||
+			    ((hinfo.hash == start_hash) &&
+			     (hinfo.minor_hash < start_minor_hash)))
+				continue;
+			ext3_htree_store_dirent(dir_file, hinfo.hash,
+						hinfo.minor_hash, de);
+			count++;
+		}
+		brelse (bh);
+		hashval = ~1;
+		ret = ext3_htree_next_block(dir, HASH_NB_ALWAYS, 
+					    frame, frames, &err, &hashval);
+		if (next_hash)
+			*next_hash = hashval;
+		if (ret == -1)
+			goto errout;
+		/*
+		 * Stop if:  (a) there are no more entries, or
+		 * (b) we have inserted at least one entry and the
+		 * next hash value is not a continuation
+		 */
+		if ((ret == 0) ||
+		    (count && ((hashval & 1) == 0)))
+			break;
+	}
+	dx_release(frames);
+	dxtrace(printk("Fill tree: returned %d entries\n", count));
+	return count;
+errout:
+	dx_release(frames);
+	return (err);
+}
+
+
+/*
+ * Directory block splitting, compacting
+ */
+
+static int dx_make_map (struct ext3_dir_entry_2 *de, int size,
+			struct dx_hash_info *hinfo, struct dx_map_entry *map_tail)
+{
+	int count = 0;
+	char *base = (char *) de;
+	struct dx_hash_info h = *hinfo;
+	
+	while ((char *) de < base + size)
+	{
+		if (de->name_len && de->inode) {
+			ext3fs_dirhash(de->name, de->name_len, &h);
+			map_tail--;
+			map_tail->hash = h.hash;
+			map_tail->offs = (u32) ((char *) de - base);
+			count++;
+		}
+		/* XXX: do we need to check rec_len == 0 case? -Chris */
+		de = (struct ext3_dir_entry_2 *) ((char *) de + le16_to_cpu(de->rec_len));
+	}
+	return count;
+}
+
+static void dx_sort_map (struct dx_map_entry *map, unsigned count)
+{
+        struct dx_map_entry *p, *q, *top = map + count - 1;
+        int more;
+        /* Combsort until bubble sort doesn't suck */
+        while (count > 2)
+	{
+                count = count*10/13;
+                if (count - 9 < 2) /* 9, 10 -> 11 */
+                        count = 11;
+                for (p = top, q = p - count; q >= map; p--, q--)
+                        if (p->hash < q->hash)
+                                swap(*p, *q);
+        }
+        /* Garden variety bubble sort */
+        do {
+                more = 0;
+                q = top;
+                while (q-- > map)
+		{
+                        if (q[1].hash >= q[0].hash)
+				continue;
+                        swap(*(q+1), *q);
+                        more = 1;
+		}
+	} while(more);
+}
+
+static void dx_insert_block(struct dx_frame *frame, u32 hash, u32 block)
+{
+	struct dx_entry *entries = frame->entries;
+	struct dx_entry *old = frame->at, *new = old + 1;
+	int count = dx_get_count(entries);
+
+	assert(count < dx_get_limit(entries));
+	assert(old < entries + count);
+	memmove(new + 1, new, (char *)(entries + count) - (char *)(new));
+	dx_set_hash(new, hash);
+	dx_set_block(new, block);
+	dx_set_count(entries, count + 1);
+}
+#endif
+
+
+static void ext3_update_dx_flag(struct inode *inode)
+{
+	if (!EXT3_HAS_COMPAT_FEATURE(inode->i_sb,
+				     EXT3_FEATURE_COMPAT_DIR_INDEX))
+		EXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;
+}
+
 /*
  * NOTE! unlike strncmp, ext3_match returns 1 for success, 0 for failure.
  *
@@ -94,6 +724,7 @@ static int inline search_dirblock(struct
 	return 0;
 }
 
+
 /*
  *	ext3_find_entry()
  *
@@ -105,6 +736,8 @@ static int inline search_dirblock(struct
  * The returned buffer_head has ->b_count elevated.  The caller is expected
  * to brelse() it when appropriate.
  */
+
+	
 static struct buffer_head * ext3_find_entry (struct dentry *dentry,
 					struct ext3_dir_entry_2 ** res_dir)
 {
@@ -119,12 +752,32 @@ static struct buffer_head * ext3_find_en
 	int num = 0;
 	int nblocks, i, err;
 	struct inode *dir = dentry->d_parent->d_inode;
+	int namelen;
+	const u8 *name;
+	unsigned blocksize;
 
 	*res_dir = NULL;
 	sb = dir->i_sb;
-
+	blocksize = sb->s_blocksize;
+	namelen = dentry->d_name.len;
+	name = dentry->d_name.name;
+	if (namelen > EXT3_NAME_LEN)
+		return NULL;
+#ifdef CONFIG_EXT3_INDEX
+	if (is_dx(dir)) {
+		bh = ext3_dx_find_entry(dentry, res_dir, &err);
+		/*
+		 * On success, or if the error was file not found,
+		 * return.  Otherwise, fall back to doing a search the
+		 * old fashioned way.
+		 */
+		if (bh || (err != ERR_BAD_DX_DIR))
+			return bh;
+		dxtrace(printk("ext3_find_entry: dx failed, falling back\n"));
+	}
+#endif
 	nblocks = dir->i_size >> EXT3_BLOCK_SIZE_BITS(sb);
-	start = dir->u.ext3_i.i_dir_start_lookup;
+	start = EXT3_I(dir)->i_dir_start_lookup;
 	if (start >= nblocks)
 		start = 0;
 	block = start;
@@ -165,7 +818,7 @@ restart:
 		i = search_dirblock(bh, dir, dentry,
 			    block << EXT3_BLOCK_SIZE_BITS(sb), res_dir);
 		if (i == 1) {
-			dir->u.ext3_i.i_dir_start_lookup = block;
+			EXT3_I(dir)->i_dir_start_lookup = block;
 			ret = bh;
 			goto cleanup_and_exit;
 		} else {
@@ -196,6 +849,66 @@ cleanup_and_exit:
 	return ret;
 }
 
+#ifdef CONFIG_EXT3_INDEX
+static struct buffer_head * ext3_dx_find_entry(struct dentry *dentry,
+		       struct ext3_dir_entry_2 **res_dir, int *err)
+{
+	struct super_block * sb;
+	struct dx_hash_info	hinfo;
+	u32 hash;
+	struct dx_frame frames[2], *frame;
+	struct ext3_dir_entry_2 *de, *top;
+	struct buffer_head *bh;
+	unsigned long block;
+	int retval;
+	int namelen = dentry->d_name.len;
+	const u8 *name = dentry->d_name.name;
+	struct inode *dir = dentry->d_parent->d_inode;
+	
+	sb = dir->i_sb;
+	if (!(frame = dx_probe (dentry, 0, &hinfo, frames, err)))
+		return NULL;
+	hash = hinfo.hash;
+	do {
+		block = dx_get_block(frame->at);
+		if (!(bh = ext3_bread (NULL,dir, block, 0, err)))
+			goto errout;
+		de = (struct ext3_dir_entry_2 *) bh->b_data;
+		top = (struct ext3_dir_entry_2 *) ((char *) de + sb->s_blocksize -
+				       EXT3_DIR_REC_LEN(0));
+		for (; de < top; de = ext3_next_entry(de))
+		if (ext3_match (namelen, name, de)) {
+			if (!ext3_check_dir_entry("ext3_find_entry",
+						  dir, de, bh,
+				  (block<<EXT3_BLOCK_SIZE_BITS(sb))
+					  +((char *)de - bh->b_data))) {
+				brelse (bh);
+				goto errout;
+			}
+			*res_dir = de;
+			dx_release (frames);
+			return bh;
+		}
+		brelse (bh);
+		/* Check to see if we should continue to search */
+		retval = ext3_htree_next_block(dir, hash, frame,
+					       frames, err, 0);
+		if (retval == -1) {
+			ext3_warning(sb, __FUNCTION__,
+			     "error reading index page in directory #%lu",
+			     dir->i_ino);
+			goto errout;
+		}
+	} while (retval == 1);
+	
+	*err = -ENOENT;
+errout:
+	dxtrace(printk("%s not found\n", name));
+	dx_release (frames);
+	return NULL;
+}
+#endif
+
 static struct dentry *ext3_lookup(struct inode * dir, struct dentry *dentry)
 {
 	struct inode * inode;
@@ -212,8 +925,9 @@ static struct dentry *ext3_lookup(struct
 		brelse (bh);
 		inode = iget(dir->i_sb, ino);
 
-		if (!inode)
+		if (!inode) {
 			return ERR_PTR(-EACCES);
+		}
 	}
 	d_add(dentry, inode);
 	return NULL;
@@ -237,6 +951,300 @@ static inline void ext3_set_de_type(stru
 		de->file_type = ext3_type_by_mode[(mode & S_IFMT)>>S_SHIFT];
 }
 
+#ifdef CONFIG_EXT3_INDEX
+static struct ext3_dir_entry_2 *
+dx_move_dirents(char *from, char *to, struct dx_map_entry *map, int count)
+{
+	unsigned rec_len = 0;
+
+	while (count--) {
+		struct ext3_dir_entry_2 *de = (struct ext3_dir_entry_2 *) (from + map->offs);
+		rec_len = EXT3_DIR_REC_LEN(de->name_len);
+		memcpy (to, de, rec_len);
+		((struct ext3_dir_entry_2 *) to)->rec_len = rec_len;
+		de->inode = 0;
+		map++;
+		to += rec_len;
+	}
+	return (struct ext3_dir_entry_2 *) (to - rec_len);
+}
+
+static struct ext3_dir_entry_2* dx_pack_dirents(char *base, int size)
+{
+	struct ext3_dir_entry_2 *next, *to, *prev, *de = (struct ext3_dir_entry_2 *) base;
+	unsigned rec_len = 0;
+
+	prev = to = de;
+	while ((char*)de < base + size) {
+		next = (struct ext3_dir_entry_2 *) ((char *) de +
+						    le16_to_cpu(de->rec_len));
+		if (de->inode && de->name_len) {
+			rec_len = EXT3_DIR_REC_LEN(de->name_len);
+			if (de > to)
+				memmove(to, de, rec_len);
+			to->rec_len = rec_len;
+			prev = to;
+			to = (struct ext3_dir_entry_2 *) (((char *) to) + rec_len);
+		}
+		de = next;
+	}
+	return prev;
+}
+
+static struct ext3_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,
+			struct buffer_head **bh,struct dx_frame *frame,
+			struct dx_hash_info *hinfo, int *error)
+{
+	unsigned blocksize = dir->i_sb->s_blocksize;
+	unsigned count, continued;
+	struct buffer_head *bh2;
+	u32 newblock;
+	u32 hash2;
+	struct dx_map_entry *map;
+	char *data1 = (*bh)->b_data, *data2;
+	unsigned split;
+	struct ext3_dir_entry_2 *de = NULL, *de2;
+	int	err;
+
+	bh2 = ext3_append (handle, dir, &newblock, error);
+	if (!(bh2)) {
+		brelse(*bh);
+		*bh = NULL;
+		goto errout;
+	}
+
+	BUFFER_TRACE(*bh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, *bh);
+	if (err) {
+	journal_error:
+		brelse(*bh);
+		brelse(bh2);
+		*bh = NULL;
+		ext3_std_error(dir->i_sb, err);
+		goto errout;
+	}
+	BUFFER_TRACE(frame->bh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, frame->bh);
+	if (err)
+		goto journal_error;
+
+	data2 = bh2->b_data;
+
+	/* create map in the end of data2 block */
+	map = (struct dx_map_entry *) (data2 + blocksize);
+	count = dx_make_map ((struct ext3_dir_entry_2 *) data1,
+			     blocksize, hinfo, map);
+	map -= count;
+	split = count/2; // need to adjust to actual middle
+	dx_sort_map (map, count);
+	hash2 = map[split].hash;
+	continued = hash2 == map[split - 1].hash;
+	dxtrace(printk("Split block %i at %x, %i/%i\n",
+		dx_get_block(frame->at), hash2, split, count-split));
+
+	/* Fancy dance to stay within two buffers */
+	de2 = dx_move_dirents(data1, data2, map + split, count - split);
+	de = dx_pack_dirents(data1,blocksize);
+	de->rec_len = cpu_to_le16(data1 + blocksize - (char *) de);
+	de2->rec_len = cpu_to_le16(data2 + blocksize - (char *) de2);
+	dxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data1, blocksize, 1));
+	dxtrace(dx_show_leaf (hinfo, (struct ext3_dir_entry_2 *) data2, blocksize, 1));
+
+	/* Which block gets the new entry? */
+	if (hinfo->hash >= hash2)
+	{
+		swap(*bh, bh2);
+		de = de2;
+	}
+	dx_insert_block (frame, hash2 + continued, newblock);
+	err = ext3_journal_dirty_metadata (handle, bh2);
+	if (err)
+		goto journal_error;
+	err = ext3_journal_dirty_metadata (handle, frame->bh);
+	if (err)
+		goto journal_error;
+	brelse (bh2);
+	dxtrace(dx_show_index ("frame", frame->entries));
+errout:
+	return de;
+}
+#endif
+
+
+/*
+ * Add a new entry into a directory (leaf) block.  If de is non-NULL,
+ * it points to a directory entry which is guaranteed to be large
+ * enough for new directory entry.  If de is NULL, then
+ * add_dirent_to_buf will attempt search the directory block for
+ * space.  It will return -ENOSPC if no space is available, and -EIO
+ * and -EEXIST if directory entry already exists.
+ * 
+ * NOTE!  bh is NOT released in the case where ENOSPC is returned.  In
+ * all other cases bh is released.
+ */
+static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
+			     struct inode *inode, struct ext3_dir_entry_2 *de,
+			     struct buffer_head * bh)
+{
+	struct inode	*dir = dentry->d_parent->d_inode;
+	const char	*name = dentry->d_name.name;
+	int		namelen = dentry->d_name.len;
+	unsigned long	offset = 0;
+	unsigned short	reclen;
+	int		nlen, rlen, err;
+	char		*top;
+	
+	reclen = EXT3_DIR_REC_LEN(namelen);
+	if (!de) {
+		de = (struct ext3_dir_entry_2 *)bh->b_data;
+		top = bh->b_data + dir->i_sb->s_blocksize - reclen;
+		while ((char *) de <= top) {
+			if (!ext3_check_dir_entry("ext3_add_entry", dir, de,
+						  bh, offset)) {
+				brelse (bh);
+				return -EIO;
+			}
+			if (ext3_match (namelen, name, de)) {
+				brelse (bh);
+				return -EEXIST;
+			}
+			nlen = EXT3_DIR_REC_LEN(de->name_len);
+			rlen = le16_to_cpu(de->rec_len);
+			if ((de->inode? rlen - nlen: rlen) >= reclen)
+				break;
+			de = (struct ext3_dir_entry_2 *)((char *)de + rlen);
+			offset += rlen;
+		}
+		if ((char *) de > top)
+			return -ENOSPC;
+	}
+	BUFFER_TRACE(bh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, bh);
+	if (err) {
+		ext3_std_error(dir->i_sb, err);
+		brelse(bh);
+		return err;
+	}
+	
+	/* By now the buffer is marked for journaling */
+	nlen = EXT3_DIR_REC_LEN(de->name_len);
+	rlen = le16_to_cpu(de->rec_len);
+	if (de->inode) {
+		struct ext3_dir_entry_2 *de1 = (struct ext3_dir_entry_2 *)((char *)de + nlen);
+		de1->rec_len = cpu_to_le16(rlen - nlen);
+		de->rec_len = cpu_to_le16(nlen);
+		de = de1;
+	}
+	de->file_type = EXT3_FT_UNKNOWN;
+	if (inode) {
+		de->inode = cpu_to_le32(inode->i_ino);
+		ext3_set_de_type(dir->i_sb, de, inode->i_mode);
+	} else
+		de->inode = 0;
+	de->name_len = namelen;
+	memcpy (de->name, name, namelen);
+	/*
+	 * XXX shouldn't update any times until successful
+	 * completion of syscall, but too many callers depend
+	 * on this.
+	 *
+	 * XXX similarly, too many callers depend on
+	 * ext3_new_inode() setting the times, but error
+	 * recovery deletes the inode, so the worst that can
+	 * happen is that the times are slightly out of date
+	 * and/or different from the directory change time.
+	 */
+	dir->i_mtime = dir->i_ctime = CURRENT_TIME;
+	ext3_update_dx_flag(dir);
+	dir->i_version = ++event;
+	ext3_mark_inode_dirty(handle, dir);
+	BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
+	err = ext3_journal_dirty_metadata(handle, bh);
+	if (err)
+		ext3_std_error(dir->i_sb, err);
+	brelse(bh);
+	return 0;
+}
+
+#ifdef CONFIG_EXT3_INDEX
+/*
+ * This converts a one block unindexed directory to a 3 block indexed
+ * directory, and adds the dentry to the indexed directory.
+ */
+static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
+			    struct inode *inode, struct buffer_head *bh)
+{
+	struct inode	*dir = dentry->d_parent->d_inode;
+	const char	*name = dentry->d_name.name;
+	int		namelen = dentry->d_name.len;
+	struct buffer_head *bh2;
+	struct dx_root	*root;
+	struct dx_frame	frames[2], *frame;
+	struct dx_entry *entries;
+	struct ext3_dir_entry_2	*de, *de2;
+	char		*data1, *top;
+	unsigned	len;
+	int		retval;
+	unsigned	blocksize;
+	struct dx_hash_info hinfo;
+	u32		block;
+		
+	blocksize =  dir->i_sb->s_blocksize;
+	dxtrace(printk("Creating index\n"));
+	retval = ext3_journal_get_write_access(handle, bh);
+	if (retval) {
+		ext3_std_error(dir->i_sb, retval);
+		brelse(bh);
+		return retval;
+	}
+	root = (struct dx_root *) bh->b_data;
+		
+	EXT3_I(dir)->i_flags |= EXT3_INDEX_FL;
+	bh2 = ext3_append (handle, dir, &block, &retval);
+	if (!(bh2)) {
+		brelse(bh);
+		return retval;
+	}
+	data1 = bh2->b_data;
+
+	/* The 0th block becomes the root, move the dirents out */
+	de = (struct ext3_dir_entry_2 *) &root->info;
+	len = ((char *) root) + blocksize - (char *) de;
+	memcpy (data1, de, len);
+	de = (struct ext3_dir_entry_2 *) data1;
+	top = data1 + len;
+	while (((char *) de2=(char*)de+le16_to_cpu(de->rec_len)) < top)
+		de = de2;
+	de->rec_len = cpu_to_le16(data1 + blocksize - (char *) de);
+	/* Initialize the root; the dot dirents already exist */
+	de = (struct ext3_dir_entry_2 *) (&root->dotdot);
+	de->rec_len = cpu_to_le16(blocksize - EXT3_DIR_REC_LEN(2));
+	memset (&root->info, 0, sizeof(root->info));
+	root->info.info_length = sizeof(root->info);
+	root->info.hash_version = dir->i_sb->u.ext3_sb.s_def_hash_version;
+	entries = root->entries;
+	dx_set_block (entries, 1);
+	dx_set_count (entries, 1);
+	dx_set_limit (entries, dx_root_limit(dir, sizeof(root->info)));
+
+	/* Initialize as for dx_probe */
+	hinfo.hash_version = root->info.hash_version;
+	hinfo.seed = dir->i_sb->u.ext3_sb.s_hash_seed;
+	ext3fs_dirhash(name, namelen, &hinfo);
+	frame = frames;
+	frame->entries = entries;
+	frame->at = entries;
+	frame->bh = bh;
+	bh = bh2;
+	de = do_split(handle,dir, &bh, frame, &hinfo, &retval);
+	dx_release (frames);
+	if (!(de))
+		return retval;
+
+	return add_dirent_to_buf(handle, dentry, inode, de, bh);
+}
+#endif
+
 /*
  *	ext3_add_entry()
  *
@@ -247,127 +1255,198 @@ static inline void ext3_set_de_type(stru
  * may not sleep between calling this and putting something into
  * the entry, as someone else might have used it while you slept.
  */
-
-/*
- * AKPM: the journalling code here looks wrong on the error paths
- */
 static int ext3_add_entry (handle_t *handle, struct dentry *dentry,
 	struct inode *inode)
 {
 	struct inode *dir = dentry->d_parent->d_inode;
-	const char *name = dentry->d_name.name;
-	int namelen = dentry->d_name.len;
 	unsigned long offset;
-	unsigned short rec_len;
 	struct buffer_head * bh;
-	struct ext3_dir_entry_2 * de, * de1;
+	struct ext3_dir_entry_2 *de;
 	struct super_block * sb;
 	int	retval;
+#ifdef CONFIG_EXT3_INDEX
+	int	dx_fallback=0;
+#endif
+	unsigned blocksize;
+	unsigned nlen, rlen;
+	u32 block, blocks;
 
 	sb = dir->i_sb;
-
-	if (!namelen)
+	blocksize = sb->s_blocksize;
+	if (!dentry->d_name.len)
 		return -EINVAL;
-	bh = ext3_bread (handle, dir, 0, 0, &retval);
+#ifdef CONFIG_EXT3_INDEX
+	if (is_dx(dir)) {
+		retval = ext3_dx_add_entry(handle, dentry, inode);
+		if (!retval || (retval != ERR_BAD_DX_DIR))
+			return retval;
+		EXT3_I(dir)->i_flags &= ~EXT3_INDEX_FL;
+		dx_fallback++;
+		ext3_mark_inode_dirty(handle, dir);
+	}
+#endif
+	blocks = dir->i_size >> sb->s_blocksize_bits;
+	for (block = 0, offset = 0; block < blocks; block++) {
+		bh = ext3_bread(handle, dir, block, 0, &retval);
+		if(!bh)
+			return retval;
+		retval = add_dirent_to_buf(handle, dentry, inode, 0, bh);
+		if (retval != -ENOSPC)
+			return retval;
+
+#ifdef CONFIG_EXT3_INDEX
+		if (blocks == 1 && !dx_fallback &&
+		    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))
+			return make_indexed_dir(handle, dentry, inode, bh);
+#endif
+		brelse(bh);
+	}
+	bh = ext3_append(handle, dir, &block, &retval);
 	if (!bh)
 		return retval;
-	rec_len = EXT3_DIR_REC_LEN(namelen);
-	offset = 0;
 	de = (struct ext3_dir_entry_2 *) bh->b_data;
-	while (1) {
-		if ((char *)de >= sb->s_blocksize + bh->b_data) {
-			brelse (bh);
-			bh = NULL;
-			bh = ext3_bread (handle, dir,
-				offset >> EXT3_BLOCK_SIZE_BITS(sb), 1, &retval);
-			if (!bh)
-				return retval;
-			if (dir->i_size <= offset) {
-				if (dir->i_size == 0) {
-					brelse(bh);
-					return -ENOENT;
-				}
+	de->inode = 0;
+	de->rec_len = cpu_to_le16(rlen = blocksize);
+	nlen = 0;
+	return add_dirent_to_buf(handle, dentry, inode, de, bh);
+}
 
-				ext3_debug ("creating next block\n");
+#ifdef CONFIG_EXT3_INDEX
+/*
+ * Returns 0 for success, or a negative error value
+ */
+static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,
+			     struct inode *inode)
+{
+	struct dx_frame frames[2], *frame;
+	struct dx_entry *entries, *at;
+	struct dx_hash_info hinfo;
+	struct buffer_head * bh;
+	struct inode *dir = dentry->d_parent->d_inode;
+	struct super_block * sb = dir->i_sb;
+	struct ext3_dir_entry_2 *de;
+	int err;
 
-				BUFFER_TRACE(bh, "get_write_access");
-				ext3_journal_get_write_access(handle, bh);
-				de = (struct ext3_dir_entry_2 *) bh->b_data;
-				de->inode = 0;
-				de->rec_len = le16_to_cpu(sb->s_blocksize);
-				dir->u.ext3_i.i_disksize =
-					dir->i_size = offset + sb->s_blocksize;
-				dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
-				ext3_mark_inode_dirty(handle, dir);
-			} else {
+	frame = dx_probe(dentry, 0, &hinfo, frames, &err);
+	if (!frame)
+		return err;
+	entries = frame->entries;
+	at = frame->at;
 
-				ext3_debug ("skipping to next block\n");
+	if (!(bh = ext3_bread(handle,dir, dx_get_block(frame->at), 0, &err)))
+		goto cleanup;
 
-				de = (struct ext3_dir_entry_2 *) bh->b_data;
-			}
-		}
-		if (!ext3_check_dir_entry ("ext3_add_entry", dir, de, bh,
-					   offset)) {
-			brelse (bh);
-			return -ENOENT;
-		}
-		if (ext3_match (namelen, name, de)) {
-				brelse (bh);
-				return -EEXIST;
+	BUFFER_TRACE(bh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, bh);
+	if (err)
+		goto journal_error;
+
+	err = add_dirent_to_buf(handle, dentry, inode, 0, bh);
+	if (err != -ENOSPC) {
+		bh = 0;
+		goto cleanup;
+	}
+
+	/* Block full, should compress but for now just split */
+	dxtrace(printk("using %u of %u node entries\n",
+		       dx_get_count(entries), dx_get_limit(entries)));
+	/* Need to split index? */
+	if (dx_get_count(entries) == dx_get_limit(entries)) {
+		u32 newblock;
+		unsigned icount = dx_get_count(entries);
+		int levels = frame - frames;
+		struct dx_entry *entries2;
+		struct dx_node *node2;
+		struct buffer_head *bh2;
+
+		if (levels && (dx_get_count(frames->entries) ==
+			       dx_get_limit(frames->entries))) {
+			ext3_warning(sb, __FUNCTION__,
+				     "Directory index full!\n");
+			err = -ENOSPC;
+			goto cleanup;
 		}
-		if ((le32_to_cpu(de->inode) == 0 &&
-				le16_to_cpu(de->rec_len) >= rec_len) ||
-		    (le16_to_cpu(de->rec_len) >=
-				EXT3_DIR_REC_LEN(de->name_len) + rec_len)) {
-			BUFFER_TRACE(bh, "get_write_access");
-			ext3_journal_get_write_access(handle, bh);
-			/* By now the buffer is marked for journaling */
-			offset += le16_to_cpu(de->rec_len);
-			if (le32_to_cpu(de->inode)) {
-				de1 = (struct ext3_dir_entry_2 *) ((char *) de +
-					EXT3_DIR_REC_LEN(de->name_len));
-				de1->rec_len =
-					cpu_to_le16(le16_to_cpu(de->rec_len) -
-					EXT3_DIR_REC_LEN(de->name_len));
-				de->rec_len = cpu_to_le16(
-						EXT3_DIR_REC_LEN(de->name_len));
-				de = de1;
+		bh2 = ext3_append (handle, dir, &newblock, &err);
+		if (!(bh2))
+			goto cleanup;
+		node2 = (struct dx_node *)(bh2->b_data);
+		entries2 = node2->entries;
+		node2->fake.rec_len = cpu_to_le16(sb->s_blocksize);
+		node2->fake.inode = 0;
+		BUFFER_TRACE(frame->bh, "get_write_access");
+		err = ext3_journal_get_write_access(handle, frame->bh);
+		if (err)
+			goto journal_error;
+		if (levels) {
+			unsigned icount1 = icount/2, icount2 = icount - icount1;
+			unsigned hash2 = dx_get_hash(entries + icount1);
+			dxtrace(printk("Split index %i/%i\n", icount1, icount2));
+				
+			BUFFER_TRACE(frame->bh, "get_write_access"); /* index root */
+			err = ext3_journal_get_write_access(handle,
+							     frames[0].bh);
+			if (err)
+				goto journal_error;
+				
+			memcpy ((char *) entries2, (char *) (entries + icount1),
+				icount2 * sizeof(struct dx_entry));
+			dx_set_count (entries, icount1);
+			dx_set_count (entries2, icount2);
+			dx_set_limit (entries2, dx_node_limit(dir));
+
+			/* Which index block gets the new entry? */
+			if (at - entries >= icount1) {
+				frame->at = at = at - entries - icount1 + entries2;
+				frame->entries = entries = entries2;
+				swap(frame->bh, bh2);
 			}
-			de->file_type = EXT3_FT_UNKNOWN;
-			if (inode) {
-				de->inode = cpu_to_le32(inode->i_ino);
-				ext3_set_de_type(dir->i_sb, de, inode->i_mode);
-			} else
-				de->inode = 0;
-			de->name_len = namelen;
-			memcpy (de->name, name, namelen);
-			/*
-			 * XXX shouldn't update any times until successful
-			 * completion of syscall, but too many callers depend
-			 * on this.
-			 *
-			 * XXX similarly, too many callers depend on
-			 * ext3_new_inode() setting the times, but error
-			 * recovery deletes the inode, so the worst that can
-			 * happen is that the times are slightly out of date
-			 * and/or different from the directory change time.
-			 */
-			dir->i_mtime = dir->i_ctime = CURRENT_TIME;
-			dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
-			dir->i_version = ++event;
-			ext3_mark_inode_dirty(handle, dir);
-			BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
-			ext3_journal_dirty_metadata(handle, bh);
-			brelse(bh);
-			return 0;
+			dx_insert_block (frames + 0, hash2, newblock);
+			dxtrace(dx_show_index ("node", frames[1].entries));
+			dxtrace(dx_show_index ("node",
+			       ((struct dx_node *) bh2->b_data)->entries));
+			err = ext3_journal_dirty_metadata(handle, bh2);
+			if (err)
+				goto journal_error;
+			brelse (bh2);
+		} else {
+			dxtrace(printk("Creating second level index...\n"));
+			memcpy((char *) entries2, (char *) entries,
+			       icount * sizeof(struct dx_entry));
+			dx_set_limit(entries2, dx_node_limit(dir));
+
+			/* Set up root */
+			dx_set_count(entries, 1);
+			dx_set_block(entries + 0, newblock);
+			((struct dx_root *) frames[0].bh->b_data)->info.indirect_levels = 1;
+
+			/* Add new access path frame */
+			frame = frames + 1;
+			frame->at = at = at - entries + entries2;
+			frame->entries = entries = entries2;
+			frame->bh = bh2;
+			err = ext3_journal_get_write_access(handle,
+							     frame->bh);
+			if (err)
+				goto journal_error;
 		}
-		offset += le16_to_cpu(de->rec_len);
-		de = (struct ext3_dir_entry_2 *)
-			((char *) de + le16_to_cpu(de->rec_len));
+		ext3_journal_dirty_metadata(handle, frames[0].bh);
 	}
-	brelse (bh);
-	return -ENOSPC;
+	de = do_split(handle, dir, &bh, frame, &hinfo, &err);
+	if (!de)
+		goto cleanup;
+	err = add_dirent_to_buf(handle, dentry, inode, de, bh);
+	bh = 0;
+	goto cleanup;
+	
+journal_error:
+	ext3_std_error(dir->i_sb, err);
+cleanup:
+	if (bh)
+		brelse(bh);
+	dx_release(frames);
+	return err;
 }
+#endif
 
 /*
  * ext3_delete_entry deletes a directory entry by merging it with the
@@ -451,9 +1530,11 @@ static int ext3_create (struct inode * d
 	struct inode * inode;
 	int err;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS + 3);
-	if (IS_ERR(handle))
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+					EXT3_INDEX_EXTRA_TRANS_BLOCKS + 3);
+	if (IS_ERR(handle)) {
 		return PTR_ERR(handle);
+	}
 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
@@ -478,9 +1559,11 @@ static int ext3_mknod (struct inode * di
 	struct inode *inode;
 	int err;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS + 3);
-	if (IS_ERR(handle))
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+			 		EXT3_INDEX_EXTRA_TRANS_BLOCKS + 3);
+	if (IS_ERR(handle)) {
 		return PTR_ERR(handle);
+	}
 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
@@ -507,9 +1590,11 @@ static int ext3_mkdir(struct inode * dir
 	if (dir->i_nlink >= EXT3_LINK_MAX)
 		return -EMLINK;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS + 3);
-	if (IS_ERR(handle))
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+					EXT3_INDEX_EXTRA_TRANS_BLOCKS + 3);
+	if (IS_ERR(handle)) {
 		return PTR_ERR(handle);
+	}
 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
@@ -521,7 +1606,7 @@ static int ext3_mkdir(struct inode * dir
 
 	inode->i_op = &ext3_dir_inode_operations;
 	inode->i_fop = &ext3_dir_operations;
-	inode->i_size = inode->u.ext3_i.i_disksize = inode->i_sb->s_blocksize;
+	inode->i_size = EXT3_I(inode)->i_disksize = inode->i_sb->s_blocksize;
 	inode->i_blocks = 0;	
 	dir_block = ext3_bread (handle, inode, 0, 1, &err);
 	if (!dir_block) {
@@ -554,21 +1639,19 @@ static int ext3_mkdir(struct inode * dir
 		inode->i_mode |= S_ISGID;
 	ext3_mark_inode_dirty(handle, inode);
 	err = ext3_add_entry (handle, dentry, inode);
-	if (err)
-		goto out_no_entry;
+	if (err) {
+		inode->i_nlink = 0;
+		ext3_mark_inode_dirty(handle, inode);
+		iput (inode);
+		goto out_stop;
+	}
 	dir->i_nlink++;
-	dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+	ext3_update_dx_flag(dir);
 	ext3_mark_inode_dirty(handle, dir);
 	d_instantiate(dentry, inode);
 out_stop:
 	ext3_journal_stop(handle, dir);
 	return err;
-
-out_no_entry:
-	inode->i_nlink = 0;
-	ext3_mark_inode_dirty(handle, inode);
-	iput (inode);
-	goto out_stop;
 }
 
 /*
@@ -655,7 +1738,7 @@ int ext3_orphan_add(handle_t *handle, st
 	int err = 0, rc;
 	
 	lock_super(sb);
-	if (!list_empty(&inode->u.ext3_i.i_orphan))
+	if (!list_empty(&EXT3_I(inode)->i_orphan))
 		goto out_unlock;
 
 	/* Orphan handling is only valid for files with data blocks
@@ -696,7 +1779,7 @@ int ext3_orphan_add(handle_t *handle, st
 	 * This is safe: on error we're going to ignore the orphan list
 	 * anyway on the next recovery. */
 	if (!err)
-		list_add(&inode->u.ext3_i.i_orphan, &EXT3_SB(sb)->s_orphan);
+		list_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);
 
 	jbd_debug(4, "superblock will point to %ld\n", inode->i_ino);
 	jbd_debug(4, "orphan inode %ld will point to %d\n",
@@ -714,25 +1797,26 @@ out_unlock:
 int ext3_orphan_del(handle_t *handle, struct inode *inode)
 {
 	struct list_head *prev;
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct ext3_sb_info *sbi;
 	ino_t ino_next; 
 	struct ext3_iloc iloc;
 	int err = 0;
 	
 	lock_super(inode->i_sb);
-	if (list_empty(&inode->u.ext3_i.i_orphan)) {
+	if (list_empty(&ei->i_orphan)) {
 		unlock_super(inode->i_sb);
 		return 0;
 	}
 
 	ino_next = NEXT_ORPHAN(inode);
-	prev = inode->u.ext3_i.i_orphan.prev;
+	prev = ei->i_orphan.prev;
 	sbi = EXT3_SB(inode->i_sb);
 
 	jbd_debug(4, "remove inode %ld from orphan list\n", inode->i_ino);
 
-	list_del(&inode->u.ext3_i.i_orphan);
-	INIT_LIST_HEAD(&inode->u.ext3_i.i_orphan);
+	list_del(&ei->i_orphan);
+	INIT_LIST_HEAD(&ei->i_orphan);
 
 	/* If we're on an error path, we may not have a valid
 	 * transaction handle with which to update the orphan list on
@@ -793,8 +1877,9 @@ static int ext3_rmdir (struct inode * di
 	handle_t *handle;
 
 	handle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS);
-	if (IS_ERR(handle))
+	if (IS_ERR(handle)) {
 		return PTR_ERR(handle);
+	}
 
 	retval = -ENOENT;
 	bh = ext3_find_entry (dentry, &de);
@@ -832,7 +1917,7 @@ static int ext3_rmdir (struct inode * di
 	dir->i_nlink--;
 	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
 	ext3_mark_inode_dirty(handle, inode);
-	dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+	ext3_update_dx_flag(dir);
 	ext3_mark_inode_dirty(handle, dir);
 
 end_rmdir:
@@ -850,8 +1935,9 @@ static int ext3_unlink(struct inode * di
 	handle_t *handle;
 
 	handle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS);
-	if (IS_ERR(handle))
+	if (IS_ERR(handle)) {
 		return PTR_ERR(handle);
+	}
 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
@@ -878,7 +1964,7 @@ static int ext3_unlink(struct inode * di
 	if (retval)
 		goto end_unlink;
 	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
-	dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+	ext3_update_dx_flag(dir);
 	ext3_mark_inode_dirty(handle, dir);
 	inode->i_nlink--;
 	if (!inode->i_nlink)
@@ -904,9 +1990,11 @@ static int ext3_symlink (struct inode * 
 	if (l > dir->i_sb->s_blocksize)
 		return -ENAMETOOLONG;
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS + 5);
-	if (IS_ERR(handle))
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+			 		EXT3_INDEX_EXTRA_TRANS_BLOCKS + 5);
+	if (IS_ERR(handle)) {
 		return PTR_ERR(handle);
+	}
 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
@@ -916,7 +2004,7 @@ static int ext3_symlink (struct inode * 
 	if (IS_ERR(inode))
 		goto out_stop;
 
-	if (l > sizeof (inode->u.ext3_i.i_data)) {
+	if (l > sizeof (EXT3_I(inode)->i_data)) {
 		inode->i_op = &page_symlink_inode_operations;
 		inode->i_mapping->a_ops = &ext3_aops;
 		/*
@@ -925,25 +2013,23 @@ static int ext3_symlink (struct inode * 
 		 * i_size in generic_commit_write().
 		 */
 		err = block_symlink(inode, symname, l);
-		if (err)
-			goto out_no_entry;
+		if (err) {
+			ext3_dec_count(handle, inode);
+			ext3_mark_inode_dirty(handle, inode);
+			iput (inode);
+			goto out_stop;
+		}
 	} else {
 		inode->i_op = &ext3_fast_symlink_inode_operations;
-		memcpy((char*)&inode->u.ext3_i.i_data,symname,l);
+		memcpy((char*)&EXT3_I(inode)->i_data,symname,l);
 		inode->i_size = l-1;
 	}
-	inode->u.ext3_i.i_disksize = inode->i_size;
+	EXT3_I(inode)->i_disksize = inode->i_size;
 	err = ext3_add_nondir(handle, dentry, inode);
 	ext3_mark_inode_dirty(handle, inode);
 out_stop:
 	ext3_journal_stop(handle, dir);
 	return err;
-
-out_no_entry:
-	ext3_dec_count(handle, inode);
-	ext3_mark_inode_dirty(handle, inode);
-	iput (inode);
-	goto out_stop;
 }
 
 static int ext3_link (struct dentry * old_dentry,
@@ -956,12 +2042,15 @@ static int ext3_link (struct dentry * ol
 	if (S_ISDIR(inode->i_mode))
 		return -EPERM;
 
-	if (inode->i_nlink >= EXT3_LINK_MAX)
+	if (inode->i_nlink >= EXT3_LINK_MAX) {
 		return -EMLINK;
+	}
 
-	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS);
-	if (IS_ERR(handle))
+	handle = ext3_journal_start(dir, EXT3_DATA_TRANS_BLOCKS +
+					EXT3_INDEX_EXTRA_TRANS_BLOCKS);
+	if (IS_ERR(handle)) {
 		return PTR_ERR(handle);
+	}
 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
@@ -995,9 +2084,11 @@ static int ext3_rename (struct inode * o
 
 	old_bh = new_bh = dir_bh = NULL;
 
-	handle = ext3_journal_start(old_dir, 2 * EXT3_DATA_TRANS_BLOCKS + 2);
-	if (IS_ERR(handle))
+	handle = ext3_journal_start(old_dir, 2 * EXT3_DATA_TRANS_BLOCKS +
+			 		EXT3_INDEX_EXTRA_TRANS_BLOCKS + 2);
+	if (IS_ERR(handle)) {
 		return PTR_ERR(handle);
+	}
 
 	if (IS_SYNC(old_dir) || IS_SYNC(new_dir))
 		handle->h_sync = 1;
@@ -1077,7 +2168,7 @@ static int ext3_rename (struct inode * o
 		new_inode->i_ctime = CURRENT_TIME;
 	}
 	old_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;
-	old_dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+	ext3_update_dx_flag(old_dir);
 	if (dir_bh) {
 		BUFFER_TRACE(dir_bh, "get_write_access");
 		ext3_journal_get_write_access(handle, dir_bh);
@@ -1089,7 +2180,7 @@ static int ext3_rename (struct inode * o
 			new_inode->i_nlink--;
 		} else {
 			new_dir->i_nlink++;
-			new_dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
+			ext3_update_dx_flag(new_dir);
 			ext3_mark_inode_dirty(handle, new_dir);
 		}
 	}
--- linux-2.4.20/fs/ext3/super.c~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/fs/ext3/super.c	Sat Apr  5 03:56:31 2003
@@ -707,6 +707,7 @@ static int ext3_setup_super(struct super
 	es->s_mtime = cpu_to_le32(CURRENT_TIME);
 	ext3_update_dynamic_rev(sb);
 	EXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);
+
 	ext3_commit_super (sb, es, 1);
 	if (test_opt (sb, DEBUG))
 		printk (KERN_INFO
@@ -717,6 +718,7 @@ static int ext3_setup_super(struct super
 			EXT3_BLOCKS_PER_GROUP(sb),
 			EXT3_INODES_PER_GROUP(sb),
 			sbi->s_mount_opt);
+
 	printk(KERN_INFO "EXT3 FS " EXT3FS_VERSION ", " EXT3FS_DATE " on %s, ",
 				bdevname(sb->s_dev));
 	if (EXT3_SB(sb)->s_journal->j_inode == NULL) {
@@ -890,6 +892,7 @@ static loff_t ext3_max_size(int bits)
 	return res;
 }
 
+
 struct super_block * ext3_read_super (struct super_block * sb, void * data,
 				      int silent)
 {
@@ -1066,6 +1069,9 @@ struct super_block * ext3_read_super (st
 	sbi->s_mount_state = le16_to_cpu(es->s_state);
 	sbi->s_addr_per_block_bits = log2(EXT3_ADDR_PER_BLOCK(sb));
 	sbi->s_desc_per_block_bits = log2(EXT3_DESC_PER_BLOCK(sb));
+	for (i=0; i < 4; i++)
+		sbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);
+	sbi->s_def_hash_version = es->s_def_hash_version;
 
 	if (sbi->s_blocks_per_group > blocksize * 8) {
 		printk (KERN_ERR
@@ -1769,6 +1775,7 @@ static void __exit exit_ext3_fs(void)
 	unregister_filesystem(&ext3_fs_type);
 }
 
+EXPORT_SYMBOL(ext3_force_commit);
 EXPORT_SYMBOL(ext3_bread);
 
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");
--- linux-2.4.20/include/linux/ext3_fs.h~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/include/linux/ext3_fs.h	Sat Apr  5 03:56:31 2003
@@ -40,6 +40,11 @@
 #define EXT3FS_VERSION		"2.4-0.9.19"
 
 /*
+ * Always enable hashed directories
+ */
+#define CONFIG_EXT3_INDEX
+
+/*
  * Debug code
  */
 #ifdef EXT3FS_DEBUG
@@ -437,8 +442,11 @@ struct ext3_super_block {
 /*E0*/	__u32	s_journal_inum;		/* inode number of journal file */
 	__u32	s_journal_dev;		/* device number of journal file */
 	__u32	s_last_orphan;		/* start of list of inodes to delete */
-
-/*EC*/	__u32	s_reserved[197];	/* Padding to the end of the block */
+	__u32	s_hash_seed[4];		/* HTREE hash seed */
+	__u8	s_def_hash_version;	/* Default hash version to use */
+	__u8	s_reserved_char_pad;
+	__u16	s_reserved_word_pad;
+	__u32	s_reserved[192];	/* Padding to the end of the block */
 };
 
 #ifdef __KERNEL__
@@ -575,9 +583,46 @@ struct ext3_dir_entry_2 {
 #define EXT3_DIR_ROUND			(EXT3_DIR_PAD - 1)
 #define EXT3_DIR_REC_LEN(name_len)	(((name_len) + 8 + EXT3_DIR_ROUND) & \
 					 ~EXT3_DIR_ROUND)
+/*
+ * Hash Tree Directory indexing
+ * (c) Daniel Phillips, 2001
+ */
+
+#ifdef CONFIG_EXT3_INDEX
+  #define is_dx(dir) (EXT3_HAS_COMPAT_FEATURE(dir->i_sb, \
+					      EXT3_FEATURE_COMPAT_DIR_INDEX) && \
+		      (EXT3_I(dir)->i_flags & EXT3_INDEX_FL))
+#define EXT3_DIR_LINK_MAX(dir) (!is_dx(dir) && (dir)->i_nlink >= EXT3_LINK_MAX)
+#define EXT3_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2 || (dir)->i_nlink == 1)
+#else
+  #define is_dx(dir) 0
+#define EXT3_DIR_LINK_MAX(dir) ((dir)->i_nlink >= EXT3_LINK_MAX)
+#define EXT3_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2)
+#endif
+
+/* Legal values for the dx_root hash_version field: */
+
+#define DX_HASH_LEGACY		0
+#define DX_HASH_HALF_MD4	1
+#define DX_HASH_TEA		2
+
+/* hash info structure used by the directory hash */
+struct dx_hash_info
+{
+	u32		hash;
+	u32		minor_hash;
+	int		hash_version;
+	u32		*seed;
+};
 
 #ifdef __KERNEL__
 /*
+ * Control parameters used by ext3_htree_next_block
+ */
+#define HASH_NB_ALWAYS		1
+
+
+/*
  * Describe an inode's exact location on disk and in memory
  */
 struct ext3_iloc
@@ -587,6 +632,27 @@ struct ext3_iloc
 	unsigned long block_group;
 };
 
+
+/*
+ * This structure is stuffed into the struct file's private_data field
+ * for directories.  It is where we put information so that we can do
+ * readdir operations in hash tree order.
+ */
+struct dir_private_info {
+	rb_root_t	root;
+	rb_node_t	*curr_node;
+	struct fname	*extra_fname;
+	loff_t		last_pos;
+	__u32		curr_hash;
+	__u32		curr_minor_hash;
+	__u32		next_hash;
+};
+
+/*
+ * Special error return code only used by dx_probe() and its callers.
+ */
+#define ERR_BAD_DX_DIR	-75000
+
 /*
  * Function prototypes
  */
@@ -614,11 +680,20 @@ extern struct ext3_group_desc * ext3_get
 
 /* dir.c */
 extern int ext3_check_dir_entry(const char *, struct inode *,
-				struct ext3_dir_entry_2 *, struct buffer_head *,
-				unsigned long);
+				struct ext3_dir_entry_2 *,
+				struct buffer_head *, unsigned long);
+extern void ext3_htree_store_dirent(struct file *dir_file, __u32 hash,
+				    __u32 minor_hash,
+				    struct ext3_dir_entry_2 *dirent);
+extern void ext3_htree_free_dir_info(struct dir_private_info *p);
+
 /* fsync.c */
 extern int ext3_sync_file (struct file *, struct dentry *, int);
 
+/* hash.c */
+extern int ext3fs_dirhash(const char *name, int len, struct
+			  dx_hash_info *hinfo);
+
 /* ialloc.c */
 extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int);
 extern void ext3_free_inode (handle_t *, struct inode *);
@@ -650,6 +725,8 @@ extern int ext3_ioctl (struct inode *, s
 /* namei.c */
 extern int ext3_orphan_add(handle_t *, struct inode *);
 extern int ext3_orphan_del(handle_t *, struct inode *);
+extern int ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,
+				__u32 start_minor_hash, __u32 *next_hash);
 
 /* super.c */
 extern void ext3_error (struct super_block *, const char *, const char *, ...)
--- linux-2.4.20/include/linux/ext3_fs_sb.h~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/include/linux/ext3_fs_sb.h	Sat Apr  5 03:56:31 2003
@@ -62,6 +62,8 @@ struct ext3_sb_info {
 	int s_inode_size;
 	int s_first_ino;
 	u32 s_next_generation;
+	u32 s_hash_seed[4];
+	int s_def_hash_version;
 
 	/* Journaling */
 	struct inode * s_journal_inode;
--- linux-2.4.20/include/linux/ext3_jbd.h~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/include/linux/ext3_jbd.h	Sat Apr  5 03:56:31 2003
@@ -63,6 +63,8 @@ extern int ext3_writepage_trans_blocks(s
 
 #define EXT3_RESERVE_TRANS_BLOCKS	12
 
+#define EXT3_INDEX_EXTRA_TRANS_BLOCKS	8
+
 int
 ext3_mark_iloc_dirty(handle_t *handle, 
 		     struct inode *inode,
--- linux-2.4.20/include/linux/rbtree.h~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/include/linux/rbtree.h	Sat Apr  5 03:56:31 2003
@@ -120,6 +120,8 @@ rb_root_t;
 
 extern void rb_insert_color(rb_node_t *, rb_root_t *);
 extern void rb_erase(rb_node_t *, rb_root_t *);
+extern rb_node_t *rb_get_first(rb_root_t *root);
+extern rb_node_t *rb_get_next(rb_node_t *n);
 
 static inline void rb_link_node(rb_node_t * node, rb_node_t * parent, rb_node_t ** rb_link)
 {
--- linux-2.4.20/lib/rbtree.c~ext-2.4-patch-1	Sat Apr  5 03:56:31 2003
+++ linux-2.4.20-braam/lib/rbtree.c	Sat Apr  5 03:56:31 2003
@@ -17,6 +17,8 @@
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
   linux/lib/rbtree.c
+
+  rb_get_first and rb_get_next written by Theodore Ts'o, 9/8/2002
 */
 
 #include <linux/rbtree.h>
@@ -294,3 +296,43 @@ void rb_erase(rb_node_t * node, rb_root_
 		__rb_erase_color(child, parent, root);
 }
 EXPORT_SYMBOL(rb_erase);
+
+/*
+ * This function returns the first node (in sort order) of the tree.
+ */
+rb_node_t *rb_get_first(rb_root_t *root)
+{
+	rb_node_t	*n;
+
+	n = root->rb_node;
+	if (!n)
+		return 0;
+	while (n->rb_left)
+		n = n->rb_left;
+	return n;
+}
+EXPORT_SYMBOL(rb_get_first);
+
+/*
+ * Given a node, this function will return the next node in the tree.
+ */
+rb_node_t *rb_get_next(rb_node_t *n)
+{
+	rb_node_t	*parent;
+
+	if (n->rb_right) {
+		n = n->rb_right;
+		while (n->rb_left)
+			n = n->rb_left;
+		return n;
+	} else {
+		while ((parent = n->rb_parent)) {
+			if (n == parent->rb_left)
+				return parent;
+			n = parent;
+		}
+		return 0;
+	}
+}
+EXPORT_SYMBOL(rb_get_next);
+

_
# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
#
# namei.c |    9 +++++++++
# 1 files changed, 9 insertions(+)
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 02/11/07	tytso@snap.thunk.org	1.777
# Add '.' and '..' entries to be returned by readdir of htree directories
# 
# This patch from Chris Li adds '.' and '..' to the rbtree so that they 
# are properly returned by readdir.
# --------------------------------------------
#
diff -Nru a/fs/ext3/namei.c b/fs/ext3/namei.c
--- a/fs/ext3/namei.c	Thu Nov  7 10:57:30 2002
+++ b/fs/ext3/namei.c	Thu Nov  7 10:57:30 2002
@@ -546,6 +546,15 @@
 	if (!frame)
 		return err;
 
+	/* Add '.' and '..' from the htree header */
+	if (!start_hash && !start_minor_hash) {
+		de = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;
+		ext3_htree_store_dirent(dir_file, 0, 0, de);
+		de = ext3_next_entry(de);
+		ext3_htree_store_dirent(dir_file, 0, 0, de);
+		count += 2;
+	}
+
 	while (1) {
 		block = dx_get_block(frame->at);
 		dxtrace(printk("Reading block %d\n", block));
# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
#
# fs/ext3/dir.c           |    7 +++++--
# fs/ext3/namei.c         |   11 +++++++----
# include/linux/ext3_fs.h |    2 +-
# 3 files changed, 13 insertions(+), 7 deletions(-)
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 02/11/07	tytso@snap.thunk.org	1.778
# Check for failed kmalloc() in ext3_htree_store_dirent()
# 
# This patch checks for a failed kmalloc() in ext3_htree_store_dirent(),
# and passes the error up to its caller, ext3_htree_fill_tree().
# --------------------------------------------
#
diff -Nru a/fs/ext3/dir.c b/fs/ext3/dir.c
--- a/fs/ext3/dir.c	Thu Nov  7 10:57:34 2002
+++ b/fs/ext3/dir.c	Thu Nov  7 10:57:34 2002
@@ -308,7 +308,7 @@
 /*
  * Given a directory entry, enter it into the fname rb tree.
  */
-void ext3_htree_store_dirent(struct file *dir_file, __u32 hash,
+int ext3_htree_store_dirent(struct file *dir_file, __u32 hash,
 			     __u32 minor_hash,
 			     struct ext3_dir_entry_2 *dirent)
 {
@@ -323,6 +323,8 @@
 	/* Create and allocate the fname structure */
 	len = sizeof(struct fname) + dirent->name_len + 1;
 	new_fn = kmalloc(len, GFP_KERNEL);
+	if (!new_fn)
+		return -ENOMEM;
 	memset(new_fn, 0, len);
 	new_fn->hash = hash;
 	new_fn->minor_hash = minor_hash;
@@ -344,7 +346,7 @@
 		    (new_fn->minor_hash == fname->minor_hash)) {
 			new_fn->next = fname->next;
 			fname->next = new_fn;
-			return;
+			return 0;
 		}
 			
 		if (new_fn->hash < fname->hash)
@@ -359,6 +361,7 @@
 
 	rb_link_node(&new_fn->rb_hash, parent, p);
 	rb_insert_color(&new_fn->rb_hash, &info->root);
+	return 0;
 }
 
 
diff -Nru a/fs/ext3/namei.c b/fs/ext3/namei.c
--- a/fs/ext3/namei.c	Thu Nov  7 10:57:34 2002
+++ b/fs/ext3/namei.c	Thu Nov  7 10:57:34 2002
@@ -549,9 +549,11 @@
 	/* Add '.' and '..' from the htree header */
 	if (!start_hash && !start_minor_hash) {
 		de = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;
-		ext3_htree_store_dirent(dir_file, 0, 0, de);
+		if ((err = ext3_htree_store_dirent(dir_file, 0, 0, de)) != 0)
+			goto errout;
 		de = ext3_next_entry(de);
-		ext3_htree_store_dirent(dir_file, 0, 0, de);
+		if ((err = ext3_htree_store_dirent(dir_file, 0, 0, de)) != 0)
+			goto errout;
 		count += 2;
 	}
 
@@ -570,8 +572,9 @@
 			    ((hinfo.hash == start_hash) &&
 			     (hinfo.minor_hash < start_minor_hash)))
 				continue;
-			ext3_htree_store_dirent(dir_file, hinfo.hash,
-						hinfo.minor_hash, de);
+			if ((err = ext3_htree_store_dirent(dir_file,
+				   hinfo.hash, hinfo.minor_hash, de)) != 0)
+				goto errout;
 			count++;
 		}
 		brelse (bh);
diff -Nru a/include/linux/ext3_fs.h b/include/linux/ext3_fs.h
--- a/include/linux/ext3_fs.h	Thu Nov  7 10:57:34 2002
+++ b/include/linux/ext3_fs.h	Thu Nov  7 10:57:34 2002
@@ -682,7 +682,7 @@
 extern int ext3_check_dir_entry(const char *, struct inode *,
 				struct ext3_dir_entry_2 *,
 				struct buffer_head *, unsigned long);
-extern void ext3_htree_store_dirent(struct file *dir_file, __u32 hash,
+extern int ext3_htree_store_dirent(struct file *dir_file, __u32 hash,
 				    __u32 minor_hash,
 				    struct ext3_dir_entry_2 *dirent);
 extern void ext3_htree_free_dir_info(struct dir_private_info *p);
# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
#
# namei.c |   21 ++++++++++++++++++++-
# 1 files changed, 20 insertions(+), 1 deletion(-)
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 02/11/07	tytso@snap.thunk.org	1.779
# Fix ext3 htree rename bug.
# 
# This fixes an ext3 htree bug pointed out by Christopher Li; if 
# adding the new name to the directory causes a split, this can cause
# the directory entry containing the old name to move to another 
# block, and then the removal of the old name will fail.
# --------------------------------------------
#
diff -Nru a/fs/ext3/namei.c b/fs/ext3/namei.c
--- a/fs/ext3/namei.c	Thu Nov  7 10:57:49 2002
+++ b/fs/ext3/namei.c	Thu Nov  7 10:57:49 2002
@@ -2173,7 +2173,26 @@
 	/*
 	 * ok, that's it
 	 */
-	ext3_delete_entry(handle, old_dir, old_de, old_bh);
+	retval = ext3_delete_entry(handle, old_dir, old_de, old_bh);
+	if (retval == -ENOENT) {
+		/*
+		 * old_de could have moved out from under us.
+		 */
+		struct buffer_head *old_bh2;
+		struct ext3_dir_entry_2 *old_de2;
+		
+		old_bh2 = ext3_find_entry(old_dentry, &old_de2);
+		if (old_bh2) {
+			retval = ext3_delete_entry(handle, old_dir,
+						   old_de2, old_bh2);
+			brelse(old_bh2);
+		}
+	}
+	if (retval) {
+		ext3_warning(old_dir->i_sb, "ext3_rename",
+				"Deleting old file (%lu), %d, error=%d",
+				old_dir->i_ino, old_dir->i_nlink, retval);
+	}
 
 	if (new_inode) {
 		new_inode->i_nlink--;
 Documentation/Configure.help  |   66 ++
 arch/alpha/defconfig          |    7 
 arch/alpha/kernel/entry.S     |   12 
 arch/arm/defconfig            |    7 
 arch/arm/kernel/calls.S       |   24 
 arch/i386/defconfig           |    7 
 arch/ia64/defconfig           |    7 
 arch/m68k/defconfig           |    7 
 arch/mips/defconfig           |    7 
 arch/mips64/defconfig         |    7 
 arch/ppc/defconfig            |   14 
 arch/ppc64/kernel/misc.S      |    2 
 arch/s390/defconfig           |    7 
 arch/s390/kernel/entry.S      |   24 
 arch/s390x/defconfig          |    7 
 arch/s390x/kernel/entry.S     |   24 
 arch/s390x/kernel/wrapper32.S |   92 +++
 arch/sparc/defconfig          |    7 
 arch/sparc/kernel/systbls.S   |   10 
 arch/sparc64/defconfig        |    7 
 arch/sparc64/kernel/systbls.S |   20 
 fs/Config.in                  |   14 
 fs/Makefile                   |    3 
 fs/ext2/Makefile              |    4 
 fs/ext2/file.c                |    5 
 fs/ext2/ialloc.c              |    2 
 fs/ext2/inode.c               |   34 -
 fs/ext2/namei.c               |   14 
 fs/ext2/super.c               |   29 
 fs/ext2/symlink.c             |   14 
 fs/ext2/xattr.c               | 1212 +++++++++++++++++++++++++++++++++++++++++
 fs/ext2/xattr_user.c          |  103 +++
 fs/ext3/Makefile              |    6 
 fs/ext3/file.c                |    5 
 fs/ext3/ialloc.c              |    2 
 fs/ext3/inode.c               |   35 -
 fs/ext3/namei.c               |   21 
 fs/ext3/super.c               |   33 +
 fs/ext3/symlink.c             |   14 
 fs/ext3/xattr.c               | 1232 ++++++++++++++++++++++++++++++++++++++++++
 fs/ext3/xattr_user.c          |  111 +++
 fs/jfs/jfs_xattr.h            |    6 
 fs/jfs/xattr.c                |    6 
 fs/mbcache.c                  |  648 ++++++++++++++++++++++
 include/asm-arm/unistd.h      |    2 
 include/asm-ppc64/unistd.h    |    2 
 include/asm-s390/unistd.h     |   15 
 include/asm-s390x/unistd.h    |   15 
 include/asm-sparc/unistd.h    |   24 
 include/asm-sparc64/unistd.h  |   24 
 include/linux/cache_def.h     |   15 
 include/linux/errno.h         |    4 
 include/linux/ext2_fs.h       |   31 -
 include/linux/ext2_xattr.h    |  157 +++++
 include/linux/ext3_fs.h       |   31 -
 include/linux/ext3_jbd.h      |    8 
 include/linux/ext3_xattr.h    |  157 +++++
 include/linux/fs.h            |    2 
 include/linux/mbcache.h       |   69 ++
 kernel/ksyms.c                |    4 
 mm/vmscan.c                   |   35 +
 61 files changed, 4336 insertions(+), 177 deletions(-)

--- linux-2.4.20-hp4_pnnl1/Documentation/Configure.help~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/Documentation/Configure.help	2003-04-09 17:20:57.000000000 -0600
@@ -15309,6 +15309,39 @@ CONFIG_EXT2_FS
   be compiled as a module, and so this could be dangerous.  Most
   everyone wants to say Y here.
 
+Ext2 extended attributes
+CONFIG_EXT2_FS_XATTR
+  Extended attributes are name:value pairs associated with inodes by
+  the kernel or by users (see the attr(5) manual page, or visit
+  <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+Ext2 extended attribute block sharing
+CONFIG_EXT2_FS_XATTR_SHARING
+  This options enables code for sharing identical extended attribute
+  blocks among multiple inodes.
+
+  Usually, say Y.
+
+Ext2 extended user attributes
+CONFIG_EXT2_FS_XATTR_USER
+  This option enables extended user attributes on ext2. Processes can
+  associate extended user attributes with inodes to store additional
+  information such as the character encoding of files, etc. (see the
+  attr(5) manual page, or visit <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+Ext2 trusted extended attributes
+CONFIG_EXT2_FS_XATTR_TRUSTED
+  This option enables extended attributes on ext2 that are accessible
+  (and visible) only to users capable of CAP_SYS_ADMIN. Usually this
+  is only the super user. Trusted extended attributes are meant for
+  implementing system/security services.
+
+  If unsure, say N.
+
 Ext3 journalling file system support (EXPERIMENTAL)
 CONFIG_EXT3_FS
   This is the journalling version of the Second extended file system
@@ -15341,6 +15374,39 @@ CONFIG_EXT3_FS
   of your root partition (the one containing the directory /) cannot
   be compiled as a module, and so this may be dangerous.
 
+Ext3 extended attributes
+CONFIG_EXT3_FS_XATTR
+  Extended attributes are name:value pairs associated with inodes by
+  the kernel or by users (see the attr(5) manual page, or visit
+  <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+Ext3 extended attribute block sharing
+CONFIG_EXT3_FS_XATTR_SHARING
+  This options enables code for sharing identical extended attribute
+  blocks among multiple inodes.
+
+  Usually, say Y.
+
+Ext3 extended user attributes
+CONFIG_EXT3_FS_XATTR_USER
+  This option enables extended user attributes on ext3. Processes can
+  associate extended user attributes with inodes to store additional
+  information such as the character encoding of files, etc. (see the
+  attr(5) manual page, or visit <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+Ext3 trusted extended attributes
+CONFIG_EXT3_FS_XATTR_TRUSTED
+  This option enables extended attributes on ext3 that are accessible
+  (and visible) only to users capable of CAP_SYS_ADMIN. Usually this
+  is only the super user. Trusted extended attributes are meant for
+  implementing system/security services.
+
+  If unsure, say N.
+
 Journal Block Device support (JBD for ext3) (EXPERIMENTAL)
 CONFIG_JBD
   This is a generic journalling layer for block devices.  It is
--- linux-2.4.20-hp4_pnnl1/arch/alpha/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/alpha/defconfig	2003-04-09 17:20:57.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 CONFIG_ALPHA=y
 # CONFIG_UID16 is not set
 # CONFIG_RWSEM_GENERIC_SPINLOCK is not set
--- linux-2.4.20-hp4_pnnl1/arch/alpha/kernel/entry.S~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/alpha/kernel/entry.S	2003-04-09 17:20:57.000000000 -0600
@@ -1154,6 +1154,18 @@ sys_call_table:
 	.quad sys_readahead
 	.quad sys_ni_syscall			/* 380, sys_security */
 	.quad sys_tkill
+	.quad sys_setxattr
+	.quad sys_lsetxattr
+	.quad sys_fsetxattr
+	.quad sys_getxattr			/* 385 */
+	.quad sys_lgetxattr
+	.quad sys_fgetxattr
+	.quad sys_listxattr
+	.quad sys_llistxattr
+	.quad sys_flistxattr			/* 390 */
+	.quad sys_removexattr
+	.quad sys_lremovexattr
+	.quad sys_fremovexattr
 
 /* Remember to update everything, kids.  */
 .ifne (. - sys_call_table) - (NR_SYSCALLS * 8)
--- linux-2.4.20-hp4_pnnl1/arch/arm/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/arm/defconfig	2003-04-09 17:20:57.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 CONFIG_ARM=y
 # CONFIG_EISA is not set
 # CONFIG_SBUS is not set
--- linux-2.4.20-hp4_pnnl1/arch/arm/kernel/calls.S~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/arm/kernel/calls.S	2003-04-09 17:20:57.000000000 -0600
@@ -240,18 +240,18 @@ __syscall_start:
 		.long	SYMBOL_NAME(sys_ni_syscall) /* Security */
 		.long	SYMBOL_NAME(sys_gettid)
 /* 225 */	.long	SYMBOL_NAME(sys_readahead)
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_setxattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_lsetxattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_fsetxattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_getxattr */
-/* 230 */	.long	SYMBOL_NAME(sys_ni_syscall) /* sys_lgetxattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_fgetxattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_listxattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_llistxattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_flistxattr */
-/* 235 */	.long	SYMBOL_NAME(sys_ni_syscall) /* sys_removexattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_lremovexattr */
-		.long	SYMBOL_NAME(sys_ni_syscall) /* sys_fremovexattr */
+		.long	SYMBOL_NAME(sys_setxattr)
+		.long	SYMBOL_NAME(sys_lsetxattr)
+		.long	SYMBOL_NAME(sys_fsetxattr)
+		.long	SYMBOL_NAME(sys_getxattr)
+/* 230 */	.long	SYMBOL_NAME(sys_lgetxattr)
+		.long	SYMBOL_NAME(sys_fgetxattr)
+		.long	SYMBOL_NAME(sys_listxattr)
+		.long	SYMBOL_NAME(sys_llistxattr)
+		.long	SYMBOL_NAME(sys_flistxattr)
+/* 235 */	.long	SYMBOL_NAME(sys_removexattr)
+		.long	SYMBOL_NAME(sys_lremovexattr)
+		.long	SYMBOL_NAME(sys_fremovexattr)
 		.long	SYMBOL_NAME(sys_tkill)
 		/*
 		 * Please check 2.5 _before_ adding calls here,
--- linux-2.4.20-hp4_pnnl1/arch/i386/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/i386/defconfig	2003-04-09 17:20:57.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 CONFIG_X86=y
 CONFIG_ISA=y
 # CONFIG_SBUS is not set
--- linux-2.4.20-hp4_pnnl1/arch/ia64/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/ia64/defconfig	2003-04-09 17:20:57.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 
 #
 # Code maturity level options
--- linux-2.4.20-hp4_pnnl1/arch/m68k/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/m68k/defconfig	2003-04-09 17:21:01.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 CONFIG_UID16=y
 
 #
--- linux-2.4.20-hp4_pnnl1/arch/mips/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/mips/defconfig	2003-04-09 17:21:01.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 CONFIG_MIPS=y
 CONFIG_MIPS32=y
 # CONFIG_MIPS64 is not set
--- linux-2.4.20-hp4_pnnl1/arch/mips64/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/mips64/defconfig	2003-04-09 17:21:01.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 CONFIG_MIPS=y
 # CONFIG_MIPS32 is not set
 CONFIG_MIPS64=y
--- linux-2.4.20-hp4_pnnl1/arch/ppc/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/ppc/defconfig	2003-04-09 17:21:01.000000000 -0600
@@ -1,6 +1,20 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 # CONFIG_UID16 is not set
 # CONFIG_RWSEM_GENERIC_SPINLOCK is not set
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
--- linux-2.4.20-hp4_pnnl1/arch/ppc64/kernel/misc.S~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/ppc64/kernel/misc.S	2003-04-09 17:21:01.000000000 -0600
@@ -731,6 +731,7 @@ _GLOBAL(sys_call_table32)
 	.llong .sys_gettid		/* 207 */
 #if 0 /* Reserved syscalls */
 	.llong .sys_tkill		/* 208 */
+#endif
 	.llong .sys_setxattr
 	.llong .sys_lsetxattr	/* 210 */
 	.llong .sys_fsetxattr
@@ -743,6 +744,7 @@ _GLOBAL(sys_call_table32)
 	.llong .sys_removexattr
 	.llong .sys_lremovexattr
 	.llong .sys_fremovexattr	/* 220 */
+#if 0 /* Reserved syscalls */
 	.llong .sys_futex
 #endif
 	.llong .sys_perfmonctl   /* Put this here for now ... */
--- linux-2.4.20-hp4_pnnl1/arch/s390/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/s390/defconfig	2003-04-09 17:21:01.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 # CONFIG_ISA is not set
 # CONFIG_EISA is not set
 # CONFIG_MCA is not set
--- linux-2.4.20-hp4_pnnl1/arch/s390/kernel/entry.S~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/s390/kernel/entry.S	2003-04-09 17:21:01.000000000 -0600
@@ -558,18 +558,18 @@ sys_call_table:
         .long  sys_fcntl64 
 	.long  sys_ni_syscall
 	.long  sys_ni_syscall
-	.long  sys_ni_syscall		 /* 224 - reserved for setxattr  */
-	.long  sys_ni_syscall            /* 225 - reserved for lsetxattr */
-	.long  sys_ni_syscall		 /* 226 - reserved for fsetxattr */
-	.long  sys_ni_syscall		 /* 227 - reserved for getxattr  */
-	.long  sys_ni_syscall		 /* 228 - reserved for lgetxattr */
-	.long  sys_ni_syscall		 /* 229 - reserved for fgetxattr */
-	.long  sys_ni_syscall		 /* 230 - reserved for listxattr */
-	.long  sys_ni_syscall		 /* 231 - reserved for llistxattr */
-	.long  sys_ni_syscall		 /* 232 - reserved for flistxattr */
-	.long  sys_ni_syscall		 /* 233 - reserved for removexattr */
-	.long  sys_ni_syscall		 /* 234 - reserved for lremovexattr */
-	.long  sys_ni_syscall		 /* 235 - reserved for fremovexattr */
+	.long  sys_setxattr
+	.long  sys_lsetxattr		/* 225 */
+	.long  sys_fsetxattr
+	.long  sys_getxattr
+	.long  sys_lgetxattr
+	.long  sys_fgetxattr
+	.long  sys_listxattr		/* 230 */
+	.long  sys_llistxattr
+	.long  sys_flistxattr
+	.long  sys_removexattr
+	.long  sys_lremovexattr
+	.long  sys_fremovexattr		/* 235 */
 	.long  sys_gettid
 	.long  sys_tkill
 	.rept  255-237
--- linux-2.4.20-hp4_pnnl1/arch/s390x/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/s390x/defconfig	2003-04-09 17:21:01.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 # CONFIG_ISA is not set
 # CONFIG_EISA is not set
 # CONFIG_MCA is not set
--- linux-2.4.20-hp4_pnnl1/arch/s390x/kernel/entry.S~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/s390x/kernel/entry.S	2003-04-09 17:21:01.000000000 -0600
@@ -591,18 +591,18 @@ sys_call_table:
 	.long  SYSCALL(sys_ni_syscall,sys32_fcntl64_wrapper)
 	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
 	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 224 - reserved for setxattr  */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 225 - reserved for lsetxattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 226 - reserved for fsetxattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 227 - reserved for getxattr  */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 228 - reserved for lgetxattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 229 - reserved for fgetxattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 230 - reserved for listxattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 231 - reserved for llistxattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 232 - reserved for flistxattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 233 - reserved for removexattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 234 - reserved for lremovexattr */
-	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 235 - reserved for fremovexattr */
+	.long  SYSCALL(sys_setxattr,sys32_setxattr_wrapper)
+	.long  SYSCALL(sys_lsetxattr,sys32_lsetxattr_wrapper)	/* 225 */
+	.long  SYSCALL(sys_fsetxattr,sys32_fsetxattr_wrapper)
+	.long  SYSCALL(sys_getxattr,sys32_getxattr_wrapper)
+	.long  SYSCALL(sys_lgetxattr,sys32_lgetxattr_wrapper)
+	.long  SYSCALL(sys_fgetxattr,sys32_fgetxattr_wrapper)
+	.long  SYSCALL(sys_listxattr,sys32_listxattr_wrapper)	/* 230 */
+	.long  SYSCALL(sys_llistxattr,sys32_llistxattr_wrapper)
+	.long  SYSCALL(sys_flistxattr,sys32_flistxattr_wrapper)
+	.long  SYSCALL(sys_removexattr,sys32_removexattr_wrapper)
+	.long  SYSCALL(sys_lremovexattr,sys32_lremovexattr_wrapper)
+	.long  SYSCALL(sys_fremovexattr,sys32_fremovexattr_wrapper)/* 235 */
 	.long  SYSCALL(sys_gettid,sys_gettid)
 	.long  SYSCALL(sys_tkill,sys_tkill)
 	.rept  255-237
--- linux-2.4.20-hp4_pnnl1/arch/s390x/kernel/wrapper32.S~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/s390x/kernel/wrapper32.S	2003-04-09 17:21:01.000000000 -0600
@@ -1091,3 +1091,95 @@ sys32_fstat64_wrapper:
 	llgtr	%r3,%r3			# struct stat64 *
 	llgfr	%r4,%r4			# long
 	jg	sys32_fstat64		# branch to system call
+
+	.globl	sys32_setxattr_wrapper
+sys32_setxattr_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# char *
+	llgtr	%r4,%r4			# void *
+	llgfr	%r5,%r5			# size_t
+	lgfr	%r6,%r6			# int
+	jg	sys_setxattr
+
+	.globl	sys32_lsetxattr_wrapper
+sys32_lsetxattr_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# char *
+	llgtr	%r4,%r4			# void *
+	llgfr	%r5,%r5			# size_t
+	lgfr	%r6,%r6			# int
+	jg	sys_lsetxattr
+
+	.globl	sys32_fsetxattr_wrapper
+sys32_fsetxattr_wrapper:
+	lgfr	%r2,%r2			# int
+	llgtr	%r3,%r3			# char *
+	llgtr	%r4,%r4			# void *
+	llgfr	%r5,%r5			# size_t
+	lgfr	%r6,%r6			# int
+	jg	sys_fsetxattr
+
+	.globl	sys32_getxattr_wrapper
+sys32_getxattr_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# char *
+	llgtr	%r4,%r4			# void *
+	llgfr	%r5,%r5			# size_t
+	jg	sys_getxattr
+
+	.globl	sys32_lgetxattr_wrapper
+sys32_lgetxattr_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# char *
+	llgtr	%r4,%r4			# void *
+	llgfr	%r5,%r5			# size_t
+	jg	sys_lgetxattr
+
+	.globl	sys32_fgetxattr_wrapper
+sys32_fgetxattr_wrapper:
+	lgfr	%r2,%r2			# int
+	llgtr	%r3,%r3			# char *
+	llgtr	%r4,%r4			# void *
+	llgfr	%r5,%r5			# size_t
+	jg	sys_fgetxattr
+
+	.globl	sys32_listxattr_wrapper
+sys32_listxattr_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# char *
+	llgfr	%r4,%r4			# size_t
+	jg	sys_listxattr
+
+	.globl	sys32_llistxattr_wrapper
+sys32_llistxattr_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# char *
+	llgfr	%r4,%r4			# size_t
+	jg	sys_llistxattr
+
+	.globl	sys32_flistxattr_wrapper
+sys32_flistxattr_wrapper:
+	lgfr	%r2,%r2			# int
+	llgtr	%r3,%r3			# char *
+	llgfr	%r4,%r4			# size_t
+	jg	sys_flistxattr
+
+	.globl	sys32_removexattr_wrapper
+sys32_removexattr_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# char *
+	jg	sys_removexattr
+
+	.globl	sys32_lremovexattr_wrapper
+sys32_lremovexattr_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# char *
+	jg	sys_lremovexattr
+
+	.globl	sys32_fremovexattr_wrapper
+sys32_fremovexattr_wrapper:
+	lgfr	%r2,%r2			# int
+	llgtr	%r3,%r3			# char *
+	jg	sys_fremovexattr
+
+
--- linux-2.4.20-hp4_pnnl1/arch/sparc/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/sparc/defconfig	2003-04-09 17:21:01.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 CONFIG_UID16=y
 CONFIG_HIGHMEM=y
 
--- linux-2.4.20-hp4_pnnl1/arch/sparc/kernel/systbls.S~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/sparc/kernel/systbls.S	2003-04-09 17:21:01.000000000 -0600
@@ -51,11 +51,11 @@ sys_call_table:
 /*150*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_poll, sys_getdents64
 /*155*/	.long sys_fcntl64, sys_nis_syscall, sys_statfs, sys_fstatfs, sys_oldumount
 /*160*/	.long sys_nis_syscall, sys_nis_syscall, sys_getdomainname, sys_setdomainname, sys_nis_syscall
-/*165*/	.long sys_quotactl, sys_nis_syscall, sys_mount, sys_ustat, sys_nis_syscall
-/*170*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_getdents
-/*175*/	.long sys_setsid, sys_fchdir, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
-/*180*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_sigpending, sys_query_module
-/*185*/	.long sys_setpgid, sys_nis_syscall, sys_tkill, sys_nis_syscall, sys_newuname
+/*165*/	.long sys_quotactl, sys_nis_syscall, sys_mount, sys_ustat, sys_setxattr
+/*170*/	.long sys_lsetxattr, sys_fsetxattr, sys_getxattr, sys_lgetxattr, sys_getdents
+/*175*/	.long sys_setsid, sys_fchdir, sys_fgetxattr, sys_listxattr, sys_llistxattr
+/*180*/	.long sys_flistxattr, sys_removexattr, sys_lremovexattr, sys_sigpending, sys_query_module
+/*185*/	.long sys_setpgid, sys_fremovexattr, sys_tkill, sys_nis_syscall, sys_newuname
 /*190*/	.long sys_init_module, sys_personality, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 /*195*/	.long sys_nis_syscall, sys_nis_syscall, sys_getppid, sparc_sigaction, sys_sgetmask
 /*200*/	.long sys_ssetmask, sys_sigsuspend, sys_newlstat, sys_uselib, old_readdir
--- linux-2.4.20-hp4_pnnl1/arch/sparc64/defconfig~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/sparc64/defconfig	2003-04-09 17:21:01.000000000 -0600
@@ -1,6 +1,13 @@
 #
 # Automatically generated make config: don't edit
 #
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT3_FS_XATTR_SHARING is not set
+# CONFIG_EXT3_FS_XATTR_USER is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XATTR_SHARING is not set
+# CONFIG_EXT2_FS_XATTR_USER is not set
+# CONFIG_FS_MBCACHE is not set
 
 #
 # Code maturity level options
--- linux-2.4.20-hp4_pnnl1/arch/sparc64/kernel/systbls.S~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/arch/sparc64/kernel/systbls.S	2003-04-09 17:21:01.000000000 -0600
@@ -52,11 +52,11 @@ sys_call_table32:
 /*150*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_poll, sys_getdents64
 	.word sys32_fcntl64, sys_nis_syscall, sys32_statfs, sys32_fstatfs, sys_oldumount
 /*160*/	.word sys_nis_syscall, sys_nis_syscall, sys_getdomainname, sys_setdomainname, sys_nis_syscall
-	.word sys32_quotactl, sys_nis_syscall, sys32_mount, sys_ustat, sys_nis_syscall
-/*170*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys32_getdents
-	.word sys_setsid, sys_fchdir, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
-/*180*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys32_sigpending, sys32_query_module
-	.word sys_setpgid, sys_nis_syscall, sys_tkill, sys_nis_syscall, sparc64_newuname
+	.word sys32_quotactl, sys_nis_syscall, sys32_mount, sys_ustat, sys_setxattr
+/*170*/	.word sys_lsetxattr, sys_fsetxattr, sys_getxattr, sys_lgetxattr, sys32_getdents
+	.word sys_setsid, sys_fchdir, sys_fgetxattr, sys_listxattr, sys_llistxattr
+/*180*/	.word sys_flistxattr, sys_removexattr, sys_lremovexattr, sys32_sigpending, sys32_query_module
+	.word sys_setpgid, sys_fremovexattr, sys_tkill, sys_nis_syscall, sparc64_newuname
 /*190*/	.word sys32_init_module, sparc64_personality, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 	.word sys_nis_syscall, sys_nis_syscall, sys_getppid, sys32_sigaction, sys_sgetmask
 /*200*/	.word sys_ssetmask, sys_sigsuspend, sys32_newlstat, sys_uselib, old32_readdir
@@ -111,11 +111,11 @@ sys_call_table:
 /*150*/	.word sys_getsockname, sys_nis_syscall, sys_nis_syscall, sys_poll, sys_getdents64
 	.word sys_nis_syscall, sys_nis_syscall, sys_statfs, sys_fstatfs, sys_oldumount
 /*160*/	.word sys_nis_syscall, sys_nis_syscall, sys_getdomainname, sys_setdomainname, sys_utrap_install
-	.word sys_quotactl, sys_nis_syscall, sys_mount, sys_ustat, sys_nis_syscall
-/*170*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_getdents
-	.word sys_setsid, sys_fchdir, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
-/*180*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_query_module
-	.word sys_setpgid, sys_nis_syscall, sys_tkill, sys_nis_syscall, sparc64_newuname
+	.word sys_quotactl, sys_nis_syscall, sys_mount, sys_ustat, sys_setxattr
+/*170*/	.word sys_lsetxattr, sys_fsetxattr, sys_getxattr, sys_lgetxattr, sys_getdents
+	.word sys_setsid, sys_fchdir, sys_fgetxattr, sys_listxattr, sys_llistxattr
+/*180*/	.word sys_flistxattr, sys_removexattr, sys_lremovexattr, sys_nis_syscall, sys_query_module
+	.word sys_setpgid, sys_fremovexattr, sys_tkill, sys_nis_syscall, sparc64_newuname
 /*190*/	.word sys_init_module, sparc64_personality, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
 	.word sys_nis_syscall, sys_nis_syscall, sys_getppid, sys_nis_syscall, sys_sgetmask
 /*200*/	.word sys_ssetmask, sys_nis_syscall, sys_newlstat, sys_uselib, sys_nis_syscall
--- linux-2.4.20-hp4_pnnl1/fs/Config.in~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/Config.in	2003-04-09 17:21:01.000000000 -0600
@@ -35,6 +35,11 @@ dep_mbool '  Debug Befs' CONFIG_BEFS_DEB
 dep_tristate 'BFS file system support (EXPERIMENTAL)' CONFIG_BFS_FS $CONFIG_EXPERIMENTAL
 
 tristate 'Ext3 journalling file system support' CONFIG_EXT3_FS
+dep_mbool '  Ext3 extended attributes' CONFIG_EXT3_FS_XATTR $CONFIG_EXT3_FS
+dep_bool '    Ext3 extended attribute block sharing' \
+    CONFIG_EXT3_FS_XATTR_SHARING $CONFIG_EXT3_FS_XATTR
+dep_bool '    Ext3 extended user attributes' \
+    CONFIG_EXT3_FS_XATTR_USER $CONFIG_EXT3_FS_XATTR
 # CONFIG_JBD could be its own option (even modular), but until there are
 # other users than ext3, we will simply make it be the same as CONFIG_EXT3_FS
 # dep_tristate '  Journal Block Device support (JBD for ext3)' CONFIG_JBD $CONFIG_EXT3_FS
@@ -98,6 +103,11 @@ dep_mbool '  QNX4FS write support (DANGE
 tristate 'ROM file system support' CONFIG_ROMFS_FS
 
 tristate 'Second extended fs support' CONFIG_EXT2_FS
+dep_mbool '  Ext2 extended attributes' CONFIG_EXT2_FS_XATTR $CONFIG_EXT2_FS
+dep_bool '    Ext2 extended attribute block sharing' \
+    CONFIG_EXT2_FS_XATTR_SHARING $CONFIG_EXT2_FS_XATTR
+dep_bool '    Ext2 extended user attributes' \
+    CONFIG_EXT2_FS_XATTR_USER $CONFIG_EXT2_FS_XATTR
 
 tristate 'System V/Xenix/V7/Coherent file system support' CONFIG_SYSV_FS
 
@@ -176,6 +186,10 @@ else
    define_tristate CONFIG_ZISOFS_FS n
 fi
 
+# Meta block cache for Extended Attributes (ext2/ext3)
+#tristate 'Meta block cache' CONFIG_FS_MBCACHE
+define_tristate CONFIG_FS_MBCACHE y
+
 mainmenu_option next_comment
 comment 'Partition Types'
 source fs/partitions/Config.in
--- linux-2.4.20-hp4_pnnl1/fs/Makefile~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/Makefile	2003-04-09 17:21:01.000000000 -0600
@@ -80,6 +80,9 @@ obj-y				+= binfmt_script.o
 
 obj-$(CONFIG_BINFMT_ELF)	+= binfmt_elf.o
 
+export-objs += mbcache.o
+obj-$(CONFIG_FS_MBCACHE)	+= mbcache.o
+
 # persistent filesystems
 obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
 
--- linux-2.4.20-hp4_pnnl1/fs/ext2/Makefile~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/Makefile	2003-04-09 17:21:01.000000000 -0600
@@ -13,4 +13,8 @@ obj-y    := balloc.o bitmap.o dir.o file
 		ioctl.o namei.o super.o symlink.o
 obj-m    := $(O_TARGET)
 
+export-objs += xattr.o
+obj-$(CONFIG_EXT2_FS_XATTR) += xattr.o
+obj-$(CONFIG_EXT2_FS_XATTR_USER) += xattr_user.o
+
 include $(TOPDIR)/Rules.make
--- linux-2.4.20-hp4_pnnl1/fs/ext2/file.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/file.c	2003-04-09 17:21:01.000000000 -0600
@@ -20,6 +20,7 @@
 
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 #include <linux/sched.h>
 
 /*
@@ -51,4 +52,8 @@ struct file_operations ext2_file_operati
 
 struct inode_operations ext2_file_inode_operations = {
 	truncate:	ext2_truncate,
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
 };
--- linux-2.4.20-hp4_pnnl1/fs/ext2/ialloc.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/ialloc.c	2003-04-09 17:21:01.000000000 -0600
@@ -15,6 +15,7 @@
 #include <linux/config.h>
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 #include <linux/locks.h>
 #include <linux/quotaops.h>
 
@@ -167,6 +168,7 @@ void ext2_free_inode (struct inode * ino
 	 */
 	if (!is_bad_inode(inode)) {
 		/* Quota is already initialized in iput() */
+		ext2_xattr_delete_inode(inode);
 	    	DQUOT_FREE_INODE(inode);
 		DQUOT_DROP(inode);
 	}
--- linux-2.4.20-hp4_pnnl1/fs/ext2/inode.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/inode.c	2003-04-09 17:21:01.000000000 -0600
@@ -39,6 +39,18 @@ MODULE_LICENSE("GPL");
 static int ext2_update_inode(struct inode * inode, int do_sync);
 
 /*
+ * Test whether an inode is a fast symlink.
+ */
+static inline int ext2_inode_is_fast_symlink(struct inode *inode)
+{
+	int ea_blocks = inode->u.ext2_i.i_file_acl ?
+		(inode->i_sb->s_blocksize >> 9) : 0;
+
+	return (S_ISLNK(inode->i_mode) &&
+		inode->i_blocks - ea_blocks == 0);
+}
+
+/*
  * Called at each iput()
  */
 void ext2_put_inode (struct inode * inode)
@@ -53,9 +65,7 @@ void ext2_delete_inode (struct inode * i
 {
 	lock_kernel();
 
-	if (is_bad_inode(inode) ||
-	    inode->i_ino == EXT2_ACL_IDX_INO ||
-	    inode->i_ino == EXT2_ACL_DATA_INO)
+	if (is_bad_inode(inode))
 		goto no_delete;
 	inode->u.ext2_i.i_dtime	= CURRENT_TIME;
 	mark_inode_dirty(inode);
@@ -801,6 +811,8 @@ void ext2_truncate (struct inode * inode
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode)))
 		return;
+	if (ext2_inode_is_fast_symlink(inode))
+		return;
 	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
 		return;
 
@@ -888,8 +900,7 @@ void ext2_read_inode (struct inode * ino
 	unsigned long offset;
 	struct ext2_group_desc * gdp;
 
-	if ((inode->i_ino != EXT2_ROOT_INO && inode->i_ino != EXT2_ACL_IDX_INO &&
-	     inode->i_ino != EXT2_ACL_DATA_INO &&
+	if ((inode->i_ino != EXT2_ROOT_INO &&
 	     inode->i_ino < EXT2_FIRST_INO(inode->i_sb)) ||
 	    inode->i_ino > le32_to_cpu(inode->i_sb->u.ext2_sb.s_es->s_inodes_count)) {
 		ext2_error (inode->i_sb, "ext2_read_inode",
@@ -974,10 +985,7 @@ void ext2_read_inode (struct inode * ino
 	for (block = 0; block < EXT2_N_BLOCKS; block++)
 		inode->u.ext2_i.i_data[block] = raw_inode->i_block[block];
 
-	if (inode->i_ino == EXT2_ACL_IDX_INO ||
-	    inode->i_ino == EXT2_ACL_DATA_INO)
-		/* Nothing to do */ ;
-	else if (S_ISREG(inode->i_mode)) {
+	if (S_ISREG(inode->i_mode)) {
 		inode->i_op = &ext2_file_inode_operations;
 		inode->i_fop = &ext2_file_operations;
 		inode->i_mapping->a_ops = &ext2_aops;
@@ -986,15 +994,17 @@ void ext2_read_inode (struct inode * ino
 		inode->i_fop = &ext2_dir_operations;
 		inode->i_mapping->a_ops = &ext2_aops;
 	} else if (S_ISLNK(inode->i_mode)) {
-		if (!inode->i_blocks)
+		if (ext2_inode_is_fast_symlink(inode))
 			inode->i_op = &ext2_fast_symlink_inode_operations;
 		else {
-			inode->i_op = &page_symlink_inode_operations;
+			inode->i_op = &ext2_symlink_inode_operations;
 			inode->i_mapping->a_ops = &ext2_aops;
 		}
-	} else 
+	} else {
+		inode->i_op = &ext2_special_inode_operations;
 		init_special_inode(inode, inode->i_mode,
 				   le32_to_cpu(raw_inode->i_block[0]));
+	}
 	brelse (bh);
 	inode->i_attr_flags = 0;
 	if (inode->u.ext2_i.i_flags & EXT2_SYNC_FL) {
--- linux-2.4.20-hp4_pnnl1/fs/ext2/namei.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/namei.c	2003-04-09 17:21:01.000000000 -0600
@@ -31,6 +31,7 @@
 
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 #include <linux/pagemap.h>
 
 /*
@@ -136,7 +137,7 @@ static int ext2_symlink (struct inode * 
 
 	if (l > sizeof (inode->u.ext2_i.i_data)) {
 		/* slow symlink */
-		inode->i_op = &page_symlink_inode_operations;
+		inode->i_op = &ext2_symlink_inode_operations;
 		inode->i_mapping->a_ops = &ext2_aops;
 		err = block_symlink(inode, symname, l);
 		if (err)
@@ -345,4 +346,15 @@ struct inode_operations ext2_dir_inode_o
 	rmdir:		ext2_rmdir,
 	mknod:		ext2_mknod,
 	rename:		ext2_rename,
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
+};
+
+struct inode_operations ext2_special_inode_operations = {
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
 };
--- linux-2.4.20-hp4_pnnl1/fs/ext2/super.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/super.c	2003-04-09 17:21:01.000000000 -0600
@@ -21,6 +21,7 @@
 #include <linux/string.h>
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/locks.h>
@@ -125,6 +126,7 @@ void ext2_put_super (struct super_block 
 	int db_count;
 	int i;
 
+	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = EXT2_SB(sb)->s_es;
 
@@ -175,6 +177,13 @@ static int parse_options (char * options
 	     this_char = strtok (NULL, ",")) {
 		if ((value = strchr (this_char, '=')) != NULL)
 			*value++ = 0;
+#ifdef CONFIG_EXT2_FS_XATTR_USER
+		if (!strcmp (this_char, "user_xattr"))
+			set_opt (*mount_options, XATTR_USER);
+		else if (!strcmp (this_char, "nouser_xattr"))
+			clear_opt (*mount_options, XATTR_USER);
+		else
+#endif
 		if (!strcmp (this_char, "bsddf"))
 			clear_opt (*mount_options, MINIX_DF);
 		else if (!strcmp (this_char, "nouid32")) {
@@ -424,6 +433,9 @@ struct super_block * ext2_read_super (st
 	    blocksize = BLOCK_SIZE;
 
 	sb->u.ext2_sb.s_mount_opt = 0;
+#ifdef CONFIG_EXT2_FS_XATTR_USER
+	/* set_opt (sb->u.ext2_sb.s_mount_opt, XATTR_USER); */
+#endif
 	if (!parse_options ((char *) data, &sb_block, &resuid, &resgid,
 	    &sb->u.ext2_sb.s_mount_opt)) {
 		return NULL;
@@ -813,12 +825,27 @@ static DECLARE_FSTYPE_DEV(ext2_fs_type, 
 
 static int __init init_ext2_fs(void)
 {
-        return register_filesystem(&ext2_fs_type);
+	int error = init_ext2_xattr();
+	if (error)
+		return error;
+	error = init_ext2_xattr_user();
+	if (error)
+		goto fail;
+	error = register_filesystem(&ext2_fs_type);
+	if (!error)
+		return 0;
+
+	exit_ext2_xattr_user();
+fail:
+	exit_ext2_xattr();
+	return error;
 }
 
 static void __exit exit_ext2_fs(void)
 {
 	unregister_filesystem(&ext2_fs_type);
+	exit_ext2_xattr_user();
+	exit_ext2_xattr();
 }
 
 EXPORT_NO_SYMBOLS;
--- linux-2.4.20-hp4_pnnl1/fs/ext2/symlink.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/symlink.c	2003-04-09 17:21:01.000000000 -0600
@@ -19,6 +19,7 @@
 
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 
 static int ext2_readlink(struct dentry *dentry, char *buffer, int buflen)
 {
@@ -32,7 +33,20 @@ static int ext2_follow_link(struct dentr
 	return vfs_follow_link(nd, s);
 }
 
+struct inode_operations ext2_symlink_inode_operations = {
+	readlink:	page_readlink,
+	follow_link:	page_follow_link,
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
+};
+
 struct inode_operations ext2_fast_symlink_inode_operations = {
 	readlink:	ext2_readlink,
 	follow_link:	ext2_follow_link,
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
 };
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/xattr.c	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,1212 @@
+/*
+ * linux/fs/ext2/xattr.c
+ *
+ * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ *
+ * Fix by Harrison Xing <harrison@mountainviewdata.com>.
+ * Extended attributes for symlinks and special files added per
+ *  suggestion of Luka Renko <luka.renko@hermes.si>.
+ */
+
+/*
+ * Extended attributes are stored on disk blocks allocated outside of
+ * any inode. The i_file_acl field is then made to point to this allocated
+ * block. If all extended attributes of an inode are identical, these
+ * inodes may share the same extended attribute block. Such situations
+ * are automatically detected by keeping a cache of recent attribute block
+ * numbers and hashes over the block's contents in memory.
+ *
+ *
+ * Extended attribute block layout:
+ *
+ *   +------------------+
+ *   | header           |
+ *   | entry 1          | |
+ *   | entry 2          | | growing downwards
+ *   | entry 3          | v
+ *   | four null bytes  |
+ *   | . . .            |
+ *   | value 1          | ^
+ *   | value 3          | | growing upwards
+ *   | value 2          | |
+ *   +------------------+
+ *
+ * The block header is followed by multiple entry descriptors. These entry
+ * descriptors are variable in size, and alligned to EXT2_XATTR_PAD
+ * byte boundaries. The entry descriptors are sorted by attribute name,
+ * so that two extended attribute blocks can be compared efficiently.
+ *
+ * Attribute values are aligned to the end of the block, stored in
+ * no specific order. They are also padded to EXT2_XATTR_PAD byte
+ * boundaries. No additional gaps are left between them.
+ *
+ * Locking strategy
+ * ----------------
+ * The VFS already holds the BKL and the inode->i_sem semaphore when any of
+ * the xattr inode operations are called, so we are guaranteed that only one
+ * processes accesses extended attributes of an inode at any time.
+ *
+ * For writing we also grab the ext2_xattr_sem semaphore. This ensures that
+ * only a single process is modifying an extended attribute block, even
+ * if the block is shared among inodes.
+ *
+ * Note for porting to 2.5
+ * -----------------------
+ * The BKL will no longer be held in the xattr inode operations.
+ */
+
+#include <linux/module.h>
+#include <linux/locks.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
+#include <linux/mbcache.h>
+#include <linux/quotaops.h>
+#include <asm/semaphore.h>
+#include <linux/compatmac.h>
+
+/* These symbols may be needed by a module. */
+EXPORT_SYMBOL(ext2_xattr_register);
+EXPORT_SYMBOL(ext2_xattr_unregister);
+EXPORT_SYMBOL(ext2_xattr_get);
+EXPORT_SYMBOL(ext2_xattr_list);
+EXPORT_SYMBOL(ext2_xattr_set);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+# define mark_buffer_dirty(bh) mark_buffer_dirty(bh, 1)
+#endif
+
+#define HDR(bh) ((struct ext2_xattr_header *)((bh)->b_data))
+#define ENTRY(ptr) ((struct ext2_xattr_entry *)(ptr))
+#define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)
+#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
+
+#ifdef EXT2_XATTR_DEBUG
+# define ea_idebug(inode, f...) do { \
+		printk(KERN_DEBUG "inode %s:%ld: ", \
+			kdevname(inode->i_dev), inode->i_ino); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+# define ea_bdebug(bh, f...) do { \
+		printk(KERN_DEBUG "block %s:%ld: ", \
+			kdevname(bh->b_dev), bh->b_blocknr); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+#else
+# define ea_idebug(f...)
+# define ea_bdebug(f...)
+#endif
+
+static int ext2_xattr_set2(struct inode *, struct buffer_head *,
+			   struct ext2_xattr_header *);
+
+#ifdef CONFIG_EXT2_FS_XATTR_SHARING
+
+static int ext2_xattr_cache_insert(struct buffer_head *);
+static struct buffer_head *ext2_xattr_cache_find(struct inode *,
+						 struct ext2_xattr_header *);
+static void ext2_xattr_cache_remove(struct buffer_head *);
+static void ext2_xattr_rehash(struct ext2_xattr_header *,
+			      struct ext2_xattr_entry *);
+
+static struct mb_cache *ext2_xattr_cache;
+
+#else
+# define ext2_xattr_cache_insert(bh) 0
+# define ext2_xattr_cache_find(inode, header) NULL
+# define ext2_xattr_cache_remove(bh) while(0) {}
+# define ext2_xattr_rehash(header, entry) while(0) {}
+#endif
+
+/*
+ * If a file system does not share extended attributes among inodes,
+ * we should not need the ext2_xattr_sem semaphore. However, the
+ * filesystem may still contain shared blocks, so we always take
+ * the lock.
+ */
+
+DECLARE_MUTEX(ext2_xattr_sem);
+
+static inline int
+ext2_xattr_new_block(struct inode *inode, int * errp, int force)
+{
+	struct super_block *sb = inode->i_sb;
+	int goal = le32_to_cpu(EXT2_SB(sb)->s_es->s_first_data_block) +
+		EXT2_I(inode)->i_block_group * EXT2_BLOCKS_PER_GROUP(sb);
+
+	/* How can we enforce the allocation? */
+	int block = ext2_new_block(inode, goal, 0, 0, errp);
+#ifdef OLD_QUOTAS
+	if (!*errp)
+		inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+#endif
+	return block;
+}
+
+static inline int
+ext2_xattr_quota_alloc(struct inode *inode, int force)
+{
+	/* How can we enforce the allocation? */
+#ifdef OLD_QUOTAS
+	int error = DQUOT_ALLOC_BLOCK(inode->i_sb, inode, 1);
+	if (!error)
+		inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+#else
+	int error = DQUOT_ALLOC_BLOCK(inode, 1);
+#endif
+	return error;
+}
+
+#ifdef OLD_QUOTAS
+
+static inline void
+ext2_xattr_quota_free(struct inode *inode)
+{
+	DQUOT_FREE_BLOCK(inode->i_sb, inode, 1);
+	inode->i_blocks -= inode->i_sb->s_blocksize >> 9;
+}
+
+static inline void
+ext2_xattr_free_block(struct inode * inode, unsigned long block)
+{
+	ext2_free_blocks(inode, block, 1);
+	inode->i_blocks -= inode->i_sb->s_blocksize >> 9;
+}
+
+#else
+# define ext2_xattr_quota_free(inode) \
+	DQUOT_FREE_BLOCK(inode, 1)
+# define ext2_xattr_free_block(inode, block) \
+	ext2_free_blocks(inode, block, 1)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
+
+static inline struct buffer_head *
+sb_bread(struct super_block *sb, int block)
+{
+	return bread(sb->s_dev, block, sb->s_blocksize);
+}
+
+static inline struct buffer_head *
+sb_getblk(struct super_block *sb, int block)
+{
+	return getblk(sb->s_dev, block, sb->s_blocksize);
+}
+
+#endif
+
+struct ext2_xattr_handler *ext2_xattr_handlers[EXT2_XATTR_INDEX_MAX];
+rwlock_t ext2_handler_lock = RW_LOCK_UNLOCKED;
+
+int
+ext2_xattr_register(int name_index, struct ext2_xattr_handler *handler)
+{
+	int error = -EINVAL;
+
+	if (name_index > 0 && name_index <= EXT2_XATTR_INDEX_MAX) {
+		write_lock(&ext2_handler_lock);
+		if (!ext2_xattr_handlers[name_index-1]) {
+			ext2_xattr_handlers[name_index-1] = handler;
+			error = 0;
+		}
+		write_unlock(&ext2_handler_lock);
+	}
+	return error;
+}
+
+void
+ext2_xattr_unregister(int name_index, struct ext2_xattr_handler *handler)
+{
+	if (name_index > 0 || name_index <= EXT2_XATTR_INDEX_MAX) {
+		write_lock(&ext2_handler_lock);
+		ext2_xattr_handlers[name_index-1] = NULL;
+		write_unlock(&ext2_handler_lock);
+	}
+}
+
+static inline const char *
+strcmp_prefix(const char *a, const char *a_prefix)
+{
+	while (*a_prefix && *a == *a_prefix) {
+		a++;
+		a_prefix++;
+	}
+	return *a_prefix ? NULL : a;
+}
+
+/*
+ * Decode the extended attribute name, and translate it into
+ * the name_index and name suffix.
+ */
+static struct ext2_xattr_handler *
+ext2_xattr_resolve_name(const char **name)
+{
+	struct ext2_xattr_handler *handler = NULL;
+	int i;
+
+	if (!*name)
+		return NULL;
+	read_lock(&ext2_handler_lock);
+	for (i=0; i<EXT2_XATTR_INDEX_MAX; i++) {
+		if (ext2_xattr_handlers[i]) {
+			const char *n = strcmp_prefix(*name,
+				ext2_xattr_handlers[i]->prefix);
+			if (n) {
+				handler = ext2_xattr_handlers[i];
+				*name = n;
+				break;
+			}
+		}
+	}
+	read_unlock(&ext2_handler_lock);
+	return handler;
+}
+
+static inline struct ext2_xattr_handler *
+ext2_xattr_handler(int name_index)
+{
+	struct ext2_xattr_handler *handler = NULL;
+	if (name_index > 0 && name_index <= EXT2_XATTR_INDEX_MAX) {
+		read_lock(&ext2_handler_lock);
+		handler = ext2_xattr_handlers[name_index-1];
+		read_unlock(&ext2_handler_lock);
+	}
+	return handler;
+}
+
+/*
+ * Inode operation getxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+ext2_getxattr(struct dentry *dentry, const char *name,
+	      void *buffer, size_t size)
+{
+	struct ext2_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = ext2_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->get(inode, name, buffer, size);
+}
+
+/*
+ * Inode operation listxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+ext2_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+	return ext2_xattr_list(dentry->d_inode, buffer, size);
+}
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+ext2_setxattr(struct dentry *dentry, const char *name,
+	      const void *value, size_t size, int flags)
+{
+	struct ext2_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	if (size == 0)
+		value = "";  /* empty EA, do not remove */
+	handler = ext2_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->set(inode, name, value, size, flags);
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+ext2_removexattr(struct dentry *dentry, const char *name)
+{
+	struct ext2_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = ext2_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->set(inode, name, NULL, 0, XATTR_REPLACE);
+}
+
+/*
+ * ext2_xattr_get()
+ *
+ * Copy an extended attribute into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+ext2_xattr_get(struct inode *inode, int name_index, const char *name,
+	       void *buffer, size_t buffer_size)
+{
+	struct buffer_head *bh = NULL;
+	struct ext2_xattr_entry *entry;
+	unsigned int block, size;
+	char *end;
+	int name_len, error;
+
+	ea_idebug(inode, "name=%d.%s, buffer=%p, buffer_size=%ld",
+		  name_index, name, buffer, (long)buffer_size);
+
+	if (name == NULL)
+		return -EINVAL;
+	if (!EXT2_I(inode)->i_file_acl)
+		return -ENOATTR;
+	block = EXT2_I(inode)->i_file_acl;
+	ea_idebug(inode, "reading block %d", block);
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		return -EIO;
+	ea_bdebug(bh, "b_count=%d, refcount=%d",
+		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
+	end = bh->b_data + bh->b_size;
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+bad_block:	ext2_error(inode->i_sb, "ext2_xattr_get",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* find named attribute */
+	name_len = strlen(name);
+
+	error = -ERANGE;
+	if (name_len > 255)
+		goto cleanup;
+	entry = FIRST_ENTRY(bh);
+	while (!IS_LAST_ENTRY(entry)) {
+		struct ext2_xattr_entry *next =
+			EXT2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		if (name_index == entry->e_name_index &&
+		    name_len == entry->e_name_len &&
+		    memcmp(name, entry->e_name, name_len) == 0)
+			goto found;
+		entry = next;
+	}
+	/* Check the remaining name entries */
+	while (!IS_LAST_ENTRY(entry)) {
+		struct ext2_xattr_entry *next =
+			EXT2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		entry = next;
+	}
+	if (ext2_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	error = -ENOATTR;
+	goto cleanup;
+found:
+	/* check the buffer size */
+	if (entry->e_value_block != 0)
+		goto bad_block;
+	size = le32_to_cpu(entry->e_value_size);
+	if (size > inode->i_sb->s_blocksize ||
+	    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)
+		goto bad_block;
+
+	if (ext2_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	if (buffer) {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+		/* return value of attribute */
+		memcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),
+			size);
+	}
+	error = size;
+
+cleanup:
+	brelse(bh);
+
+	return error;
+}
+
+/*
+ * ext2_xattr_list()
+ *
+ * Copy a list of attribute names into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+ext2_xattr_list(struct inode *inode, char *buffer, size_t buffer_size)
+{
+	struct buffer_head *bh = NULL;
+	struct ext2_xattr_entry *entry;
+	unsigned int block, size = 0;
+	char *buf, *end;
+	int error;
+
+	ea_idebug(inode, "buffer=%p, buffer_size=%ld",
+		  buffer, (long)buffer_size);
+
+	if (!EXT2_I(inode)->i_file_acl)
+		return 0;
+	block = EXT2_I(inode)->i_file_acl;
+	ea_idebug(inode, "reading block %d", block);
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		return -EIO;
+	ea_bdebug(bh, "b_count=%d, refcount=%d",
+		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
+	end = bh->b_data + bh->b_size;
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+bad_block:	ext2_error(inode->i_sb, "ext2_xattr_list",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* compute the size required for the list of attribute names */
+	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
+	     entry = EXT2_XATTR_NEXT(entry)) {
+		struct ext2_xattr_handler *handler;
+		struct ext2_xattr_entry *next =
+			EXT2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+
+		handler = ext2_xattr_handler(entry->e_name_index);
+		if (handler)
+			size += handler->list(NULL, inode, entry->e_name,
+					      entry->e_name_len);
+	}
+
+	if (ext2_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	if (!buffer) {
+		error = size;
+		goto cleanup;
+	} else {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+	}
+
+	/* list the attribute names */
+	buf = buffer;
+	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
+	     entry = EXT2_XATTR_NEXT(entry)) {
+		struct ext2_xattr_handler *handler;
+		
+		handler = ext2_xattr_handler(entry->e_name_index);
+		if (handler)
+			buf += handler->list(buf, inode, entry->e_name,
+					     entry->e_name_len);
+	}
+	error = size;
+
+cleanup:
+	brelse(bh);
+
+	return error;
+}
+
+/*
+ * If the EXT2_FEATURE_COMPAT_EXT_ATTR feature of this file system is
+ * not set, set it.
+ */
+static void ext2_xattr_update_super_block(struct super_block *sb)
+{
+	if (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))
+		return;
+
+	lock_super(sb);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	EXT2_SB(sb)->s_feature_compat |= EXT2_FEATURE_COMPAT_EXT_ATTR;
+#endif
+	EXT2_SB(sb)->s_es->s_feature_compat |=
+		cpu_to_le32(EXT2_FEATURE_COMPAT_EXT_ATTR);
+	sb->s_dirt = 1;
+	mark_buffer_dirty(EXT2_SB(sb)->s_sbh);
+	unlock_super(sb);
+}
+
+/*
+ * ext2_xattr_set()
+ *
+ * Create, replace or remove an extended attribute for this inode. Buffer
+ * is NULL to remove an existing extended attribute, and non-NULL to
+ * either replace an existing extended attribute, or create a new extended
+ * attribute. The flags XATTR_REPLACE and XATTR_CREATE
+ * specify that an extended attribute must exist and must not exist
+ * previous to the call, respectively.
+ *
+ * Returns 0, or a negative error number on failure.
+ */
+int
+ext2_xattr_set(struct inode *inode, int name_index, const char *name,
+	       const void *value, size_t value_len, int flags)
+{
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *bh = NULL;
+	struct ext2_xattr_header *header = NULL;
+	struct ext2_xattr_entry *here, *last;
+	unsigned int name_len;
+	int block = EXT2_I(inode)->i_file_acl;
+	int min_offs = sb->s_blocksize, not_found = 1, free, error;
+	char *end;
+	
+	/*
+	 * header -- Points either into bh, or to a temporarily
+	 *           allocated buffer.
+	 * here -- The named entry found, or the place for inserting, within
+	 *         the block pointed to by header.
+	 * last -- Points right after the last named entry within the block
+	 *         pointed to by header.
+	 * min_offs -- The offset of the first value (values are aligned
+	 *             towards the end of the block).
+	 * end -- Points right after the block pointed to by header.
+	 */
+	
+	ea_idebug(inode, "name=%d.%s, value=%p, value_len=%ld",
+		  name_index, name, value, (long)value_len);
+
+	if (IS_RDONLY(inode))
+		return -EROFS;
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		return -EPERM;
+	if (value == NULL)
+		value_len = 0;
+	if (name == NULL)
+		return -EINVAL;
+	name_len = strlen(name);
+	if (name_len > 255 || value_len > sb->s_blocksize)
+		return -ERANGE;
+	down(&ext2_xattr_sem);
+
+	if (block) {
+		/* The inode already has an extended attribute block. */
+
+		bh = sb_bread(sb, block);
+		error = -EIO;
+		if (!bh)
+			goto cleanup;
+		ea_bdebug(bh, "b_count=%d, refcount=%d",
+			atomic_read(&(bh->b_count)),
+			le32_to_cpu(HDR(bh)->h_refcount));
+		header = HDR(bh);
+		end = bh->b_data + bh->b_size;
+		if (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
+		    header->h_blocks != cpu_to_le32(1)) {
+bad_block:		ext2_error(sb, "ext2_xattr_set",
+				"inode %ld: bad block %d", inode->i_ino, block);
+			error = -EIO;
+			goto cleanup;
+		}
+		/* Find the named attribute. */
+		here = FIRST_ENTRY(bh);
+		while (!IS_LAST_ENTRY(here)) {
+			struct ext2_xattr_entry *next = EXT2_XATTR_NEXT(here);
+			if ((char *)next >= end)
+				goto bad_block;
+			if (!here->e_value_block && here->e_value_size) {
+				int offs = le16_to_cpu(here->e_value_offs);
+				if (offs < min_offs)
+					min_offs = offs;
+			}
+			not_found = name_index - here->e_name_index;
+			if (!not_found)
+				not_found = name_len - here->e_name_len;
+			if (!not_found)
+				not_found = memcmp(name, here->e_name,name_len);
+			if (not_found <= 0)
+				break;
+			here = next;
+		}
+		last = here;
+		/* We still need to compute min_offs and last. */
+		while (!IS_LAST_ENTRY(last)) {
+			struct ext2_xattr_entry *next = EXT2_XATTR_NEXT(last);
+			if ((char *)next >= end)
+				goto bad_block;
+			if (!last->e_value_block && last->e_value_size) {
+				int offs = le16_to_cpu(last->e_value_offs);
+				if (offs < min_offs)
+					min_offs = offs;
+			}
+			last = next;
+		}
+
+		/* Check whether we have enough space left. */
+		free = min_offs - ((char*)last - (char*)header) - sizeof(__u32);
+	} else {
+		/* We will use a new extended attribute block. */
+		free = sb->s_blocksize -
+			sizeof(struct ext2_xattr_header) - sizeof(__u32);
+		here = last = NULL;  /* avoid gcc uninitialized warning. */
+	}
+
+	if (not_found) {
+		/* Request to remove a nonexistent attribute? */
+		error = -ENOATTR;
+		if (flags & XATTR_REPLACE)
+			goto cleanup;
+		error = 0;
+		if (value == NULL)
+			goto cleanup;
+		else
+			free -= EXT2_XATTR_LEN(name_len);
+	} else {
+		/* Request to create an existing attribute? */
+		error = -EEXIST;
+		if (flags & XATTR_CREATE)
+			goto cleanup;
+		if (!here->e_value_block && here->e_value_size) {
+			unsigned int size = le32_to_cpu(here->e_value_size);
+
+			if (le16_to_cpu(here->e_value_offs) + size > 
+			    sb->s_blocksize || size > sb->s_blocksize)
+				goto bad_block;
+			free += EXT2_XATTR_SIZE(size);
+		}
+	}
+	free -= EXT2_XATTR_SIZE(value_len);
+	error = -ENOSPC;
+	if (free < 0)
+		goto cleanup;
+
+	/* Here we know that we can set the new attribute. */
+
+	if (header) {
+		if (header->h_refcount == cpu_to_le32(1)) {
+			ea_bdebug(bh, "modifying in-place");
+			ext2_xattr_cache_remove(bh);
+		} else {
+			int offset;
+
+			ea_bdebug(bh, "cloning");
+			header = kmalloc(bh->b_size, GFP_KERNEL);
+			error = -ENOMEM;
+			if (header == NULL)
+				goto cleanup;
+			memcpy(header, HDR(bh), bh->b_size);
+			header->h_refcount = cpu_to_le32(1);
+			offset = (char *)header - bh->b_data;
+			here = ENTRY((char *)here + offset);
+			last = ENTRY((char *)last + offset);
+		}
+	} else {
+		/* Allocate a buffer where we construct the new block. */
+		header = kmalloc(sb->s_blocksize, GFP_KERNEL);
+		error = -ENOMEM;
+		if (header == NULL)
+			goto cleanup;
+		memset(header, 0, sb->s_blocksize);
+		end = (char *)header + sb->s_blocksize;
+		header->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);
+		header->h_blocks = header->h_refcount = cpu_to_le32(1);
+		last = here = ENTRY(header+1);
+	}
+
+	if (not_found) {
+		/* Insert the new name. */
+		int size = EXT2_XATTR_LEN(name_len);
+		int rest = (char *)last - (char *)here;
+		memmove((char *)here + size, here, rest);
+		memset(here, 0, size);
+		here->e_name_index = name_index;
+		here->e_name_len = name_len;
+		memcpy(here->e_name, name, name_len);
+	} else {
+		/* Remove the old value. */
+		if (!here->e_value_block && here->e_value_size) {
+			char *first_val = (char *)header + min_offs;
+			int offs = le16_to_cpu(here->e_value_offs);
+			char *val = (char *)header + offs;
+			size_t size = EXT2_XATTR_SIZE(
+				le32_to_cpu(here->e_value_size));
+			memmove(first_val + size, first_val, val - first_val);
+			memset(first_val, 0, size);
+			here->e_value_offs = 0;
+			min_offs += size;
+
+			/* Adjust all value offsets. */
+			last = ENTRY(header+1);
+			while (!IS_LAST_ENTRY(last)) {
+				int o = le16_to_cpu(last->e_value_offs);
+				if (!last->e_value_block && o < offs)
+					last->e_value_offs =
+						cpu_to_le16(o + size);
+				last = EXT2_XATTR_NEXT(last);
+			}
+		}
+		if (value == NULL) {
+			/* Remove this attribute. */
+			if (EXT2_XATTR_NEXT(ENTRY(header+1)) == last) {
+				/* This block is now empty. */
+				error = ext2_xattr_set2(inode, bh, NULL);
+				goto cleanup;
+			} else {
+				/* Remove the old name. */
+				int size = EXT2_XATTR_LEN(name_len);
+				last = ENTRY((char *)last - size);
+				memmove(here, (char*)here + size,
+					(char*)last - (char*)here);
+				memset(last, 0, size);
+			}
+		}
+	}
+
+	if (value != NULL) {
+		/* Insert the new value. */
+		here->e_value_size = cpu_to_le32(value_len);
+		if (value_len) {
+			size_t size = EXT2_XATTR_SIZE(value_len);
+			char *val = (char *)header + min_offs - size;
+			here->e_value_offs =
+				cpu_to_le16((char *)val - (char *)header);
+			memset(val + size - EXT2_XATTR_PAD, 0,
+			       EXT2_XATTR_PAD); /* Clear the pad bytes. */
+			memcpy(val, value, value_len);
+		}
+	}
+	ext2_xattr_rehash(header, here);
+
+	error = ext2_xattr_set2(inode, bh, header);
+
+cleanup:
+	brelse(bh);
+	if (!(bh && header == HDR(bh)))
+		kfree(header);
+	up(&ext2_xattr_sem);
+
+	return error;
+}
+
+/*
+ * Second half of ext2_xattr_set(): Update the file system.
+ */
+static int
+ext2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,
+		struct ext2_xattr_header *header)
+{
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *new_bh = NULL;
+	int error;
+
+	if (header) {
+		new_bh = ext2_xattr_cache_find(inode, header);
+		if (new_bh) {
+			/*
+			 * We found an identical block in the cache.
+			 * The old block will be released after updating
+			 * the inode.
+			 */
+			ea_bdebug(old_bh, "reusing block %ld",
+				new_bh->b_blocknr);
+			
+			error = -EDQUOT;
+			if (ext2_xattr_quota_alloc(inode, 1))
+				goto cleanup;
+			
+			HDR(new_bh)->h_refcount = cpu_to_le32(
+				le32_to_cpu(HDR(new_bh)->h_refcount) + 1);
+			ea_bdebug(new_bh, "refcount now=%d",
+				le32_to_cpu(HDR(new_bh)->h_refcount));
+		} else if (old_bh && header == HDR(old_bh)) {
+			/* Keep this block. */
+			new_bh = old_bh;
+			ext2_xattr_cache_insert(new_bh);
+		} else {
+			/* We need to allocate a new block */
+			int force = EXT2_I(inode)->i_file_acl != 0;
+			int block = ext2_xattr_new_block(inode, &error, force);
+			if (error)
+				goto cleanup;
+			ea_idebug(inode, "creating block %d", block);
+
+			new_bh = sb_getblk(sb, block);
+			if (!new_bh) {
+				ext2_xattr_free_block(inode, block);
+				error = -EIO;
+				goto cleanup;
+			}
+			lock_buffer(new_bh);
+			memcpy(new_bh->b_data, header, new_bh->b_size);
+			mark_buffer_uptodate(new_bh, 1);
+			unlock_buffer(new_bh);
+			ext2_xattr_cache_insert(new_bh);
+			
+			ext2_xattr_update_super_block(sb);
+		}
+		mark_buffer_dirty(new_bh);
+		if (IS_SYNC(inode)) {
+			ll_rw_block(WRITE, 1, &new_bh);
+			wait_on_buffer(new_bh); 
+			error = -EIO;
+			if (buffer_req(new_bh) && !buffer_uptodate(new_bh))
+				goto cleanup;
+		}
+	}
+
+	/* Update the inode. */
+	EXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;
+	inode->i_ctime = CURRENT_TIME;
+	if (IS_SYNC(inode)) {
+		error = ext2_sync_inode (inode);
+		if (error)
+			goto cleanup;
+	} else
+		mark_inode_dirty(inode);
+
+	error = 0;
+	if (old_bh && old_bh != new_bh) {
+		/*
+		 * If there was an old block, and we are not still using it,
+		 * we now release the old block.
+		*/
+		unsigned int refcount = le32_to_cpu(HDR(old_bh)->h_refcount);
+
+		if (refcount == 1) {
+			/* Free the old block. */
+			ea_bdebug(old_bh, "freeing");
+			ext2_xattr_free_block(inode, old_bh->b_blocknr);
+			mark_buffer_clean(old_bh);
+		} else {
+			/* Decrement the refcount only. */
+			refcount--;
+			HDR(old_bh)->h_refcount = cpu_to_le32(refcount);
+			ext2_xattr_quota_free(inode);
+			mark_buffer_dirty(old_bh);
+			ea_bdebug(old_bh, "refcount now=%d", refcount);
+		}
+	}
+
+cleanup:
+	if (old_bh != new_bh)
+		brelse(new_bh);
+
+	return error;
+}
+
+/*
+ * ext2_xattr_delete_inode()
+ *
+ * Free extended attribute resources associated with this inode. This
+ * is called immediately before an inode is freed.
+ */
+void
+ext2_xattr_delete_inode(struct inode *inode)
+{
+	struct buffer_head *bh;
+	unsigned int block = EXT2_I(inode)->i_file_acl;
+
+	if (!block)
+		return;
+	down(&ext2_xattr_sem);
+
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh) {
+		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
+			"inode %ld: block %d read error", inode->i_ino, block);
+		goto cleanup;
+	}
+	ea_bdebug(bh, "b_count=%d", atomic_read(&(bh->b_count)));
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		goto cleanup;
+	}
+	ea_bdebug(bh, "refcount now=%d", le32_to_cpu(HDR(bh)->h_refcount) - 1);
+	if (HDR(bh)->h_refcount == cpu_to_le32(1)) {
+		ext2_xattr_cache_remove(bh);
+		ext2_xattr_free_block(inode, block);
+		bforget(bh);
+		bh = NULL;
+	} else {
+		HDR(bh)->h_refcount = cpu_to_le32(
+			le32_to_cpu(HDR(bh)->h_refcount) - 1);
+		mark_buffer_dirty(bh);
+		if (IS_SYNC(inode)) {
+			ll_rw_block(WRITE, 1, &bh);
+			wait_on_buffer(bh);
+		}
+		ext2_xattr_quota_free(inode);
+	}
+	EXT2_I(inode)->i_file_acl = 0;
+
+cleanup:
+	brelse(bh);
+	up(&ext2_xattr_sem);
+}
+
+/*
+ * ext2_xattr_put_super()
+ *
+ * This is called when a file system is unmounted.
+ */
+void
+ext2_xattr_put_super(struct super_block *sb)
+{
+#ifdef CONFIG_EXT2_FS_XATTR_SHARING
+	mb_cache_shrink(ext2_xattr_cache, sb->s_dev);
+#endif
+}
+
+#ifdef CONFIG_EXT2_FS_XATTR_SHARING
+
+/*
+ * ext2_xattr_cache_insert()
+ *
+ * Create a new entry in the extended attribute cache, and insert
+ * it unless such an entry is already in the cache.
+ *
+ * Returns 0, or a negative error number on failure.
+ */
+static int
+ext2_xattr_cache_insert(struct buffer_head *bh)
+{
+	__u32 hash = le32_to_cpu(HDR(bh)->h_hash);
+	struct mb_cache_entry *ce;
+	int error;
+
+	ce = mb_cache_entry_alloc(ext2_xattr_cache);
+	if (!ce)
+		return -ENOMEM;
+	error = mb_cache_entry_insert(ce, bh->b_dev, bh->b_blocknr, &hash);
+	if (error) {
+		mb_cache_entry_free(ce);
+		if (error == -EBUSY) {
+			ea_bdebug(bh, "already in cache (%d cache entries)",
+				atomic_read(&ext2_xattr_cache->c_entry_count));
+			error = 0;
+		}
+	} else {
+		ea_bdebug(bh, "inserting [%x] (%d cache entries)", (int)hash,
+			  atomic_read(&ext2_xattr_cache->c_entry_count));
+		mb_cache_entry_release(ce);
+	}
+	return error;
+}
+
+/*
+ * ext2_xattr_cmp()
+ *
+ * Compare two extended attribute blocks for equality.
+ *
+ * Returns 0 if the blocks are equal, 1 if they differ, and
+ * a negative error number on errors.
+ */
+static int
+ext2_xattr_cmp(struct ext2_xattr_header *header1,
+	       struct ext2_xattr_header *header2)
+{
+	struct ext2_xattr_entry *entry1, *entry2;
+
+	entry1 = ENTRY(header1+1);
+	entry2 = ENTRY(header2+1);
+	while (!IS_LAST_ENTRY(entry1)) {
+		if (IS_LAST_ENTRY(entry2))
+			return 1;
+		if (entry1->e_hash != entry2->e_hash ||
+		    entry1->e_name_len != entry2->e_name_len ||
+		    entry1->e_value_size != entry2->e_value_size ||
+		    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))
+			return 1;
+		if (entry1->e_value_block != 0 || entry2->e_value_block != 0)
+			return -EIO;
+		if (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),
+			   (char *)header2 + le16_to_cpu(entry2->e_value_offs),
+			   le32_to_cpu(entry1->e_value_size)))
+			return 1;
+
+		entry1 = EXT2_XATTR_NEXT(entry1);
+		entry2 = EXT2_XATTR_NEXT(entry2);
+	}
+	if (!IS_LAST_ENTRY(entry2))
+		return 1;
+	return 0;
+}
+
+/*
+ * ext2_xattr_cache_find()
+ *
+ * Find an identical extended attribute block.
+ *
+ * Returns a pointer to the block found, or NULL if such a block was
+ * not found or an error occurred.
+ */
+static struct buffer_head *
+ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)
+{
+	__u32 hash = le32_to_cpu(header->h_hash);
+	struct mb_cache_entry *ce;
+
+	if (!header->h_hash)
+		return NULL;  /* never share */
+	ea_idebug(inode, "looking for cached blocks [%x]", (int)hash);
+	ce = mb_cache_entry_find_first(ext2_xattr_cache, 0, inode->i_dev, hash);
+	while (ce) {
+		struct buffer_head *bh = sb_bread(inode->i_sb, ce->e_block);
+
+		if (!bh) {
+			ext2_error(inode->i_sb, "ext2_xattr_cache_find",
+				"inode %ld: block %ld read error",
+				inode->i_ino, ce->e_block);
+		} else if (le32_to_cpu(HDR(bh)->h_refcount) >
+			   EXT2_XATTR_REFCOUNT_MAX) {
+			ea_idebug(inode, "block %ld refcount %d>%d",ce->e_block,
+				le32_to_cpu(HDR(bh)->h_refcount),
+				EXT2_XATTR_REFCOUNT_MAX);
+		} else if (!ext2_xattr_cmp(header, HDR(bh))) {
+			ea_bdebug(bh, "b_count=%d",atomic_read(&(bh->b_count)));
+			mb_cache_entry_release(ce);
+			return bh;
+		}
+		brelse(bh);
+		ce = mb_cache_entry_find_next(ce, 0, inode->i_dev, hash);
+	}
+	return NULL;
+}
+
+/*
+ * ext2_xattr_cache_remove()
+ *
+ * Remove the cache entry of a block from the cache. Called when a
+ * block becomes invalid.
+ */
+static void
+ext2_xattr_cache_remove(struct buffer_head *bh)
+{
+	struct mb_cache_entry *ce;
+
+	ce = mb_cache_entry_get(ext2_xattr_cache, bh->b_dev, bh->b_blocknr);
+	if (ce) {
+		ea_bdebug(bh, "removing (%d cache entries remaining)",
+			  atomic_read(&ext2_xattr_cache->c_entry_count)-1);
+		mb_cache_entry_free(ce);
+	} else 
+		ea_bdebug(bh, "no cache entry");
+}
+
+#define NAME_HASH_SHIFT 5
+#define VALUE_HASH_SHIFT 16
+
+/*
+ * ext2_xattr_hash_entry()
+ *
+ * Compute the hash of an extended attribute.
+ */
+static inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,
+					 struct ext2_xattr_entry *entry)
+{
+	__u32 hash = 0;
+	char *name = entry->e_name;
+	int n;
+
+	for (n=0; n < entry->e_name_len; n++) {
+		hash = (hash << NAME_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^
+		       *name++;
+	}
+
+	if (entry->e_value_block == 0 && entry->e_value_size != 0) {
+		__u32 *value = (__u32 *)((char *)header +
+			le16_to_cpu(entry->e_value_offs));
+		for (n = (le32_to_cpu(entry->e_value_size) +
+		     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {
+			hash = (hash << VALUE_HASH_SHIFT) ^
+			       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^
+			       le32_to_cpu(*value++);
+		}
+	}
+	entry->e_hash = cpu_to_le32(hash);
+}
+
+#undef NAME_HASH_SHIFT
+#undef VALUE_HASH_SHIFT
+
+#define BLOCK_HASH_SHIFT 16
+
+/*
+ * ext2_xattr_rehash()
+ *
+ * Re-compute the extended attribute hash value after an entry has changed.
+ */
+static void ext2_xattr_rehash(struct ext2_xattr_header *header,
+			      struct ext2_xattr_entry *entry)
+{
+	struct ext2_xattr_entry *here;
+	__u32 hash = 0;
+	
+	ext2_xattr_hash_entry(header, entry);
+	here = ENTRY(header+1);
+	while (!IS_LAST_ENTRY(here)) {
+		if (!here->e_hash) {
+			/* Block is not shared if an entry's hash value == 0 */
+			hash = 0;
+			break;
+		}
+		hash = (hash << BLOCK_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^
+		       le32_to_cpu(here->e_hash);
+		here = EXT2_XATTR_NEXT(here);
+	}
+	header->h_hash = cpu_to_le32(hash);
+}
+
+#undef BLOCK_HASH_SHIFT
+
+int __init
+init_ext2_xattr(void)
+{
+	ext2_xattr_cache = mb_cache_create("ext2_xattr", NULL,
+		sizeof(struct mb_cache_entry) +
+		sizeof(struct mb_cache_entry_index), 1, 61);
+	if (!ext2_xattr_cache)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void
+exit_ext2_xattr(void)
+{
+	mb_cache_destroy(ext2_xattr_cache);
+}
+
+#else  /* CONFIG_EXT2_FS_XATTR_SHARING */
+
+int __init
+init_ext2_xattr(void)
+{
+	return 0;
+}
+
+void
+exit_ext2_xattr(void)
+{
+}
+
+#endif  /* CONFIG_EXT2_FS_XATTR_SHARING */
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext2/xattr_user.c	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,103 @@
+/*
+ * linux/fs/ext2/xattr_user.c
+ * Handler for extended user attributes.
+ *
+ * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fs.h>
+#include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
+
+#ifdef CONFIG_EXT2_FS_POSIX_ACL
+# include <linux/ext2_acl.h>
+#endif
+
+#define XATTR_USER_PREFIX "user."
+
+static size_t
+ext2_xattr_user_list(char *list, struct inode *inode,
+		     const char *name, int name_len)
+{
+	const int prefix_len = sizeof(XATTR_USER_PREFIX)-1;
+
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return 0;
+
+	if (list) {
+		memcpy(list, XATTR_USER_PREFIX, prefix_len);
+		memcpy(list+prefix_len, name, name_len);
+		list[prefix_len + name_len] = '\0';
+	}
+	return prefix_len + name_len + 1;
+}
+
+static int
+ext2_xattr_user_get(struct inode *inode, const char *name,
+		    void *buffer, size_t size)
+{
+	int error;
+
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return -ENOTSUP;
+#ifdef CONFIG_EXT2_FS_POSIX_ACL
+	error = ext2_permission_locked(inode, MAY_READ);
+#else
+	error = permission(inode, MAY_READ);
+#endif
+	if (error)
+		return error;
+
+	return ext2_xattr_get(inode, EXT2_XATTR_INDEX_USER, name,
+			      buffer, size);
+}
+
+static int
+ext2_xattr_user_set(struct inode *inode, const char *name,
+		    const void *value, size_t size, int flags)
+{
+	int error;
+
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return -ENOTSUP;
+	if ( !S_ISREG(inode->i_mode) &&
+	    (!S_ISDIR(inode->i_mode) || inode->i_mode & S_ISVTX))
+		return -EPERM;
+#ifdef CONFIG_EXT2_FS_POSIX_ACL
+	error = ext2_permission_locked(inode, MAY_WRITE);
+#else
+	error = permission(inode, MAY_WRITE);
+#endif
+	if (error)
+		return error;
+  
+	return ext2_xattr_set(inode, EXT2_XATTR_INDEX_USER, name,
+			      value, size, flags);
+}
+
+struct ext2_xattr_handler ext2_xattr_user_handler = {
+	prefix:	XATTR_USER_PREFIX,
+	list:	ext2_xattr_user_list,
+	get:	ext2_xattr_user_get,
+	set:	ext2_xattr_user_set,
+};
+
+int __init
+init_ext2_xattr_user(void)
+{
+	return ext2_xattr_register(EXT2_XATTR_INDEX_USER,
+				   &ext2_xattr_user_handler);
+}
+
+void
+exit_ext2_xattr_user(void)
+{
+	ext2_xattr_unregister(EXT2_XATTR_INDEX_USER,
+			      &ext2_xattr_user_handler);
+}
--- linux-2.4.20-hp4_pnnl1/fs/ext3/Makefile~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/Makefile	2003-04-09 17:21:01.000000000 -0600
@@ -1,5 +1,5 @@
 #
-# Makefile for the linux ext2-filesystem routines.
+# Makefile for the linux ext3-filesystem routines.
 #
 # Note! Dependencies are done automagically by 'make dep', which also
 # removes any old dependencies. DON'T put your own dependencies here
@@ -15,4 +15,8 @@ obj-y    := balloc.o bitmap.o dir.o file
 		ioctl.o namei.o super.o symlink.o hash.o
 obj-m    := $(O_TARGET)
 
+export-objs += xattr.o
+obj-$(CONFIG_EXT3_FS_XATTR) += xattr.o
+obj-$(CONFIG_EXT3_FS_XATTR_USER) += xattr_user.o
+
 include $(TOPDIR)/Rules.make
--- linux-2.4.20-hp4_pnnl1/fs/ext3/file.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/file.c	2003-04-09 17:21:01.000000000 -0600
@@ -23,6 +23,7 @@
 #include <linux/locks.h>
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
+#include <linux/ext3_xattr.h>
 #include <linux/ext3_jbd.h>
 #include <linux/smp_lock.h>
 
@@ -126,5 +127,9 @@ struct file_operations ext3_file_operati
 struct inode_operations ext3_file_inode_operations = {
 	truncate:	ext3_truncate,		/* BKL held */
 	setattr:	ext3_setattr,		/* BKL held */
+	setxattr:	ext3_setxattr,		/* BKL held */
+	getxattr:	ext3_getxattr,		/* BKL held */
+	listxattr:	ext3_listxattr,		/* BKL held */
+	removexattr:	ext3_removexattr,	/* BKL held */
 };
 
--- linux-2.4.20-hp4_pnnl1/fs/ext3/ialloc.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/ialloc.c	2003-04-09 17:21:01.000000000 -0600
@@ -17,6 +17,7 @@
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/ext3_xattr.h>
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/locks.h>
@@ -216,6 +217,7 @@ void ext3_free_inode (handle_t *handle, 
 	 * as writing the quota to disk may need the lock as well.
 	 */
 	DQUOT_INIT(inode);
+	ext3_xattr_delete_inode(handle, inode);
 	DQUOT_FREE_INODE(inode);
 	DQUOT_DROP(inode);
 
--- linux-2.4.20-hp4_pnnl1/fs/ext3/inode.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:23.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/inode.c	2003-04-09 17:21:01.000000000 -0600
@@ -39,6 +39,18 @@
  */
 #undef SEARCH_FROM_ZERO
 
+/*
+ * Test whether an inode is a fast symlink.
+ */
+static inline int ext3_inode_is_fast_symlink(struct inode *inode)
+{
+	int ea_blocks = inode->u.ext3_i.i_file_acl ?
+		(inode->i_sb->s_blocksize >> 9) : 0;
+
+	return (S_ISLNK(inode->i_mode) &&
+		inode->i_blocks - ea_blocks == 0);
+}
+
 /* The ext3 forget function must perform a revoke if we are freeing data
  * which has been journaled.  Metadata (eg. indirect blocks) must be
  * revoked in all cases. 
@@ -48,7 +60,7 @@
  * still needs to be revoked.
  */
 
-static int ext3_forget(handle_t *handle, int is_metadata,
+int ext3_forget(handle_t *handle, int is_metadata,
 		       struct inode *inode, struct buffer_head *bh,
 		       int blocknr)
 {
@@ -164,9 +176,7 @@ void ext3_delete_inode (struct inode * i
 {
 	handle_t *handle;
 	
-	if (is_bad_inode(inode) ||
-	    inode->i_ino == EXT3_ACL_IDX_INO ||
-	    inode->i_ino == EXT3_ACL_DATA_INO)
+	if (is_bad_inode(inode))
 		goto no_delete;
 
 	lock_kernel();
@@ -1855,6 +1865,8 @@ void ext3_truncate(struct inode * inode)
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode)))
 		return;
+	if (ext3_inode_is_fast_symlink(inode))
+		return;
 	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
 		return;
 
@@ -2002,8 +2014,6 @@ int ext3_get_inode_loc (struct inode *in
 	struct ext3_group_desc * gdp;
 		
 	if ((inode->i_ino != EXT3_ROOT_INO &&
-		inode->i_ino != EXT3_ACL_IDX_INO &&
-		inode->i_ino != EXT3_ACL_DATA_INO &&
 		inode->i_ino != EXT3_JOURNAL_INO &&
 		inode->i_ino < EXT3_FIRST_INO(inode->i_sb)) ||
 		inode->i_ino > le32_to_cpu(
@@ -2130,10 +2140,7 @@ void ext3_read_inode(struct inode * inod
 
 	brelse (iloc.bh);
 
-	if (inode->i_ino == EXT3_ACL_IDX_INO ||
-	    inode->i_ino == EXT3_ACL_DATA_INO)
-		/* Nothing to do */ ;
-	else if (S_ISREG(inode->i_mode)) {
+	if (S_ISREG(inode->i_mode)) {
 		inode->i_op = &ext3_file_inode_operations;
 		inode->i_fop = &ext3_file_operations;
 		inode->i_mapping->a_ops = &ext3_aops;
@@ -2141,15 +2148,17 @@ void ext3_read_inode(struct inode * inod
 		inode->i_op = &ext3_dir_inode_operations;
 		inode->i_fop = &ext3_dir_operations;
 	} else if (S_ISLNK(inode->i_mode)) {
-		if (!inode->i_blocks)
+		if (ext3_inode_is_fast_symlink(inode))
 			inode->i_op = &ext3_fast_symlink_inode_operations;
 		else {
-			inode->i_op = &page_symlink_inode_operations;
+			inode->i_op = &ext3_symlink_inode_operations;
 			inode->i_mapping->a_ops = &ext3_aops;
 		}
-	} else 
+	} else {
+		inode->i_op = &ext3_special_inode_operations;
 		init_special_inode(inode, inode->i_mode,
 				   le32_to_cpu(iloc.raw_inode->i_block[0]));
+	}
 	/* inode->i_attr_flags = 0;				unused */
 	if (inode->u.ext3_i.i_flags & EXT3_SYNC_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_SYNCRONOUS; unused */
--- linux-2.4.20-hp4_pnnl1/fs/ext3/namei.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:46.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/namei.c	2003-04-09 17:21:01.000000000 -0600
@@ -29,6 +29,7 @@
 #include <linux/sched.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/ext3_xattr.h>
 #include <linux/fcntl.h>
 #include <linux/stat.h>
 #include <linux/string.h>
@@ -1611,7 +1612,7 @@ static int ext3_mkdir(struct inode * dir
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, S_IFDIR);
+	inode = ext3_new_inode (handle, dir, S_IFDIR | mode);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
@@ -1619,7 +1620,6 @@ static int ext3_mkdir(struct inode * dir
 	inode->i_op = &ext3_dir_inode_operations;
 	inode->i_fop = &ext3_dir_operations;
 	inode->i_size = EXT3_I(inode)->i_disksize = inode->i_sb->s_blocksize;
-	inode->i_blocks = 0;	
 	dir_block = ext3_bread (handle, inode, 0, 1, &err);
 	if (!dir_block) {
 		inode->i_nlink--; /* is this nlink == 0? */
@@ -1646,9 +1646,6 @@ static int ext3_mkdir(struct inode * dir
 	BUFFER_TRACE(dir_block, "call ext3_journal_dirty_metadata");
 	ext3_journal_dirty_metadata(handle, dir_block);
 	brelse (dir_block);
-	inode->i_mode = S_IFDIR | mode;
-	if (dir->i_mode & S_ISGID)
-		inode->i_mode |= S_ISGID;
 	ext3_mark_inode_dirty(handle, inode);
 	err = ext3_add_entry (handle, dentry, inode);
 	if (err) {
@@ -2017,7 +2014,7 @@ static int ext3_symlink (struct inode * 
 		goto out_stop;
 
 	if (l > sizeof (EXT3_I(inode)->i_data)) {
-		inode->i_op = &page_symlink_inode_operations;
+		inode->i_op = &ext3_symlink_inode_operations;
 		inode->i_mapping->a_ops = &ext3_aops;
 		/*
 		 * block_symlink() calls back into ext3_prepare/commit_write.
@@ -2244,4 +2241,16 @@ struct inode_operations ext3_dir_inode_o
 	rmdir:		ext3_rmdir,		/* BKL held */
 	mknod:		ext3_mknod,		/* BKL held */
 	rename:		ext3_rename,		/* BKL held */
+	setxattr:	ext3_setxattr,		/* BKL held */
+	getxattr:	ext3_getxattr,		/* BKL held */
+	listxattr:	ext3_listxattr,		/* BKL held */
+	removexattr:	ext3_removexattr,	/* BKL held */
 };
+
+struct inode_operations ext3_special_inode_operations = {
+	setxattr:	ext3_setxattr,		/* BKL held */
+	getxattr:	ext3_getxattr,		/* BKL held */
+	listxattr:	ext3_listxattr,		/* BKL held */
+	removexattr:	ext3_removexattr,	/* BKL held */
+};
+
--- linux-2.4.20-hp4_pnnl1/fs/ext3/super.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/super.c	2003-04-09 17:21:01.000000000 -0600
@@ -24,6 +24,7 @@
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/ext3_xattr.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/locks.h>
@@ -404,6 +405,7 @@ void ext3_put_super (struct super_block 
 	kdev_t j_dev = sbi->s_journal->j_dev;
 	int i;
 
+	ext3_xattr_put_super(sb);
 	journal_destroy(sbi->s_journal);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		EXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);
@@ -499,6 +501,7 @@ static int parse_options (char * options
 			  int is_remount)
 {
 	unsigned long *mount_options = &sbi->s_mount_opt;
+	
 	uid_t *resuid = &sbi->s_resuid;
 	gid_t *resgid = &sbi->s_resgid;
 	char * this_char;
@@ -511,6 +514,13 @@ static int parse_options (char * options
 	     this_char = strtok (NULL, ",")) {
 		if ((value = strchr (this_char, '=')) != NULL)
 			*value++ = 0;
+#ifdef CONFIG_EXT3_FS_XATTR_USER
+		if (!strcmp (this_char, "user_xattr"))
+			set_opt (*mount_options, XATTR_USER);
+		else if (!strcmp (this_char, "nouser_xattr"))
+			clear_opt (*mount_options, XATTR_USER);
+		else
+#endif
 		if (!strcmp (this_char, "bsddf"))
 			clear_opt (*mount_options, MINIX_DF);
 		else if (!strcmp (this_char, "nouid32")) {
@@ -928,6 +938,12 @@ struct super_block * ext3_read_super (st
 	sbi->s_mount_opt = 0;
 	sbi->s_resuid = EXT3_DEF_RESUID;
 	sbi->s_resgid = EXT3_DEF_RESGID;
+
+	/* Default extended attribute flags */
+#ifdef CONFIG_EXT3_FS_XATTR_USER
+	/* set_opt(sbi->s_mount_opt, XATTR_USER); */
+#endif
+
 	if (!parse_options ((char *) data, &sb_block, sbi, &journal_inum, 0)) {
 		sb->s_dev = 0;
 		goto out_fail;
@@ -1767,12 +1783,27 @@ static DECLARE_FSTYPE_DEV(ext3_fs_type, 
 
 static int __init init_ext3_fs(void)
 {
-        return register_filesystem(&ext3_fs_type);
+	int error = init_ext3_xattr();
+	if (error)
+		return error;
+	error = init_ext3_xattr_user();
+	if (error)
+		goto fail;
+	error = register_filesystem(&ext3_fs_type);
+	if (!error)
+		return 0;
+	
+	exit_ext3_xattr_user();
+fail:
+	exit_ext3_xattr();
+	return error;
 }
 
 static void __exit exit_ext3_fs(void)
 {
 	unregister_filesystem(&ext3_fs_type);
+	exit_ext3_xattr_user();
+	exit_ext3_xattr();
 }
 
 EXPORT_SYMBOL(ext3_force_commit);
--- linux-2.4.20-hp4_pnnl1/fs/ext3/symlink.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/symlink.c	2003-04-09 17:21:01.000000000 -0600
@@ -20,6 +20,7 @@
 #include <linux/fs.h>
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
+#include <linux/ext3_xattr.h>
 
 static int ext3_readlink(struct dentry *dentry, char *buffer, int buflen)
 {
@@ -33,7 +34,20 @@ static int ext3_follow_link(struct dentr
 	return vfs_follow_link(nd, s);
 }
 
+struct inode_operations ext3_symlink_inode_operations = {
+	readlink:	page_readlink,		/* BKL not held.  Don't need */
+	follow_link:	page_follow_link,	/* BKL not held.  Don't need */
+	setxattr:	ext3_setxattr,		/* BKL held */
+	getxattr:	ext3_getxattr,		/* BKL held */
+	listxattr:	ext3_listxattr,		/* BKL held */
+	removexattr:	ext3_removexattr,	/* BKL held */
+};
+
 struct inode_operations ext3_fast_symlink_inode_operations = {
 	readlink:	ext3_readlink,		/* BKL not held.  Don't need */
 	follow_link:	ext3_follow_link,	/* BKL not held.  Don't need */
+	setxattr:	ext3_setxattr,		/* BKL held */
+	getxattr:	ext3_getxattr,		/* BKL held */
+	listxattr:	ext3_listxattr,		/* BKL held */
+	removexattr:	ext3_removexattr,	/* BKL held */
 };
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/xattr.c	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,1232 @@
+/*
+ * linux/fs/ext3/xattr.c
+ *
+ * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ *
+ * Fix by Harrison Xing <harrison@mountainviewdata.com>.
+ * Ext3 code with a lot of help from Eric Jarman <ejarman@acm.org>.
+ * Extended attributes for symlinks and special files added per
+ *  suggestion of Luka Renko <luka.renko@hermes.si>.
+ */
+
+/*
+ * Extended attributes are stored on disk blocks allocated outside of
+ * any inode. The i_file_acl field is then made to point to this allocated
+ * block. If all extended attributes of an inode are identical, these
+ * inodes may share the same extended attribute block. Such situations
+ * are automatically detected by keeping a cache of recent attribute block
+ * numbers and hashes over the block's contents in memory.
+ *
+ *
+ * Extended attribute block layout:
+ *
+ *   +------------------+
+ *   | header           |
+ *   | entry 1          | |
+ *   | entry 2          | | growing downwards
+ *   | entry 3          | v
+ *   | four null bytes  |
+ *   | . . .            |
+ *   | value 1          | ^
+ *   | value 3          | | growing upwards
+ *   | value 2          | |
+ *   +------------------+
+ *
+ * The block header is followed by multiple entry descriptors. These entry
+ * descriptors are variable in size, and alligned to EXT3_XATTR_PAD
+ * byte boundaries. The entry descriptors are sorted by attribute name,
+ * so that two extended attribute blocks can be compared efficiently.
+ *
+ * Attribute values are aligned to the end of the block, stored in
+ * no specific order. They are also padded to EXT3_XATTR_PAD byte
+ * boundaries. No additional gaps are left between them.
+ *
+ * Locking strategy
+ * ----------------
+ * The VFS already holds the BKL and the inode->i_sem semaphore when any of
+ * the xattr inode operations are called, so we are guaranteed that only one
+ * processes accesses extended attributes of an inode at any time.
+ *
+ * For writing we also grab the ext3_xattr_sem semaphore. This ensures that
+ * only a single process is modifying an extended attribute block, even
+ * if the block is shared among inodes.
+ *
+ * Note for porting to 2.5
+ * -----------------------
+ * The BKL will no longer be held in the xattr inode operations.
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/locks.h>
+#include <linux/slab.h>
+#include <linux/ext3_jbd.h>
+#include <linux/ext3_fs.h>
+#include <linux/ext3_xattr.h>
+#include <linux/mbcache.h>
+#include <linux/quotaops.h>
+#include <asm/semaphore.h>
+#include <linux/compatmac.h>
+
+#define EXT3_EA_USER "user."
+
+/* These symbols may be needed by a module. */
+EXPORT_SYMBOL(ext3_xattr_register);
+EXPORT_SYMBOL(ext3_xattr_unregister);
+EXPORT_SYMBOL(ext3_xattr_get);
+EXPORT_SYMBOL(ext3_xattr_list);
+EXPORT_SYMBOL(ext3_xattr_set);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+# define mark_buffer_dirty(bh) mark_buffer_dirty(bh, 1)
+#endif
+
+#define HDR(bh) ((struct ext3_xattr_header *)((bh)->b_data))
+#define ENTRY(ptr) ((struct ext3_xattr_entry *)(ptr))
+#define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)
+#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
+
+#ifdef EXT3_XATTR_DEBUG
+# define ea_idebug(inode, f...) do { \
+		printk(KERN_DEBUG "inode %s:%ld: ", \
+			kdevname(inode->i_dev), inode->i_ino); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+# define ea_bdebug(bh, f...) do { \
+		printk(KERN_DEBUG "block %s:%ld: ", \
+			kdevname(bh->b_dev), bh->b_blocknr); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+#else
+# define ea_idebug(f...)
+# define ea_bdebug(f...)
+#endif
+
+static int ext3_xattr_set2(handle_t *, struct inode *, struct buffer_head *,
+			   struct ext3_xattr_header *);
+
+#ifdef CONFIG_EXT3_FS_XATTR_SHARING
+
+static int ext3_xattr_cache_insert(struct buffer_head *);
+static struct buffer_head *ext3_xattr_cache_find(struct inode *,
+						 struct ext3_xattr_header *);
+static void ext3_xattr_cache_remove(struct buffer_head *);
+static void ext3_xattr_rehash(struct ext3_xattr_header *,
+			      struct ext3_xattr_entry *);
+
+static struct mb_cache *ext3_xattr_cache;
+
+#else
+# define ext3_xattr_cache_insert(bh) 0
+# define ext3_xattr_cache_find(inode, header) NULL
+# define ext3_xattr_cache_remove(bh) while(0) {}
+# define ext3_xattr_rehash(header, entry) while(0) {}
+#endif
+
+/*
+ * If a file system does not share extended attributes among inodes,
+ * we should not need the ext3_xattr_sem semaphore. However, the
+ * filesystem may still contain shared blocks, so we always take
+ * the lock.
+ */
+
+DECLARE_MUTEX(ext3_xattr_sem);
+
+static inline int
+ext3_xattr_new_block(handle_t *handle, struct inode *inode,
+		     int * errp, int force)
+{
+	struct super_block *sb = inode->i_sb;
+	int goal = le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block) +
+		EXT3_I(inode)->i_block_group * EXT3_BLOCKS_PER_GROUP(sb);
+
+	/* How can we enforce the allocation? */
+	int block = ext3_new_block(handle, inode, goal, 0, 0, errp);
+#ifdef OLD_QUOTAS
+	if (!*errp)
+		inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+#endif
+	return block;
+}
+
+static inline int
+ext3_xattr_quota_alloc(struct inode *inode, int force)
+{
+	/* How can we enforce the allocation? */
+#ifdef OLD_QUOTAS
+	int error = DQUOT_ALLOC_BLOCK(inode->i_sb, inode, 1);
+	if (!error)
+		inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+#else
+	int error = DQUOT_ALLOC_BLOCK(inode, 1);
+#endif
+	return error;
+}
+
+#ifdef OLD_QUOTAS
+
+static inline void
+ext3_xattr_quota_free(struct inode *inode)
+{
+	DQUOT_FREE_BLOCK(inode->i_sb, inode, 1);
+	inode->i_blocks -= inode->i_sb->s_blocksize >> 9;
+}
+
+static inline void
+ext3_xattr_free_block(handle_t *handle, struct inode * inode,
+		      unsigned long block)
+{
+	ext3_free_blocks(handle, inode, block, 1);
+	inode->i_blocks -= inode->i_sb->s_blocksize >> 9;
+}
+
+#else
+# define ext3_xattr_quota_free(inode) \
+	DQUOT_FREE_BLOCK(inode, 1)
+# define ext3_xattr_free_block(handle, inode, block) \
+	ext3_free_blocks(handle, inode, block, 1)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
+
+static inline struct buffer_head *
+sb_bread(struct super_block *sb, int block)
+{
+	return bread(sb->s_dev, block, sb->s_blocksize);
+}
+
+static inline struct buffer_head *
+sb_getblk(struct super_block *sb, int block)
+{
+	return getblk(sb->s_dev, block, sb->s_blocksize);
+}
+
+#endif
+
+struct ext3_xattr_handler *ext3_xattr_handlers[EXT3_XATTR_INDEX_MAX];
+rwlock_t ext3_handler_lock = RW_LOCK_UNLOCKED;
+
+int
+ext3_xattr_register(int name_index, struct ext3_xattr_handler *handler)
+{
+	int error = -EINVAL;
+
+	if (name_index > 0 && name_index <= EXT3_XATTR_INDEX_MAX) {
+		write_lock(&ext3_handler_lock);
+		if (!ext3_xattr_handlers[name_index-1]) {
+			ext3_xattr_handlers[name_index-1] = handler;
+			error = 0;
+		}
+		write_unlock(&ext3_handler_lock);
+	}
+	return error;
+}
+
+void
+ext3_xattr_unregister(int name_index, struct ext3_xattr_handler *handler)
+{
+	if (name_index > 0 || name_index <= EXT3_XATTR_INDEX_MAX) {
+		write_lock(&ext3_handler_lock);
+		ext3_xattr_handlers[name_index-1] = NULL;
+		write_unlock(&ext3_handler_lock);
+	}
+}
+
+static inline const char *
+strcmp_prefix(const char *a, const char *a_prefix)
+{
+	while (*a_prefix && *a == *a_prefix) {
+		a++;
+		a_prefix++;
+	}
+	return *a_prefix ? NULL : a;
+}
+
+/*
+ * Decode the extended attribute name, and translate it into
+ * the name_index and name suffix.
+ */
+static inline struct ext3_xattr_handler *
+ext3_xattr_resolve_name(const char **name)
+{
+	struct ext3_xattr_handler *handler = NULL;
+	int i;
+
+	if (!*name)
+		return NULL;
+	read_lock(&ext3_handler_lock);
+	for (i=0; i<EXT3_XATTR_INDEX_MAX; i++) {
+		if (ext3_xattr_handlers[i]) {
+			const char *n = strcmp_prefix(*name,
+				ext3_xattr_handlers[i]->prefix);
+			if (n) {
+				handler = ext3_xattr_handlers[i];
+				*name = n;
+				break;
+			}
+		}
+	}
+	read_unlock(&ext3_handler_lock);
+	return handler;
+}
+
+static inline struct ext3_xattr_handler *
+ext3_xattr_handler(int name_index)
+{
+	struct ext3_xattr_handler *handler = NULL;
+	if (name_index > 0 && name_index <= EXT3_XATTR_INDEX_MAX) {
+		read_lock(&ext3_handler_lock);
+		handler = ext3_xattr_handlers[name_index-1];
+		read_unlock(&ext3_handler_lock);
+	}
+	return handler;
+}
+
+/*
+ * Inode operation getxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+ext3_getxattr(struct dentry *dentry, const char *name,
+	      void *buffer, size_t size)
+{
+	struct ext3_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = ext3_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->get(inode, name, buffer, size);
+}
+
+/*
+ * Inode operation listxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+ext3_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+	return ext3_xattr_list(dentry->d_inode, buffer, size);
+}
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+ext3_setxattr(struct dentry *dentry, const char *name,
+	      const void *value, size_t size, int flags)
+{
+	struct ext3_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	if (size == 0)
+		value = "";  /* empty EA, do not remove */
+	handler = ext3_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->set(inode, name, value, size, flags);
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+ext3_removexattr(struct dentry *dentry, const char *name)
+{
+	struct ext3_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = ext3_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->set(inode, name, NULL, 0, XATTR_REPLACE);
+}
+
+/*
+ * ext3_xattr_get()
+ *
+ * Copy an extended attribute into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+ext3_xattr_get(struct inode *inode, int name_index, const char *name,
+	       void *buffer, size_t buffer_size)
+{
+	struct buffer_head *bh = NULL;
+	struct ext3_xattr_entry *entry;
+	unsigned int block, size;
+	char *end;
+	int name_len, error;
+
+	ea_idebug(inode, "name=%d.%s, buffer=%p, buffer_size=%ld",
+		  name_index, name, buffer, (long)buffer_size);
+
+	if (name == NULL)
+		return -EINVAL;
+	if (!EXT3_I(inode)->i_file_acl)
+		return -ENOATTR;
+	block = EXT3_I(inode)->i_file_acl;
+	ea_idebug(inode, "reading block %d", block);
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		return -EIO;
+	ea_bdebug(bh, "b_count=%d, refcount=%d",
+		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
+	end = bh->b_data + bh->b_size;
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+bad_block:	ext3_error(inode->i_sb, "ext3_xattr_get",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* find named attribute */
+	name_len = strlen(name);
+
+	error = -ERANGE;
+	if (name_len > 255)
+		goto cleanup;
+	entry = FIRST_ENTRY(bh);
+	while (!IS_LAST_ENTRY(entry)) {
+		struct ext3_xattr_entry *next =
+			EXT3_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		if (name_index == entry->e_name_index &&
+		    name_len == entry->e_name_len &&
+		    memcmp(name, entry->e_name, name_len) == 0)
+			goto found;
+		entry = next;
+	}
+	/* Check the remaining name entries */
+	while (!IS_LAST_ENTRY(entry)) {
+		struct ext3_xattr_entry *next =
+			EXT3_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		entry = next;
+	}
+	if (ext3_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	error = -ENOATTR;
+	goto cleanup;
+found:
+	/* check the buffer size */
+	if (entry->e_value_block != 0)
+		goto bad_block;
+	size = le32_to_cpu(entry->e_value_size);
+	if (size > inode->i_sb->s_blocksize ||
+	    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)
+		goto bad_block;
+
+	if (ext3_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	if (buffer) {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+		/* return value of attribute */
+		memcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),
+			size);
+	}
+	error = size;
+
+cleanup:
+	brelse(bh);
+
+	return error;
+}
+
+/*
+ * ext3_xattr_list()
+ *
+ * Copy a list of attribute names into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+ext3_xattr_list(struct inode *inode, char *buffer, size_t buffer_size)
+{
+	struct buffer_head *bh = NULL;
+	struct ext3_xattr_entry *entry;
+	unsigned int block, size = 0;
+	char *buf, *end;
+	int error;
+
+	ea_idebug(inode, "buffer=%p, buffer_size=%ld",
+		  buffer, (long)buffer_size);
+
+	if (!EXT3_I(inode)->i_file_acl)
+		return 0;
+	block = EXT3_I(inode)->i_file_acl;
+	ea_idebug(inode, "reading block %d", block);
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		return -EIO;
+	ea_bdebug(bh, "b_count=%d, refcount=%d",
+		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
+	end = bh->b_data + bh->b_size;
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+bad_block:	ext3_error(inode->i_sb, "ext3_xattr_list",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* compute the size required for the list of attribute names */
+	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
+	     entry = EXT3_XATTR_NEXT(entry)) {
+		struct ext3_xattr_handler *handler;
+		struct ext3_xattr_entry *next =
+			EXT3_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+
+		handler = ext3_xattr_handler(entry->e_name_index);
+		if (handler)
+			size += handler->list(NULL, inode, entry->e_name,
+					      entry->e_name_len);
+	}
+
+	if (ext3_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	if (!buffer) {
+		error = size;
+		goto cleanup;
+	} else {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+	}
+
+	/* list the attribute names */
+	buf = buffer;
+	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
+	     entry = EXT3_XATTR_NEXT(entry)) {
+		struct ext3_xattr_handler *handler;
+
+		handler = ext3_xattr_handler(entry->e_name_index);
+		if (handler)
+			buf += handler->list(buf, inode, entry->e_name,
+					     entry->e_name_len);
+	}
+	error = size;
+
+cleanup:
+	brelse(bh);
+
+	return error;
+}
+
+/*
+ * If the EXT3_FEATURE_COMPAT_EXT_ATTR feature of this file system is
+ * not set, set it.
+ */
+static void ext3_xattr_update_super_block(handle_t *handle,
+					  struct super_block *sb)
+{
+	if (EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR))
+		return;
+
+	lock_super(sb);
+	ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	EXT3_SB(sb)->s_feature_compat |= EXT3_FEATURE_COMPAT_EXT_ATTR;
+#endif
+	EXT3_SB(sb)->s_es->s_feature_compat |=
+		cpu_to_le32(EXT3_FEATURE_COMPAT_EXT_ATTR);
+	sb->s_dirt = 1;
+	ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
+	unlock_super(sb);
+}
+
+/*
+ * ext3_xattr_set()
+ *
+ * Create, replace or remove an extended attribute for this inode. Buffer
+ * is NULL to remove an existing extended attribute, and non-NULL to
+ * either replace an existing extended attribute, or create a new extended
+ * attribute. The flags XATTR_REPLACE and XATTR_CREATE
+ * specify that an extended attribute must exist and must not exist
+ * previous to the call, respectively.
+ *
+ * Returns 0, or a negative error number on failure.
+ */
+int
+ext3_xattr_set(handle_t *handle, struct inode *inode, int name_index,
+	       const char *name, const void *value, size_t value_len, int flags)
+{
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *bh = NULL;
+	struct ext3_xattr_header *header = NULL;
+	struct ext3_xattr_entry *here, *last;
+	unsigned int name_len;
+	int block = EXT3_I(inode)->i_file_acl;
+	int min_offs = sb->s_blocksize, not_found = 1, free, error;
+	char *end;
+	
+	/*
+	 * header -- Points either into bh, or to a temporarily
+	 *           allocated buffer.
+	 * here -- The named entry found, or the place for inserting, within
+	 *         the block pointed to by header.
+	 * last -- Points right after the last named entry within the block
+	 *         pointed to by header.
+	 * min_offs -- The offset of the first value (values are aligned
+	 *             towards the end of the block).
+	 * end -- Points right after the block pointed to by header.
+	 */
+	
+	ea_idebug(inode, "name=%d.%s, value=%p, value_len=%ld",
+		  name_index, name, value, (long)value_len);
+
+	if (IS_RDONLY(inode))
+		return -EROFS;
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		return -EPERM;
+	if (value == NULL)
+		value_len = 0;
+	if (name == NULL)
+		return -EINVAL;
+	name_len = strlen(name);
+	if (name_len > 255 || value_len > sb->s_blocksize)
+		return -ERANGE;
+	down(&ext3_xattr_sem);
+
+	if (block) {
+		/* The inode already has an extended attribute block. */
+		bh = sb_bread(sb, block);
+		error = -EIO;
+		if (!bh)
+			goto cleanup;
+		ea_bdebug(bh, "b_count=%d, refcount=%d",
+			atomic_read(&(bh->b_count)),
+			le32_to_cpu(HDR(bh)->h_refcount));
+		header = HDR(bh);
+		end = bh->b_data + bh->b_size;
+		if (header->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||
+		    header->h_blocks != cpu_to_le32(1)) {
+bad_block:		ext3_error(sb, "ext3_xattr_set",
+				"inode %ld: bad block %d", inode->i_ino, block);
+			error = -EIO;
+			goto cleanup;
+		}
+		/* Find the named attribute. */
+		here = FIRST_ENTRY(bh);
+		while (!IS_LAST_ENTRY(here)) {
+			struct ext3_xattr_entry *next = EXT3_XATTR_NEXT(here);
+			if ((char *)next >= end)
+				goto bad_block;
+			if (!here->e_value_block && here->e_value_size) {
+				int offs = le16_to_cpu(here->e_value_offs);
+				if (offs < min_offs)
+					min_offs = offs;
+			}
+			not_found = name_index - here->e_name_index;
+			if (!not_found)
+				not_found = name_len - here->e_name_len;
+			if (!not_found)
+				not_found = memcmp(name, here->e_name,name_len);
+			if (not_found <= 0)
+				break;
+			here = next;
+		}
+		last = here;
+		/* We still need to compute min_offs and last. */
+		while (!IS_LAST_ENTRY(last)) {
+			struct ext3_xattr_entry *next = EXT3_XATTR_NEXT(last);
+			if ((char *)next >= end)
+				goto bad_block;
+			if (!last->e_value_block && last->e_value_size) {
+				int offs = le16_to_cpu(last->e_value_offs);
+				if (offs < min_offs)
+					min_offs = offs;
+			}
+			last = next;
+		}
+
+		/* Check whether we have enough space left. */
+		free = min_offs - ((char*)last - (char*)header) - sizeof(__u32);
+	} else {
+		/* We will use a new extended attribute block. */
+		free = sb->s_blocksize -
+			sizeof(struct ext3_xattr_header) - sizeof(__u32);
+		here = last = NULL;  /* avoid gcc uninitialized warning. */
+	}
+
+	if (not_found) {
+		/* Request to remove a nonexistent attribute? */
+		error = -ENOATTR;
+		if (flags & XATTR_REPLACE)
+			goto cleanup;
+		error = 0;
+		if (value == NULL)
+			goto cleanup;
+		else
+			free -= EXT3_XATTR_LEN(name_len);
+	} else {
+		/* Request to create an existing attribute? */
+		error = -EEXIST;
+		if (flags & XATTR_CREATE)
+			goto cleanup;
+		if (!here->e_value_block && here->e_value_size) {
+			unsigned int size = le32_to_cpu(here->e_value_size);
+
+			if (le16_to_cpu(here->e_value_offs) + size > 
+			    sb->s_blocksize || size > sb->s_blocksize)
+				goto bad_block;
+			free += EXT3_XATTR_SIZE(size);
+		}
+	}
+	free -= EXT3_XATTR_SIZE(value_len);
+	error = -ENOSPC;
+	if (free < 0)
+		goto cleanup;
+
+	/* Here we know that we can set the new attribute. */
+
+	if (header) {
+		if (header->h_refcount == cpu_to_le32(1)) {
+			ea_bdebug(bh, "modifying in-place");
+			ext3_xattr_cache_remove(bh);
+			error = ext3_journal_get_write_access(handle, bh);
+			if (error)
+				goto cleanup;
+		} else {
+			int offset;
+
+			ea_bdebug(bh, "cloning");
+			header = kmalloc(bh->b_size, GFP_KERNEL);
+			error = -ENOMEM;
+			if (header == NULL)
+				goto cleanup;
+			memcpy(header, HDR(bh), bh->b_size);
+			header->h_refcount = cpu_to_le32(1);
+			offset = (char *)header - bh->b_data;
+			here = ENTRY((char *)here + offset);
+			last = ENTRY((char *)last + offset);
+		}
+	} else {
+		/* Allocate a buffer where we construct the new block. */
+		header = kmalloc(sb->s_blocksize, GFP_KERNEL);
+		error = -ENOMEM;
+		if (header == NULL)
+			goto cleanup;
+		memset(header, 0, sb->s_blocksize);
+		end = (char *)header + sb->s_blocksize;
+		header->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);
+		header->h_blocks = header->h_refcount = cpu_to_le32(1);
+		last = here = ENTRY(header+1);
+	}
+
+	if (not_found) {
+		/* Insert the new name. */
+		int size = EXT3_XATTR_LEN(name_len);
+		int rest = (char *)last - (char *)here;
+		memmove((char *)here + size, here, rest);
+		memset(here, 0, size);
+		here->e_name_index = name_index;
+		here->e_name_len = name_len;
+		memcpy(here->e_name, name, name_len);
+	} else {
+		/* Remove the old value. */
+		if (!here->e_value_block && here->e_value_size) {
+			char *first_val = (char *)header + min_offs;
+			int offs = le16_to_cpu(here->e_value_offs);
+			char *val = (char *)header + offs;
+			size_t size = EXT3_XATTR_SIZE(
+				le32_to_cpu(here->e_value_size));
+			memmove(first_val + size, first_val, val - first_val);
+			memset(first_val, 0, size);
+			here->e_value_offs = 0;
+			min_offs += size;
+
+			/* Adjust all value offsets. */
+			last = ENTRY(header+1);
+			while (!IS_LAST_ENTRY(last)) {
+				int o = le16_to_cpu(last->e_value_offs);
+				if (!last->e_value_block && o < offs)
+					last->e_value_offs =
+						cpu_to_le16(o + size);
+				last = EXT3_XATTR_NEXT(last);
+			}
+		}
+		if (value == NULL) {
+			/* Remove this attribute. */
+			if (EXT3_XATTR_NEXT(ENTRY(header+1)) == last) {
+				/* This block is now empty. */
+				error = ext3_xattr_set2(handle, inode, bh,NULL);
+				goto cleanup;
+			} else {
+				/* Remove the old name. */
+				int size = EXT3_XATTR_LEN(name_len);
+				last = ENTRY((char *)last - size);
+				memmove(here, (char*)here + size,
+					(char*)last - (char*)here);
+				memset(last, 0, size);
+			}
+		}
+	}
+
+	if (value != NULL) {
+		/* Insert the new value. */
+		here->e_value_size = cpu_to_le32(value_len);
+		if (value_len) {
+			size_t size = EXT3_XATTR_SIZE(value_len);
+			char *val = (char *)header + min_offs - size;
+			here->e_value_offs =
+				cpu_to_le16((char *)val - (char *)header);
+			memset(val + size - EXT3_XATTR_PAD, 0,
+			       EXT3_XATTR_PAD); /* Clear the pad bytes. */
+			memcpy(val, value, value_len);
+		}
+	}
+	ext3_xattr_rehash(header, here);
+
+	error = ext3_xattr_set2(handle, inode, bh, header);
+
+cleanup:
+	brelse(bh);
+	if (!(bh && header == HDR(bh)))
+		kfree(header);
+	up(&ext3_xattr_sem);
+
+	return error;
+}
+
+/*
+ * Second half of ext3_xattr_set(): Update the file system.
+ */
+static int
+ext3_xattr_set2(handle_t *handle, struct inode *inode,
+		struct buffer_head *old_bh, struct ext3_xattr_header *header)
+{
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *new_bh = NULL;
+	int error;
+
+	if (header) {
+		new_bh = ext3_xattr_cache_find(inode, header);
+		if (new_bh) {
+			/*
+			 * We found an identical block in the cache.
+			 * The old block will be released after updating
+			 * the inode.
+			 */
+			ea_bdebug(old_bh, "reusing block %ld",
+				new_bh->b_blocknr);
+			
+			error = -EDQUOT;
+			if (ext3_xattr_quota_alloc(inode, 1))
+				goto cleanup;
+			
+			error = ext3_journal_get_write_access(handle, new_bh);
+			if (error)
+				goto cleanup;
+			HDR(new_bh)->h_refcount = cpu_to_le32(
+				le32_to_cpu(HDR(new_bh)->h_refcount) + 1);
+			ea_bdebug(new_bh, "refcount now=%d",
+				le32_to_cpu(HDR(new_bh)->h_refcount));
+		} else if (old_bh && header == HDR(old_bh)) {
+			/* Keep this block. */
+			new_bh = old_bh;
+			ext3_xattr_cache_insert(new_bh);
+		} else {
+			/* We need to allocate a new block */
+			int force = EXT3_I(inode)->i_file_acl != 0;
+			int block = ext3_xattr_new_block(handle, inode,
+							 &error, force);
+			if (error)
+				goto cleanup;
+			ea_idebug(inode, "creating block %d", block);
+
+			new_bh = sb_getblk(sb, block);
+			if (!new_bh) {
+getblk_failed:			ext3_xattr_free_block(handle, inode, block);
+				error = -EIO;
+				goto cleanup;
+			}
+			lock_buffer(new_bh);
+			error = ext3_journal_get_create_access(handle, new_bh);
+			if (error) {
+				unlock_buffer(new_bh);
+				goto getblk_failed;
+			}
+			memcpy(new_bh->b_data, header, new_bh->b_size);
+			mark_buffer_uptodate(new_bh, 1);
+			unlock_buffer(new_bh);
+			ext3_xattr_cache_insert(new_bh);
+			
+			ext3_xattr_update_super_block(handle, sb);
+		}
+		error = ext3_journal_dirty_metadata(handle, new_bh);
+		if (error)
+			goto cleanup;
+	}
+
+	/* Update the inode. */
+	EXT3_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;
+	inode->i_ctime = CURRENT_TIME;
+	ext3_mark_inode_dirty(handle, inode);
+	if (IS_SYNC(inode))
+		handle->h_sync = 1;
+
+	error = 0;
+	if (old_bh && old_bh != new_bh) {
+		/*
+		 * If there was an old block, and we are not still using it,
+		 * we now release the old block.
+		*/
+		unsigned int refcount = le32_to_cpu(HDR(old_bh)->h_refcount);
+
+		error = ext3_journal_get_write_access(handle, old_bh);
+		if (error)
+			goto cleanup;
+		if (refcount == 1) {
+			/* Free the old block. */
+			ea_bdebug(old_bh, "freeing");
+			ext3_xattr_free_block(handle, inode, old_bh->b_blocknr);
+
+			/* ext3_forget() calls bforget() for us, but we
+			   let our caller release old_bh, so we need to
+			   duplicate the handle before. */
+			get_bh(old_bh);
+			ext3_forget(handle, 1, inode, old_bh,old_bh->b_blocknr);
+		} else {
+			/* Decrement the refcount only. */
+			refcount--;
+			HDR(old_bh)->h_refcount = cpu_to_le32(refcount);
+			ext3_xattr_quota_free(inode);
+			ext3_journal_dirty_metadata(handle, old_bh);
+			ea_bdebug(old_bh, "refcount now=%d", refcount);
+		}
+	}
+
+cleanup:
+	if (old_bh != new_bh)
+		brelse(new_bh);
+
+	return error;
+}
+
+/*
+ * ext3_xattr_delete_inode()
+ *
+ * Free extended attribute resources associated with this inode. This
+ * is called immediately before an inode is freed.
+ */
+void
+ext3_xattr_delete_inode(handle_t *handle, struct inode *inode)
+{
+	struct buffer_head *bh;
+	unsigned int block = EXT3_I(inode)->i_file_acl;
+
+	if (!block)
+		return;
+	down(&ext3_xattr_sem);
+
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh) {
+		ext3_error(inode->i_sb, "ext3_xattr_delete_inode",
+			"inode %ld: block %d read error", inode->i_ino, block);
+		goto cleanup;
+	}
+	ea_bdebug(bh, "b_count=%d", atomic_read(&(bh->b_count)));
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+		ext3_error(inode->i_sb, "ext3_xattr_delete_inode",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		goto cleanup;
+	}
+	ext3_journal_get_write_access(handle, bh);
+	ea_bdebug(bh, "refcount now=%d", le32_to_cpu(HDR(bh)->h_refcount) - 1);
+	if (HDR(bh)->h_refcount == cpu_to_le32(1)) {
+		ext3_xattr_cache_remove(bh);
+		ext3_xattr_free_block(handle, inode, block);
+		ext3_forget(handle, 1, inode, bh, block);
+		bh = NULL;
+	} else {
+		HDR(bh)->h_refcount = cpu_to_le32(
+			le32_to_cpu(HDR(bh)->h_refcount) - 1);
+		ext3_journal_dirty_metadata(handle, bh);
+		if (IS_SYNC(inode))
+			handle->h_sync = 1;
+		ext3_xattr_quota_free(inode);
+	}
+	EXT3_I(inode)->i_file_acl = 0;
+
+cleanup:
+	brelse(bh);
+	up(&ext3_xattr_sem);
+}
+
+/*
+ * ext3_xattr_put_super()
+ *
+ * This is called when a file system is unmounted.
+ */
+void
+ext3_xattr_put_super(struct super_block *sb)
+{
+#ifdef CONFIG_EXT3_FS_XATTR_SHARING
+	mb_cache_shrink(ext3_xattr_cache, sb->s_dev);
+#endif
+}
+
+#ifdef CONFIG_EXT3_FS_XATTR_SHARING
+
+/*
+ * ext3_xattr_cache_insert()
+ *
+ * Create a new entry in the extended attribute cache, and insert
+ * it unless such an entry is already in the cache.
+ *
+ * Returns 0, or a negative error number on failure.
+ */
+static int
+ext3_xattr_cache_insert(struct buffer_head *bh)
+{
+	__u32 hash = le32_to_cpu(HDR(bh)->h_hash);
+	struct mb_cache_entry *ce;
+	int error;
+
+	ce = mb_cache_entry_alloc(ext3_xattr_cache);
+	if (!ce)
+		return -ENOMEM;
+	error = mb_cache_entry_insert(ce, bh->b_dev, bh->b_blocknr, &hash);
+	if (error) {
+		mb_cache_entry_free(ce);
+		if (error == -EBUSY) {
+			ea_bdebug(bh, "already in cache (%d cache entries)",
+				atomic_read(&ext3_xattr_cache->c_entry_count));
+			error = 0;
+		}
+	} else {
+		ea_bdebug(bh, "inserting [%x] (%d cache entries)", (int)hash,
+			  atomic_read(&ext3_xattr_cache->c_entry_count));
+		mb_cache_entry_release(ce);
+	}
+	return error;
+}
+
+/*
+ * ext3_xattr_cmp()
+ *
+ * Compare two extended attribute blocks for equality.
+ *
+ * Returns 0 if the blocks are equal, 1 if they differ, and
+ * a negative error number on errors.
+ */
+static int
+ext3_xattr_cmp(struct ext3_xattr_header *header1,
+	       struct ext3_xattr_header *header2)
+{
+	struct ext3_xattr_entry *entry1, *entry2;
+
+	entry1 = ENTRY(header1+1);
+	entry2 = ENTRY(header2+1);
+	while (!IS_LAST_ENTRY(entry1)) {
+		if (IS_LAST_ENTRY(entry2))
+			return 1;
+		if (entry1->e_hash != entry2->e_hash ||
+		    entry1->e_name_len != entry2->e_name_len ||
+		    entry1->e_value_size != entry2->e_value_size ||
+		    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))
+			return 1;
+		if (entry1->e_value_block != 0 || entry2->e_value_block != 0)
+			return -EIO;
+		if (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),
+			   (char *)header2 + le16_to_cpu(entry2->e_value_offs),
+			   le32_to_cpu(entry1->e_value_size)))
+			return 1;
+
+		entry1 = EXT3_XATTR_NEXT(entry1);
+		entry2 = EXT3_XATTR_NEXT(entry2);
+	}
+	if (!IS_LAST_ENTRY(entry2))
+		return 1;
+	return 0;
+}
+
+/*
+ * ext3_xattr_cache_find()
+ *
+ * Find an identical extended attribute block.
+ *
+ * Returns a pointer to the block found, or NULL if such a block was
+ * not found or an error occurred.
+ */
+static struct buffer_head *
+ext3_xattr_cache_find(struct inode *inode, struct ext3_xattr_header *header)
+{
+	__u32 hash = le32_to_cpu(header->h_hash);
+	struct mb_cache_entry *ce;
+
+	if (!header->h_hash)
+		return NULL;  /* never share */
+	ea_idebug(inode, "looking for cached blocks [%x]", (int)hash);
+	ce = mb_cache_entry_find_first(ext3_xattr_cache, 0, inode->i_dev, hash);
+	while (ce) {
+		struct buffer_head *bh = sb_bread(inode->i_sb, ce->e_block);
+
+		if (!bh) {
+			ext3_error(inode->i_sb, "ext3_xattr_cache_find",
+				"inode %ld: block %ld read error",
+				inode->i_ino, ce->e_block);
+		} else if (le32_to_cpu(HDR(bh)->h_refcount) >
+			   EXT3_XATTR_REFCOUNT_MAX) {
+			ea_idebug(inode, "block %ld refcount %d>%d",ce->e_block,
+				le32_to_cpu(HDR(bh)->h_refcount),
+				EXT3_XATTR_REFCOUNT_MAX);
+		} else if (!ext3_xattr_cmp(header, HDR(bh))) {
+			ea_bdebug(bh, "b_count=%d",atomic_read(&(bh->b_count)));
+			mb_cache_entry_release(ce);
+			return bh;
+		}
+		brelse(bh);
+		ce = mb_cache_entry_find_next(ce, 0, inode->i_dev, hash);
+	}
+	return NULL;
+}
+
+/*
+ * ext3_xattr_cache_remove()
+ *
+ * Remove the cache entry of a block from the cache. Called when a
+ * block becomes invalid.
+ */
+static void
+ext3_xattr_cache_remove(struct buffer_head *bh)
+{
+	struct mb_cache_entry *ce;
+
+	ce = mb_cache_entry_get(ext3_xattr_cache, bh->b_dev, bh->b_blocknr);
+	if (ce) {
+		ea_bdebug(bh, "removing (%d cache entries remaining)",
+			  atomic_read(&ext3_xattr_cache->c_entry_count)-1);
+		mb_cache_entry_free(ce);
+	} else 
+		ea_bdebug(bh, "no cache entry");
+}
+
+#define NAME_HASH_SHIFT 5
+#define VALUE_HASH_SHIFT 16
+
+/*
+ * ext3_xattr_hash_entry()
+ *
+ * Compute the hash of an extended attribute.
+ */
+static inline void ext3_xattr_hash_entry(struct ext3_xattr_header *header,
+					 struct ext3_xattr_entry *entry)
+{
+	__u32 hash = 0;
+	char *name = entry->e_name;
+	int n;
+
+	for (n=0; n < entry->e_name_len; n++) {
+		hash = (hash << NAME_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^
+		       *name++;
+	}
+
+	if (entry->e_value_block == 0 && entry->e_value_size != 0) {
+		__u32 *value = (__u32 *)((char *)header +
+			le16_to_cpu(entry->e_value_offs));
+		for (n = (le32_to_cpu(entry->e_value_size) +
+		     EXT3_XATTR_ROUND) >> EXT3_XATTR_PAD_BITS; n; n--) {
+			hash = (hash << VALUE_HASH_SHIFT) ^
+			       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^
+			       le32_to_cpu(*value++);
+		}
+	}
+	entry->e_hash = cpu_to_le32(hash);
+}
+
+#undef NAME_HASH_SHIFT
+#undef VALUE_HASH_SHIFT
+
+#define BLOCK_HASH_SHIFT 16
+
+/*
+ * ext3_xattr_rehash()
+ *
+ * Re-compute the extended attribute hash value after an entry has changed.
+ */
+static void ext3_xattr_rehash(struct ext3_xattr_header *header,
+			      struct ext3_xattr_entry *entry)
+{
+	struct ext3_xattr_entry *here;
+	__u32 hash = 0;
+	
+	ext3_xattr_hash_entry(header, entry);
+	here = ENTRY(header+1);
+	while (!IS_LAST_ENTRY(here)) {
+		if (!here->e_hash) {
+			/* Block is not shared if an entry's hash value == 0 */
+			hash = 0;
+			break;
+		}
+		hash = (hash << BLOCK_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^
+		       le32_to_cpu(here->e_hash);
+		here = EXT3_XATTR_NEXT(here);
+	}
+	header->h_hash = cpu_to_le32(hash);
+}
+
+#undef BLOCK_HASH_SHIFT
+
+int __init
+init_ext3_xattr(void)
+{
+	ext3_xattr_cache = mb_cache_create("ext3_xattr", NULL,
+		sizeof(struct mb_cache_entry) +
+		sizeof(struct mb_cache_entry_index), 1, 61);
+	if (!ext3_xattr_cache)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void
+exit_ext3_xattr(void)
+{
+	if (ext3_xattr_cache)
+		mb_cache_destroy(ext3_xattr_cache);
+	ext3_xattr_cache = NULL;
+}
+
+#else  /* CONFIG_EXT3_FS_XATTR_SHARING */
+
+int __init
+init_ext3_xattr(void)
+{
+	return 0;
+}
+
+void
+exit_ext3_xattr(void)
+{
+}
+
+#endif  /* CONFIG_EXT3_FS_XATTR_SHARING */
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/fs/ext3/xattr_user.c	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,111 @@
+/*
+ * linux/fs/ext3/xattr_user.c
+ * Handler for extended user attributes.
+ *
+ * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fs.h>
+#include <linux/ext3_jbd.h>
+#include <linux/ext3_fs.h>
+#include <linux/ext3_xattr.h>
+
+#ifdef CONFIG_EXT3_FS_POSIX_ACL
+# include <linux/ext3_acl.h>
+#endif
+
+#define XATTR_USER_PREFIX "user."
+
+static size_t
+ext3_xattr_user_list(char *list, struct inode *inode,
+		     const char *name, int name_len)
+{
+	const int prefix_len = sizeof(XATTR_USER_PREFIX)-1;
+
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return 0;
+
+	if (list) {
+		memcpy(list, XATTR_USER_PREFIX, prefix_len);
+		memcpy(list+prefix_len, name, name_len);
+		list[prefix_len + name_len] = '\0';
+	}
+	return prefix_len + name_len + 1;
+}
+
+static int
+ext3_xattr_user_get(struct inode *inode, const char *name,
+		    void *buffer, size_t size)
+{
+	int error;
+
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return -ENOTSUP;
+#ifdef CONFIG_EXT3_FS_POSIX_ACL
+	error = ext3_permission_locked(inode, MAY_READ);
+#else
+	error = permission(inode, MAY_READ);
+#endif
+	if (error)
+		return error;
+
+	return ext3_xattr_get(inode, EXT3_XATTR_INDEX_USER, name,
+			      buffer, size);
+}
+
+static int
+ext3_xattr_user_set(struct inode *inode, const char *name,
+		    const void *value, size_t size, int flags)
+{
+	handle_t *handle;
+	int error;
+
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return -ENOTSUP;
+	if ( !S_ISREG(inode->i_mode) &&
+	    (!S_ISDIR(inode->i_mode) || inode->i_mode & S_ISVTX))
+		return -EPERM;
+#ifdef CONFIG_EXT3_FS_POSIX_ACL
+	error = ext3_permission_locked(inode, MAY_WRITE);
+#else
+	error = permission(inode, MAY_WRITE);
+#endif
+	if (error)
+		return error;
+  
+	handle = ext3_journal_start(inode, EXT3_XATTR_TRANS_BLOCKS);
+	if (IS_ERR(handle))
+		return PTR_ERR(handle);
+	error = ext3_xattr_set(handle, inode, EXT3_XATTR_INDEX_USER, name,
+			       value, size, flags);
+	ext3_journal_stop(handle, inode);
+
+	return error;
+}
+
+struct ext3_xattr_handler ext3_xattr_user_handler = {
+	prefix:	XATTR_USER_PREFIX,
+	list:	ext3_xattr_user_list,
+	get:	ext3_xattr_user_get,
+	set:	ext3_xattr_user_set,
+};
+
+int __init
+init_ext3_xattr_user(void)
+{
+	return ext3_xattr_register(EXT3_XATTR_INDEX_USER,
+				   &ext3_xattr_user_handler);
+}
+
+void
+exit_ext3_xattr_user(void)
+{
+	ext3_xattr_unregister(EXT3_XATTR_INDEX_USER,
+			      &ext3_xattr_user_handler);
+}
--- linux-2.4.20-hp4_pnnl1/fs/jfs/jfs_xattr.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/jfs/jfs_xattr.h	2003-04-09 17:21:01.000000000 -0600
@@ -52,8 +52,10 @@ struct jfs_ea_list {
 #define	END_EALIST(ealist) \
 	((struct jfs_ea *) (((char *) (ealist)) + EALIST_SIZE(ealist)))
 
-extern int __jfs_setxattr(struct inode *, const char *, void *, size_t, int);
-extern int jfs_setxattr(struct dentry *, const char *, void *, size_t, int);
+extern int __jfs_setxattr(struct inode *, const char *, const void *, size_t,
+			  int);
+extern int jfs_setxattr(struct dentry *, const char *, const void *, size_t,
+			int);
 extern ssize_t __jfs_getxattr(struct inode *, const char *, void *, size_t);
 extern ssize_t jfs_getxattr(struct dentry *, const char *, void *, size_t);
 extern ssize_t jfs_listxattr(struct dentry *, char *, size_t);
--- linux-2.4.20-hp4_pnnl1/fs/jfs/xattr.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/fs/jfs/xattr.c	2003-04-09 17:21:01.000000000 -0600
@@ -641,7 +641,7 @@ static int ea_put(struct inode *inode, s
 }
 
 static int can_set_xattr(struct inode *inode, const char *name,
-			 void *value, size_t value_len)
+			 const void *value, size_t value_len)
 {
 	if (IS_RDONLY(inode))
 		return -EROFS;
@@ -660,7 +660,7 @@ static int can_set_xattr(struct inode *i
 	return permission(inode, MAY_WRITE);
 }
 
-int __jfs_setxattr(struct inode *inode, const char *name, void *value,
+int __jfs_setxattr(struct inode *inode, const char *name, const void *value,
 		   size_t value_len, int flags)
 {
 	struct jfs_ea_list *ealist;
@@ -799,7 +799,7 @@ int __jfs_setxattr(struct inode *inode, 
 	return rc;
 }
 
-int jfs_setxattr(struct dentry *dentry, const char *name, void *value,
+int jfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		 size_t value_len, int flags)
 {
 	if (value == NULL) {	/* empty EA, do not remove */
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/fs/mbcache.c	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,648 @@
+/*
+ * linux/fs/mbcache.c
+ * (C) 2001-2002 Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ */
+
+/*
+ * Filesystem Meta Information Block Cache (mbcache)
+ *
+ * The mbcache caches blocks of block devices that need to be located
+ * by their device/block number, as well as by other criteria (such
+ * as the block's contents).
+ *
+ * There can only be one cache entry in a cache per device and block number.
+ * Additional indexes need not be unique in this sense. The number of
+ * additional indexes (=other criteria) can be hardwired at compile time
+ * or specified at cache create time.
+ *
+ * Each cache entry is of fixed size. An entry may be `valid' or `invalid'
+ * in the cache. A valid entry is in the main hash tables of the cache,
+ * and may also be in the lru list. An invalid entry is not in any hashes
+ * or lists.
+ *
+ * A valid cache entry is only in the lru list if no handles refer to it.
+ * Invalid cache entries will be freed when the last handle to the cache
+ * entry is released. Entries that cannot be freed immediately are put
+ * back on the lru list.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/cache_def.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/mbcache.h>
+
+
+#ifdef MB_CACHE_DEBUG
+# define mb_debug(f...) do { \
+		printk(KERN_DEBUG f); \
+		printk("\n"); \
+	} while (0)
+#define mb_assert(c) do { if (!(c)) \
+		printk(KERN_ERR "assertion " #c " failed\n"); \
+	} while(0)
+#else
+# define mb_debug(f...) do { } while(0)
+# define mb_assert(c) do { } while(0)
+#endif
+#define mb_error(f...) do { \
+		printk(KERN_ERR f); \
+		printk("\n"); \
+	} while(0)
+		
+MODULE_AUTHOR("Andreas Gruenbacher <a.gruenbacher@computer.org>");
+MODULE_DESCRIPTION("Meta block cache (for extended attributes)");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+MODULE_LICENSE("GPL");
+#endif
+
+EXPORT_SYMBOL(mb_cache_create);
+EXPORT_SYMBOL(mb_cache_shrink);
+EXPORT_SYMBOL(mb_cache_destroy);
+EXPORT_SYMBOL(mb_cache_entry_alloc);
+EXPORT_SYMBOL(mb_cache_entry_insert);
+EXPORT_SYMBOL(mb_cache_entry_release);
+EXPORT_SYMBOL(mb_cache_entry_takeout);
+EXPORT_SYMBOL(mb_cache_entry_free);
+EXPORT_SYMBOL(mb_cache_entry_dup);
+EXPORT_SYMBOL(mb_cache_entry_get);
+#if !defined(MB_CACHE_INDEXES_COUNT) || (MB_CACHE_INDEXES_COUNT > 0)
+EXPORT_SYMBOL(mb_cache_entry_find_first);
+EXPORT_SYMBOL(mb_cache_entry_find_next);
+#endif
+
+
+/*
+ * Global data: list of all mbcache's, lru list, and a spinlock for
+ * accessing cache data structures on SMP machines. The lru list is
+ * global across all mbcaches.
+ */
+
+static LIST_HEAD(mb_cache_list);
+static LIST_HEAD(mb_cache_lru_list);
+static spinlock_t mb_cache_spinlock = SPIN_LOCK_UNLOCKED;
+
+static inline int
+mb_cache_indexes(struct mb_cache *cache)
+{
+#ifdef MB_CACHE_INDEXES_COUNT
+	return MB_CACHE_INDEXES_COUNT;
+#else
+	return cache->c_indexes_count;
+#endif
+}
+
+/*
+ * What the mbcache registers as to get shrunk dynamically.
+ */
+
+static void
+mb_cache_memory_pressure(int priority, unsigned int gfp_mask);
+
+static struct cache_definition mb_cache_definition = {
+	"mb_cache",
+	mb_cache_memory_pressure
+};
+
+
+static inline int
+__mb_cache_entry_is_hashed(struct mb_cache_entry *ce)
+{
+	return !list_empty(&ce->e_block_list);
+}
+
+
+static inline void
+__mb_cache_entry_unhash(struct mb_cache_entry *ce)
+{
+	int n;
+
+	if (__mb_cache_entry_is_hashed(ce)) {
+		list_del_init(&ce->e_block_list);
+		for (n=0; n<mb_cache_indexes(ce->e_cache); n++)
+			list_del(&ce->e_indexes[n].o_list);
+	}
+}
+
+
+static inline void
+__mb_cache_entry_forget(struct mb_cache_entry *ce, int gfp_mask)
+{
+	struct mb_cache *cache = ce->e_cache;
+
+	mb_assert(atomic_read(&ce->e_used) == 0);
+	if (cache->c_op.free && cache->c_op.free(ce, gfp_mask)) {
+		/* free failed -- put back on the lru list
+		   for freeing later. */
+		spin_lock(&mb_cache_spinlock);
+		list_add(&ce->e_lru_list, &mb_cache_lru_list);
+		spin_unlock(&mb_cache_spinlock);
+	} else {
+		kmem_cache_free(cache->c_entry_cache, ce);
+		atomic_dec(&cache->c_entry_count);
+	}
+}
+
+
+static inline void
+__mb_cache_entry_release_unlock(struct mb_cache_entry *ce)
+{
+	if (atomic_dec_and_test(&ce->e_used)) {
+		if (__mb_cache_entry_is_hashed(ce))
+			list_add_tail(&ce->e_lru_list, &mb_cache_lru_list);
+		else {
+			spin_unlock(&mb_cache_spinlock);
+			__mb_cache_entry_forget(ce, GFP_KERNEL);
+			return;
+		}
+	}
+	spin_unlock(&mb_cache_spinlock);
+}
+
+
+/*
+ * mb_cache_memory_pressure()  memory pressure callback
+ *
+ * This function is called by the kernel memory management when memory
+ * gets low.
+ *
+ * @priority: Amount by which to shrink the cache (0 = highes priority)
+ * @gfp_mask: (ignored)
+ */
+static void
+mb_cache_memory_pressure(int priority, unsigned int gfp_mask)
+{
+	LIST_HEAD(free_list);
+	struct list_head *l, *ltmp;
+	int count = 0;
+
+	spin_lock(&mb_cache_spinlock);
+	list_for_each(l, &mb_cache_list) {
+		struct mb_cache *cache =
+			list_entry(l, struct mb_cache, c_cache_list);
+		mb_debug("cache %s (%d)", cache->c_name,
+			  atomic_read(&cache->c_entry_count));
+		count += atomic_read(&cache->c_entry_count);
+	}
+	mb_debug("trying to free %d of %d entries",
+		  count / (priority ? priority : 1), count);
+	if (priority)
+		count /= priority;
+	while (count-- && !list_empty(&mb_cache_lru_list)) {
+		struct mb_cache_entry *ce =
+			list_entry(mb_cache_lru_list.next,
+				   struct mb_cache_entry, e_lru_list);
+		list_del(&ce->e_lru_list);
+		__mb_cache_entry_unhash(ce);
+		list_add_tail(&ce->e_lru_list, &free_list);
+	}
+	spin_unlock(&mb_cache_spinlock);
+	list_for_each_safe(l, ltmp, &free_list) {
+		__mb_cache_entry_forget(list_entry(l, struct mb_cache_entry,
+						   e_lru_list), gfp_mask);
+	}
+}
+
+
+/*
+ * mb_cache_create()  create a new cache
+ *
+ * All entries in one cache are equal size. Cache entries may be from
+ * multiple devices. If this is the first mbcache created, registers
+ * the cache with kernel memory management. Returns NULL if no more
+ * memory was available.
+ *
+ * @name: name of the cache (informal)
+ * @cache_op: contains the callback called when freeing a cache entry
+ * @entry_size: The size of a cache entry, including
+ *              struct mb_cache_entry
+ * @indexes_count: number of additional indexes in the cache. Must equal
+ *                 MB_CACHE_INDEXES_COUNT if the number of indexes is
+ *                 hardwired.
+ * @bucket_count: number of hash buckets
+ */
+struct mb_cache *
+mb_cache_create(const char *name, struct mb_cache_op *cache_op,
+		size_t entry_size, int indexes_count, int bucket_count)
+{
+	int m=0, n;
+	struct mb_cache *cache = NULL;
+
+	if(entry_size < sizeof(struct mb_cache_entry) +
+	   indexes_count * sizeof(struct mb_cache_entry_index))
+		return NULL;
+
+	MOD_INC_USE_COUNT;
+	cache = kmalloc(sizeof(struct mb_cache) +
+	                indexes_count * sizeof(struct list_head), GFP_KERNEL);
+	if (!cache)
+		goto fail;
+	cache->c_name = name;
+	cache->c_op.free = NULL;
+	if (cache_op)
+		cache->c_op.free = cache_op->free;
+	atomic_set(&cache->c_entry_count, 0);
+	cache->c_bucket_count = bucket_count;
+#ifdef MB_CACHE_INDEXES_COUNT
+	mb_assert(indexes_count == MB_CACHE_INDEXES_COUNT);
+#else
+	cache->c_indexes_count = indexes_count;
+#endif
+	cache->c_block_hash = kmalloc(bucket_count * sizeof(struct list_head),
+	                              GFP_KERNEL);
+	if (!cache->c_block_hash)
+		goto fail;
+	for (n=0; n<bucket_count; n++)
+		INIT_LIST_HEAD(&cache->c_block_hash[n]);
+	for (m=0; m<indexes_count; m++) {
+		cache->c_indexes_hash[m] = kmalloc(bucket_count *
+		                                 sizeof(struct list_head),
+		                                 GFP_KERNEL);
+		if (!cache->c_indexes_hash[m])
+			goto fail;
+		for (n=0; n<bucket_count; n++)
+			INIT_LIST_HEAD(&cache->c_indexes_hash[m][n]);
+	}
+	cache->c_entry_cache = kmem_cache_create(name, entry_size, 0,
+		0 /*SLAB_POISON | SLAB_RED_ZONE*/, NULL, NULL);
+	if (!cache->c_entry_cache)
+		goto fail;
+
+	spin_lock(&mb_cache_spinlock);
+	list_add(&cache->c_cache_list, &mb_cache_list);
+	spin_unlock(&mb_cache_spinlock);
+	return cache;
+
+fail:
+	if (cache) {
+		while (--m >= 0)
+			kfree(cache->c_indexes_hash[m]);
+		if (cache->c_block_hash)
+			kfree(cache->c_block_hash);
+		kfree(cache);
+	}
+	MOD_DEC_USE_COUNT;
+	return NULL;
+}
+
+
+/*
+ * mb_cache_shrink()
+ *
+ * Removes all cache entires of a device from the cache. All cache entries
+ * currently in use cannot be freed, and thus remain in the cache.
+ *
+ * @cache: which cache to shrink
+ * @dev: which device's cache entries to shrink
+ */
+void
+mb_cache_shrink(struct mb_cache *cache, kdev_t dev)
+{
+	LIST_HEAD(free_list);
+	struct list_head *l, *ltmp;
+
+	spin_lock(&mb_cache_spinlock);
+	list_for_each_safe(l, ltmp, &mb_cache_lru_list) {
+		struct mb_cache_entry *ce =
+			list_entry(l, struct mb_cache_entry, e_lru_list);
+		if (ce->e_dev == dev) {
+			list_del(&ce->e_lru_list);
+			list_add_tail(&ce->e_lru_list, &free_list);
+			__mb_cache_entry_unhash(ce);
+		}
+	}
+	spin_unlock(&mb_cache_spinlock);
+	list_for_each_safe(l, ltmp, &free_list) {
+		__mb_cache_entry_forget(list_entry(l, struct mb_cache_entry,
+						   e_lru_list), GFP_KERNEL);
+	}
+}
+
+
+/*
+ * mb_cache_destroy()
+ *
+ * Shrinks the cache to its minimum possible size (hopefully 0 entries),
+ * and then destroys it. If this was the last mbcache, un-registers the
+ * mbcache from kernel memory management.
+ */
+void
+mb_cache_destroy(struct mb_cache *cache)
+{
+	LIST_HEAD(free_list);
+	struct list_head *l, *ltmp;
+	int n;
+
+	spin_lock(&mb_cache_spinlock);
+	list_for_each_safe(l, ltmp, &mb_cache_lru_list) {
+		struct mb_cache_entry *ce =
+			list_entry(l, struct mb_cache_entry, e_lru_list);
+		if (ce->e_cache == cache) {
+			list_del(&ce->e_lru_list);
+			list_add_tail(&ce->e_lru_list, &free_list);
+			__mb_cache_entry_unhash(ce);
+		}
+	}
+	list_del(&cache->c_cache_list);
+	spin_unlock(&mb_cache_spinlock);
+	list_for_each_safe(l, ltmp, &free_list) {
+		__mb_cache_entry_forget(list_entry(l, struct mb_cache_entry,
+						   e_lru_list), GFP_KERNEL);
+	}
+
+	if (atomic_read(&cache->c_entry_count) > 0) {
+		mb_error("cache %s: %d orphaned entries",
+			  cache->c_name,
+			  atomic_read(&cache->c_entry_count));
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+	/* We don't have kmem_cache_destroy() in 2.2.x */
+	kmem_cache_shrink(cache->c_entry_cache);
+#else
+	kmem_cache_destroy(cache->c_entry_cache);
+#endif
+	for (n=0; n < mb_cache_indexes(cache); n++)
+		kfree(cache->c_indexes_hash[n]);
+	kfree(cache->c_block_hash);
+	kfree(cache);
+
+	MOD_DEC_USE_COUNT;
+}
+
+
+/*
+ * mb_cache_entry_alloc()
+ *
+ * Allocates a new cache entry. The new entry will not be valid initially,
+ * and thus cannot be looked up yet. It should be filled with data, and
+ * then inserted into the cache using mb_cache_entry_insert(). Returns NULL
+ * if no more memory was available.
+ */
+struct mb_cache_entry *
+mb_cache_entry_alloc(struct mb_cache *cache)
+{
+	struct mb_cache_entry *ce;
+
+	atomic_inc(&cache->c_entry_count);
+	ce = kmem_cache_alloc(cache->c_entry_cache, GFP_KERNEL);
+	if (ce) {
+		INIT_LIST_HEAD(&ce->e_lru_list);
+		INIT_LIST_HEAD(&ce->e_block_list);
+		ce->e_cache = cache;
+		atomic_set(&ce->e_used, 1);
+	}
+	return ce;
+}
+
+
+/*
+ * mb_cache_entry_insert()
+ *
+ * Inserts an entry that was allocated using mb_cache_entry_alloc() into
+ * the cache. After this, the cache entry can be looked up, but is not yet
+ * in the lru list as the caller still holds a handle to it. Returns 0 on
+ * success, or -EBUSY if a cache entry for that device + inode exists
+ * already (this may happen after a failed lookup, if another process has
+ * inserted the same cache entry in the meantime).
+ *
+ * @dev: device the cache entry belongs to
+ * @block: block number
+ * @keys: array of additional keys. There must be indexes_count entries
+ *        in the array (as specified when creating the cache).
+ */
+int
+mb_cache_entry_insert(struct mb_cache_entry *ce, kdev_t dev,
+		      unsigned long block, unsigned int keys[])
+{
+	struct mb_cache *cache = ce->e_cache;
+	unsigned int bucket = (HASHDEV(dev) + block) % cache->c_bucket_count;
+	struct list_head *l;
+	int error = -EBUSY, n;
+
+	spin_lock(&mb_cache_spinlock);
+	list_for_each(l, &cache->c_block_hash[bucket]) {
+		struct mb_cache_entry *ce =
+			list_entry(l, struct mb_cache_entry, e_block_list);
+		if (ce->e_dev == dev && ce->e_block == block)
+			goto out;
+	}
+	__mb_cache_entry_unhash(ce);
+	ce->e_dev = dev;
+	ce->e_block = block;
+	list_add(&ce->e_block_list, &cache->c_block_hash[bucket]);
+	for (n=0; n<mb_cache_indexes(cache); n++) {
+		ce->e_indexes[n].o_key = keys[n];
+		bucket = keys[n] % cache->c_bucket_count;
+		list_add(&ce->e_indexes[n].o_list,
+		         &cache->c_indexes_hash[n][bucket]);
+	}
+out:
+	spin_unlock(&mb_cache_spinlock);
+	return error;
+}
+
+
+/*
+ * mb_cache_entry_release()
+ *
+ * Release a handle to a cache entry. When the last handle to a cache entry
+ * is released it is either freed (if it is invalid) or otherwise inserted
+ * in to the lru list.
+ */
+void
+mb_cache_entry_release(struct mb_cache_entry *ce)
+{
+	spin_lock(&mb_cache_spinlock);
+	__mb_cache_entry_release_unlock(ce);
+}
+
+
+/*
+ * mb_cache_entry_takeout()
+ *
+ * Take a cache entry out of the cache, making it invalid. The entry can later
+ * be re-inserted using mb_cache_entry_insert(), or released using
+ * mb_cache_entry_release().
+ */
+void
+mb_cache_entry_takeout(struct mb_cache_entry *ce)
+{
+	spin_lock(&mb_cache_spinlock);
+	mb_assert(list_empty(&ce->e_lru_list));
+	__mb_cache_entry_unhash(ce);
+	spin_unlock(&mb_cache_spinlock);
+}
+
+
+/*
+ * mb_cache_entry_free()
+ *
+ * This is equivalent to the sequence mb_cache_entry_takeout() --
+ * mb_cache_entry_release().
+ */
+void
+mb_cache_entry_free(struct mb_cache_entry *ce)
+{
+	spin_lock(&mb_cache_spinlock);
+	mb_assert(list_empty(&ce->e_lru_list));
+	__mb_cache_entry_unhash(ce);
+	__mb_cache_entry_release_unlock(ce);
+}
+
+
+/*
+ * mb_cache_entry_dup()
+ *
+ * Duplicate a handle to a cache entry (does not duplicate the cache entry
+ * itself). After the call, both the old and the new handle must be released.
+ */
+struct mb_cache_entry *
+mb_cache_entry_dup(struct mb_cache_entry *ce)
+{
+	atomic_inc(&ce->e_used);
+	return ce;
+}
+
+
+/*
+ * mb_cache_entry_get()
+ *
+ * Get a cache entry  by device / block number. (There can only be one entry
+ * in the cache per device and block.) Returns NULL if no such cache entry
+ * exists.
+ */
+struct mb_cache_entry *
+mb_cache_entry_get(struct mb_cache *cache, kdev_t dev, unsigned long block)
+{
+	unsigned int bucket = (HASHDEV(dev) + block) % cache->c_bucket_count;
+	struct list_head *l;
+	struct mb_cache_entry *ce;
+
+	spin_lock(&mb_cache_spinlock);
+	list_for_each(l, &cache->c_block_hash[bucket]) {
+		ce = list_entry(l, struct mb_cache_entry, e_block_list);
+		if (ce->e_dev == dev && ce->e_block == block) {
+			if (!list_empty(&ce->e_lru_list))
+				list_del_init(&ce->e_lru_list);
+			atomic_inc(&ce->e_used);
+			goto cleanup;
+		}
+	}
+	ce = NULL;
+
+cleanup:
+	spin_unlock(&mb_cache_spinlock);
+	return ce;
+}
+
+#if !defined(MB_CACHE_INDEXES_COUNT) || (MB_CACHE_INDEXES_COUNT > 0)
+
+static struct mb_cache_entry *
+__mb_cache_entry_find(struct list_head *l, struct list_head *head,
+		      int index, kdev_t dev, unsigned int key)
+{
+	while (l != head) {
+		struct mb_cache_entry *ce =
+			list_entry(l, struct mb_cache_entry,
+			           e_indexes[index].o_list);
+		if (ce->e_dev == dev && ce->e_indexes[index].o_key == key) {
+			if (!list_empty(&ce->e_lru_list))
+				list_del_init(&ce->e_lru_list);
+			atomic_inc(&ce->e_used);
+			return ce;
+		}
+		l = l->next;
+	}
+	return NULL;
+}
+
+
+/*
+ * mb_cache_entry_find_first()
+ *
+ * Find the first cache entry on a given device with a certain key in
+ * an additional index. Additonal matches can be found with
+ * mb_cache_entry_find_next(). Returns NULL if no match was found.
+ *
+ * @cache: the cache to search
+ * @index: the number of the additonal index to search (0<=index<indexes_count)
+ * @dev: the device the cache entry should belong to
+ * @key: the key in the index
+ */
+struct mb_cache_entry *
+mb_cache_entry_find_first(struct mb_cache *cache, int index, kdev_t dev,
+			  unsigned int key)
+{
+	unsigned int bucket = key % cache->c_bucket_count;
+	struct list_head *l;
+	struct mb_cache_entry *ce;
+
+	mb_assert(index < mb_cache_indexes(cache));
+	spin_lock(&mb_cache_spinlock);
+	l = cache->c_indexes_hash[index][bucket].next;
+	ce = __mb_cache_entry_find(l, &cache->c_indexes_hash[index][bucket],
+	                           index, dev, key);
+	spin_unlock(&mb_cache_spinlock);
+	return ce;
+}
+
+
+/*
+ * mb_cache_entry_find_next()
+ *
+ * Find the next cache entry on a given device with a certain key in an
+ * additional index. Returns NULL if no match could be found. The previous
+ * entry is atomatically released, so that mb_cache_entry_find_next() can
+ * be called like this:
+ *
+ * entry = mb_cache_entry_find_first();
+ * while (entry) {
+ * 	...
+ *	entry = mb_cache_entry_find_next(entry, ...);
+ * }
+ *
+ * @prev: The previous match
+ * @index: the number of the additonal index to search (0<=index<indexes_count)
+ * @dev: the device the cache entry should belong to
+ * @key: the key in the index
+ */
+struct mb_cache_entry *
+mb_cache_entry_find_next(struct mb_cache_entry *prev, int index, kdev_t dev,
+			 unsigned int key)
+{
+	struct mb_cache *cache = prev->e_cache;
+	unsigned int bucket = key % cache->c_bucket_count;
+	struct list_head *l;
+	struct mb_cache_entry *ce;
+
+	mb_assert(index < mb_cache_indexes(cache));
+	spin_lock(&mb_cache_spinlock);
+	l = prev->e_indexes[index].o_list.next;
+	ce = __mb_cache_entry_find(l, &cache->c_indexes_hash[index][bucket],
+	                           index, dev, key);
+	__mb_cache_entry_release_unlock(prev);
+	return ce;
+}
+
+#endif  /* !defined(MB_CACHE_INDEXES_COUNT) || (MB_CACHE_INDEXES_COUNT > 0) */
+
+static int __init init_mbcache(void)
+{
+	register_cache(&mb_cache_definition);
+	return 0;
+}
+
+static void __exit exit_mbcache(void)
+{
+	unregister_cache(&mb_cache_definition);
+}
+
+module_init(init_mbcache)
+module_exit(exit_mbcache)
+
--- linux-2.4.20-hp4_pnnl1/include/asm-arm/unistd.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/asm-arm/unistd.h	2003-04-09 17:21:01.000000000 -0600
@@ -244,7 +244,6 @@
 #define __NR_security			(__NR_SYSCALL_BASE+223)
 #define __NR_gettid			(__NR_SYSCALL_BASE+224)
 #define __NR_readahead			(__NR_SYSCALL_BASE+225)
-#if 0 /* allocated in 2.5 */
 #define __NR_setxattr			(__NR_SYSCALL_BASE+226)
 #define __NR_lsetxattr			(__NR_SYSCALL_BASE+227)
 #define __NR_fsetxattr			(__NR_SYSCALL_BASE+228)
@@ -257,7 +256,6 @@
 #define __NR_removexattr		(__NR_SYSCALL_BASE+235)
 #define __NR_lremovexattr		(__NR_SYSCALL_BASE+236)
 #define __NR_fremovexattr		(__NR_SYSCALL_BASE+237)
-#endif
 #define __NR_tkill			(__NR_SYSCALL_BASE+238)
 /*
  * Please check 2.5 _before_ adding calls here,
--- linux-2.4.20-hp4_pnnl1/include/asm-ppc64/unistd.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/asm-ppc64/unistd.h	2003-04-09 17:21:01.000000000 -0600
@@ -218,6 +218,7 @@
 #define __NR_gettid		207
 #if 0 /* Reserved syscalls */
 #define __NR_tkill		208
+#endif
 #define __NR_setxattr		209
 #define __NR_lsetxattr		210
 #define __NR_fsetxattr		211
@@ -230,6 +231,7 @@
 #define __NR_removexattr	218
 #define __NR_lremovexattr	219
 #define __NR_fremovexattr	220
+#if 0 /* Reserved syscalls */
 #define __NR_futex		221
 #endif
 
--- linux-2.4.20-hp4_pnnl1/include/asm-s390/unistd.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/asm-s390/unistd.h	2003-04-09 17:21:01.000000000 -0600
@@ -212,9 +212,18 @@
 #define __NR_madvise            219
 #define __NR_getdents64		220
 #define __NR_fcntl64		221
-/*
- * Numbers 224-235 are reserved for posix acl
- */
+#define __NR_setxattr		224
+#define __NR_lsetxattr		225
+#define __NR_fsetxattr		226
+#define __NR_getxattr		227
+#define __NR_lgetxattr		228
+#define __NR_fgetxattr		229
+#define __NR_listxattr		230
+#define __NR_llistxattr		231
+#define __NR_flistxattr		232
+#define __NR_removexattr	233
+#define __NR_lremovexattr	234
+#define __NR_fremovexattr	235
 #define __NR_gettid		236
 #define __NR_tkill		237
 
--- linux-2.4.20-hp4_pnnl1/include/asm-s390x/unistd.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/asm-s390x/unistd.h	2003-04-09 17:21:01.000000000 -0600
@@ -180,9 +180,18 @@
 #define __NR_pivot_root         217
 #define __NR_mincore            218
 #define __NR_madvise            219
-/*
- * Numbers 224-235 are reserved for posix acl
- */
+#define __NR_setxattr		224
+#define __NR_lsetxattr		225
+#define __NR_fsetxattr		226
+#define __NR_getxattr		227
+#define __NR_lgetxattr		228
+#define __NR_fgetxattr		229
+#define __NR_listxattr		230
+#define __NR_llistxattr		231
+#define __NR_flistxattr		232
+#define __NR_removexattr	233
+#define __NR_lremovexattr	234
+#define __NR_fremovexattr	235
 #define __NR_gettid		236
 #define __NR_tkill		237
 
--- linux-2.4.20-hp4_pnnl1/include/asm-sparc/unistd.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/asm-sparc/unistd.h	2003-04-09 17:21:01.000000000 -0600
@@ -184,24 +184,24 @@
 /* #define __NR_exportfs        166    SunOS Specific                              */
 #define __NR_mount              167 /* Common                                      */
 #define __NR_ustat              168 /* Common                                      */
-/* #define __NR_semsys          169    SunOS Specific                              */
-/* #define __NR_msgsys          170    SunOS Specific                              */
-/* #define __NR_shmsys          171    SunOS Specific                              */
-/* #define __NR_auditsys        172    SunOS Specific                              */
-/* #define __NR_rfssys          173    SunOS Specific                              */
+#define __NR_setxattr           169 /* SunOS: semsys                               */
+#define __NR_lsetxattr          170 /* SunOS: msgsys                               */
+#define __NR_fsetxattr          171 /* SunOS: shmsys                               */
+#define __NR_getxattr           172 /* SunOS: auditsys                             */
+#define __NR_lgetxattr          173 /* SunOS: rfssys                               */
 #define __NR_getdents           174 /* Common                                      */
 #define __NR_setsid             175 /* Common                                      */
 #define __NR_fchdir             176 /* Common                                      */
-/* #define __NR_fchroot         177    SunOS Specific                              */
-/* #define __NR_vpixsys         178    SunOS Specific                              */
-/* #define __NR_aioread         179    SunOS Specific                              */
-/* #define __NR_aiowrite        180    SunOS Specific                              */
-/* #define __NR_aiowait         181    SunOS Specific                              */
-/* #define __NR_aiocancel       182    SunOS Specific                              */
+#define __NR_fgetxattr          177 /* SunOS: fchroot                              */
+#define __NR_listxattr          178 /* SunOS: vpixsys                              */
+#define __NR_llistxattr         179 /* SunOS: aioread                              */
+#define __NR_flistxattr         180 /* SunOS: aiowrite                             */
+#define __NR_removexattr        181 /* SunOS: aiowait                              */
+#define __NR_lremovexattr       182 /* SunOS: aiocancel                            */
 #define __NR_sigpending         183 /* Common                                      */
 #define __NR_query_module	184 /* Linux Specific				   */
 #define __NR_setpgid            185 /* Common                                      */
-/* #define __NR_pathconf        186    SunOS Specific                              */
+#define __NR_fremovexattr       186 /* SunOS: pathconf                             */
 #define __NR_tkill              187 /* SunOS: fpathconf                            */
 /* #define __NR_sysconf         188    SunOS Specific                              */
 #define __NR_uname              189 /* Linux Specific                              */
--- linux-2.4.20-hp4_pnnl1/include/asm-sparc64/unistd.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/asm-sparc64/unistd.h	2003-04-09 17:21:01.000000000 -0600
@@ -184,24 +184,24 @@
 /* #define __NR_exportfs        166    SunOS Specific                              */
 #define __NR_mount              167 /* Common                                      */
 #define __NR_ustat              168 /* Common                                      */
-/* #define __NR_semsys          169    SunOS Specific                              */
-/* #define __NR_msgsys          170    SunOS Specific                              */
-/* #define __NR_shmsys          171    SunOS Specific                              */
-/* #define __NR_auditsys        172    SunOS Specific                              */
-/* #define __NR_rfssys          173    SunOS Specific                              */
+#define __NR_setxattr           169 /* SunOS: semsys                               */
+#define __NR_lsetxattr          170 /* SunOS: msgsys                               */
+#define __NR_fsetxattr          171 /* SunOS: shmsys                               */
+#define __NR_getxattr           172 /* SunOS: auditsys                             */
+#define __NR_lgetxattr          173 /* SunOS: rfssys                               */
 #define __NR_getdents           174 /* Common                                      */
 #define __NR_setsid             175 /* Common                                      */
 #define __NR_fchdir             176 /* Common                                      */
-/* #define __NR_fchroot         177    SunOS Specific                              */
-/* #define __NR_vpixsys         178    SunOS Specific                              */
-/* #define __NR_aioread         179    SunOS Specific                              */
-/* #define __NR_aiowrite        180    SunOS Specific                              */
-/* #define __NR_aiowait         181    SunOS Specific                              */
-/* #define __NR_aiocancel       182    SunOS Specific                              */
+#define __NR_fgetxattr          177 /* SunOS: fchroot                              */
+#define __NR_listxattr          178 /* SunOS: vpixsys                              */
+#define __NR_llistxattr         179 /* SunOS: aioread                              */
+#define __NR_flistxattr         180 /* SunOS: aiowrite                             */
+#define __NR_removexattr        181 /* SunOS: aiowait                              */
+#define __NR_lremovexattr       182 /* SunOS: aiocancel                            */
 #define __NR_sigpending         183 /* Common                                      */
 #define __NR_query_module	184 /* Linux Specific				   */
 #define __NR_setpgid            185 /* Common                                      */
-/* #define __NR_pathconf        186    SunOS Specific                              */
+#define __NR_fremovexattr       186 /* SunOS: pathconf                             */
 #define __NR_tkill              187 /* SunOS: fpathconf                            */
 /* #define __NR_sysconf         188    SunOS Specific                              */
 #define __NR_uname              189 /* Linux Specific                              */
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/cache_def.h	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,15 @@
+/*
+ * linux/cache_def.h
+ * Handling of caches defined in drivers, filesystems, ...
+ *
+ * Copyright (C) 2002 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ */
+
+struct cache_definition {
+	const char *name;
+	void (*shrink)(int, unsigned int);
+	struct list_head link;
+};
+
+extern void register_cache(struct cache_definition *);
+extern void unregister_cache(struct cache_definition *);
--- linux-2.4.20-hp4_pnnl1/include/linux/errno.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/errno.h	2003-04-09 17:21:01.000000000 -0600
@@ -23,4 +23,8 @@
 
 #endif
 
+/* Defined for extended attributes */
+#define ENOATTR ENODATA		/* No such attribute */
+#define ENOTSUP EOPNOTSUPP	/* Operation not supported */
+
 #endif
--- linux-2.4.20-hp4_pnnl1/include/linux/ext2_fs.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/ext2_fs.h	2003-04-09 17:21:01.000000000 -0600
@@ -57,8 +57,6 @@
  */
 #define	EXT2_BAD_INO		 1	/* Bad blocks inode */
 #define EXT2_ROOT_INO		 2	/* Root inode */
-#define EXT2_ACL_IDX_INO	 3	/* ACL inode */
-#define EXT2_ACL_DATA_INO	 4	/* ACL inode */
 #define EXT2_BOOT_LOADER_INO	 5	/* Boot loader inode */
 #define EXT2_UNDEL_DIR_INO	 6	/* Undelete directory inode */
 
@@ -86,7 +84,6 @@
 #else
 # define EXT2_BLOCK_SIZE(s)		(EXT2_MIN_BLOCK_SIZE << (s)->s_log_block_size)
 #endif
-#define EXT2_ACLE_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (struct ext2_acl_entry))
 #define	EXT2_ADDR_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (__u32))
 #ifdef __KERNEL__
 # define EXT2_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
@@ -121,28 +118,6 @@
 #endif
 
 /*
- * ACL structures
- */
-struct ext2_acl_header	/* Header of Access Control Lists */
-{
-	__u32	aclh_size;
-	__u32	aclh_file_count;
-	__u32	aclh_acle_count;
-	__u32	aclh_first_acle;
-};
-
-struct ext2_acl_entry	/* Access Control List Entry */
-{
-	__u32	acle_size;
-	__u16	acle_perms;	/* Access permissions */
-	__u16	acle_type;	/* Type of entry */
-	__u16	acle_tag;	/* User or group identity */
-	__u16	acle_pad1;
-	__u32	acle_next;	/* Pointer on next entry for the */
-					/* same inode or on next free entry */
-};
-
-/*
  * Structure of a blocks group descriptor
  */
 struct ext2_group_desc
@@ -314,6 +289,7 @@ struct ext2_inode {
 #define EXT2_MOUNT_ERRORS_PANIC		0x0040	/* Panic on errors */
 #define EXT2_MOUNT_MINIX_DF		0x0080	/* Mimics the Minix statfs */
 #define EXT2_MOUNT_NO_UID32		0x0200  /* Disable 32-bit UIDs */
+#define EXT2_MOUNT_XATTR_USER		0x4000	/* Extended user attributes */
 
 #define clear_opt(o, opt)		o &= ~EXT2_MOUNT_##opt
 #define set_opt(o, opt)			o |= EXT2_MOUNT_##opt
@@ -397,6 +373,7 @@ struct ext2_super_block {
 
 #ifdef __KERNEL__
 #define EXT2_SB(sb)	(&((sb)->u.ext2_sb))
+#define EXT2_I(inode)	(&((inode)->u.ext2_i))
 #else
 /* Assume that user mode programs are passing in an ext2fs superblock, not
  * a kernel struct super_block.  This will allow us to call the feature-test
@@ -466,7 +443,7 @@ struct ext2_super_block {
 #define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008
 #define EXT2_FEATURE_INCOMPAT_ANY		0xffffffff
 
-#define EXT2_FEATURE_COMPAT_SUPP	0
+#define EXT2_FEATURE_COMPAT_SUPP	EXT2_FEATURE_COMPAT_EXT_ATTR
 #define EXT2_FEATURE_INCOMPAT_SUPP	EXT2_FEATURE_INCOMPAT_FILETYPE
 #define EXT2_FEATURE_RO_COMPAT_SUPP	(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \
 					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \
@@ -623,8 +600,10 @@ extern struct address_space_operations e
 
 /* namei.c */
 extern struct inode_operations ext2_dir_inode_operations;
+extern struct inode_operations ext2_special_inode_operations;
 
 /* symlink.c */
+extern struct inode_operations ext2_symlink_inode_operations;
 extern struct inode_operations ext2_fast_symlink_inode_operations;
 
 #endif	/* __KERNEL__ */
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/ext2_xattr.h	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,157 @@
+/*
+  File: linux/ext2_xattr.h
+
+  On-disk format of extended attributes for the ext2 filesystem.
+
+  (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+
+/* Magic value in attribute blocks */
+#define EXT2_XATTR_MAGIC		0xEA020000
+
+/* Maximum number of references to one attribute block */
+#define EXT2_XATTR_REFCOUNT_MAX		1024
+
+/* Name indexes */
+#define EXT2_XATTR_INDEX_MAX			10
+#define EXT2_XATTR_INDEX_USER			1
+#define EXT2_XATTR_INDEX_POSIX_ACL_ACCESS	2
+#define EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT	3
+
+struct ext2_xattr_header {
+	__u32	h_magic;	/* magic number for identification */
+	__u32	h_refcount;	/* reference count */
+	__u32	h_blocks;	/* number of disk blocks used */
+	__u32	h_hash;		/* hash value of all attributes */
+	__u32	h_reserved[4];	/* zero right now */
+};
+
+struct ext2_xattr_entry {
+	__u8	e_name_len;	/* length of name */
+	__u8	e_name_index;	/* attribute name index */
+	__u16	e_value_offs;	/* offset in disk block of value */
+	__u32	e_value_block;	/* disk block attribute is stored on (n/i) */
+	__u32	e_value_size;	/* size of attribute value */
+	__u32	e_hash;		/* hash value of name and value */
+	char	e_name[0];	/* attribute name */
+};
+
+#define EXT2_XATTR_PAD_BITS		2
+#define EXT2_XATTR_PAD		(1<<EXT2_XATTR_PAD_BITS)
+#define EXT2_XATTR_ROUND		(EXT2_XATTR_PAD-1)
+#define EXT2_XATTR_LEN(name_len) \
+	(((name_len) + EXT2_XATTR_ROUND + \
+	sizeof(struct ext2_xattr_entry)) & ~EXT2_XATTR_ROUND)
+#define EXT2_XATTR_NEXT(entry) \
+	( (struct ext2_xattr_entry *)( \
+	  (char *)(entry) + EXT2_XATTR_LEN((entry)->e_name_len)) )
+#define EXT2_XATTR_SIZE(size) \
+	(((size) + EXT2_XATTR_ROUND) & ~EXT2_XATTR_ROUND)
+
+#ifdef __KERNEL__
+
+# ifdef CONFIG_EXT2_FS_XATTR
+
+struct ext2_xattr_handler {
+	char *prefix;
+	size_t (*list)(char *list, struct inode *inode, const char *name,
+		       int name_len);
+	int (*get)(struct inode *inode, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct inode *inode, const char *name, const void *buffer,
+		   size_t size, int flags);
+};
+
+extern int ext2_xattr_register(int, struct ext2_xattr_handler *);
+extern void ext2_xattr_unregister(int, struct ext2_xattr_handler *);
+
+extern int ext2_setxattr(struct dentry *, const char *, const void *, size_t, int);
+extern ssize_t ext2_getxattr(struct dentry *, const char *, void *, size_t);
+extern ssize_t ext2_listxattr(struct dentry *, char *, size_t);
+extern int ext2_removexattr(struct dentry *, const char *);
+
+extern int ext2_xattr_get(struct inode *, int, const char *, void *, size_t);
+extern int ext2_xattr_list(struct inode *, char *, size_t);
+extern int ext2_xattr_set(struct inode *, int, const char *, const void *, size_t, int);
+
+extern void ext2_xattr_delete_inode(struct inode *);
+extern void ext2_xattr_put_super(struct super_block *);
+
+extern int init_ext2_xattr(void) __init;
+extern void exit_ext2_xattr(void);
+
+# else  /* CONFIG_EXT2_FS_XATTR */
+#  define ext2_setxattr		NULL
+#  define ext2_getxattr		NULL
+#  define ext2_listxattr	NULL
+#  define ext2_removexattr	NULL
+
+static inline int
+ext2_xattr_get(struct inode *inode, int name_index,
+	       const char *name, void *buffer, size_t size)
+{
+	return -ENOTSUP;
+}
+
+static inline int
+ext2_xattr_list(struct inode *inode, char *buffer, size_t size)
+{
+	return -ENOTSUP;
+}
+
+static inline int
+ext2_xattr_set(struct inode *inode, int name_index, const char *name,
+	       const void *value, size_t size, int flags)
+{
+	return -ENOTSUP;
+}
+
+static inline void
+ext2_xattr_delete_inode(struct inode *inode)
+{
+}
+
+static inline void
+ext2_xattr_put_super(struct super_block *sb)
+{
+}
+
+static inline int
+init_ext2_xattr(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ext2_xattr(void)
+{
+}
+
+# endif  /* CONFIG_EXT2_FS_XATTR */
+
+# ifdef CONFIG_EXT2_FS_XATTR_USER
+
+extern int init_ext2_xattr_user(void) __init;
+extern void exit_ext2_xattr_user(void);
+
+# else  /* CONFIG_EXT2_FS_XATTR_USER */
+
+static inline int
+init_ext2_xattr_user(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ext2_xattr_user(void)
+{
+}
+
+# endif  /* CONFIG_EXT2_FS_XATTR_USER */
+
+#endif  /* __KERNEL__ */
+
--- linux-2.4.20-hp4_pnnl1/include/linux/ext3_fs.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/ext3_fs.h	2003-04-09 17:21:01.000000000 -0600
@@ -63,8 +63,6 @@
  */
 #define	EXT3_BAD_INO		 1	/* Bad blocks inode */
 #define EXT3_ROOT_INO		 2	/* Root inode */
-#define EXT3_ACL_IDX_INO	 3	/* ACL inode */
-#define EXT3_ACL_DATA_INO	 4	/* ACL inode */
 #define EXT3_BOOT_LOADER_INO	 5	/* Boot loader inode */
 #define EXT3_UNDEL_DIR_INO	 6	/* Undelete directory inode */
 #define EXT3_RESIZE_INO		 7	/* Reserved group descriptors inode */
@@ -94,7 +92,6 @@
 #else
 # define EXT3_BLOCK_SIZE(s)		(EXT3_MIN_BLOCK_SIZE << (s)->s_log_block_size)
 #endif
-#define EXT3_ACLE_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (struct ext3_acl_entry))
 #define	EXT3_ADDR_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (__u32))
 #ifdef __KERNEL__
 # define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
@@ -129,28 +126,6 @@
 #endif
 
 /*
- * ACL structures
- */
-struct ext3_acl_header	/* Header of Access Control Lists */
-{
-	__u32	aclh_size;
-	__u32	aclh_file_count;
-	__u32	aclh_acle_count;
-	__u32	aclh_first_acle;
-};
-
-struct ext3_acl_entry	/* Access Control List Entry */
-{
-	__u32	acle_size;
-	__u16	acle_perms;	/* Access permissions */
-	__u16	acle_type;	/* Type of entry */
-	__u16	acle_tag;	/* User or group identity */
-	__u16	acle_pad1;
-	__u32	acle_next;	/* Pointer on next entry for the */
-					/* same inode or on next free entry */
-};
-
-/*
  * Structure of a blocks group descriptor
  */
 struct ext3_group_desc
@@ -344,6 +319,7 @@ struct ext3_inode {
   #define EXT3_MOUNT_WRITEBACK_DATA	0x0C00	/* No data ordering */
 #define EXT3_MOUNT_UPDATE_JOURNAL	0x1000	/* Update the journal format */
 #define EXT3_MOUNT_NO_UID32		0x2000  /* Disable 32-bit UIDs */
+#define EXT3_MOUNT_XATTR_USER		0x4000	/* Extended user attributes */
 
 /* Compatibility, for having both ext2_fs.h and ext3_fs.h included at once */
 #ifndef _LINUX_EXT2_FS_H
@@ -520,7 +496,7 @@ struct ext3_super_block {
 #define EXT3_FEATURE_INCOMPAT_RECOVER		0x0004 /* Needs recovery */
 #define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008 /* Journal device */
 
-#define EXT3_FEATURE_COMPAT_SUPP	0
+#define EXT3_FEATURE_COMPAT_SUPP	EXT2_FEATURE_COMPAT_EXT_ATTR
 #define EXT3_FEATURE_INCOMPAT_SUPP	(EXT3_FEATURE_INCOMPAT_FILETYPE| \
 					 EXT3_FEATURE_INCOMPAT_RECOVER)
 #define EXT3_FEATURE_RO_COMPAT_SUPP	(EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER| \
@@ -703,6 +679,7 @@ extern void ext3_check_inodes_bitmap (st
 extern unsigned long ext3_count_free (struct buffer_head *, unsigned);
 
 /* inode.c */
+extern int ext3_forget(handle_t *, int, struct inode *, struct buffer_head *, int);
 extern struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);
 extern struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);
 
@@ -771,8 +748,10 @@ extern struct address_space_operations e
 
 /* namei.c */
 extern struct inode_operations ext3_dir_inode_operations;
+extern struct inode_operations ext3_special_inode_operations;
 
 /* symlink.c */
+extern struct inode_operations ext3_symlink_inode_operations;
 extern struct inode_operations ext3_fast_symlink_inode_operations;
 
 
--- linux-2.4.20-hp4_pnnl1/include/linux/ext3_jbd.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/ext3_jbd.h	2003-04-09 17:21:01.000000000 -0600
@@ -30,13 +30,19 @@
 
 #define EXT3_SINGLEDATA_TRANS_BLOCKS	8
 
+/* Extended attributes may touch two data buffers, two bitmap buffers,
+ * and two group and summaries. */
+
+#define EXT3_XATTR_TRANS_BLOCKS		8
+
 /* Define the minimum size for a transaction which modifies data.  This
  * needs to take into account the fact that we may end up modifying two
  * quota files too (one for the group, one for the user quota).  The
  * superblock only gets updated once, of course, so don't bother
  * counting that again for the quota updates. */
 
-#define EXT3_DATA_TRANS_BLOCKS		(3 * EXT3_SINGLEDATA_TRANS_BLOCKS - 2)
+#define EXT3_DATA_TRANS_BLOCKS		(3 * EXT3_SINGLEDATA_TRANS_BLOCKS + \
+					 EXT3_XATTR_TRANS_BLOCKS - 2)
 
 extern int ext3_writepage_trans_blocks(struct inode *inode);
 
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/ext3_xattr.h	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,157 @@
+/*
+  File: linux/ext3_xattr.h
+
+  On-disk format of extended attributes for the ext3 filesystem.
+
+  (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+
+/* Magic value in attribute blocks */
+#define EXT3_XATTR_MAGIC		0xEA020000
+
+/* Maximum number of references to one attribute block */
+#define EXT3_XATTR_REFCOUNT_MAX		1024
+
+/* Name indexes */
+#define EXT3_XATTR_INDEX_MAX			10
+#define EXT3_XATTR_INDEX_USER			1
+#define EXT3_XATTR_INDEX_POSIX_ACL_ACCESS	2
+#define EXT3_XATTR_INDEX_POSIX_ACL_DEFAULT	3
+
+struct ext3_xattr_header {
+	__u32	h_magic;	/* magic number for identification */
+	__u32	h_refcount;	/* reference count */
+	__u32	h_blocks;	/* number of disk blocks used */
+	__u32	h_hash;		/* hash value of all attributes */
+	__u32	h_reserved[4];	/* zero right now */
+};
+
+struct ext3_xattr_entry {
+	__u8	e_name_len;	/* length of name */
+	__u8	e_name_index;	/* attribute name index */
+	__u16	e_value_offs;	/* offset in disk block of value */
+	__u32	e_value_block;	/* disk block attribute is stored on (n/i) */
+	__u32	e_value_size;	/* size of attribute value */
+	__u32	e_hash;		/* hash value of name and value */
+	char	e_name[0];	/* attribute name */
+};
+
+#define EXT3_XATTR_PAD_BITS		2
+#define EXT3_XATTR_PAD		(1<<EXT3_XATTR_PAD_BITS)
+#define EXT3_XATTR_ROUND		(EXT3_XATTR_PAD-1)
+#define EXT3_XATTR_LEN(name_len) \
+	(((name_len) + EXT3_XATTR_ROUND + \
+	sizeof(struct ext3_xattr_entry)) & ~EXT3_XATTR_ROUND)
+#define EXT3_XATTR_NEXT(entry) \
+	( (struct ext3_xattr_entry *)( \
+	  (char *)(entry) + EXT3_XATTR_LEN((entry)->e_name_len)) )
+#define EXT3_XATTR_SIZE(size) \
+	(((size) + EXT3_XATTR_ROUND) & ~EXT3_XATTR_ROUND)
+
+#ifdef __KERNEL__
+
+# ifdef CONFIG_EXT3_FS_XATTR
+
+struct ext3_xattr_handler {
+	char *prefix;
+	size_t (*list)(char *list, struct inode *inode, const char *name,
+		       int name_len);
+	int (*get)(struct inode *inode, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct inode *inode, const char *name, const void *buffer,
+		   size_t size, int flags);
+};
+
+extern int ext3_xattr_register(int, struct ext3_xattr_handler *);
+extern void ext3_xattr_unregister(int, struct ext3_xattr_handler *);
+
+extern int ext3_setxattr(struct dentry *, const char *, const void *, size_t, int);
+extern ssize_t ext3_getxattr(struct dentry *, const char *, void *, size_t);
+extern ssize_t ext3_listxattr(struct dentry *, char *, size_t);
+extern int ext3_removexattr(struct dentry *, const char *);
+
+extern int ext3_xattr_get(struct inode *, int, const char *, void *, size_t);
+extern int ext3_xattr_list(struct inode *, char *, size_t);
+extern int ext3_xattr_set(handle_t *handle, struct inode *, int, const char *, const void *, size_t, int);
+
+extern void ext3_xattr_delete_inode(handle_t *, struct inode *);
+extern void ext3_xattr_put_super(struct super_block *);
+
+extern int init_ext3_xattr(void) __init;
+extern void exit_ext3_xattr(void);
+
+# else  /* CONFIG_EXT3_FS_XATTR */
+#  define ext3_setxattr		NULL
+#  define ext3_getxattr		NULL
+#  define ext3_listxattr	NULL
+#  define ext3_removexattr	NULL
+
+static inline int
+ext3_xattr_get(struct inode *inode, int name_index, const char *name,
+	       void *buffer, size_t size)
+{
+	return -ENOTSUP;
+}
+
+static inline int
+ext3_xattr_list(struct inode *inode, void *buffer, size_t size)
+{
+	return -ENOTSUP;
+}
+
+static inline int
+ext3_xattr_set(handle_t *handle, struct inode *inode, int name_index,
+	       const char *name, const void *value, size_t size, int flags)
+{
+	return -ENOTSUP;
+}
+
+static inline void
+ext3_xattr_delete_inode(handle_t *handle, struct inode *inode)
+{
+}
+
+static inline void
+ext3_xattr_put_super(struct super_block *sb)
+{
+}
+
+static inline int
+init_ext3_xattr(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ext3_xattr(void)
+{
+}
+
+# endif  /* CONFIG_EXT3_FS_XATTR */
+
+# ifdef CONFIG_EXT3_FS_XATTR_USER
+
+extern int init_ext3_xattr_user(void) __init;
+extern void exit_ext3_xattr_user(void);
+
+# else  /* CONFIG_EXT3_FS_XATTR_USER */
+
+static inline int
+init_ext3_xattr_user(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ext3_xattr_user(void)
+{
+}
+
+#endif  /* CONFIG_EXT3_FS_XATTR_USER */
+
+#endif  /* __KERNEL__ */
+
--- linux-2.4.20-hp4_pnnl1/include/linux/fs.h~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/fs.h	2003-04-09 17:21:01.000000000 -0600
@@ -909,7 +909,7 @@ struct inode_operations {
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct dentry *, struct iattr *);
-	int (*setxattr) (struct dentry *, const char *, void *, size_t, int);
+	int (*setxattr) (struct dentry *, const char *, const void *, size_t, int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
 	int (*removexattr) (struct dentry *, const char *);
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-hp4_pnnl1-braam/include/linux/mbcache.h	2003-04-09 17:21:01.000000000 -0600
@@ -0,0 +1,69 @@
+/*
+  File: linux/mbcache.h
+
+  (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+*/
+
+/* Hardwire the number of additional indexes */
+#define MB_CACHE_INDEXES_COUNT 1
+
+struct mb_cache_entry;
+
+struct mb_cache_op {
+	int (*free)(struct mb_cache_entry *, int);
+};
+
+struct mb_cache {
+	struct list_head		c_cache_list;
+	const char			*c_name;
+	struct mb_cache_op		c_op;
+	atomic_t			c_entry_count;
+	int				c_bucket_count;
+#ifndef MB_CACHE_INDEXES_COUNT
+	int				c_indexes_count;
+#endif
+	kmem_cache_t			*c_entry_cache;
+	struct list_head		*c_block_hash;
+	struct list_head		*c_indexes_hash[0];
+};
+
+struct mb_cache_entry_index {
+	struct list_head		o_list;
+	unsigned int			o_key;
+};
+
+struct mb_cache_entry {
+	struct list_head		e_lru_list;
+	struct mb_cache			*e_cache;
+	atomic_t			e_used;
+	kdev_t				e_dev;
+	unsigned long			e_block;
+	struct list_head		e_block_list;
+	struct mb_cache_entry_index	e_indexes[0];
+};
+
+/* Functions on caches */
+
+struct mb_cache * mb_cache_create(const char *, struct mb_cache_op *, size_t,
+				  int, int);
+void mb_cache_shrink(struct mb_cache *, kdev_t);
+void mb_cache_destroy(struct mb_cache *);
+
+/* Functions on cache entries */
+
+struct mb_cache_entry *mb_cache_entry_alloc(struct mb_cache *);
+int mb_cache_entry_insert(struct mb_cache_entry *, kdev_t, unsigned long,
+			  unsigned int[]);
+void mb_cache_entry_rehash(struct mb_cache_entry *, unsigned int[]);
+void mb_cache_entry_release(struct mb_cache_entry *);
+void mb_cache_entry_takeout(struct mb_cache_entry *);
+void mb_cache_entry_free(struct mb_cache_entry *);
+struct mb_cache_entry *mb_cache_entry_dup(struct mb_cache_entry *);
+struct mb_cache_entry *mb_cache_entry_get(struct mb_cache *, kdev_t,
+					  unsigned long);
+#if !defined(MB_CACHE_INDEXES_COUNT) || (MB_CACHE_INDEXES_COUNT > 0)
+struct mb_cache_entry *mb_cache_entry_find_first(struct mb_cache *cache, int,
+						 kdev_t, unsigned int);
+struct mb_cache_entry *mb_cache_entry_find_next(struct mb_cache_entry *, int,
+						kdev_t, unsigned int);
+#endif
--- linux-2.4.20-hp4_pnnl1/kernel/ksyms.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/kernel/ksyms.c	2003-04-09 17:22:19.000000000 -0600
@@ -11,6 +11,7 @@
 
 #include <linux/config.h>
 #include <linux/slab.h>
+#include <linux/cache_def.h>
 #include <linux/module.h>
 #include <linux/blkdev.h>
 #include <linux/cdrom.h>
@@ -103,6 +104,7 @@ EXPORT_SYMBOL(exit_mm);
 EXPORT_SYMBOL(exit_files);
 EXPORT_SYMBOL(exit_fs);
 EXPORT_SYMBOL(exit_sighand);
+EXPORT_SYMBOL(copy_fs_struct);
 EXPORT_SYMBOL(make_pages_present);
 
 /* internal kernel memory management */
@@ -123,6 +125,8 @@ EXPORT_SYMBOL(kmem_cache_validate);
 EXPORT_SYMBOL(kmem_cache_alloc);
 EXPORT_SYMBOL(kmem_cache_free);
 EXPORT_SYMBOL(kmem_cache_size);
+EXPORT_SYMBOL(register_cache);
+EXPORT_SYMBOL(unregister_cache);
 EXPORT_SYMBOL(kmalloc);
 EXPORT_SYMBOL(kfree);
 EXPORT_SYMBOL(vfree);
--- linux-2.4.20-hp4_pnnl1/mm/vmscan.c~linux-2.4.20-xattr-0.8.54-hp	2003-04-09 17:20:37.000000000 -0600
+++ linux-2.4.20-hp4_pnnl1-braam/mm/vmscan.c	2003-04-09 17:21:01.000000000 -0600
@@ -18,6 +18,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/swap.h>
 #include <linux/swapctl.h>
+#include <linux/cache_def.h>
 #include <linux/smp_lock.h>
 #include <linux/pagemap.h>
 #include <linux/init.h>
@@ -35,6 +36,39 @@
  */
 #define DEF_PRIORITY (6)
 
+static DECLARE_MUTEX(other_caches_sem);
+static LIST_HEAD(cache_definitions);
+
+void register_cache(struct cache_definition *cache)
+{
+	down(&other_caches_sem);
+	list_add(&cache->link, &cache_definitions);
+	up(&other_caches_sem);
+}
+
+void unregister_cache(struct cache_definition *cache)
+{
+	down(&other_caches_sem);
+	list_del(&cache->link);
+	up(&other_caches_sem);
+}
+
+static void shrink_other_caches(unsigned int priority, int gfp_mask)
+{
+	struct list_head *p;
+
+	if (down_trylock(&other_caches_sem))
+		return;
+
+	list_for_each_prev(p, &cache_definitions) {
+		struct cache_definition *cache =
+			list_entry(p, struct cache_definition, link);
+
+		cache->shrink(priority, gfp_mask);
+	}
+	up(&other_caches_sem);
+}
+
 /*
  * The swap-out function returns 1 if it successfully
  * scanned all the pages it was asked to (`count').
@@ -579,6 +613,7 @@ static int shrink_caches(zone_t * classz
 
 	shrink_dcache_memory(priority, gfp_mask);
 	shrink_icache_memory(priority, gfp_mask);
+	shrink_other_caches(priority, gfp_mask);
 #ifdef CONFIG_QUOTA
 	shrink_dqcache_memory(DEF_PRIORITY, gfp_mask);
 #endif

_



 fs/ext3/balloc.c |   53 +++++++++++++++++++++++++++++++----------------------
 1 files changed, 31 insertions(+), 22 deletions(-)

--- linux-2.4.20/fs/ext3/balloc.c~ext3-2.4.20-fixes	2003-04-08 23:35:17.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/balloc.c	2003-04-08 23:35:17.000000000 -0600
@@ -276,7 +276,8 @@ void ext3_free_blocks (handle_t *handle,
 	}
 	lock_super (sb);
 	es = sb->u.ext3_sb.s_es;
-	if (block < le32_to_cpu(es->s_first_data_block) || 
+	if (block < le32_to_cpu(es->s_first_data_block) ||
+	    block + count < block ||
 	    (block + count) > le32_to_cpu(es->s_blocks_count)) {
 		ext3_error (sb, "ext3_free_blocks",
 			    "Freeing blocks not in datazone - "
@@ -309,17 +310,6 @@ do_more:
 	if (!gdp)
 		goto error_return;
 
-	if (in_range (le32_to_cpu(gdp->bg_block_bitmap), block, count) ||
-	    in_range (le32_to_cpu(gdp->bg_inode_bitmap), block, count) ||
-	    in_range (block, le32_to_cpu(gdp->bg_inode_table),
-		      sb->u.ext3_sb.s_itb_per_group) ||
-	    in_range (block + count - 1, le32_to_cpu(gdp->bg_inode_table),
-		      sb->u.ext3_sb.s_itb_per_group))
-		ext3_error (sb, "ext3_free_blocks",
-			    "Freeing blocks in system zones - "
-			    "Block = %lu, count = %lu",
-			    block, count);
-
 	/*
 	 * We are about to start releasing blocks in the bitmap,
 	 * so we need undo access.
@@ -345,14 +335,24 @@ do_more:
 	if (err)
 		goto error_return;
 
-	for (i = 0; i < count; i++) {
+	for (i = 0; i < count; i++, block++) {
+		if (block == le32_to_cpu(gdp->bg_block_bitmap) ||
+		    block == le32_to_cpu(gdp->bg_inode_bitmap) ||
+		    in_range(block, le32_to_cpu(gdp->bg_inode_table),
+			     EXT3_SB(sb)->s_itb_per_group)) {
+			ext3_error(sb, __FUNCTION__,
+				   "Freeing block in system zone - block = %lu",
+				   block);
+			continue;
+		}
+
 		/*
 		 * An HJ special.  This is expensive...
 		 */
 #ifdef CONFIG_JBD_DEBUG
 		{
 			struct buffer_head *debug_bh;
-			debug_bh = sb_get_hash_table(sb, block + i);
+			debug_bh = sb_get_hash_table(sb, block);
 			if (debug_bh) {
 				BUFFER_TRACE(debug_bh, "Deleted!");
 				if (!bh2jh(bitmap_bh)->b_committed_data)
@@ -365,9 +365,8 @@ do_more:
 #endif
 		BUFFER_TRACE(bitmap_bh, "clear bit");
 		if (!ext3_clear_bit (bit + i, bitmap_bh->b_data)) {
-			ext3_error (sb, __FUNCTION__,
-				      "bit already cleared for block %lu", 
-				      block + i);
+			ext3_error(sb, __FUNCTION__,
+				   "bit already cleared for block %lu", block);
 			BUFFER_TRACE(bitmap_bh, "bit already cleared");
 		} else {
 			dquot_freed_blocks++;
@@ -415,7 +414,6 @@ do_more:
 	if (!err) err = ret;
 
 	if (overflow && !err) {
-		block += count;
 		count = overflow;
 		goto do_more;
 	}
@@ -576,6 +574,7 @@ int ext3_new_block (handle_t *handle, st
 
 	ext3_debug ("goal=%lu.\n", goal);
 
+repeat:
 	/*
 	 * First, test whether the goal block is free.
 	 */
@@ -684,10 +683,20 @@ got_block:
 	if (tmp == le32_to_cpu(gdp->bg_block_bitmap) ||
 	    tmp == le32_to_cpu(gdp->bg_inode_bitmap) ||
 	    in_range (tmp, le32_to_cpu(gdp->bg_inode_table),
-		      sb->u.ext3_sb.s_itb_per_group))
-		ext3_error (sb, "ext3_new_block",
-			    "Allocating block in system zone - "
-			    "block = %u", tmp);
+		      EXT3_SB(sb)->s_itb_per_group)) {
+		ext3_error(sb, __FUNCTION__,
+			   "Allocating block in system zone - block = %u", tmp);
+
+		/* Note: This will potentially use up one of the handle's
+		 * buffer credits.  Normally we have way too many credits,
+		 * so that is OK.  In _very_ rare cases it might not be OK.
+		 * We will trigger an assertion if we run out of credits,
+		 * and we will have to do a full fsck of the filesystem -
+		 * better than randomly corrupting filesystem metadata.
+		 */
+		ext3_set_bit(j, bh->b_data);
+		goto repeat;
+	}
 
 	/* The superblock lock should guard against anybody else beating
 	 * us to this point! */

_
 fs/ext3/ialloc.c        |   20 ++++++++++----------
 fs/ext3/namei.c         |   16 ++++++++--------
 include/linux/ext3_fs.h |    2 +-
 3 files changed, 19 insertions(+), 19 deletions(-)

--- linux-2.4.20/fs/ext3/ialloc.c~ext3-2.4-ino_t	2003-04-08 23:35:24.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/ialloc.c	2003-04-08 23:35:24.000000000 -0600
@@ -65,8 +65,8 @@ static int read_inode_bitmap (struct sup
 	if (!bh) {
 		ext3_error (sb, "read_inode_bitmap",
 			    "Cannot read inode bitmap - "
-			    "block_group = %lu, inode_bitmap = %lu",
-			    block_group, (unsigned long) gdp->bg_inode_bitmap);
+			    "block_group = %lu, inode_bitmap = %u",
+			    block_group, gdp->bg_inode_bitmap);
 		retval = -EIO;
 	}
 	/*
@@ -533,19 +533,19 @@ out:
 }
 
 /* Verify that we are loading a valid orphan from disk */
-struct inode *ext3_orphan_get (struct super_block * sb, ino_t ino)
+struct inode *ext3_orphan_get(struct super_block *sb, unsigned long ino)
 {
-	ino_t max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);
+	unsigned long max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);
 	unsigned long block_group;
 	int bit;
 	int bitmap_nr;
 	struct buffer_head *bh;
 	struct inode *inode = NULL;
-	
+
 	/* Error cases - e2fsck has already cleaned up for us */
 	if (ino > max_ino) {
 		ext3_warning(sb, __FUNCTION__,
-			     "bad orphan ino %ld!  e2fsck was run?\n", ino);
+			     "bad orphan ino %lu!  e2fsck was run?\n", ino);
 		return NULL;
 	}
 
@@ -554,7 +554,7 @@ struct inode *ext3_orphan_get (struct su
 	if ((bitmap_nr = load_inode_bitmap(sb, block_group)) < 0 ||
 	    !(bh = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr])) {
 		ext3_warning(sb, __FUNCTION__,
-			     "inode bitmap error for orphan %ld\n", ino);
+			     "inode bitmap error for orphan %lu\n", ino);
 		return NULL;
 	}
 
@@ -565,16 +565,16 @@ struct inode *ext3_orphan_get (struct su
 	if (!ext3_test_bit(bit, bh->b_data) || !(inode = iget(sb, ino)) ||
 	    is_bad_inode(inode) || NEXT_ORPHAN(inode) > max_ino) {
 		ext3_warning(sb, __FUNCTION__,
-			     "bad orphan inode %ld!  e2fsck was run?\n", ino);
+			     "bad orphan inode %lu!  e2fsck was run?\n", ino);
 		printk(KERN_NOTICE "ext3_test_bit(bit=%d, block=%ld) = %d\n",
 		       bit, bh->b_blocknr, ext3_test_bit(bit, bh->b_data));
 		printk(KERN_NOTICE "inode=%p\n", inode);
 		if (inode) {
 			printk(KERN_NOTICE "is_bad_inode(inode)=%d\n",
 			       is_bad_inode(inode));
-			printk(KERN_NOTICE "NEXT_ORPHAN(inode)=%d\n",
+			printk(KERN_NOTICE "NEXT_ORPHAN(inode)=%u\n",
 			       NEXT_ORPHAN(inode));
-			printk(KERN_NOTICE "max_ino=%ld\n", max_ino);
+			printk(KERN_NOTICE "max_ino=%lu\n", max_ino);
 		}
 		/* Avoid freeing blocks if we got a bad deleted inode */
 		if (inode && inode->i_nlink == 0)
--- linux-2.4.20/fs/ext3/namei.c~ext3-2.4-ino_t	2003-04-08 23:35:24.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/namei.c	2003-04-08 23:35:24.000000000 -0600
@@ -1808,10 +1808,10 @@ int ext3_orphan_del(handle_t *handle, st
 	struct list_head *prev;
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct ext3_sb_info *sbi;
-	ino_t ino_next; 
+	unsigned long ino_next;
 	struct ext3_iloc iloc;
 	int err = 0;
-	
+
 	lock_super(inode->i_sb);
 	if (list_empty(&ei->i_orphan)) {
 		unlock_super(inode->i_sb);
@@ -1822,7 +1822,7 @@ int ext3_orphan_del(handle_t *handle, st
 	prev = ei->i_orphan.prev;
 	sbi = EXT3_SB(inode->i_sb);
 
-	jbd_debug(4, "remove inode %ld from orphan list\n", inode->i_ino);
+	jbd_debug(4, "remove inode %lu from orphan list\n", inode->i_ino);
 
 	list_del(&ei->i_orphan);
 	INIT_LIST_HEAD(&ei->i_orphan);
@@ -1833,13 +1833,13 @@ int ext3_orphan_del(handle_t *handle, st
 	 * list in memory. */
 	if (!handle)
 		goto out;
-	
+
 	err = ext3_reserve_inode_write(handle, inode, &iloc);
 	if (err)
 		goto out_err;
 
 	if (prev == &sbi->s_orphan) {
-		jbd_debug(4, "superblock will point to %ld\n", ino_next);
+		jbd_debug(4, "superblock will point to %lu\n", ino_next);
 		BUFFER_TRACE(sbi->s_sbh, "get_write_access");
 		err = ext3_journal_get_write_access(handle, sbi->s_sbh);
 		if (err)
@@ -1850,8 +1850,8 @@ int ext3_orphan_del(handle_t *handle, st
 		struct ext3_iloc iloc2;
 		struct inode *i_prev =
 			list_entry(prev, struct inode, u.ext3_i.i_orphan);
-		
-		jbd_debug(4, "orphan inode %ld will point to %ld\n",
+
+		jbd_debug(4, "orphan inode %lu will point to %lu\n",
 			  i_prev->i_ino, ino_next);
 		err = ext3_reserve_inode_write(handle, i_prev, &iloc2);
 		if (err)
@@ -1866,7 +1866,7 @@ int ext3_orphan_del(handle_t *handle, st
 	if (err)
 		goto out_brelse;
 
-out_err: 	
+out_err: 
 	ext3_std_error(inode->i_sb, err);
 out:
 	unlock_super(inode->i_sb);
--- linux-2.4.20/include/linux/ext3_fs.h~ext3-2.4-ino_t	2003-04-08 23:35:24.000000000 -0600
+++ linux-2.4.20-braam/include/linux/ext3_fs.h	2003-04-08 23:35:24.000000000 -0600
@@ -673,7 +673,7 @@ extern int ext3fs_dirhash(const char *na
 /* ialloc.c */
 extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int);
 extern void ext3_free_inode (handle_t *, struct inode *);
-extern struct inode * ext3_orphan_get (struct super_block *, ino_t);
+extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);
 extern unsigned long ext3_count_free_inodes (struct super_block *);
 extern void ext3_check_inodes_bitmap (struct super_block *);
 extern unsigned long ext3_count_free (struct buffer_head *, unsigned);

_
 fs/ext3/inode.c |    2 +-
 1 files changed, 1 insertion(+), 1 deletion(-)

--- linux-2.4.20/fs/ext3/inode.c~ext3-largefile	2003-04-08 23:35:36.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/inode.c	2003-04-08 23:35:36.000000000 -0600
@@ -2562,7 +2562,7 @@ void ext3_dirty_inode(struct inode *inod
 	handle_t *handle;
 
 	lock_kernel();
-	handle = ext3_journal_start(inode, 1);
+	handle = ext3_journal_start(inode, 2);
 	if (IS_ERR(handle))
 		goto out;
 	if (current_handle &&

_
--- ./fs/ext3/inode.c.orig	Wed Mar 12 02:44:06 2003
+++ ./fs/ext3/inode.c	Wed Mar 12 11:55:20 2003
@@ -99,7 +99,35 @@ int ext3_forget(handle_t *handle, int is
 	return err;
 }
 
-/* 
+/*
+ * Work out how many blocks we need to progress with the next chunk of a
+ * truncate transaction.
+ */
+
+static unsigned long blocks_for_truncate(struct inode *inode)
+{
+	unsigned long needed;
+
+	needed = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);
+
+	/* Give ourselves just enough room to cope with inodes in which
+	 * i_blocks is corrupt: we've seen disk corruptions in the past
+	 * which resulted in random data in an inode which looked enough
+	 * like a regular file for ext3 to try to delete it.  Things
+	 * will go a bit crazy if that happens, but at least we should
+	 * try not to panic the whole kernel. */
+	if (needed < 2)
+		needed = 2;
+
+	/* But we need to bound the transaction so we don't overflow the
+	 * journal. */
+	if (needed > EXT3_MAX_TRANS_DATA)
+		needed = EXT3_MAX_TRANS_DATA;
+
+	return EXT3_DATA_TRANS_BLOCKS + needed;
+}
+
+/*
  * Truncate transactions can be complex and absolutely huge.  So we need to
  * be able to restart the transaction at a conventient checkpoint to make
  * sure we don't overflow the journal.
@@ -110,19 +138,14 @@ int ext3_forget(handle_t *handle, int is
  * transaction in the top-level truncate loop. --sct 
  */
 
-static handle_t *start_transaction(struct inode *inode) 
+static handle_t *start_transaction(struct inode *inode)
 {
-	long needed;
 	handle_t *result;
-	
-	needed = inode->i_blocks;
-	if (needed > EXT3_MAX_TRANS_DATA) 
-		needed = EXT3_MAX_TRANS_DATA;
-	
-	result = ext3_journal_start(inode, EXT3_DATA_TRANS_BLOCKS + needed);
+
+	result = ext3_journal_start(inode, blocks_for_truncate(inode));
 	if (!IS_ERR(result))
 		return result;
-	
+
 	ext3_std_error(inode->i_sb, PTR_ERR(result));
 	return result;
 }
@@ -135,14 +158,9 @@ static handle_t *start_transaction(struc
  */
 static int try_to_extend_transaction(handle_t *handle, struct inode *inode)
 {
-	long needed;
-	
 	if (handle->h_buffer_credits > EXT3_RESERVE_TRANS_BLOCKS)
 		return 0;
-	needed = inode->i_blocks;
-	if (needed > EXT3_MAX_TRANS_DATA) 
-		needed = EXT3_MAX_TRANS_DATA;
-	if (!ext3_journal_extend(handle, EXT3_RESERVE_TRANS_BLOCKS + needed))
+	if (!ext3_journal_extend(handle, blocks_for_truncate(inode)))
 		return 0;
 	return 1;
 }
@@ -154,11 +172,8 @@ static int try_to_extend_transaction(han
  */
 static int ext3_journal_test_restart(handle_t *handle, struct inode *inode)
 {
-	long needed = inode->i_blocks;
-	if (needed > EXT3_MAX_TRANS_DATA) 
-		needed = EXT3_MAX_TRANS_DATA;
 	jbd_debug(2, "restarting handle %p\n", handle);
-	return ext3_journal_restart(handle, EXT3_DATA_TRANS_BLOCKS + needed);
+	return ext3_journal_restart(handle, blocks_for_truncate(inode));
 }
 
 /*
 fs/ext3/super.c |    7 ++++++-
 1 files changed, 6 insertions(+), 1 deletion(-)

--- linux-2.4.20/fs/ext3/super.c~ext3-unmount_sync	2003-04-08 23:35:44.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/super.c	2003-04-08 23:35:44.000000000 -0600
@@ -1612,7 +1612,12 @@ void ext3_write_super (struct super_bloc
 	sb->s_dirt = 0;
 	target = log_start_commit(EXT3_SB(sb)->s_journal, NULL);
 
-	if (do_sync_supers) {
+	/*
+	 * Tricky --- if we are unmounting, the write really does need
+	 * to be synchronous.  We can detect that by looking for NULL in
+	 * sb->s_root.
+	 */
+	if (do_sync_supers || !sb->s_root) {
 		unlock_super(sb);
 		log_wait_commit(EXT3_SB(sb)->s_journal, target);
 		lock_super(sb);

_
 ./fs/ext3/namei.c |   11 +++++------
 1 files changed, 5 insertions(+), 6 deletions(-)

--- linux-2.4.20/./fs/ext3/namei.c~ext3-use-after-free	2003-04-08 23:35:51.000000000 -0600
+++ linux-2.4.20-braam/./fs/ext3/namei.c	2003-04-08 23:35:51.000000000 -0600
@@ -1521,8 +1521,11 @@ static int ext3_add_nondir(handle_t *han
 {
 	int err = ext3_add_entry(handle, dentry, inode);
 	if (!err) {
-		d_instantiate(dentry, inode);
-		return 0;
+		err = ext3_mark_inode_dirty(handle, inode);
+		if (err == 0) {
+			d_instantiate(dentry, inode);
+			return 0;
+		}
 	}
 	ext3_dec_count(handle, inode);
 	iput(inode);
@@ -1559,7 +1562,6 @@ static int ext3_create (struct inode * d
 		inode->i_fop = &ext3_file_operations;
 		inode->i_mapping->a_ops = &ext3_aops;
 		err = ext3_add_nondir(handle, dentry, inode);
-		ext3_mark_inode_dirty(handle, inode);
 	}
 	ext3_journal_stop(handle, dir);
 	return err;
@@ -1586,7 +1588,6 @@ static int ext3_mknod (struct inode * di
 	if (!IS_ERR(inode)) {
 		init_special_inode(inode, mode, rdev);
 		err = ext3_add_nondir(handle, dentry, inode);
-		ext3_mark_inode_dirty(handle, inode);
 	}
 	ext3_journal_stop(handle, dir);
 	return err;
@@ -2035,7 +2036,6 @@ static int ext3_symlink (struct inode * 
 	}
 	EXT3_I(inode)->i_disksize = inode->i_size;
 	err = ext3_add_nondir(handle, dentry, inode);
-	ext3_mark_inode_dirty(handle, inode);
 out_stop:
 	ext3_journal_stop(handle, dir);
 	return err;
@@ -2069,7 +2069,6 @@ static int ext3_link (struct dentry * ol
 	atomic_inc(&inode->i_count);
 
 	err = ext3_add_nondir(handle, dentry, inode);
-	ext3_mark_inode_dirty(handle, inode);
 	ext3_journal_stop(handle, dir);
 	return err;
 }

_
 fs/ext3/ialloc.c        |   38 ++++++++++++++++++++++++++++++++++++--
 fs/ext3/ioctl.c         |   25 +++++++++++++++++++++++++
 fs/ext3/namei.c         |   12 ++++++++----
 include/linux/ext3_fs.h |    5 ++++-
 4 files changed, 73 insertions(+), 7 deletions(-)

--- linux-2.4.20/fs/ext3/namei.c~extN-wantedi	2003-04-08 23:35:55.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/namei.c	2003-04-08 23:35:55.000000000 -0600
@@ -1555,7 +1555,8 @@ static int ext3_create (struct inode * d
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, mode);
+	inode = ext3_new_inode (handle, dir, mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		inode->i_op = &ext3_file_inode_operations;
@@ -1583,7 +1584,8 @@ static int ext3_mknod (struct inode * di
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, mode);
+	inode = ext3_new_inode (handle, dir, mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		init_special_inode(inode, mode, rdev);
@@ -1613,7 +1615,8 @@ static int ext3_mkdir(struct inode * dir
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, S_IFDIR | mode);
+	inode = ext3_new_inode (handle, dir, S_IFDIR | mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
@@ -2009,7 +2012,8 @@ static int ext3_symlink (struct inode * 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, S_IFLNK|S_IRWXUGO);
+	inode = ext3_new_inode (handle, dir, S_IFLNK|S_IRWXUGO,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
--- linux-2.4.20/fs/ext3/ialloc.c~extN-wantedi	2003-04-08 23:35:55.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/ialloc.c	2003-04-08 23:35:55.000000000 -0600
@@ -299,7 +299,8 @@ error_return:
  * group to find a free inode.
  */
 struct inode * ext3_new_inode (handle_t *handle,
-				const struct inode * dir, int mode)
+				const struct inode * dir, int mode,
+                               unsigned long goal)
 {
 	struct super_block * sb;
 	struct buffer_head * bh;
@@ -323,7 +324,39 @@ struct inode * ext3_new_inode (handle_t 
 	init_rwsem(&inode->u.ext3_i.truncate_sem);
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
+ 
+ 	if (goal) {
+ 		i = (goal - 1) / EXT3_INODES_PER_GROUP(sb);
+ 		j = (goal - 1) % EXT3_INODES_PER_GROUP(sb);
+ 		gdp = ext3_get_group_desc(sb, i, &bh2);
+ 
+ 		bitmap_nr = load_inode_bitmap (sb, i);
+ 		if (bitmap_nr < 0)
+ 			goto fail;
+ 
+ 		bh = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr];
+ 
+ 		BUFFER_TRACE(bh, "get_write_access");
+ 		err = ext3_journal_get_write_access(handle, bh);
+ 		if (err) goto fail;
+ 
+ 		if (ext3_set_bit(j, bh->b_data)) {
+ 			printk(KERN_ERR "goal inode %lu unavailable\n", goal);
+ 			/* Oh well, we tried. */
+ 			goto repeat;
+ 		}
+ 
+ 		BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
+ 		err = ext3_journal_dirty_metadata(handle, bh);
+ 		if (err) goto fail;
+ 
+ 		/* We've shortcircuited the allocation system successfully,
+ 		 * now finish filling in the inode.
+ 		 */
+ 		goto have_bit_and_group;
+ 	}
+ 
 repeat:
 	gdp = NULL;
 	i = 0;
@@ -438,6 +471,7 @@ repeat:
 		}
 		goto repeat;
 	}
+ have_bit_and_group:
 	j += i * EXT3_INODES_PER_GROUP(sb) + 1;
 	if (j < EXT3_FIRST_INO(sb) || j > le32_to_cpu(es->s_inodes_count)) {
 		ext3_error (sb, "ext3_new_inode",
--- linux-2.4.20/fs/ext3/ioctl.c~extN-wantedi	2003-04-08 23:35:55.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/ioctl.c	2003-04-08 23:35:55.000000000 -0600
@@ -23,6 +23,31 @@ int ext3_ioctl (struct inode * inode, st
 	ext3_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
+ 	case EXT3_IOC_CREATE_INUM: {
+ 		char name[32];
+ 		struct dentry *dchild, *dparent;
+ 		int rc = 0;
+ 
+ 		dparent = list_entry(inode->i_dentry.next, struct dentry,
+ 				     d_alias);
+ 		snprintf(name, sizeof name, "%lu", arg);
+ 		dchild = lookup_one_len(name, dparent, strlen(name));
+ 		if (dchild->d_inode) {
+ 			printk(KERN_ERR "%*s/%lu already exists (ino %lu)\n",
+ 			       dparent->d_name.len, dparent->d_name.name, arg,
+ 			       dchild->d_inode->i_ino);
+ 			rc = -EEXIST;
+ 		} else {
+ 			dchild->d_fsdata = (void *)arg;
+ 			rc = vfs_create(inode, dchild, 0644);
+ 			if (rc)
+ 				printk(KERN_ERR "vfs_create: %d\n", rc);
+ 			else if (dchild->d_inode->i_ino != arg)
+ 				rc = -EEXIST;
+ 		}
+ 		dput(dchild);
+ 		return rc;
+ 	}
 	case EXT3_IOC_GETFLAGS:
 		flags = inode->u.ext3_i.i_flags & EXT3_FL_USER_VISIBLE;
 		return put_user(flags, (int *) arg);
--- linux-2.4.20/include/linux/ext3_fs.h~extN-wantedi	2003-04-08 23:35:55.000000000 -0600
+++ linux-2.4.20-braam/include/linux/ext3_fs.h	2003-04-08 23:35:55.000000000 -0600
@@ -201,6 +201,7 @@ struct ext3_group_desc
 #define	EXT3_IOC_SETFLAGS		_IOW('f', 2, long)
 #define	EXT3_IOC_GETVERSION		_IOR('f', 3, long)
 #define	EXT3_IOC_SETVERSION		_IOW('f', 4, long)
+/* EXT3_IOC_CREATE_INUM at bottom of file (visible to kernel and user). */
 #define	EXT3_IOC_GETVERSION_OLD		_IOR('v', 1, long)
 #define	EXT3_IOC_SETVERSION_OLD		_IOW('v', 2, long)
 #ifdef CONFIG_JBD_DEBUG
@@ -671,7 +672,8 @@ extern int ext3fs_dirhash(const char *na
 			  dx_hash_info *hinfo);
 
 /* ialloc.c */
-extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int);
+extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int,
+ 				      unsigned long);
 extern void ext3_free_inode (handle_t *, struct inode *);
 extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);
 extern unsigned long ext3_count_free_inodes (struct super_block *);
@@ -757,4 +759,5 @@ extern struct inode_operations ext3_fast
 
 #endif	/* __KERNEL__ */
 
+#define EXT3_IOC_CREATE_INUM			_IOW('f', 5, long)
 #endif	/* _LINUX_EXT3_FS_H */

_
 fs/ext3/inode.c |   82 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 82 insertions(+)

--- linux-2.4.20/fs/ext3/inode.c~extN-san	2003-04-08 23:35:59.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/inode.c	2003-04-08 23:35:59.000000000 -0600
@@ -2734,3 +2734,85 @@ int ext3_change_inode_journal_flag(struc
  * here, in ext3_aops_journal_start() to ensure that the forthcoming "see if we
  * need to extend" test in ext3_prepare_write() succeeds.  
  */
+
+/* for each block: 1 ind + 1 dind + 1 tind
+ * for each block: 3 bitmap blocks
+ * for each block: 3 group descriptor blocks
+ * i inode block
+ * 1 superblock
+ * 2 * EXT3_SINGLEDATA_TRANS_BLOCKS for the quote files
+ * ((1+1+1) * 3 * nblocks) + 1 + 1 + 2 * EXT3_SINGLEDATA_TRANS_BLOCKS
+ *
+ * XXX assuming:
+ * (1) fs logic block size == page size
+ * (2) ext3 in writeback mode
+ */
+static inline int ext3_san_write_trans_blocks(int nblocks)
+{
+	int ret;
+	
+	ret = (1 + 1 + 1) * 3 * nblocks + 1 + 1;
+
+#ifdef CONFIG_QUOTA
+	ret += 2 * EXT3_SINGLEDATA_TRANS_BLOCKS;
+#endif
+
+	return ret;
+}
+
+/* Alloc blocks for an inode, while don't create any buffer/page
+ * for data I/O; set the inode size if file is extended.
+ *
+ * @inode:    target inode
+ * @blocks:   array of logic block number
+ * @nblocks:  how many blocks need be alloced
+ * @newsize:  new filesize we should set
+ *
+ * return:    0 success, otherwise failed
+ *            (*blocks) contains physical block number alloced
+ *
+ * XXX this assume the fs block size == page size
+ */
+int ext3_prep_san_write(struct inode *inode, long *blocks,
+			int nblocks, loff_t newsize)
+{
+	handle_t *handle;
+	struct buffer_head bh_tmp;
+	int needed_blocks;
+	int i, ret = 0, ret2;
+
+	needed_blocks = ext3_san_write_trans_blocks(nblocks);
+
+	lock_kernel();
+	handle = ext3_journal_start(inode, needed_blocks);
+	if (IS_ERR(handle)) {
+		unlock_kernel();
+		return PTR_ERR(handle);
+	}
+	unlock_kernel();
+
+	/* alloc blocks one by one */
+	for (i = 0; i < nblocks; i++) {
+		ret = ext3_get_block_handle(handle, inode, blocks[i],
+						&bh_tmp, 1);
+		if (ret)
+			break;
+
+		blocks[i] = bh_tmp.b_blocknr;
+	}
+
+	/* set inode size if needed */
+	if (!ret && (newsize > inode->i_size)) {
+		inode->i_size = newsize;
+		ext3_mark_inode_dirty(handle, inode);
+	}
+
+	lock_kernel();
+	ret2 = ext3_journal_stop(handle, inode);
+	unlock_kernel();
+
+	if (!ret)
+		ret = ret2;
+	return ret;
+}
+EXPORT_SYMBOL(ext3_prep_san_write);

_
