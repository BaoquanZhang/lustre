--- ./fs/ext3/balloc.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/balloc.c	Tue May  7 15:35:59 2002
@@ -46,18 +46,18 @@ struct ext3_group_desc * ext3_get_group_
 	unsigned long desc;
 	struct ext3_group_desc * gdp;
 
-	if (block_group >= sb->u.ext3_sb.s_groups_count) {
+	if (block_group >= EXT3_SB(sb)->s_groups_count) {
 		ext3_error (sb, "ext3_get_group_desc",
 			    "block_group >= groups_count - "
 			    "block_group = %d, groups_count = %lu",
-			    block_group, sb->u.ext3_sb.s_groups_count);
+			    block_group, EXT3_SB(sb)->s_groups_count);
 
 		return NULL;
 	}
 	
 	group_desc = block_group / EXT3_DESC_PER_BLOCK(sb);
 	desc = block_group % EXT3_DESC_PER_BLOCK(sb);
-	if (!sb->u.ext3_sb.s_group_desc[group_desc]) {
+	if (!EXT3_SB(sb)->s_group_desc[group_desc]) {
 		ext3_error (sb, "ext3_get_group_desc",
 			    "Group descriptor not loaded - "
 			    "block_group = %d, group_desc = %lu, desc = %lu",
@@ -66,9 +66,9 @@ struct ext3_group_desc * ext3_get_group_
 	}
 	
 	gdp = (struct ext3_group_desc *) 
-	      sb->u.ext3_sb.s_group_desc[group_desc]->b_data;
+	      EXT3_SB(sb)->s_group_desc[group_desc]->b_data;
 	if (bh)
-		*bh = sb->u.ext3_sb.s_group_desc[group_desc];
+		*bh = EXT3_SB(sb)->s_group_desc[group_desc];
 	return gdp + desc;
 }
 
@@ -104,8 +104,8 @@ static int read_block_bitmap (struct sup
 	 * this group.  The IO will be retried next time.
 	 */
 error_out:
-	sb->u.ext3_sb.s_block_bitmap_number[bitmap_nr] = block_group;
-	sb->u.ext3_sb.s_block_bitmap[bitmap_nr] = bh;
+	EXT3_SB(sb)->s_block_bitmap_number[bitmap_nr] = block_group;
+	EXT3_SB(sb)->s_block_bitmap[bitmap_nr] = bh;
 	return retval;
 }
 
@@ -128,16 +128,17 @@ static int __load_block_bitmap (struct s
 	int i, j, retval = 0;
 	unsigned long block_bitmap_number;
 	struct buffer_head * block_bitmap;
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
 
-	if (block_group >= sb->u.ext3_sb.s_groups_count)
+	if (block_group >= sbi->s_groups_count)
 		ext3_panic (sb, "load_block_bitmap",
 			    "block_group >= groups_count - "
 			    "block_group = %d, groups_count = %lu",
-			    block_group, sb->u.ext3_sb.s_groups_count);
+			    block_group, EXT3_SB(sb)->s_groups_count);
 
-	if (sb->u.ext3_sb.s_groups_count <= EXT3_MAX_GROUP_LOADED) {
-		if (sb->u.ext3_sb.s_block_bitmap[block_group]) {
-			if (sb->u.ext3_sb.s_block_bitmap_number[block_group] ==
+	if (sbi->s_groups_count <= EXT3_MAX_GROUP_LOADED) {
+		if (sbi->s_block_bitmap[block_group]) {
+			if (sbi->s_block_bitmap_number[block_group] ==
 			    block_group)
 				return block_group;
 			ext3_error (sb, "__load_block_bitmap",
@@ -149,21 +150,20 @@ static int __load_block_bitmap (struct s
 		return block_group;
 	}
 
-	for (i = 0; i < sb->u.ext3_sb.s_loaded_block_bitmaps &&
-		    sb->u.ext3_sb.s_block_bitmap_number[i] != block_group; i++)
+	for (i = 0; i < sbi->s_loaded_block_bitmaps &&
+		    sbi->s_block_bitmap_number[i] != block_group; i++)
 		;
-	if (i < sb->u.ext3_sb.s_loaded_block_bitmaps &&
-  	    sb->u.ext3_sb.s_block_bitmap_number[i] == block_group) {
-		block_bitmap_number = sb->u.ext3_sb.s_block_bitmap_number[i];
-		block_bitmap = sb->u.ext3_sb.s_block_bitmap[i];
+	if (i < sbi->s_loaded_block_bitmaps &&
+  	    sbi->s_block_bitmap_number[i] == block_group) {
+		block_bitmap_number = sbi->s_block_bitmap_number[i];
+		block_bitmap = sbi->s_block_bitmap[i];
 		for (j = i; j > 0; j--) {
-			sb->u.ext3_sb.s_block_bitmap_number[j] =
-				sb->u.ext3_sb.s_block_bitmap_number[j - 1];
-			sb->u.ext3_sb.s_block_bitmap[j] =
-				sb->u.ext3_sb.s_block_bitmap[j - 1];
+			sbi->s_block_bitmap_number[j] =
+				sbi->s_block_bitmap_number[j - 1];
+			sbi->s_block_bitmap[j] = sbi->s_block_bitmap[j - 1];
 		}
-		sb->u.ext3_sb.s_block_bitmap_number[0] = block_bitmap_number;
-		sb->u.ext3_sb.s_block_bitmap[0] = block_bitmap;
+		sbi->s_block_bitmap_number[0] = block_bitmap_number;
+		sbi->s_block_bitmap[0] = block_bitmap;
 
 		/*
 		 * There's still one special case here --- if block_bitmap == 0
@@ -173,17 +173,14 @@ static int __load_block_bitmap (struct s
 		if (!block_bitmap)
 			retval = read_block_bitmap (sb, block_group, 0);
 	} else {
-		if (sb->u.ext3_sb.s_loaded_block_bitmaps<EXT3_MAX_GROUP_LOADED)
-			sb->u.ext3_sb.s_loaded_block_bitmaps++;
+		if (sbi->s_loaded_block_bitmaps<EXT3_MAX_GROUP_LOADED)
+			sbi->s_loaded_block_bitmaps++;
 		else
-			brelse (sb->u.ext3_sb.s_block_bitmap
-					[EXT3_MAX_GROUP_LOADED - 1]);
-		for (j = sb->u.ext3_sb.s_loaded_block_bitmaps - 1;
-					j > 0;  j--) {
-			sb->u.ext3_sb.s_block_bitmap_number[j] =
-				sb->u.ext3_sb.s_block_bitmap_number[j - 1];
-			sb->u.ext3_sb.s_block_bitmap[j] =
-				sb->u.ext3_sb.s_block_bitmap[j - 1];
+			brelse(sbi->s_block_bitmap[EXT3_MAX_GROUP_LOADED - 1]);
+		for (j = sbi->s_loaded_block_bitmaps - 1; j > 0;  j--) {
+			sbi->s_block_bitmap_number[j] =
+				sbi->s_block_bitmap_number[j - 1];
+			sbi->s_block_bitmap[j] = sbi->s_block_bitmap[j - 1];
 		}
 		retval = read_block_bitmap (sb, block_group, 0);
 	}
@@ -206,24 +203,25 @@ static int __load_block_bitmap (struct s
 static inline int load_block_bitmap (struct super_block * sb,
 				     unsigned int block_group)
 {
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
 	int slot;
-	
+
 	/*
 	 * Do the lookup for the slot.  First of all, check if we're asking
 	 * for the same slot as last time, and did we succeed that last time?
 	 */
-	if (sb->u.ext3_sb.s_loaded_block_bitmaps > 0 &&
-	    sb->u.ext3_sb.s_block_bitmap_number[0] == block_group &&
-	    sb->u.ext3_sb.s_block_bitmap[0]) {
+	if (sbi->s_loaded_block_bitmaps > 0 &&
+	    sbi->s_block_bitmap_number[0] == block_group &&
+	    sbi->s_block_bitmap[0]) {
 		return 0;
 	}
 	/*
 	 * Or can we do a fast lookup based on a loaded group on a filesystem
 	 * small enough to be mapped directly into the superblock?
 	 */
-	else if (sb->u.ext3_sb.s_groups_count <= EXT3_MAX_GROUP_LOADED && 
-		 sb->u.ext3_sb.s_block_bitmap_number[block_group]==block_group
-			&& sb->u.ext3_sb.s_block_bitmap[block_group]) {
+	else if (sbi->s_groups_count <= EXT3_MAX_GROUP_LOADED &&
+		 sbi->s_block_bitmap_number[block_group] == block_group
+			&& sbi->s_block_bitmap[block_group]) {
 		slot = block_group;
 	}
 	/*
@@ -243,7 +241,7 @@ static inline int load_block_bitmap (str
 	 * If it's a valid slot, we may still have cached a previous IO error,
 	 * in which case the bh in the superblock cache will be zero.
 	 */
-	if (!sb->u.ext3_sb.s_block_bitmap[slot])
+	if (!sbi->s_block_bitmap[slot])
 		return -EIO;
 	
 	/*
@@ -275,7 +273,7 @@ void ext3_free_blocks (handle_t *handle,
 		return;
 	}
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	if (block < le32_to_cpu(es->s_first_data_block) ||
 	    block + count < block ||
 	    (block + count) > le32_to_cpu(es->s_blocks_count)) {
@@ -304,7 +302,7 @@ do_more:
 	if (bitmap_nr < 0)
 		goto error_return;
 	
-	bitmap_bh = sb->u.ext3_sb.s_block_bitmap[bitmap_nr];
+	bitmap_bh = EXT3_SB(sb)->s_block_bitmap[bitmap_nr];
 	gdp = ext3_get_group_desc (sb, block_group, &gd_bh);
 	if (!gdp)
 		goto error_return;
@@ -330,8 +328,8 @@ do_more:
 	if (err)
 		goto error_return;
 
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get_write_access");
-	err = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
 	if (err)
 		goto error_return;
 
@@ -341,7 +339,7 @@
 		if (block == le32_to_cpu(gdp->bg_block_bitmap) ||
 		    block == le32_to_cpu(gdp->bg_inode_bitmap) ||
 		    in_range(block, le32_to_cpu(gdp->bg_inode_table),
-			     sb->u.ext2_sb.s_itb_per_group)) {
+			     EXT3_SB(sb)->s_itb_per_group)) {
 			ext3_error(sb, __FUNCTION__,
 				   "Freeing block in system zone - block = %lu",
 				   block);
@@ -410,8 +407,8 @@ do_more:
 	if (!err) err = ret;
 
 	/* And the superblock */
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "dirtied superblock");
-	ret = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "dirtied superblock");
+	ret = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 	if (!err) err = ret;
 
 	if (overflow && !err) {
@@ -564,12 +560,12 @@ int ext3_new_block (handle_t *handle, st
 	}
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	if (le32_to_cpu(es->s_free_blocks_count) <=
 			le32_to_cpu(es->s_r_blocks_count) &&
-	    ((sb->u.ext3_sb.s_resuid != current->fsuid) &&
-	     (sb->u.ext3_sb.s_resgid == 0 ||
-	      !in_group_p (sb->u.ext3_sb.s_resgid)) && 
+	    ((EXT3_SB(sb)->s_resuid != current->fsuid) &&
+	     (EXT3_SB(sb)->s_resgid == 0 ||
+	      !in_group_p (EXT3_SB(sb)->s_resgid)) &&
 	     !capable(CAP_SYS_RESOURCE)))
 		goto out;
 
@@ -598,7 +595,7 @@ int ext3_new_block (handle_t *handle, st
 		if (bitmap_nr < 0)
 			goto io_error;
 		
-		bh = sb->u.ext3_sb.s_block_bitmap[bitmap_nr];
+		bh = EXT3_SB(sb)->s_block_bitmap[bitmap_nr];
 
 		ext3_debug ("goal is at %d:%d.\n", i, j);
 
@@ -621,9 +618,9 @@ int ext3_new_block (handle_t *handle, st
 	 * Now search the rest of the groups.  We assume that 
 	 * i and gdp correctly point to the last group visited.
 	 */
-	for (k = 0; k < sb->u.ext3_sb.s_groups_count; k++) {
+	for (k = 0; k < EXT3_SB(sb)->s_groups_count; k++) {
 		i++;
-		if (i >= sb->u.ext3_sb.s_groups_count)
+		if (i >= EXT3_SB(sb)->s_groups_count)
 			i = 0;
 		gdp = ext3_get_group_desc (sb, i, &bh2);
 		if (!gdp) {
@@ -635,7 +632,7 @@ int ext3_new_block (handle_t *handle, st
 			if (bitmap_nr < 0)
 				goto io_error;
 	
-			bh = sb->u.ext3_sb.s_block_bitmap[bitmap_nr];
+			bh = EXT3_SB(sb)->s_block_bitmap[bitmap_nr];
 			j = find_next_usable_block(-1, bh, 
 						   EXT3_BLOCKS_PER_GROUP(sb));
 			if (j >= 0) 
@@ -674,8 +671,8 @@ got_block:
 	fatal = ext3_journal_get_write_access(handle, bh2);
 	if (fatal) goto out;
 
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get_write_access");
-	fatal = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "get_write_access");
+	fatal = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
 	if (fatal) goto out;
 
 	tmp = j + i * EXT3_BLOCKS_PER_GROUP(sb)
@@ -796,7 +804,7 @@ got_block:
 	if (!fatal) fatal = err;
 	
 	BUFFER_TRACE(bh, "journal_dirty_metadata for superblock");
-	err = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+	err = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 	if (!fatal) fatal = err;
 
 	sb->s_dirt = 1;
@@ -829,11 +837,11 @@ unsigned long ext3_count_free_blocks (st
 	int i;
 	
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	desc_count = 0;
 	bitmap_count = 0;
 	gdp = NULL;
-	for (i = 0; i < sb->u.ext3_sb.s_groups_count; i++) {
+	for (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {
 		gdp = ext3_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
@@ -842,7 +850,7 @@ unsigned long ext3_count_free_blocks (st
 		if (bitmap_nr < 0)
 			continue;
 		
-		x = ext3_count_free (sb->u.ext3_sb.s_block_bitmap[bitmap_nr],
+		x = ext3_count_free (EXT3_SB(sb)->s_block_bitmap[bitmap_nr],
 				     sb->s_blocksize);
 		printk ("group %d: stored = %d, counted = %lu\n",
 			i, le16_to_cpu(gdp->bg_free_blocks_count), x);
@@ -853,7 +861,7 @@ unsigned long ext3_count_free_blocks (st
 	unlock_super (sb);
 	return bitmap_count;
 #else
-	return le32_to_cpu(sb->u.ext3_sb.s_es->s_free_blocks_count);
+	return le32_to_cpu(EXT3_SB(sb)->s_es->s_free_blocks_count);
 #endif
 }
 
@@ -862,7 +870,7 @@ static inline int block_in_use (unsigned
 				unsigned char * map)
 {
 	return ext3_test_bit ((block -
-		le32_to_cpu(sb->u.ext3_sb.s_es->s_first_data_block)) %
+		le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block)) %
 			 EXT3_BLOCKS_PER_GROUP(sb), map);
 }
 
@@ -930,11 +938,11 @@ void ext3_check_blocks_bitmap (struct su
 	struct ext3_group_desc * gdp;
 	int i;
 
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	desc_count = 0;
 	bitmap_count = 0;
 	gdp = NULL;
-	for (i = 0; i < sb->u.ext3_sb.s_groups_count; i++) {
+	for (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {
 		gdp = ext3_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
@@ -968,7 +976,7 @@ void ext3_check_blocks_bitmap (struct su
 				    "Inode bitmap for group %d is marked free",
 				    i);
 
-		for (j = 0; j < sb->u.ext3_sb.s_itb_per_group; j++)
+		for (j = 0; j < EXT3_SB(sb)->s_itb_per_group; j++)
 			if (!block_in_use (le32_to_cpu(gdp->bg_inode_table) + j,
 							sb, bh->b_data))
 				ext3_error (sb, "ext3_check_blocks_bitmap",
--- ./fs/ext3/dir.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/dir.c	Tue May  7 14:54:13 2002
@@ -52,7 +52,7 @@ int ext3_check_dir_entry (const char * f
 	else if (((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)
 		error_msg = "directory entry across blocks";
 	else if (le32_to_cpu(de->inode) >
-			le32_to_cpu(dir->i_sb->u.ext3_sb.s_es->s_inodes_count))
+			le32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count))
 		error_msg = "inode out of bounds";
 
 	if (error_msg != NULL)
--- ./fs/ext3/ialloc.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/ialloc.c	Tue May  7 15:39:26 2002
@@ -73,8 +73,8 @@ static int read_inode_bitmap (struct sup
 	 * this group.  The IO will be retried next time.
 	 */
 error_out:
-	sb->u.ext3_sb.s_inode_bitmap_number[bitmap_nr] = block_group;
-	sb->u.ext3_sb.s_inode_bitmap[bitmap_nr] = bh;
+	EXT3_SB(sb)->s_inode_bitmap_number[bitmap_nr] = block_group;
+	EXT3_SB(sb)->s_inode_bitmap[bitmap_nr] = bh;
 	return retval;
 }
 
@@ -225,7 +225,7 @@ void ext3_free_inode (handle_t *handle, 
 	clear_inode (inode);
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
 	if (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {
 		ext3_error (sb, "ext3_free_inode",
 			    "reserved or nonexistent inode %lu", ino);
@@ -237,7 +237,7 @@ void ext3_free_inode (handle_t *handle, 
 	if (bitmap_nr < 0)
 		goto error_return;
 
-	bh = sb->u.ext3_sb.s_inode_bitmap[bitmap_nr];
+	bh = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr];
 
 	BUFFER_TRACE(bh, "get_write_access");
 	fatal = ext3_journal_get_write_access(handle, bh);
@@ -255,8 +255,8 @@ void ext3_free_inode (handle_t *handle, 
 		fatal = ext3_journal_get_write_access(handle, bh2);
 		if (fatal) goto error_return;
 
-		BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get write access");
-		fatal = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+		BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "get write access");
+		fatal = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
 		if (fatal) goto error_return;
 
 		if (gdp) {
@@ -271,9 +271,9 @@ void ext3_free_inode (handle_t *handle, 
 		if (!fatal) fatal = err;
 		es->s_free_inodes_count =
 			cpu_to_le32(le32_to_cpu(es->s_free_inodes_count) + 1);
-		BUFFER_TRACE(sb->u.ext3_sb.s_sbh,
+		BUFFER_TRACE(EXT3_SB(sb)->s_sbh,
 					"call ext3_journal_dirty_metadata");
-		err = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+		err = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 		if (!fatal) fatal = err;
 	}
 	BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
@@ -305,6 +305,8 @@ struct inode * ext3_new_inode (handle_t 
 	int i, j, avefreei;
 	struct inode * inode;
 	int bitmap_nr;
+	struct ext3_inode_info *ei;
+	struct ext3_sb_info *sbi;
 	struct ext3_group_desc * gdp;
 	struct ext3_group_desc * tmp;
 	struct ext3_super_block * es;
@@ -318,7 +320,9 @@ struct inode * ext3_new_inode (handle_t 
 	inode = new_inode(sb);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
-	init_rwsem(&inode->u.ext3_i.truncate_sem);
+	sbi = EXT3_SB(sb);
+	ei = EXT3_I(inode);
+	init_rwsem(&ei->truncate_sem);
 
 	lock_super (sb);
 	es = sb->u.ext3_sb.s_es;
@@ -328,9 +332,9 @@ struct inode * ext3_new_inode (handle_t 
 
 	if (S_ISDIR(mode)) {
 		avefreei = le32_to_cpu(es->s_free_inodes_count) /
-			sb->u.ext3_sb.s_groups_count;
+			sbi->s_groups_count;
 		if (!gdp) {
-			for (j = 0; j < sb->u.ext3_sb.s_groups_count; j++) {
+			for (j = 0; j < sbi->s_groups_count; j++) {
 				struct buffer_head *temp_buffer;
 				tmp = ext3_get_group_desc (sb, j, &temp_buffer);
 				if (tmp &&
@@ -350,7 +354,7 @@ repeat:
 		/*
 		 * Try to place the inode in its parent directory
 		 */
-		i = dir->u.ext3_i.i_block_group;
+		i = EXT3_I(dir)->i_block_group;
 		tmp = ext3_get_group_desc (sb, i, &bh2);
 		if (tmp && le16_to_cpu(tmp->bg_free_inodes_count))
 			gdp = tmp;
@@ -360,10 +364,10 @@ repeat:
 			 * Use a quadratic hash to find a group with a
 			 * free inode
 			 */
-			for (j = 1; j < sb->u.ext3_sb.s_groups_count; j <<= 1) {
+			for (j = 1; j < sbi->s_groups_count; j <<= 1) {
 				i += j;
-				if (i >= sb->u.ext3_sb.s_groups_count)
-					i -= sb->u.ext3_sb.s_groups_count;
+				if (i >= sbi->s_groups_count)
+					i -= sbi->s_groups_count;
 				tmp = ext3_get_group_desc (sb, i, &bh2);
 				if (tmp &&
 				    le16_to_cpu(tmp->bg_free_inodes_count)) {
@@ -376,9 +380,9 @@ repeat:
 			/*
 			 * That failed: try linear search for a free inode
 			 */
-			i = dir->u.ext3_i.i_block_group + 1;
-			for (j = 2; j < sb->u.ext3_sb.s_groups_count; j++) {
-				if (++i >= sb->u.ext3_sb.s_groups_count)
+			i = EXT3_I(dir)->i_block_group + 1;
+			for (j = 2; j < sbi->s_groups_count; j++) {
+				if (++i >= sbi->s_groups_count)
 					i = 0;
 				tmp = ext3_get_group_desc (sb, i, &bh2);
 				if (tmp &&
@@ -399,11 +403,11 @@ repeat:
 	if (bitmap_nr < 0)
 		goto fail;
 
-	bh = sb->u.ext3_sb.s_inode_bitmap[bitmap_nr];
+	bh = sbi->s_inode_bitmap[bitmap_nr];
 
 	if ((j = ext3_find_first_zero_bit ((unsigned long *) bh->b_data,
-				      EXT3_INODES_PER_GROUP(sb))) <
-	    EXT3_INODES_PER_GROUP(sb)) {
+				      sbi->s_inodes_per_group)) <
+	    sbi->s_inodes_per_group) {
 		BUFFER_TRACE(bh, "get_write_access");
 		err = ext3_journal_get_write_access(handle, bh);
 		if (err) goto fail;
@@ -457,13 +461,13 @@ repeat:
 	err = ext3_journal_dirty_metadata(handle, bh2);
 	if (err) goto fail;
 	
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get_write_access");
-	err = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(sbi->s_sbh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, sbi->s_sbh);
 	if (err) goto fail;
 	es->s_free_inodes_count =
 		cpu_to_le32(le32_to_cpu(es->s_free_inodes_count) - 1);
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "call ext3_journal_dirty_metadata");
-	err = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(sbi->s_sbh, "call ext3_journal_dirty_metadata");
+	err = ext3_journal_dirty_metadata(handle, sbi->s_sbh);
 	sb->s_dirt = 1;
 	if (err) goto fail;
 
@@ -483,31 +487,31 @@ repeat:
 	inode->i_blksize = PAGE_SIZE;
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
-	inode->u.ext3_i.i_flags = dir->u.ext3_i.i_flags & ~EXT3_INDEX_FL;
+	ei->i_flags = EXT3_I(dir)->i_flags & ~EXT3_INDEX_FL;
 	if (S_ISLNK(mode))
-		inode->u.ext3_i.i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_APPEND_FL);
+		ei->i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_APPEND_FL);
 #ifdef EXT3_FRAGMENTS
-	inode->u.ext3_i.i_faddr = 0;
-	inode->u.ext3_i.i_frag_no = 0;
-	inode->u.ext3_i.i_frag_size = 0;
+	ei->i_faddr = 0;
+	ei->i_frag_no = 0;
+	ei->i_frag_size = 0;
 #endif
-	inode->u.ext3_i.i_file_acl = 0;
-	inode->u.ext3_i.i_dir_acl = 0;
-	inode->u.ext3_i.i_dtime = 0;
-	INIT_LIST_HEAD(&inode->u.ext3_i.i_orphan);
+	ei->i_file_acl = 0;
+	ei->i_dir_acl = 0;
+	ei->i_dtime = 0;
+	INIT_LIST_HEAD(&ei->i_orphan);
 #ifdef EXT3_PREALLOCATE
-	inode->u.ext3_i.i_prealloc_count = 0;
+	ei->i_prealloc_count = 0;
 #endif
-	inode->u.ext3_i.i_block_group = i;
+	ei->i_block_group = i;
 	
-	if (inode->u.ext3_i.i_flags & EXT3_SYNC_FL)
+	if (ei->i_flags & EXT3_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (IS_SYNC(inode))
 		handle->h_sync = 1;
 	insert_inode_hash(inode);
-	inode->i_generation = sb->u.ext3_sb.s_next_generation++;
+	inode->i_generation = sbi->s_next_generation++;
 
-	inode->u.ext3_i.i_state = EXT3_STATE_NEW;
+	ei->i_state = EXT3_STATE_NEW;
 	err = ext3_mark_inode_dirty(handle, inode);
 	if (err) goto fail;
 	
@@ -585,19 +589,19 @@ struct inode *ext3_orphan_get (struct su
 
 unsigned long ext3_count_free_inodes (struct super_block * sb)
 {
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
+	struct ext3_super_block *es = sbi->s_es;
 #ifdef EXT3FS_DEBUG
-	struct ext3_super_block * es;
 	unsigned long desc_count, bitmap_count, x;
 	int bitmap_nr;
 	struct ext3_group_desc * gdp;
 	int i;
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
 	desc_count = 0;
 	bitmap_count = 0;
 	gdp = NULL;
-	for (i = 0; i < sb->u.ext3_sb.s_groups_count; i++) {
+	for (i = 0; i < sbi->s_groups_count; i++) {
 		gdp = ext3_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
@@ -606,8 +610,8 @@ unsigned long ext3_count_free_inodes (st
 		if (bitmap_nr < 0)
 			continue;
 
-		x = ext3_count_free (sb->u.ext3_sb.s_inode_bitmap[bitmap_nr],
-				     EXT3_INODES_PER_GROUP(sb) / 8);
+		x = ext3_count_free(sbi->s_inode_bitmap[bitmap_nr],
+				    sbi->s_inodes_per_group / 8);
 		printk ("group %d: stored = %d, counted = %lu\n",
 			i, le16_to_cpu(gdp->bg_free_inodes_count), x);
 		bitmap_count += x;
@@ -617,7 +621,7 @@ unsigned long ext3_count_free_inodes (st
 	unlock_super (sb);
 	return desc_count;
 #else
-	return le32_to_cpu(sb->u.ext3_sb.s_es->s_free_inodes_count);
+	return le32_to_cpu(es->s_free_inodes_count);
 #endif
 }
 
@@ -626,16 +630,18 @@ unsigned long ext3_count_free_inodes (st
 void ext3_check_inodes_bitmap (struct super_block * sb)
 {
 	struct ext3_super_block * es;
+	struct ext3_sb_info *sbi;
 	unsigned long desc_count, bitmap_count, x;
 	int bitmap_nr;
 	struct ext3_group_desc * gdp;
 	int i;
 
-	es = sb->u.ext3_sb.s_es;
+	sbi = EXT3_SB(sb);
+	es = sbi->s_es;
 	desc_count = 0;
 	bitmap_count = 0;
 	gdp = NULL;
-	for (i = 0; i < sb->u.ext3_sb.s_groups_count; i++) {
+	for (i = 0; i < sbi->s_groups_count; i++) {
 		gdp = ext3_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
@@ -644,7 +650,7 @@ void ext3_check_inodes_bitmap (struct su
 		if (bitmap_nr < 0)
 			continue;
 
-		x = ext3_count_free (sb->u.ext3_sb.s_inode_bitmap[bitmap_nr],
+		x = ext3_count_free (sbi->s_inode_bitmap[bitmap_nr],
 				     EXT3_INODES_PER_GROUP(sb) / 8);
 		if (le16_to_cpu(gdp->bg_free_inodes_count) != x)
 			ext3_error (sb, "ext3_check_inodes_bitmap",
--- ./fs/ext3/inode.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/inode.c	Tue May  7 15:41:23 2002
@@ -196,7 +196,7 @@ void ext3_delete_inode (struct inode * i
 	 * (Well, we could do this if we need to, but heck - it works)
 	 */
 	ext3_orphan_del(handle, inode);
-	inode->u.ext3_i.i_dtime	= CURRENT_TIME;
+	EXT3_I(inode)->i_dtime = CURRENT_TIME;
 
 	/* 
 	 * One subtle ordering requirement: if anything has gone wrong
@@ -220,13 +220,14 @@ no_delete:
 void ext3_discard_prealloc (struct inode * inode)
 {
 #ifdef EXT3_PREALLOCATE
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	lock_kernel();
 	/* Writer: ->i_prealloc* */
-	if (inode->u.ext3_i.i_prealloc_count) {
-		unsigned short total = inode->u.ext3_i.i_prealloc_count;
-		unsigned long block = inode->u.ext3_i.i_prealloc_block;
-		inode->u.ext3_i.i_prealloc_count = 0;
-		inode->u.ext3_i.i_prealloc_block = 0;
+	if (ei->i_prealloc_count) {
+		unsigned short total = ei->i_prealloc_count;
+		unsigned long block = ei->i_prealloc_block;
+		ei->i_prealloc_count = 0;
+		ei->i_prealloc_block = 0;
 		/* Writer: end */
 		ext3_free_blocks (inode, block, total);
 	}
@@ -243,13 +244,15 @@ static int ext3_alloc_block (handle_t *h
 	unsigned long result;
 
 #ifdef EXT3_PREALLOCATE
+	struct ext3_inode_info *ei = EXT3_I(inode);
+
 	/* Writer: ->i_prealloc* */
-	if (inode->u.ext3_i.i_prealloc_count &&
-	    (goal == inode->u.ext3_i.i_prealloc_block ||
-	     goal + 1 == inode->u.ext3_i.i_prealloc_block))
+	if (ei->i_prealloc_count &&
+	    (goal == ei->i_prealloc_block ||
+	     goal + 1 == ei->i_prealloc_block))
 	{
-		result = inode->u.ext3_i.i_prealloc_block++;
-		inode->u.ext3_i.i_prealloc_count--;
+		result = ei->i_prealloc_block++;
+		ei->i_prealloc_count--;
 		/* Writer: end */
 		ext3_debug ("preallocation hit (%lu/%lu).\n",
 			    ++alloc_hits, ++alloc_attempts);
@@ -259,8 +262,8 @@ static int ext3_alloc_block (handle_t *h
 			    alloc_hits, ++alloc_attempts);
 		if (S_ISREG(inode->i_mode))
 			result = ext3_new_block (inode, goal, 
-				 &inode->u.ext3_i.i_prealloc_count,
-				 &inode->u.ext3_i.i_prealloc_block, err);
+				 &ei->i_prealloc_count,
+				 &ei->i_prealloc_block, err);
 		else
 			result = ext3_new_block (inode, goal, 0, 0, err);
 		/*
@@ -394,7 +397,7 @@ static Indirect *ext3_get_branch(struct 
 
 	*err = 0;
 	/* i_data is not going away, no lock needed */
-	add_chain (chain, NULL, inode->u.ext3_i.i_data + *offsets);
+	add_chain (chain, NULL, EXT3_I(inode)->i_data + *offsets);
 	if (!p->key)
 		goto no_block;
 	while (--depth) {
@@ -437,7 +440,8 @@ no_block:
 
 static inline unsigned long ext3_find_near(struct inode *inode, Indirect *ind)
 {
-	u32 *start = ind->bh ? (u32*) ind->bh->b_data : inode->u.ext3_i.i_data;
+	struct ext3_inode_info *ei = EXT3_I(inode);
+	u32 *start = ind->bh ? (u32*) ind->bh->b_data : ei->i_data;
 	u32 *p;
 
 	/* Try to find previous block */
@@ -453,9 +456,8 @@ static inline unsigned long ext3_find_ne
 	 * It is going to be refered from inode itself? OK, just put it into
 	 * the same cylinder group then.
 	 */
-	return (inode->u.ext3_i.i_block_group * 
-		EXT3_BLOCKS_PER_GROUP(inode->i_sb)) +
-	       le32_to_cpu(inode->i_sb->u.ext3_sb.s_es->s_first_data_block);
+	return (ei->i_block_group * EXT3_BLOCKS_PER_GROUP(inode->i_sb)) +
+	       le32_to_cpu(EXT3_SB(inode->i_sb)->s_es->s_first_data_block);
 }
 
 /**
@@ -474,14 +477,15 @@
 static int ext3_find_goal(struct inode *inode, long block, Indirect chain[4],
 			  Indirect *partial, unsigned long *goal)
 {
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	/* Writer: ->i_next_alloc* */
-	if (block == inode->u.ext3_i.i_next_alloc_block + 1) {
-		inode->u.ext3_i.i_next_alloc_block++;
-		inode->u.ext3_i.i_next_alloc_goal++;
+	if (block == ei->i_next_alloc_block + 1) {
+		ei->i_next_alloc_block++;
+		ei->i_next_alloc_goal++;
 	}
 #ifdef SEARCH_FROM_ZERO
-	inode->u.ext3_i.i_next_alloc_block = 0;
-	inode->u.ext3_i.i_next_alloc_goal = 0;
+	ei->i_next_alloc_block = 0;
+	ei->i_next_alloc_goal = 0;
 #endif
 	/* Writer: end */
 	/* Reader: pointers, ->i_next_alloc* */
@@ -490,8 +493,8 @@ static int ext3_find_goal(struct inode *
 		 * try the heuristic for sequential allocation,
 		 * failing that at least try to get decent locality.
 		 */
-		if (block == inode->u.ext3_i.i_next_alloc_block)
-			*goal = inode->u.ext3_i.i_next_alloc_goal;
+		if (block == ei->i_next_alloc_block)
+			*goal = ei->i_next_alloc_goal;
 		if (!*goal)
 			*goal = ext3_find_near(inode, partial);
 #ifdef SEARCH_FROM_ZERO
@@ -619,6 +621,7 @@
 {
 	int i;
 	int err = 0;
+	struct ext3_inode_info *ei = EXT3_I(inode);
 
 	/*
 	 * If we're splicing into a [td]indirect block (as opposed to the
@@ -641,11 +644,11 @@ static int ext3_splice_branch(handle_t *
 	/* That's it */
 
 	*where->p = where->key;
-	inode->u.ext3_i.i_next_alloc_block = block;
-	inode->u.ext3_i.i_next_alloc_goal = le32_to_cpu(where[num-1].key);
+	ei->i_next_alloc_block = block;
+	ei->i_next_alloc_goal = le32_to_cpu(where[num-1].key);
 #ifdef SEARCH_FROM_ZERO
-	inode->u.ext3_i.i_next_alloc_block = 0;
-	inode->u.ext3_i.i_next_alloc_goal = 0;
+	ei->i_next_alloc_block = 0;
+	ei->i_next_alloc_goal = 0;
 #endif
 	/* Writer: end */
 
@@ -729,6 +732,7 @@
 	unsigned long goal;
 	int left;
 	int depth = ext3_block_to_path(inode, iblock, offsets);
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	loff_t new_size;
 
 	J_ASSERT(handle != NULL || create == 0);
@@ -782,7 +785,7 @@ out:
 	/*
 	 * Block out ext3_truncate while we alter the tree
 	 */
-	down_read(&inode->u.ext3_i.truncate_sem);
+	down_read(&ei->truncate_sem);
 	err = ext3_alloc_branch(handle, inode, left, goal,
 					offsets+(partial-chain), partial);
 
@@ -794,7 +797,7 @@ out:
 	if (!err)
 		err = ext3_splice_branch(handle, inode, iblock, chain,
 					 partial, left);
-	up_read(&inode->u.ext3_i.truncate_sem);
+	up_read(&ei->truncate_sem);
 	if (err == -EAGAIN)
 		goto changed;
 	if (err)
@@ -807,8 +810,8 @@ out:
 	 * truncate is in progress.  It is racy between multiple parallel
 	 * instances of get_block, but we have the BKL.
 	 */
-	if (new_size > inode->u.ext3_i.i_disksize)
-		inode->u.ext3_i.i_disksize = new_size;
+	if (new_size > ei->i_disksize)
+		ei->i_disksize = new_size;
 
 	bh_result->b_state |= (1UL << BH_New);
 	goto got_it;
@@ -921,7 +924,7 @@ struct buffer_head *ext3_bread(handle_t 
 		struct buffer_head *tmp_bh;
 
 		for (i = 1;
-		     inode->u.ext3_i.i_prealloc_count &&
+		     EXT3_I(inode)->i_prealloc_count &&
 		     i < EXT3_SB(inode->i_sb)->s_es->s_prealloc_dir_blocks;
 		     i++) {
 			/*
@@ -1131,8 +1134,8 @@ static int ext3_commit_write(struct file
 			kunmap(page);
 		}
 	}
-	if (inode->i_size > inode->u.ext3_i.i_disksize) {
-		inode->u.ext3_i.i_disksize = inode->i_size;
+	if (inode->i_size > EXT3_I(inode)->i_disksize) {
+		EXT3_I(inode)->i_disksize = inode->i_size;
 		ret2 = ext3_mark_inode_dirty(handle, inode);
 		if (!ret) 
 			ret = ret2;
@@ -1832,7 +1835,8 @@ static void ext3_free_branches(handle_t 
 void ext3_truncate(struct inode * inode)
 {
 	handle_t *handle;
-	u32 *i_data = inode->u.ext3_i.i_data;
+	struct ext3_inode_info *ei = EXT3_I(inode);
+	u32 *i_data = EXT3_I(inode)->i_data;
 	int addr_per_block = EXT3_ADDR_PER_BLOCK(inode->i_sb);
 	int offsets[4];
 	Indirect chain[4];
@@ -1884,13 +1887,13 @@ void ext3_truncate(struct inode * inode)
 	 * on-disk inode. We do this via i_disksize, which is the value which
 	 * ext3 *really* writes onto the disk inode.
 	 */
-	inode->u.ext3_i.i_disksize = inode->i_size;
+	ei->i_disksize = inode->i_size;
 
 	/*
 	 * From here we block out all ext3_get_block() callers who want to
 	 * modify the block allocation tree.
 	 */
-	down_write(&inode->u.ext3_i.truncate_sem);
+	down_write(&ei->truncate_sem);
 
 	if (n == 1) {		/* direct blocks */
 		ext3_free_data(handle, inode, NULL, i_data+offsets[0],
@@ -1954,7 +1957,7 @@ do_indirects:
 		case EXT3_TIND_BLOCK:
 			;
 	}
-	up_write(&inode->u.ext3_i.truncate_sem);
+	up_write(&ei->truncate_sem);
 	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 	ext3_mark_inode_dirty(handle, inode);
 
@@ -1983,6 +1986,8 @@ out_stop:
 
 int ext3_get_inode_loc (struct inode *inode, struct ext3_iloc *iloc)
 {
+	struct super_block *sb = inode->i_sb;
+	struct ext3_sb_info *sbi = EXT3_SB(sb);
 	struct buffer_head *bh = 0;
 	unsigned long block;
 	unsigned long block_group;
@@ -1997,23 +2010,19 @@ int ext3_get_inode_loc (struct inode *in
 		inode->i_ino != EXT3_JOURNAL_INO &&
-		inode->i_ino < EXT3_FIRST_INO(inode->i_sb)) ||
-		inode->i_ino > le32_to_cpu(
-			inode->i_sb->u.ext3_sb.s_es->s_inodes_count)) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
-			    "bad inode number: %lu", inode->i_ino);
+		inode->i_ino < EXT3_FIRST_INO(sb)) ||
+		inode->i_ino > le32_to_cpu(sbi->s_es->s_inodes_count)) {
+		ext3_error (sb, __FUNCTION__, "bad inode #%lu", inode->i_ino);
 		goto bad_inode;
 	}
-	block_group = (inode->i_ino - 1) / EXT3_INODES_PER_GROUP(inode->i_sb);
-	if (block_group >= inode->i_sb->u.ext3_sb.s_groups_count) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
-			    "group >= groups count");
+	block_group = (inode->i_ino - 1) / sbi->s_inodes_per_group;
+	if (block_group >= sbi->s_groups_count) {
+		ext3_error(sb, __FUNCTION__, "group >= groups count");
 		goto bad_inode;
 	}
-	group_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(inode->i_sb);
-	desc = block_group & (EXT3_DESC_PER_BLOCK(inode->i_sb) - 1);
-	bh = inode->i_sb->u.ext3_sb.s_group_desc[group_desc];
+	group_desc = block_group >> sbi->s_desc_per_block_bits;
+	desc = block_group & (sbi->s_desc_per_block - 1);
+	bh = sbi->s_group_desc[group_desc];
 	if (!bh) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
-			    "Descriptor not loaded");
+		ext3_error(sb, __FUNCTION__, "Descriptor not loaded");
 		goto bad_inode;
 	}
 
@@ -2021,17 +2022,17 @@ int ext3_get_inode_loc (struct inode *in
 	/*
 	 * Figure out the offset within the block group inode table
 	 */
-	offset = ((inode->i_ino - 1) % EXT3_INODES_PER_GROUP(inode->i_sb)) *
-		EXT3_INODE_SIZE(inode->i_sb);
+	offset = ((inode->i_ino - 1) % sbi->s_inodes_per_group) *
+		sbi->s_inode_size;
 	block = le32_to_cpu(gdp[desc].bg_inode_table) +
-		(offset >> EXT3_BLOCK_SIZE_BITS(inode->i_sb));
-	if (!(bh = sb_bread(inode->i_sb, block))) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
+		(offset >> EXT3_BLOCK_SIZE_BITS(sb));
+	if (!(bh = sb_bread(sb, block))) {
+		ext3_error (sb, __FUNCTION__,
 			    "unable to read inode block - "
 			    "inode=%lu, block=%lu", inode->i_ino, block);
 		goto bad_inode;
 	}
-	offset &= (EXT3_BLOCK_SIZE(inode->i_sb) - 1);
+	offset &= (EXT3_BLOCK_SIZE(sb) - 1);
 
 	iloc->bh = bh;
 	iloc->raw_inode = (struct ext3_inode *) (bh->b_data + offset);
@@ -2047,6 +2048,7 @@ void ext3_read_inode(struct inode * inod
 {
 	struct ext3_iloc iloc;
 	struct ext3_inode *raw_inode;
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct buffer_head *bh;
 	int block;
 	
@@ -2054,7 +2056,7 @@ void ext3_read_inode(struct inode * inod
 		goto bad_inode;
 	bh = iloc.bh;
 	raw_inode = iloc.raw_inode;
-	init_rwsem(&inode->u.ext3_i.truncate_sem);
+	init_rwsem(&ei->truncate_sem);
 	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
 	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
 	inode->i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
@@ -2067,7 +2069,7 @@ void ext3_read_inode(struct inode * inod
 	inode->i_atime = le32_to_cpu(raw_inode->i_atime);
 	inode->i_ctime = le32_to_cpu(raw_inode->i_ctime);
 	inode->i_mtime = le32_to_cpu(raw_inode->i_mtime);
-	inode->u.ext3_i.i_dtime = le32_to_cpu(raw_inode->i_dtime);
+	ei->i_dtime = le32_to_cpu(raw_inode->i_dtime);
 	/* We now have enough fields to check if the inode was active or not.
 	 * This is needed because nfsd might try to access dead inodes
 	 * the test is that same one that e2fsck uses
@@ -2075,7 +2077,7 @@ void ext3_read_inode(struct inode * inod
 	 */
 	if (inode->i_nlink == 0) {
 		if (inode->i_mode == 0 ||
-		    !(inode->i_sb->u.ext3_sb.s_mount_state & EXT3_ORPHAN_FS)) {
+		    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {
 			/* this inode is deleted */
 			brelse (bh);
 			goto bad_inode;
@@ -2090,33 +2092,33 @@ void ext3_read_inode(struct inode * inod
 					 * size */  
 	inode->i_blocks = le32_to_cpu(raw_inode->i_blocks);
 	inode->i_version = ++event;
-	inode->u.ext3_i.i_flags = le32_to_cpu(raw_inode->i_flags);
+	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
 #ifdef EXT3_FRAGMENTS
-	inode->u.ext3_i.i_faddr = le32_to_cpu(raw_inode->i_faddr);
-	inode->u.ext3_i.i_frag_no = raw_inode->i_frag;
-	inode->u.ext3_i.i_frag_size = raw_inode->i_fsize;
+	ei->i_faddr = le32_to_cpu(raw_inode->i_faddr);
+	ei->i_frag_no = raw_inode->i_frag;
+	ei->i_frag_size = raw_inode->i_fsize;
 #endif
-	inode->u.ext3_i.i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
+	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
 	if (!S_ISREG(inode->i_mode)) {
-		inode->u.ext3_i.i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);
+		ei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);
 	} else {
 		inode->i_size |=
 			((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;
 	}
-	inode->u.ext3_i.i_disksize = inode->i_size;
+	ei->i_disksize = inode->i_size;
 	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
 #ifdef EXT3_PREALLOCATE
-	inode->u.ext3_i.i_prealloc_count = 0;
+	ei->i_prealloc_count = 0;
 #endif
-	inode->u.ext3_i.i_block_group = iloc.block_group;
+	ei->i_block_group = iloc.block_group;
 
 	/*
 	 * NOTE! The in-memory inode i_data array is in little-endian order
 	 * even on big-endian machines: we do NOT byteswap the block numbers!
 	 */
 	for (block = 0; block < EXT3_N_BLOCKS; block++)
-		inode->u.ext3_i.i_data[block] = iloc.raw_inode->i_block[block];
-	INIT_LIST_HEAD(&inode->u.ext3_i.i_orphan);
+		ei->i_data[block] = iloc.raw_inode->i_block[block];
+	INIT_LIST_HEAD(&ei->i_orphan);
 
 	brelse (iloc.bh);
 
@@ -2143,17 +2145,17 @@ void ext3_read_inode(struct inode * inod
 	/* inode->i_attr_flags = 0;				unused */
-	if (inode->u.ext3_i.i_flags & EXT3_SYNC_FL) {
+	if (ei->i_flags & EXT3_SYNC_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_SYNCRONOUS; unused */
 		inode->i_flags |= S_SYNC;
 	}
-	if (inode->u.ext3_i.i_flags & EXT3_APPEND_FL) {
+	if (ei->i_flags & EXT3_APPEND_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_APPEND;	unused */
 		inode->i_flags |= S_APPEND;
 	}
-	if (inode->u.ext3_i.i_flags & EXT3_IMMUTABLE_FL) {
+	if (ei->i_flags & EXT3_IMMUTABLE_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_IMMUTABLE;	unused */
 		inode->i_flags |= S_IMMUTABLE;
 	}
-	if (inode->u.ext3_i.i_flags & EXT3_NOATIME_FL) {
+	if (ei->i_flags & EXT3_NOATIME_FL) {
 		/* inode->i_attr_flags |= ATTR_FLAG_NOATIME;	unused */
 		inode->i_flags |= S_NOATIME;
 	}
@@ -2175,6 +2177,7 @@ static int ext3_do_update_inode(handle_t
 				struct ext3_iloc *iloc)
 {
 	struct ext3_inode *raw_inode = iloc->raw_inode;
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct buffer_head *bh = iloc->bh;
 	int err = 0, rc, block;
 
@@ -2192,7 +2195,7 @@ static int ext3_do_update_inode(handle_t
  * Fix up interoperability with old kernels. Otherwise, old inodes get
  * re-used with the upper 16 bits of the uid/gid intact
  */
-		if(!inode->u.ext3_i.i_dtime) {
+		if(!ei->i_dtime) {
 			raw_inode->i_uid_high =
 				cpu_to_le16(high_16_bits(inode->i_uid));
 			raw_inode->i_gid_high =
@@ -2210,34 +2213,33 @@ static int ext3_do_update_inode(handle_t
 		raw_inode->i_gid_high = 0;
 	}
 	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
-	raw_inode->i_size = cpu_to_le32(inode->u.ext3_i.i_disksize);
+	raw_inode->i_size = cpu_to_le32(ei->i_disksize);
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime);
 	raw_inode->i_ctime = cpu_to_le32(inode->i_ctime);
 	raw_inode->i_mtime = cpu_to_le32(inode->i_mtime);
 	raw_inode->i_blocks = cpu_to_le32(inode->i_blocks);
-	raw_inode->i_dtime = cpu_to_le32(inode->u.ext3_i.i_dtime);
-	raw_inode->i_flags = cpu_to_le32(inode->u.ext3_i.i_flags);
+	raw_inode->i_dtime = cpu_to_le32(ei->i_dtime);
+	raw_inode->i_flags = cpu_to_le32(ei->i_flags);
 #ifdef EXT3_FRAGMENTS
-	raw_inode->i_faddr = cpu_to_le32(inode->u.ext3_i.i_faddr);
-	raw_inode->i_frag = inode->u.ext3_i.i_frag_no;
-	raw_inode->i_fsize = inode->u.ext3_i.i_frag_size;
+	raw_inode->i_faddr = cpu_to_le32(ei->i_faddr);
+	raw_inode->i_frag = ei->i_frag_no;
+	raw_inode->i_fsize = ei->i_frag_size;
 #else
 	/* If we are not tracking these fields in the in-memory inode,
 	 * then preserve them on disk, but still initialise them to zero
 	 * for new inodes. */
-	if (EXT3_I(inode)->i_state & EXT3_STATE_NEW) {
+	if (ei->i_state & EXT3_STATE_NEW) {
 		raw_inode->i_faddr = 0;
 		raw_inode->i_frag = 0;
 		raw_inode->i_fsize = 0;
 	}
 #endif
-	raw_inode->i_file_acl = cpu_to_le32(inode->u.ext3_i.i_file_acl);
+	raw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);
 	if (!S_ISREG(inode->i_mode)) {
-		raw_inode->i_dir_acl = cpu_to_le32(inode->u.ext3_i.i_dir_acl);
+		raw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);
 	} else {
-		raw_inode->i_size_high =
-			cpu_to_le32(inode->u.ext3_i.i_disksize >> 32);
-		if (inode->u.ext3_i.i_disksize > 0x7fffffffULL) {
+		raw_inode->i_size_high = cpu_to_le32(ei->i_disksize >> 32);
+		if (ei->i_disksize > MAX_NON_LFS) {
 			struct super_block *sb = inode->i_sb;
 			if (!EXT3_HAS_RO_COMPAT_FEATURE(sb,
 					EXT3_FEATURE_RO_COMPAT_LARGE_FILE) ||
@@ -2247,7 +2249,7 @@ static int ext3_do_update_inode(handle_t
 				* created, add a flag to the superblock.
 				*/
 				err = ext3_journal_get_write_access(handle,
-						sb->u.ext3_sb.s_sbh);
+						EXT3_SB(sb)->s_sbh);
 				if (err)
 					goto out_brelse;
 				ext3_update_dynamic_rev(sb);
@@ -2256,7 +2258,7 @@ static int ext3_do_update_inode(handle_t
 				sb->s_dirt = 1;
 				handle->h_sync = 1;
 				err = ext3_journal_dirty_metadata(handle,
-						sb->u.ext3_sb.s_sbh);
+						EXT3_SB(sb)->s_sbh);
 			}
 		}
 	}
@@ -2265,13 +2267,13 @@ static int ext3_do_update_inode(handle_t
 		raw_inode->i_block[0] =
 			cpu_to_le32(kdev_t_to_nr(inode->i_rdev));
 	else for (block = 0; block < EXT3_N_BLOCKS; block++)
-		raw_inode->i_block[block] = inode->u.ext3_i.i_data[block];
+		raw_inode->i_block[block] = ei->i_data[block];
 
 	BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
 	rc = ext3_journal_dirty_metadata(handle, bh);
 	if (!err)
 		err = rc;
-	EXT3_I(inode)->i_state &= ~EXT3_STATE_NEW;
+	ei->i_state &= ~EXT3_STATE_NEW;
 
 out_brelse:
 	brelse (bh);
@@ -2379,7 +2381,7 @@ int ext3_setattr(struct dentry *dentry, 
 		}
 		
 		error = ext3_orphan_add(handle, inode);
-		inode->u.ext3_i.i_disksize = attr->ia_size;
+		EXT3_I(inode)->i_disksize = attr->ia_size;
 		rc = ext3_mark_inode_dirty(handle, inode);
 		if (!error)
 			error = rc;
@@ -2622,9 +2624,9 @@ int ext3_change_inode_journal_flag(struc
 	 */
 
 	if (val)
-		inode->u.ext3_i.i_flags |= EXT3_JOURNAL_DATA_FL;
+		EXT3_I(inode)->i_flags |= EXT3_JOURNAL_DATA_FL;
 	else
-		inode->u.ext3_i.i_flags &= ~EXT3_JOURNAL_DATA_FL;
+		EXT3_I(inode)->i_flags &= ~EXT3_JOURNAL_DATA_FL;
 
 	journal_unlock_updates(journal);
 
--- ./fs/ext3/ioctl.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/ioctl.c	Tue May  7 15:20:52 2002
@@ -18,13 +18,14 @@
 int ext3_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 		unsigned long arg)
 {
+	struct ext3_inode_info *ei = EXT3_I(inode);
 	unsigned int flags;
 
 	ext3_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
 	case EXT3_IOC_GETFLAGS:
-		flags = inode->u.ext3_i.i_flags & EXT3_FL_USER_VISIBLE;
+		flags = ei->i_flags & EXT3_FL_USER_VISIBLE;
 		return put_user(flags, (int *) arg);
 	case EXT3_IOC_SETFLAGS: {
 		handle_t *handle = NULL;
@@ -42,7 +42,7 @@ int ext3_ioctl (struct inode * inode, st
 		if (get_user(flags, (int *) arg))
 			return -EFAULT;
 
-		oldflags = inode->u.ext3_i.i_flags;
+		oldflags = ei->i_flags;
 
 		/* The JOURNAL_DATA flag is modifiable only by root */
 		jflag = flags & EXT3_JOURNAL_DATA_FL;
@@ -79,7 +79,7 @@ int ext3_ioctl (struct inode * inode, st
 		
 		flags = flags & EXT3_FL_USER_MODIFIABLE;
 		flags |= oldflags & ~EXT3_FL_USER_MODIFIABLE;
-		inode->u.ext3_i.i_flags = flags;
+		ei->i_flags = flags;
 
 		if (flags & EXT3_SYNC_FL)
 			inode->i_flags |= S_SYNC;
@@ -155,12 +155,12 @@ flags_err:
 			int ret = 0;
 
 			set_current_state(TASK_INTERRUPTIBLE);
-			add_wait_queue(&sb->u.ext3_sb.ro_wait_queue, &wait);
-			if (timer_pending(&sb->u.ext3_sb.turn_ro_timer)) {
+			add_wait_queue(&EXT3_SB(sb)->ro_wait_queue, &wait);
+			if (timer_pending(&EXT3_SB(sb)->turn_ro_timer)) {
 				schedule();
 				ret = 1;
 			}
-			remove_wait_queue(&sb->u.ext3_sb.ro_wait_queue, &wait);
+			remove_wait_queue(&EXT3_SB(sb)->ro_wait_queue, &wait);
 			return ret;
 		}
 #endif
--- ./fs/ext3/namei.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/namei.c	Tue May  7 16:05:51 2002
@@ -1430,8 +1430,8 @@ int ext3_orphan_add(handle_t *handle, st
 	J_ASSERT ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 		S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);
 
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "get_write_access");
-	err = ext3_journal_get_write_access(handle, sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(EXT3_SB(sb)->s_sbh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh);
 	if (err)
 		goto out_unlock;
 	
@@ -1442,7 +1442,7 @@ int ext3_orphan_add(handle_t *handle, st
 	/* Insert this inode at the head of the on-disk orphan list... */
 	NEXT_ORPHAN(inode) = le32_to_cpu(EXT3_SB(sb)->s_es->s_last_orphan);
 	EXT3_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);
-	err = ext3_journal_dirty_metadata(handle, sb->u.ext3_sb.s_sbh);
+	err = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 	rc = ext3_mark_iloc_dirty(handle, inode, &iloc);
 	if (!err)
 		err = rc;
@@ -1520,8 +1520,7 @@ int ext3_orphan_del(handle_t *handle, st
 		err = ext3_journal_dirty_metadata(handle, sbi->s_sbh);
 	} else {
 		struct ext3_iloc iloc2;
-		struct inode *i_prev =
-			list_entry(prev, struct inode, u.ext3_i.i_orphan);
+		struct inode *i_prev = orphan_list_entry(prev);
 
 		jbd_debug(4, "orphan inode %lu will point to %lu\n",
 			  i_prev->i_ino, ino_next);
--- ./fs/ext3/super.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/super.c	Tue May  7 16:05:44 2002
@@ -121,7 +121,7 @@ static int ext3_error_behaviour(struct s
 	/* If no overrides were specified on the mount, then fall back
 	 * to the default behaviour set in the filesystem's superblock
 	 * on disk. */
-	switch (le16_to_cpu(sb->u.ext3_sb.s_es->s_errors)) {
+	switch (le16_to_cpu(EXT3_SB(sb)->s_es->s_errors)) {
 	case EXT3_ERRORS_PANIC:
 		return EXT3_ERRORS_PANIC;
 	case EXT3_ERRORS_RO:
@@ -269,9 +269,9 @@ void ext3_abort (struct super_block * sb
 		return;
 	
 	printk (KERN_CRIT "Remounting filesystem read-only\n");
-	sb->u.ext3_sb.s_mount_state |= EXT3_ERROR_FS;
+	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
 	sb->s_flags |= MS_RDONLY;
-	sb->u.ext3_sb.s_mount_opt |= EXT3_MOUNT_ABORT;
+	EXT3_SB(sb)->s_mount_opt |= EXT3_MOUNT_ABORT;
 	journal_abort(EXT3_SB(sb)->s_journal, -EIO);
 }
 
@@ -377,8 +377,6 @@ static int ext3_blkdev_remove(struct ext3
 	return ret;
 }
 
-#define orphan_list_entry(l) list_entry((l), struct inode, u.ext3_i.i_orphan)
-
 static void dump_orphan_list(struct super_block *sb, struct ext3_sb_info *sbi)
 {
 	struct list_head *l;
@@ -818,7 +818,7 @@ static void ext3_orphan_cleanup (struct 
 		sb->s_flags &= ~MS_RDONLY;
 	}
 
-	if (sb->u.ext3_sb.s_mount_state & EXT3_ERROR_FS) {
+	if (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {
 		if (es->s_last_orphan)
 			jbd_debug(1, "Errors on filesystem, "
 				  "clearing orphan list.\n");
@@ -1463,12 +1463,14 @@ static void ext3_commit_super (struct su
 			       struct ext3_super_block * es,
 			       int sync)
 {
+	struct buffer_head *sbh = EXT3_SB(sb)->s_sbh;
+
 	es->s_wtime = cpu_to_le32(CURRENT_TIME);
-	BUFFER_TRACE(sb->u.ext3_sb.s_sbh, "marking dirty");
-	mark_buffer_dirty(sb->u.ext3_sb.s_sbh);
+	BUFFER_TRACE(sbh, "marking dirty");
+	mark_buffer_dirty(sbh);
 	if (sync) {
-		ll_rw_block(WRITE, 1, &sb->u.ext3_sb.s_sbh);
-		wait_on_buffer(sb->u.ext3_sb.s_sbh);
+		ll_rw_block(WRITE, 1, &sbh);
+		wait_on_buffer(sbh);
 	}
 }
 
@@ -1519,7 +1521,7 @@ static void ext3_clear_journal_err(struc
 		ext3_warning(sb, __FUNCTION__, "Marking fs in need of "
 			     "filesystem check.");
 		
-		sb->u.ext3_sb.s_mount_state |= EXT3_ERROR_FS;
+		EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
 		es->s_state |= cpu_to_le16(EXT3_ERROR_FS);
 		ext3_commit_super (sb, es, 1);
 
--- ./fs/ext3/symlink.c.orig	Fri Apr 12 10:27:49 2002
+++ ./fs/ext3/symlink.c	Tue May  7 15:25:39 2002
@@ -23,13 +23,13 @@
 
 static int ext3_readlink(struct dentry *dentry, char *buffer, int buflen)
 {
-	char *s = (char *)dentry->d_inode->u.ext3_i.i_data;
-	return vfs_readlink(dentry, buffer, buflen, s);
+	struct ext3_inode_info *ei = EXT3_I(dentry->d_inode);
+	return vfs_readlink(dentry, buffer, buflen, (char *)ei->i_data);
 }
 
 static int ext3_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	char *s = (char *)dentry->d_inode->u.ext3_i.i_data;
-	return vfs_follow_link(nd, s);
+	struct ext3_inode_info *ei = EXT3_I(dentry->d_inode);
+	return vfs_follow_link(nd, (char*)ei->i_data);
 }
 
--- ./include/linux/ext3_fs.h.orig	Tue Apr 16 14:27:25 2002
+++ ./include/linux/ext3_fs.h	Tue May  7 16:47:36 2002
@@ -84,22 +84,25 @@
 #define EXT3_MIN_BLOCK_SIZE		1024
 #define	EXT3_MAX_BLOCK_SIZE		4096
 #define EXT3_MIN_BLOCK_LOG_SIZE		  10
+
 #ifdef __KERNEL__
-# define EXT3_BLOCK_SIZE(s)		((s)->s_blocksize)
-#else
-# define EXT3_BLOCK_SIZE(s)		(EXT3_MIN_BLOCK_SIZE << (s)->s_log_block_size)
-#endif
-#define	EXT3_ADDR_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (__u32))
-#ifdef __KERNEL__
-# define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
-#else
-# define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_log_block_size + 10)
-#endif
-#ifdef __KERNEL__
-#define	EXT3_ADDR_PER_BLOCK_BITS(s)	((s)->u.ext3_sb.s_addr_per_block_bits)
-#define EXT3_INODE_SIZE(s)		((s)->u.ext3_sb.s_inode_size)
-#define EXT3_FIRST_INO(s)		((s)->u.ext3_sb.s_first_ino)
+#define EXT3_SB(sb)	(&((sb)->u.ext3_sb))
+#define EXT3_I(inode)	(&((inode)->u.ext3_i))
+
+#define EXT3_BLOCK_SIZE(s)		((s)->s_blocksize)
+#define EXT3_BLOCK_SIZE_BITS(s)		((s)->s_blocksize_bits)
+#define	EXT3_ADDR_PER_BLOCK_BITS(s)	(EXT3_SB(s)->s_addr_per_block_bits)
+#define EXT3_INODE_SIZE(s)		(EXT3_SB(s)->s_inode_size)
+#define EXT3_FIRST_INO(s)		(EXT3_SB(s)->s_first_ino)
 #else
+
+/* Assume that user mode programs are passing in an ext3fs superblock, not
+ * a kernel struct super_block.  This will allow us to call the feature-test
+ * macros from user land. */
+#define EXT3_SB(sb)	(sb)
+
+#define EXT3_BLOCK_SIZE(s)	(EXT3_MIN_BLOCK_SIZE << (s)->s_log_block_size)
+#define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_log_block_size + 10)
 #define EXT3_INODE_SIZE(s)	(((s)->s_rev_level == EXT3_GOOD_OLD_REV) ? \
 				 EXT3_GOOD_OLD_INODE_SIZE : \
 				 (s)->s_inode_size)
@@ -108,6 +110,7 @@
 				 EXT3_GOOD_OLD_FIRST_INO : \
 				 (s)->s_first_ino)
 #endif
+#define EXT3_ADDR_PER_BLOCK(s)	(EXT3_BLOCK_SIZE(s) / sizeof (__u32))
 
 /*
  * Macro-instructions used to manage fragments
@@ -116,8 +120,8 @@
 #define	EXT3_MAX_FRAG_SIZE		4096
 #define EXT3_MIN_FRAG_LOG_SIZE		  10
 #ifdef __KERNEL__
-# define EXT3_FRAG_SIZE(s)		((s)->u.ext3_sb.s_frag_size)
-# define EXT3_FRAGS_PER_BLOCK(s)	((s)->u.ext3_sb.s_frags_per_block)
+# define EXT3_FRAG_SIZE(s)		(EXT3_SB(s)->s_frag_size)
+# define EXT3_FRAGS_PER_BLOCK(s)	(EXT3_SB(s)->s_frags_per_block)
 #else
 # define EXT3_FRAG_SIZE(s)		(EXT3_MIN_FRAG_SIZE << (s)->s_log_frag_size)
 # define EXT3_FRAGS_PER_BLOCK(s)	(EXT3_BLOCK_SIZE(s) / EXT3_FRAG_SIZE(s))
@@ -163,15 +167,13 @@
 /*
  * Macro-instructions used to manage group descriptors
  */
+# define EXT3_BLOCKS_PER_GROUP(s)	(EXT3_SB(s)->s_blocks_per_group)
+# define EXT3_INODES_PER_GROUP(s)	(EXT3_SB(s)->s_inodes_per_group)
 #ifdef __KERNEL__
-# define EXT3_BLOCKS_PER_GROUP(s)	((s)->u.ext3_sb.s_blocks_per_group)
-# define EXT3_DESC_PER_BLOCK(s)		((s)->u.ext3_sb.s_desc_per_block)
-# define EXT3_INODES_PER_GROUP(s)	((s)->u.ext3_sb.s_inodes_per_group)
-# define EXT3_DESC_PER_BLOCK_BITS(s)	((s)->u.ext3_sb.s_desc_per_block_bits)
+# define EXT3_DESC_PER_BLOCK(s)		(EXT3_SB(s)->s_desc_per_block)
+# define EXT3_DESC_PER_BLOCK_BITS(s)	(EXT3_SB(s)->s_desc_per_block_bits)
 #else
-# define EXT3_BLOCKS_PER_GROUP(s)	((s)->s_blocks_per_group)
 # define EXT3_DESC_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (struct ext3_group_desc))
-# define EXT3_INODES_PER_GROUP(s)	((s)->s_inodes_per_group)
 #endif
 
 /*
@@ -344,7 +347,7 @@
 #ifndef _LINUX_EXT2_FS_H
 #define clear_opt(o, opt)		o &= ~EXT3_MOUNT_##opt
 #define set_opt(o, opt)			o |= EXT3_MOUNT_##opt
-#define test_opt(sb, opt)		((sb)->u.ext3_sb.s_mount_opt & \
+#define test_opt(sb, opt)		(EXT3_SB(sb)->s_mount_opt & \
 					 EXT3_MOUNT_##opt)
 #else
 #define EXT2_MOUNT_NOLOAD		EXT3_MOUNT_NOLOAD
@@ -441,17 +443,11 @@
 /*EC*/	__u32	s_reserved[197];	/* Padding to the end of the block */
 };
 
-#ifdef __KERNEL__
-#define EXT3_SB(sb)	(&((sb)->u.ext3_sb))
-#define EXT3_I(inode)	(&((inode)->u.ext3_i))
-#else
-/* Assume that user mode programs are passing in an ext3fs superblock, not
- * a kernel struct super_block.  This will allow us to call the feature-test
- * macros from user land. */
-#define EXT3_SB(sb)	(sb)
-#endif
-
-#define NEXT_ORPHAN(inode) (inode)->u.ext3_i.i_dtime
+#define NEXT_ORPHAN(inode) EXT3_I(inode)->i_dtime
+static inline struct inode *orphan_list_entry(struct list_head *l)
+{
+	return list_entry(l, struct inode, u.ext3_i.i_orphan);
+}
 
 /*
  * Codes for operating systems
--- ./include/linux/ext3_jbd.h.orig	Tue May  7 14:44:08 2002
+++ ./include/linux/ext3_jbd.h	Tue May  7 14:44:43 2002
@@ -291,7 +291,7 @@
 		return 1;
 	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)
 		return 1;
-	if (inode->u.ext3_i.i_flags & EXT3_JOURNAL_DATA_FL)
+	if (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)
 		return 1;
 	return 0;
 }
