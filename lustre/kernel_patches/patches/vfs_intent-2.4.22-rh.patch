 fs/dcache.c               |   19 ++
 fs/exec.c                 |   17 +-
 fs/namei.c                |  295 +++++++++++++++++++++++++++++++++++++++-------
 fs/namespace.c            |   28 +++-
 fs/open.c                 |  172 +++++++++++++++++++-------
 fs/stat.c                 |   52 +++++---
 include/linux/dcache.h    |   60 +++++++++
 include/linux/fs.h        |   32 ++++
 include/linux/fs_struct.h |    4 
 kernel/exit.c             |    3 
 kernel/fork.c             |    3 
 kernel/ksyms.c            |    1 
 12 files changed, 558 insertions(+), 128 deletions(-)

--- linux-2.4.22-ac1/fs/dcache.c~vfs_intent-2.4.22-rh	2003-09-25 14:16:29.000000000 +0400
+++ linux-2.4.22-ac1-alexey/fs/dcache.c	2003-09-25 14:42:46.000000000 +0400
@@ -181,6 +181,13 @@ int d_invalidate(struct dentry * dentry)
 		spin_unlock(&dcache_lock);
 		return 0;
 	}
+
+	/* network invalidation by Lustre */
+	if (dentry->d_flags & DCACHE_LUSTRE_INVALID) {
+		spin_unlock(&dcache_lock);
+		return 0;
+	}
+
 	/*
 	 * Check whether to do a partial shrink_dcache
 	 * to get rid of unused child entries.
@@ -833,13 +840,19 @@ void d_delete(struct dentry * dentry)
  * Adds a dentry to the hash according to its name.
  */
  
-void d_rehash(struct dentry * entry)
+void __d_rehash(struct dentry * entry, int lock)
 {
 	struct list_head *list = d_hash(entry->d_parent, entry->d_name.hash);
 	if (!list_empty(&entry->d_hash)) BUG();
-	spin_lock(&dcache_lock);
+	if (lock) spin_lock(&dcache_lock);
 	list_add(&entry->d_hash, list);
-	spin_unlock(&dcache_lock);
+	if (lock) spin_unlock(&dcache_lock);
+}
+EXPORT_SYMBOL(__d_rehash);
+
+void d_rehash(struct dentry * entry)
+{
+	__d_rehash(entry, 1);
 }
 
 #define do_switch(x,y) do { \
--- linux-2.4.22-ac1/fs/exec.c~vfs_intent-2.4.22-rh	2003-09-25 14:16:29.000000000 +0400
+++ linux-2.4.22-ac1-alexey/fs/exec.c	2003-09-25 14:42:46.000000000 +0400
@@ -115,8 +115,10 @@ asmlinkage long sys_uselib(const char * 
 	struct file * file;
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_OPEN,
+				    .it_flags = FMODE_READ|FMODE_EXEC };
 
-	error = user_path_walk(library, &nd);
+	error = user_path_walk_it(library, &nd, &it);
 	if (error)
 		goto out;
 
@@ -128,7 +130,8 @@ asmlinkage long sys_uselib(const char * 
 	if (error)
 		goto exit;
 
-	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+	file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &it);
+	intent_release(&it);
 	error = PTR_ERR(file);
 	if (IS_ERR(file))
 		goto out;
@@ -390,8 +393,10 @@ struct file *open_exec(const char *name)
 	struct inode *inode;
 	struct file *file;
 	int err = 0;
+	struct lookup_intent it = { .it_op = IT_OPEN,
+				    .it_flags = FMODE_READ|FMODE_EXEC };
 
-	err = path_lookup(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &nd);
+	err = path_lookup_it(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &nd, &it);
 	file = ERR_PTR(err);
 	if (!err) {
 		inode = nd.dentry->d_inode;
@@ -403,7 +408,8 @@ struct file *open_exec(const char *name)
 				err = -EACCES;
 			file = ERR_PTR(err);
 			if (!err) {
-				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+				file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &it);
+				intent_release(&it);
 				if (!IS_ERR(file)) {
 					err = deny_write_access(file);
 					if (err) {
@@ -415,6 +421,7 @@ out:
 				return file;
 			}
 		}
+		intent_release(&it);
 		path_release(&nd);
 	}
 	goto out;
@@ -1322,7 +1329,7 @@ int do_coredump(long signr, int exit_cod
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
-	if (do_truncate(file->f_dentry, 0) != 0)
+	if (do_truncate(file->f_dentry, 0, 0) != 0)
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);
--- linux-2.4.22-ac1/fs/namei.c~vfs_intent-2.4.22-rh	2003-09-25 14:16:23.000000000 +0400
+++ linux-2.4.22-ac1-alexey/fs/namei.c	2003-09-25 14:44:40.000000000 +0400
@@ -94,6 +94,13 @@
  * XEmacs seems to be relying on it...
  */
 
+void intent_release(struct lookup_intent *it)
+{
+	if (it && it->it_op_release)
+		it->it_op_release(it);
+
+}
+
 /* In order to reduce some races, while at the same time doing additional
  * checking and hopefully speeding things up, we copy filenames to the
  * kernel data space before using them..
@@ -260,10 +267,19 @@ void path_release(struct nameidata *nd)
  * Internal lookup() using the new generic dcache.
  * SMP-safe
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry *cached_lookup(struct dentry *parent, struct qstr *name,
+				    int flags, struct lookup_intent *it)
 {
 	struct dentry * dentry = d_lookup(parent, name);
 
+	if (dentry && dentry->d_op && dentry->d_op->d_revalidate_it) {
+		if (!dentry->d_op->d_revalidate_it(dentry, flags, NULL, it) &&
+		    !d_invalidate(dentry)) {
+			dput(dentry);
+			dentry = NULL;
+		}
+		return dentry;
+	} else
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
@@ -281,11 +297,15 @@ static struct dentry * cached_lookup(str
  * make sure that nobody added the entry to the dcache in the meantime..
  * SMP-safe
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry *real_lookup(struct dentry *parent, struct qstr *name,
+				  int flags, struct lookup_intent *it)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
+	int counter = 0;
 
+again:
+	counter++;
 	down(&dir->i_sem);
 	/*
 	 * First re-do the cached lookup just in case it was created
@@ -300,6 +320,9 @@ static struct dentry * real_lookup(struc
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
 			lock_kernel();
+			if (dir->i_op->lookup_it)
+				result = dir->i_op->lookup_it(dir, dentry, NULL, it, flags);
+			else
 			result = dir->i_op->lookup(dir, dentry);
 			unlock_kernel();
 			if (result)
@@ -321,6 +344,15 @@ static struct dentry * real_lookup(struc
 			dput(result);
 			result = ERR_PTR(-ENOENT);
 		}
+	} else if (result->d_op && result->d_op->d_revalidate_it) {
+		if (!result->d_op->d_revalidate_it(result, flags, NULL, it) &&
+		    !d_invalidate(result)) {
+			dput(result);
+			if (counter > 10)
+				result = ERR_PTR(-ESTALE);
+			if (!IS_ERR(result))
+				goto again;
+		}
 	}
 	return result;
 }
@@ -332,7 +364,8 @@ static struct dentry * real_lookup(struc
  * Without that kind of total limit, nasty chains of consecutive
  * symlinks can cause almost arbitrarily long lookups. 
  */
-static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd)
+static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd,
+				 struct lookup_intent *it)
 {
 	int err;
 	if (current->link_count >= 5)
@@ -346,10 +379,12 @@ static inline int do_follow_link(struct 
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
+	nd->intent = it;
 	err = dentry->d_inode->i_op->follow_link(dentry, nd);
 	current->link_count--;
 	return err;
 loop:
+	intent_release(it);
 	path_release(nd);
 	return -ELOOP;
 }
@@ -447,7 +482,8 @@ static inline void follow_dotdot(struct 
  *
  * We expect 'base' to be positive and a directory.
  */
-int link_path_walk(const char * name, struct nameidata *nd)
+int link_path_walk_it(const char *name, struct nameidata *nd,
+		      struct lookup_intent *it)
 {
 	struct dentry *dentry;
 	struct inode *inode;
@@ -520,9 +556,9 @@ int link_path_walk(const char * name, st
 				break;
 		}
 		/* This does the actual lookups.. */
-		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE, NULL);
 		if (!dentry) {
-			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE, NULL);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
@@ -540,7 +576,7 @@ int link_path_walk(const char * name, st
 			goto out_dput;
 
 		if (inode->i_op->follow_link) {
-			err = do_follow_link(dentry, nd);
+			err = do_follow_link(dentry, nd, NULL);
 			dput(dentry);
 			if (err)
 				goto return_err;
@@ -556,7 +592,7 @@ int link_path_walk(const char * name, st
 			nd->dentry = dentry;
 		}
 		err = -ENOTDIR; 
-		if (!inode->i_op->lookup)
+		if (!inode->i_op->lookup && !inode->i_op->lookup_it)
 			break;
 		continue;
 		/* here ends the main loop */
@@ -583,9 +619,9 @@ last_component:
 			if (err < 0)
 				break;
 		}
-		dentry = cached_lookup(nd->dentry, &this, 0);
+		dentry = cached_lookup(nd->dentry, &this, 0, it);
 		if (!dentry) {
-			dentry = real_lookup(nd->dentry, &this, 0);
+			dentry = real_lookup(nd->dentry, &this, 0, it);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
@@ -595,7 +631,7 @@ last_component:
 		inode = dentry->d_inode;
 		if ((lookup_flags & LOOKUP_FOLLOW)
 		    && inode && inode->i_op && inode->i_op->follow_link) {
-			err = do_follow_link(dentry, nd);
+			err = do_follow_link(dentry, nd, it);
 			dput(dentry);
 			if (err)
 				goto return_err;
@@ -609,7 +645,8 @@ last_component:
 			goto no_inode;
 		if (lookup_flags & LOOKUP_DIRECTORY) {
 			err = -ENOTDIR; 
-			if (!inode->i_op || !inode->i_op->lookup)
+			if (!inode->i_op ||
+			    (!inode->i_op->lookup && !inode->i_op->lookup_it))
 				break;
 		}
 		goto return_base;
@@ -635,6 +672,25 @@ return_reval:
 		 * Check the cached dentry for staleness.
 		 */
 		dentry = nd->dentry;
+		if (dentry && dentry->d_op && dentry->d_op->d_revalidate_it) {
+			err = -ESTALE;
+			if (!dentry->d_op->d_revalidate_it(dentry, 0, NULL, it)) {
+				struct dentry *new;
+				err = permission(dentry->d_parent->d_inode,
+						 MAY_EXEC);
+				if (err)
+					break;
+				new = real_lookup(dentry->d_parent,
+						  &dentry->d_name, 0, it);
+				d_invalidate(dentry);
+				dput(dentry);
+				if (IS_ERR(new)) {
+					err = PTR_ERR(new);
+					break;
+				}
+				nd->dentry = new;
+			}
+		} else
 		if (dentry && dentry->d_sb
 		    && (dentry->d_sb->s_type->fs_flags & FS_ALWAYS_REVAL)) {
 			err = -ESTALE;
@@ -649,15 +705,28 @@ out_dput:
 		dput(dentry);
 		break;
 	}
+	if (err)
+		intent_release(it);
 	path_release(nd);
 return_err:
 	return err;
 }
 
+int link_path_walk(const char * name, struct nameidata *nd)
+{
+	return link_path_walk_it(name, nd, NULL);
+}
+
+int path_walk_it(const char * name, struct nameidata *nd, struct lookup_intent *it)
+{
+	current->total_link_count = 0;
+	return link_path_walk_it(name, nd, it);
+}
+
 int path_walk(const char * name, struct nameidata *nd)
 {
 	current->total_link_count = 0;
-	return link_path_walk(name, nd);
+	return link_path_walk_it(name, nd, NULL);
 }
 
 /* SMP-safe */
@@ -742,6 +811,17 @@ walk_init_root(const char *name, struct 
 }
 
 /* SMP-safe */
+int path_lookup_it(const char *path, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it)
+{
+	int error = 0;
+	if (path_init(path, flags, nd))
+		error = path_walk_it(path, nd, it);
+	return error;
+}
+
+
+/* SMP-safe */
 int path_lookup(const char *path, unsigned flags, struct nameidata *nd)
 {
 	int error = 0;
@@ -756,6 +836,7 @@ int path_init(const char *name, unsigned
 {
 	nd->last_type = LAST_ROOT; /* if there are only slashes... */
 	nd->flags = flags;
+	nd->intent = NULL;
 	if (*name=='/')
 		return walk_init_root(name,nd);
 	read_lock(&current->fs->lock);
@@ -770,7 +851,8 @@ int path_init(const char *name, unsigned
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+struct dentry * lookup_hash_it(struct qstr *name, struct dentry * base,
+			       struct lookup_intent *it)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -793,13 +875,16 @@ struct dentry * lookup_hash(struct qstr 
 			goto out;
 	}
 
-	dentry = cached_lookup(base, name, 0);
+	dentry = cached_lookup(base, name, 0, it);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
 		lock_kernel();
+		if (inode->i_op->lookup_it)
+			dentry = inode->i_op->lookup_it(inode, new, NULL, it, 0);
+		else
 		dentry = inode->i_op->lookup(inode, new);
 		unlock_kernel();
 		if (!dentry)
@@ -811,6 +896,12 @@ out:
 	return dentry;
 }
 
+struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+{
+	return lookup_hash_it(name, base, NULL);
+}
+
+
 /* SMP-safe */
 struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
 {
@@ -832,7 +923,7 @@ struct dentry * lookup_one_len(const cha
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return lookup_hash_it(&this, base, NULL);
 access:
 	return ERR_PTR(-EACCES);
 }
@@ -863,6 +954,23 @@ int __user_walk(const char *name, unsign
 	return err;
 }
 
+int __user_walk_it(const char *name, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it)
+{
+	char *tmp;
+	int err;
+
+	tmp = getname(name);
+	err = PTR_ERR(tmp);
+	if (!IS_ERR(tmp)) {
+		err = 0;
+		if (path_init(tmp, flags, nd))
+			err = path_walk_it(tmp, nd, it);
+		putname(tmp);
+	}
+	return err;
+}
+
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -958,7 +1066,8 @@ static inline int lookup_flags(unsigned 
 	return retval;
 }
 
-int vfs_create(struct inode *dir, struct dentry *dentry, int mode)
+static int vfs_create_it(struct inode *dir, struct dentry *dentry, int mode,
+			 struct lookup_intent *it)
 {
 	int error;
 
@@ -971,12 +1080,15 @@ int vfs_create(struct inode *dir, struct
 		goto exit_lock;
 
 	error = -EACCES;	/* shouldn't it be ENOSYS? */
-	if (!dir->i_op || !dir->i_op->create)
+	if (!dir->i_op || (!dir->i_op->create && !dir->i_op->create_it))
 		goto exit_lock;
 
 	DQUOT_INIT(dir);
 	lock_kernel();
-	error = dir->i_op->create(dir, dentry, mode);
+	if (dir->i_op->create_it)
+		error = dir->i_op->create_it(dir, dentry, mode, it);
+	else
+		error = dir->i_op->create(dir, dentry, mode);
 	unlock_kernel();
 exit_lock:
 	up(&dir->i_zombie);
@@ -985,6 +1097,11 @@ exit_lock:
 	return error;
 }
 
+int vfs_create(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return vfs_create_it(dir, dentry, mode, NULL);
+}
+
 /*
  *	open_namei()
  *
@@ -999,7 +1116,8 @@ exit_lock:
  * for symlinks (where the permissions are checked later).
  * SMP-safe
  */
-int open_namei(const char * pathname, int flag, int mode, struct nameidata *nd)
+int open_namei_it(const char *pathname, int flag, int mode,
+		  struct nameidata *nd, struct lookup_intent *it)
 {
 	int acc_mode, error = 0;
 	struct inode *inode;
@@ -1009,11 +1127,14 @@ int open_namei(const char * pathname, in
 
 	acc_mode = ACC_MODE(flag);
 
+	if (it)
+		it->it_flags = flag;
+
 	/*
 	 * The simplest case - just a plain lookup.
 	 */
 	if (!(flag & O_CREAT)) {
-		error = path_lookup(pathname, lookup_flags(flag), nd);
+		error = path_lookup_it(pathname, lookup_flags(flag), nd, it);
 		if (error)
 			return error;
 		dentry = nd->dentry;
@@ -1023,6 +1144,10 @@ int open_namei(const char * pathname, in
 	/*
 	 * Create - we need to know the parent.
 	 */
+	if (it) {
+		it->it_create_mode = mode;
+		it->it_op |= IT_CREAT;
+	}
 	error = path_lookup(pathname, LOOKUP_PARENT, nd);
 	if (error)
 		return error;
@@ -1038,7 +1163,7 @@ int open_namei(const char * pathname, in
 
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1047,10 +1172,11 @@ do_last:
 		goto exit;
 	}
 
+	it->it_create_mode = mode;
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
-		error = vfs_create(dir->d_inode, dentry,
-				   mode & ~current->fs->umask);
+		error = vfs_create_it(dir->d_inode, dentry,
+				   mode & ~current->fs->umask, it);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
 		nd->dentry = dentry;
@@ -1154,7 +1280,7 @@ ok:
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0);
+			error = do_truncate(dentry, 0, 1);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1166,8 +1292,10 @@ ok:
 	return 0;
 
 exit_dput:
+	intent_release(it);
 	dput(dentry);
 exit:
+	intent_release(it);
 	path_release(nd);
 	return error;
 
@@ -1186,7 +1314,10 @@ do_link:
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
 	UPDATE_ATIME(dentry->d_inode);
+	nd->intent = it;
 	error = dentry->d_inode->i_op->follow_link(dentry, nd);
+	if (error)
+		intent_release(it);
 	dput(dentry);
 	if (error)
 		return error;
@@ -1208,13 +1339,20 @@ do_link:
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 	putname(nd->last.name);
 	goto do_last;
 }
 
+int open_namei(const char *pathname, int flag, int mode, struct nameidata *nd)
+{
+	return open_namei_it(pathname, flag, mode, nd, NULL);
+}
+
+
 /* SMP-safe */
-static struct dentry *lookup_create(struct nameidata *nd, int is_dir)
+static struct dentry *lookup_create(struct nameidata *nd, int is_dir,
+				    struct lookup_intent *it)
 {
 	struct dentry *dentry;
 
@@ -1222,7 +1360,7 @@ static struct dentry *lookup_create(stru
 	dentry = ERR_PTR(-EEXIST);
 	if (nd->last_type != LAST_NORM)
 		goto fail;
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 	if (IS_ERR(dentry))
 		goto fail;
 	if (!is_dir && nd->last.name[nd->last.len] && !dentry->d_inode)
@@ -1278,7 +1416,20 @@ asmlinkage long sys_mknod(const char * f
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
-	dentry = lookup_create(&nd, 0);
+
+	if (nd.last_type != LAST_NORM) {
+		error = -EEXIST;
+		goto out2;
+	}
+	if (nd.dentry->d_inode->i_op->mknod_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->mknod_raw(&nd, mode, dev);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out2;
+	}
+
+	dentry = lookup_create(&nd, 0, NULL);
 	error = PTR_ERR(dentry);
 
 	mode &= ~current->fs->umask;
@@ -1299,6 +1446,7 @@ asmlinkage long sys_mknod(const char * f
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
+out2:
 	path_release(&nd);
 out:
 	putname(tmp);
@@ -1346,7 +1494,20 @@ asmlinkage long sys_mkdir(const char * p
 		error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 1);
+		if (nd.last_type != LAST_NORM) {
+			error = -EEXIST;
+			goto out2;
+		}
+		if (nd.dentry->d_inode->i_op->mkdir_raw) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->mkdir_raw(&nd, mode);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
+		dentry = lookup_create(&nd, 1, NULL);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1354,6 +1509,7 @@ asmlinkage long sys_mkdir(const char * p
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 		putname(tmp);
@@ -1454,8 +1610,16 @@ asmlinkage long sys_rmdir(const char * p
 			error = -EBUSY;
 			goto exit1;
 	}
+	if (nd.dentry->d_inode->i_op->rmdir_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		error = op->rmdir_raw(&nd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, NULL);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1513,8 +1677,15 @@ asmlinkage long sys_unlink(const char * 
 	error = -EISDIR;
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
+	if (nd.dentry->d_inode->i_op->unlink_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->unlink_raw(&nd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, NULL);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -1581,15 +1752,27 @@ asmlinkage long sys_symlink(const char *
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 0);
+		if (nd.last_type != LAST_NORM) {
+			error = -EEXIST;
+			goto out2;
+		}
+		if (nd.dentry->d_inode->i_op->symlink_raw) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->symlink_raw(&nd, from);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
+		dentry = lookup_create(&nd, 0, NULL);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+	out2:
 		path_release(&nd);
-out:
+	out:
 		putname(to);
 	}
 	putname(from);
@@ -1665,7 +1844,18 @@ asmlinkage long sys_link(const char * ol
 		error = -EXDEV;
 		if (old_nd.mnt != nd.mnt)
 			goto out_release;
-		new_dentry = lookup_create(&nd, 0);
+		if (nd.last_type != LAST_NORM) {
+			error = -EEXIST;
+			goto out2;
+		}
+		if (nd.dentry->d_inode->i_op->link_raw) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->link_raw(&old_nd, &nd);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out_release;
+		}
+		new_dentry = lookup_create(&nd, 0, NULL);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -1709,7 +1895,7 @@ exit:
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		   struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error;
 	struct inode *target;
@@ -1788,7 +1974,7 @@ out_unlock:
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		     struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error;
 
@@ -1876,9 +2062,18 @@ static inline int do_rename(const char *
 	if (newnd.last_type != LAST_NORM)
 		goto exit2;
 
+	if (old_dir->d_inode->i_op->rename_raw) {
+		lock_kernel();
+		error = old_dir->d_inode->i_op->rename_raw(&oldnd, &newnd);
+		unlock_kernel();
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit2;
+	}
+
 	double_lock(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = lookup_hash_it(&oldnd.last, old_dir, NULL);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -1894,16 +2089,16 @@ static inline int do_rename(const char *
 		if (newnd.last.name[newnd.last.len])
 			goto exit4;
 	}
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = lookup_hash_it(&newnd.last, new_dir, NULL);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
+
 	lock_kernel();
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
-
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -1954,20 +2149,26 @@ out:
 }
 
 static inline int
-__vfs_follow_link(struct nameidata *nd, const char *link)
+__vfs_follow_link(struct nameidata *nd, const char *link,
+		  struct lookup_intent *it)
 {
 	int res = 0;
 	char *name;
 	if (IS_ERR(link))
 		goto fail;
 
+	if (it == NULL)
+		it = nd->intent;
+	else if (it != nd->intent)
+		printk("it != nd->intent: tell phil@clusterfs.com\n");
+
 	if (*link == '/') {
 		path_release(nd);
 		if (!walk_init_root(link, nd))
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
-	res = link_path_walk(link, nd);
+	res = link_path_walk_it(link, nd, it);
 out:
 	if (current->link_count || res || nd->last_type!=LAST_NORM)
 		return res;
@@ -1991,7 +2192,13 @@ fail:
 
 int vfs_follow_link(struct nameidata *nd, const char *link)
 {
-	return __vfs_follow_link(nd, link);
+	return __vfs_follow_link(nd, link, NULL);
+}
+
+int vfs_follow_link_it(struct nameidata *nd, const char *link,
+		       struct lookup_intent *it)
+{
+	return __vfs_follow_link(nd, link, it);
 }
 
 /* get the link contents into pagecache */
@@ -2033,7 +2240,7 @@ int page_follow_link(struct dentry *dent
 {
 	struct page *page = NULL;
 	char *s = page_getlink(dentry, &page);
-	int res = __vfs_follow_link(nd, s);
+	int res = __vfs_follow_link(nd, s, NULL);
 	if (page) {
 		kunmap(page);
 		page_cache_release(page);
--- linux-2.4.22-ac1/fs/namespace.c~vfs_intent-2.4.22-rh	2003-09-25 14:16:28.000000000 +0400
+++ linux-2.4.22-ac1-alexey/fs/namespace.c	2003-09-25 14:42:46.000000000 +0400
@@ -98,6 +98,7 @@ static void detach_mnt(struct vfsmount *
 {
 	old_nd->dentry = mnt->mnt_mountpoint;
 	old_nd->mnt = mnt->mnt_parent;
+	UNPIN(old_nd->dentry, old_nd->mnt, 1);
 	mnt->mnt_parent = mnt;
 	mnt->mnt_mountpoint = mnt->mnt_root;
 	list_del_init(&mnt->mnt_child);
@@ -109,6 +110,7 @@ static void attach_mnt(struct vfsmount *
 {
 	mnt->mnt_parent = mntget(nd->mnt);
 	mnt->mnt_mountpoint = dget(nd->dentry);
+	PIN(nd->dentry, nd->mnt, 1);
 	list_add(&mnt->mnt_hash, mount_hashtable+hash(nd->mnt, nd->dentry));
 	list_add(&mnt->mnt_child, &nd->mnt->mnt_mounts);
 	nd->dentry->d_mounted++;
@@ -488,14 +490,17 @@ static int do_loopback(struct nameidata 
 {
 	struct nameidata old_nd;
 	struct vfsmount *mnt = NULL;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int err = mount_is_safe(nd);
 	if (err)
 		return err;
 	if (!old_name || !*old_name)
 		return -EINVAL;
-	err = path_lookup(old_name, LOOKUP_POSITIVE|LOOKUP_FOLLOW, &old_nd);
-	if (err)
+	err = path_lookup_it(old_name, LOOKUP_POSITIVE|LOOKUP_FOLLOW, &old_nd, &it);
+	if (err) {
+		intent_release(&it);
 		return err;
+	}
 
 	down_write(&current->namespace->sem);
 	err = -EINVAL;
@@ -518,6 +523,7 @@ static int do_loopback(struct nameidata 
 	}
 
 	up_write(&current->namespace->sem);
+	intent_release(&it);
 	path_release(&old_nd);
 	return err;
 }
@@ -701,6 +707,7 @@ long do_mount(char * dev_name, char * di
 		  unsigned long flags, void *data_page)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int retval = 0;
 	int mnt_flags = 0;
 
@@ -725,9 +732,11 @@ long do_mount(char * dev_name, char * di
 	flags &= ~(MS_NOSUID|MS_NOEXEC|MS_NODEV);
 
 	/* ... and get the mountpoint */
-	retval = path_lookup(dir_name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &nd);
-	if (retval)
+	retval = path_lookup_it(dir_name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &nd, &it);
+	if (retval) {
+		intent_release(&it);
 		return retval;
+	}

 	if (flags & MS_REMOUNT)
 		retval = do_remount(&nd, flags & ~MS_REMOUNT, mnt_flags,
@@ -739,6 +747,8 @@ long do_mount(char * dev_name, char * di
 	else
 		retval = do_add_mount(&nd, type_page, flags, mnt_flags,
 				      dev_name, data_page);
+
+	intent_release(&it);
 	path_release(&nd);
 	return retval;
 }
@@ -904,6 +914,8 @@ asmlinkage long sys_pivot_root(const cha
 {
 	struct vfsmount *tmp;
 	struct nameidata new_nd, old_nd, parent_nd, root_parent, user_nd;
+	struct lookup_intent new_it = { .it_op = IT_GETATTR };
+	struct lookup_intent old_it = { .it_op = IT_GETATTR };
 	int error;
 
 	if (!capable(CAP_SYS_ADMIN))
@@ -911,14 +923,14 @@ asmlinkage long sys_pivot_root(const cha
 
 	lock_kernel();
 
-	error = __user_walk(new_root, LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd);
+	error = __user_walk_it(new_root, LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd, &new_it);
 	if (error)
 		goto out0;
 	error = -EINVAL;
 	if (!check_mnt(new_nd.mnt))
 		goto out1;
 
-	error = __user_walk(put_old, LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &old_nd);
+	error = __user_walk_it(put_old, LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &old_nd, &old_it);
 	if (error)
 		goto out1;
 
@@ -973,8 +985,10 @@ out2:
 	up(&old_nd.dentry->d_inode->i_zombie);
 	up_write(&current->namespace->sem);
 	path_release(&user_nd);
+	intent_release(&old_it);
 	path_release(&old_nd);
 out1:
+	intent_release(&new_it);
 	path_release(&new_nd);
 out0:
 	unlock_kernel();
--- linux-2.4.22-ac1/fs/open.c~vfs_intent-2.4.22-rh	2003-08-25 15:44:43.000000000 +0400
+++ linux-2.4.22-ac1-alexey/fs/open.c	2003-09-25 14:42:46.000000000 +0400
@@ -19,6 +19,8 @@
 #include <asm/uaccess.h>
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
+extern int path_walk_it(const char *name, struct nameidata *nd,
+			struct lookup_intent *it);
 
 int vfs_statfs(struct super_block *sb, struct statfs *buf)
 {
@@ -95,9 +97,10 @@ void fd_install(unsigned int fd, struct 
 	write_unlock(&files->file_lock);
 }
 
-int do_truncate(struct dentry *dentry, loff_t length)
+int do_truncate(struct dentry *dentry, loff_t length, int called_from_open)
 {
 	struct inode *inode = dentry->d_inode;
+	struct inode_operations *op = dentry->d_inode->i_op;
 	int error;
 	struct iattr newattrs;
 
@@ -109,7 +112,13 @@ int do_truncate(struct dentry *dentry, l
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-	error = notify_change(dentry, &newattrs);
+	if (called_from_open)
+		newattrs.ia_valid |= ATTR_FROM_OPEN;
+	if (op->setattr_raw) {
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+	} else
+		error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
 	up_write(&inode->i_alloc_sem);
 	return error;
@@ -120,12 +129,13 @@ static inline long do_sys_truncate(const
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path_walk(path, &nd);
+	error = user_path_walk_it(path, &nd, &it);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
@@ -165,11 +175,13 @@ static inline long do_sys_truncate(const
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length);
+		intent_release(&it);
+		error = do_truncate(nd.dentry, length, 0);
 	}
 	put_write_access(inode);
 
 dput_and_out:
+	intent_release(&it);
 	path_release(&nd);
 out:
 	return error;
@@ -217,7 +229,7 @@ static inline long do_sys_ftruncate(unsi
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length);
+		error = do_truncate(dentry, length, 0);
 out_putf:
 	fput(file);
 out:
@@ -262,11 +274,13 @@ asmlinkage long sys_utime(char * filenam
 	struct inode * inode;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, NULL);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
 
+	/* this is safe without a Lustre lock because it only depends
+	   on the super block */
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
@@ -281,11 +295,25 @@ asmlinkage long sys_utime(char * filenam
 			goto dput_and_out;
 
 		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
-	} else {
+	}
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
+	error = -EPERM;
+	if (!times) {
 		if (current->fsuid != inode->i_uid &&
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
 	path_release(&nd);
@@ -306,12 +334,14 @@ asmlinkage long sys_utimes(char * filena
 	struct inode * inode;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, NULL);
 
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
 
+	/* this is safe without a Lustre lock because it only depends
+	   on the super block */
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
@@ -326,7 +356,20 @@ asmlinkage long sys_utimes(char * filena
 		newattrs.ia_atime = times[0].tv_sec;
 		newattrs.ia_mtime = times[1].tv_sec;
 		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
-	} else {
+	}
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
+	error = -EPERM;
+	if (!utimes) {
 		if (current->fsuid != inode->i_uid &&
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
@@ -349,6 +392,7 @@ asmlinkage long sys_access(const char * 
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -366,13 +410,14 @@ asmlinkage long sys_access(const char * 
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = user_path_walk(filename, &nd);
+	res = user_path_walk_it(filename, &nd, &it);
 	if (!res) {
 		res = permission(nd.dentry->d_inode, mode);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+		intent_release(&it);
 		path_release(&nd);
 	}
 
@@ -387,8 +432,9 @@ asmlinkage long sys_chdir(const char * f
 {
 	int error;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = __user_walk(filename,LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,&nd);
+	error = __user_walk_it(filename,LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,&nd, &it);
 	if (error)
 		goto out;
 
@@ -399,6 +445,7 @@ asmlinkage long sys_chdir(const char * f
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
+	intent_release(&it);
 	path_release(&nd);
 out:
 	return error;
@@ -438,9 +485,10 @@ asmlinkage long sys_chroot(const char * 
 {
 	int error;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = __user_walk(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
-		      LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
+	error = __user_walk_it(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
+			       LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd, &it);
 	if (error)
 		goto out;
 
@@ -456,39 +504,56 @@ asmlinkage long sys_chroot(const char * 
 	set_fs_altroot();
 	error = 0;
 dput_and_out:
+	intent_release(&it);
 	path_release(&nd);
 out:
 	return error;
 }
 
-asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
+int chmod_common(struct dentry *dentry, mode_t mode)
 {
-	struct inode * inode;
-	struct dentry * dentry;
-	struct file * file;
-	int err = -EBADF;
+	struct inode *inode = dentry->d_inode;
 	struct iattr newattrs;
+	int err = -EROFS;
 
-	file = fget(fd);
-	if (!file)
+	if (IS_RDONLY(inode))
 		goto out;
 
-	dentry = file->f_dentry;
-	inode = dentry->d_inode;
+	if (inode->i_op->setattr_raw) {
+		newattrs.ia_mode = mode;
+		newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		err = inode->i_op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (err != -EOPNOTSUPP)
+			goto out;
+	}
 
-	err = -EROFS;
-	if (IS_RDONLY(inode))
-		goto out_putf;
 	err = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
-		goto out_putf;
+		goto out;
+
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
 	err = notify_change(dentry, &newattrs);
 
-out_putf:
+out:
+	return err;
+}
+
+asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
+{
+	struct file * file;
+	int err = -EBADF;
+
+	file = fget(fd);
+	if (!file)
+		goto out;
+
+	err = chmod_common(file->f_dentry, mode);
+
 	fput(file);
 out:
 	return err;
@@ -497,30 +562,14 @@ out:
 asmlinkage long sys_chmod(const char * filename, mode_t mode)
 {
 	struct nameidata nd;
-	struct inode * inode;
 	int error;
-	struct iattr newattrs;
 
 	error = user_path_walk(filename, &nd);
 	if (error)
 		goto out;
-	inode = nd.dentry->d_inode;
-
-	error = -EROFS;
-	if (IS_RDONLY(inode))
-		goto dput_and_out;
 
-	error = -EPERM;
-	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
-		goto dput_and_out;
+	error = chmod_common(nd.dentry, mode);
 
-	if (mode == (mode_t) -1)
-		mode = inode->i_mode;
-	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
-	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
-	error = notify_change(nd.dentry, &newattrs);
-
-dput_and_out:
 	path_release(&nd);
 out:
 	return error;
@@ -540,6 +589,20 @@ static int chown_common(struct dentry * 
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto out;
+
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = dentry->d_inode->i_op;
+
+		newattrs.ia_uid = user;
+		newattrs.ia_gid = group;
+		newattrs.ia_valid = ATTR_UID | ATTR_GID | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			return error;
+	}
+
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
@@ -644,6 +707,7 @@ struct file *filp_open(const char * file
 {
 	int namei_flags, error;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_OPEN };
 
 	namei_flags = flags;
 	if ((namei_flags+1) & O_ACCMODE)
@@ -651,14 +715,15 @@ struct file *filp_open(const char * file
 	if (namei_flags & O_TRUNC)
 		namei_flags |= 2;
 
-	error = open_namei(filename, namei_flags, mode, &nd);
-	if (!error)
-		return dentry_open(nd.dentry, nd.mnt, flags);
+	error = open_namei_it(filename, namei_flags, mode, &nd, &it);
+	if (error)
+		return ERR_PTR(error);
 
-	return ERR_PTR(error);
+	return dentry_open_it(nd.dentry, nd.mnt, flags, &it);
 }
 
-struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+			    int flags, struct lookup_intent *it)
 {
 	struct file * f;
 	struct inode *inode;
@@ -695,12 +760,15 @@ struct file *dentry_open(struct dentry *
 	}
 
 	if (f->f_op && f->f_op->open) {
+		f->f_it = it;
 		error = f->f_op->open(inode,f);
+		f->f_it = NULL;
 		if (error)
 			goto cleanup_all;
 	}
 	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);
 
+	intent_release(it);
 	return f;
 
 cleanup_all:
@@ -715,11 +783,17 @@ cleanup_all:
 cleanup_file:
 	put_filp(f);
 cleanup_dentry:
+	intent_release(it);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
 }
 
+struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+{
+	return dentry_open_it(dentry, mnt, flags, NULL);
+}
+
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
--- linux-2.4.22-ac1/fs/stat.c~vfs_intent-2.4.22-rh	2003-09-25 14:16:27.000000000 +0400
+++ linux-2.4.22-ac1-alexey/fs/stat.c	2003-09-25 14:42:46.000000000 +0400
@@ -17,10 +17,12 @@
  * Revalidate the inode. This is required for proper NFS attribute caching.
  */
 static __inline__ int
-do_revalidate(struct dentry *dentry)
+do_revalidate(struct dentry *dentry, struct lookup_intent *it)
 {
 	struct inode * inode = dentry->d_inode;
-	if (inode->i_op && inode->i_op->revalidate)
+	if (inode->i_op && inode->i_op->revalidate_it)
+		return inode->i_op->revalidate_it(dentry, it);
+	else if (inode->i_op && inode->i_op->revalidate)
 		return inode->i_op->revalidate(dentry);
 	return 0;
 }
@@ -143,13 +147,15 @@ static int cp_new_stat(struct inode * in
 asmlinkage long sys_stat(char * filename, struct __old_kernel_stat * statbuf)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int error;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (!error) {
-		error = do_revalidate(nd.dentry);
+		error = do_revalidate(nd.dentry, &it);
 		if (!error)
 			error = cp_old_stat(nd.dentry->d_inode, statbuf);
+		intent_release(&it);
 		path_release(&nd);
 	}
 	return error;
@@ -159,13 +165,15 @@ asmlinkage long sys_stat(char * filename
 asmlinkage long sys_newstat(char * filename, struct stat * statbuf)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int error;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (!error) {
-		error = do_revalidate(nd.dentry);
+		error = do_revalidate(nd.dentry, &it);
 		if (!error)
 			error = cp_new_stat(nd.dentry->d_inode, statbuf);
+		intent_release(&it);
 		path_release(&nd);
 	}
 	return error;
@@ -180,13 +188,15 @@ asmlinkage long sys_newstat(char * filen
 asmlinkage long sys_lstat(char * filename, struct __old_kernel_stat * statbuf)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int error;
 
-	error = user_path_walk_link(filename, &nd);
+	error = user_path_walk_link_it(filename, &nd, &it);
 	if (!error) {
-		error = do_revalidate(nd.dentry);
+		error = do_revalidate(nd.dentry, &it);
 		if (!error)
 			error = cp_old_stat(nd.dentry->d_inode, statbuf);
+		intent_release(&it);
 		path_release(&nd);
 	}
 	return error;
@@ -197,13 +207,15 @@ asmlinkage long sys_lstat(char * filenam
 asmlinkage long sys_newlstat(char * filename, struct stat * statbuf)
 {
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 	int error;
 
-	error = user_path_walk_link(filename, &nd);
+	error = user_path_walk_link_it(filename, &nd, &it);
 	if (!error) {
-		error = do_revalidate(nd.dentry);
+		error = do_revalidate(nd.dentry, &it);
 		if (!error)
 			error = cp_new_stat(nd.dentry->d_inode, statbuf);
+		intent_release(&it);
 		path_release(&nd);
 	}
 	return error;
@@ -224,7 +236,7 @@ asmlinkage long sys_fstat(unsigned int f
 	if (f) {
 		struct dentry * dentry = f->f_dentry;
 
-		err = do_revalidate(dentry);
+		err = do_revalidate(dentry, NULL);
 		if (!err)
 			err = cp_old_stat(dentry->d_inode, statbuf);
 		fput(f);
@@ -243,7 +255,7 @@ asmlinkage long sys_newfstat(unsigned in
 	if (f) {
 		struct dentry * dentry = f->f_dentry;
 
-		err = do_revalidate(dentry);
+		err = do_revalidate(dentry, NULL);
 		if (!err)
 			err = cp_new_stat(dentry->d_inode, statbuf);
 		fput(f);
@@ -265,7 +277,7 @@ asmlinkage long sys_readlink(const char 
 
 		error = -EINVAL;
 		if (inode->i_op && inode->i_op->readlink &&
-		    !(error = do_revalidate(nd.dentry))) {
+		    !(error = do_revalidate(nd.dentry, NULL))) {
 			UPDATE_ATIME(inode);
 			error = inode->i_op->readlink(nd.dentry, buf, bufsiz);
 		}
@@ -341,12 +353,14 @@ asmlinkage long sys_stat64(char * filena
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (!error) {
-		error = do_revalidate(nd.dentry);
+		error = do_revalidate(nd.dentry, &it);
 		if (!error)
 			error = cp_new_stat64(nd.dentry->d_inode, statbuf);
+		intent_release(&it);
 		path_release(&nd);
 	}
 	return error;
@@ -356,12 +370,14 @@ asmlinkage long sys_lstat64(char * filen
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = user_path_walk_link(filename, &nd);
+	error = user_path_walk_link_it(filename, &nd, &it);
 	if (!error) {
-		error = do_revalidate(nd.dentry);
+		error = do_revalidate(nd.dentry, &it);
 		if (!error)
 			error = cp_new_stat64(nd.dentry->d_inode, statbuf);
+		intent_release(&it);
 		path_release(&nd);
 	}
 	return error;
@@ -376,7 +392,7 @@ asmlinkage long sys_fstat64(unsigned lon
 	if (f) {
 		struct dentry * dentry = f->f_dentry;
 
-		err = do_revalidate(dentry);
+		err = do_revalidate(dentry, NULL);
 		if (!err)
 			err = cp_new_stat64(dentry->d_inode, statbuf);
 		fput(f);
--- linux-2.4.22-ac1/include/linux/dcache.h~vfs_intent-2.4.22-rh	2003-09-25 14:16:28.000000000 +0400
+++ linux-2.4.22-ac1-alexey/include/linux/dcache.h	2003-09-25 14:42:46.000000000 +0400
@@ -6,6 +6,51 @@
 #include <asm/atomic.h>
 #include <linux/mount.h>
 #include <linux/kernel.h>
+#include <linux/string.h>
+
+#define IT_OPEN     0x0001
+#define IT_CREAT    0x0002
+#define IT_READDIR  0x0004
+#define IT_GETATTR  0x0008
+#define IT_LOOKUP   0x0010
+#define IT_UNLINK   0x0020
+#define IT_GETXATTR 0x0040
+#define IT_EXEC     0x0080
+#define IT_PIN      0x0100
+
+#define IT_FL_LOCKED   0x0001
+#define IT_FL_FOLLOWED 0x0002 /* set by vfs_follow_link */
+
+#define INTENT_MAGIC 0x19620323
+
+
+struct lustre_intent_data {
+	int       it_disposition;
+	int       it_status;
+	__u64     it_lock_handle;
+	void     *it_data;
+	int       it_lock_mode;
+	int it_int_flags;
+};
+struct lookup_intent {
+	int     it_magic;
+	void    (*it_op_release)(struct lookup_intent *);
+	int     it_op;
+	int     it_flags;
+	int     it_create_mode;
+	union {
+		struct lustre_intent_data lustre;
+	} d;
+};
+
+static inline void intent_init(struct lookup_intent *it, int op, int flags)
+{
+	memset(it, 0, sizeof(*it));
+	it->it_magic = INTENT_MAGIC;
+	it->it_op = op;
+	it->it_flags = flags;
+}
+
 
 /*
  * linux/include/linux/dcache.h
@@ -84,6 +130,8 @@
 	unsigned char d_iname[DNAME_INLINE_LEN]; /* small names */
 };
 
+struct nameidata;
+
 struct dentry_operations {
 	int (*d_revalidate)(struct dentry *, int);
 	int (*d_hash) (struct dentry *, struct qstr *);
@@ -95,8 +140,22 @@ struct dentry_operations {
 	int (*d_delete)(struct dentry *);
 	void (*d_release)(struct dentry *);
 	void (*d_iput)(struct dentry *, struct inode *);
+	int (*d_revalidate_it)(struct dentry *, int, struct nameidata *, struct lookup_intent *);
+	void (*d_pin)(struct dentry *, struct vfsmount * , int);
+	void (*d_unpin)(struct dentry *, struct vfsmount *, int);
 };
 
+#define PIN(de,mnt,flag)  if (de && de->d_op && de->d_op->d_pin) \
+				de->d_op->d_pin(de, mnt, flag);
+#define UNPIN(de,mnt,flag)  if (de && de->d_op && de->d_op->d_unpin) \
+				de->d_op->d_unpin(de, mnt, flag);
+
+
+/* defined in fs/namei.c */
+extern void intent_release(struct lookup_intent *it);
+/* defined in fs/dcache.c */
+extern void __d_rehash(struct dentry * entry, int lock);
+
 /* the dentry parameter passed to d_hash and d_compare is the parent
  * directory of the entries to be compared. It is used in case these
  * functions need any directory specific information for determining
@@ -128,6 +187,7 @@ d_iput:		no		no		yes
 					 * s_nfsd_free_path semaphore will be down
 					 */
 #define DCACHE_REFERENCED	0x0008  /* Recently used, don't discard. */
+#define DCACHE_LUSTRE_INVALID	0x0010  /* Lustre invalidated */
 
 extern spinlock_t dcache_lock;
 
--- linux-2.4.22-ac1/include/linux/fs.h~vfs_intent-2.4.22-rh	2003-09-25 14:39:01.000000000 +0400
+++ linux-2.4.22-ac1-alexey/include/linux/fs.h	2003-09-25 14:42:46.000000000 +0400
@@ -73,6 +73,7 @@ extern int leases_enable, dir_notify_ena
 
 #define FMODE_READ 1
 #define FMODE_WRITE 2
+#define FMODE_EXEC 4
 
 #define READ 0
 #define WRITE 1
@@ -343,6 +344,9 @@ extern void set_bh_page(struct buffer_he
 #define ATTR_MTIME_SET	256
 #define ATTR_FORCE	512	/* Not a change, but a change it */
 #define ATTR_ATTR_FLAG	1024
+#define ATTR_RAW	0x0800	/* file system, not vfs will massage attrs */
+#define ATTR_FROM_OPEN	0x1000	/* called from open path, ie O_TRUNC */
+#define ATTR_CTIME_SET	0x2000
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -481,6 +485,7 @@ struct inode {
 	struct pipe_inode_info	*i_pipe;
 	struct block_device	*i_bdev;
 	struct char_device	*i_cdev;
+	void			*i_filterdata;
 
 	unsigned long		i_dnotify_mask; /* Directory notify events */
 	struct dnotify_struct	*i_dnotify; /* for directory notifications */
@@ -583,6 +588,7 @@ struct file {
 
 	/* needed for tty driver, and maybe others */
 	void			*private_data;
+	struct lookup_intent    *f_it;
 
 	/* preallocated helper kiobuf to speedup O_DIRECT */
 	struct kiobuf		*f_iobuf;
@@ -703,6 +709,7 @@ struct nameidata {
 	struct qstr last;
 	unsigned int flags;
 	int last_type;
+	struct lookup_intent *intent;
 };
 
 /*
@@ -823,7 +830,8 @@ extern int vfs_symlink(struct inode *, s
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+	       struct inode *new_dir, struct dentry *new_dentry);
 
 /*
  * File types
@@ -883,21 +891,32 @@ struct file_operations {
 
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
+	int (*create_it) (struct inode *,struct dentry *,int, struct lookup_intent *);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
+	struct dentry * (*lookup_it) (struct inode *,struct dentry *, struct nameidata *, struct lookup_intent *, int flags);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*link_raw) (struct nameidata *,struct nameidata *);
 	int (*unlink) (struct inode *,struct dentry *);
+	int (*unlink_raw) (struct nameidata *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*symlink_raw) (struct nameidata *,const char *);
 	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*mkdir_raw) (struct nameidata *,int);
 	int (*rmdir) (struct inode *,struct dentry *);
+	int (*rmdir_raw) (struct nameidata *);
 	int (*mknod) (struct inode *,struct dentry *,int,int);
+	int (*mknod_raw) (struct nameidata *,int,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename_raw) (struct nameidata *, struct nameidata *);
 	int (*readlink) (struct dentry *, char *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int);
 	int (*revalidate) (struct dentry *);
+	int (*revalidate_it) (struct dentry *, struct lookup_intent *);
 	int (*setattr) (struct dentry *, struct iattr *);
+	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct dentry *, struct iattr *);
 	int (*setxattr) (struct dentry *, const char *, void *, size_t, int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
@@ -1094,10 +1113,14 @@ static inline int get_lease(struct inode
 
 asmlinkage long sys_open(const char *, int, int);
 asmlinkage long sys_close(unsigned int);	/* yes, it's really unsigned */
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, int called_from_open);
 
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern int open_namei_it(const char *filename, int namei_flags, int mode,
+			 struct nameidata *nd, struct lookup_intent *it);
+extern struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+			    int flags, struct lookup_intent *it);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char *);
 
@@ -1388,6 +1411,7 @@ typedef int (*read_actor_t)(read_descrip
 extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
 
 extern int FASTCALL(__user_walk(const char *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_it(const char *, unsigned, struct nameidata *, struct lookup_intent *it));
 extern int FASTCALL(path_init(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
@@ -1399,6 +1423,8 @@ extern struct dentry * lookup_one_len(co
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
 #define user_path_walk(name,nd)	 __user_walk(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd)
 #define user_path_walk_link(name,nd) __user_walk(name, LOOKUP_POSITIVE, nd)
+#define user_path_walk_it(name,nd,it)  __user_walk_it(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd, it)
+#define user_path_walk_link_it(name,nd,it) __user_walk_it(name, LOOKUP_POSITIVE, nd, it)
 
 extern void inode_init_once(struct inode *);
 extern void iput(struct inode *);
@@ -1538,6 +1564,8 @@ extern struct file_operations generic_ro
 
 extern int vfs_readlink(struct dentry *, char *, int, const char *);
 extern int vfs_follow_link(struct nameidata *, const char *);
+extern int vfs_follow_link_it(struct nameidata *, const char *,
+			      struct lookup_intent *it);
 extern int page_readlink(struct dentry *, char *, int);
 extern int page_follow_link(struct dentry *, struct nameidata *);
 extern struct inode_operations page_symlink_inode_operations;
--- linux-2.4.22-ac1/include/linux/fs_struct.h~vfs_intent-2.4.22-rh	2003-09-25 14:16:24.000000000 +0400
+++ linux-2.4.22-ac1-alexey/include/linux/fs_struct.h	2003-09-25 14:42:46.000000000 +0400
@@ -37,10 +37,12 @@ static inline void set_fs_root(struct fs
 	write_lock(&fs->lock);
 	old_root = fs->root;
 	old_rootmnt = fs->rootmnt;
+	PIN(dentry, mnt, 1);
 	fs->rootmnt = mntget(mnt);
 	fs->root = dget(dentry);
 	write_unlock(&fs->lock);
 	if (old_root) {
+		UNPIN(old_root, old_rootmnt, 1);
 		dput(old_root);
 		mntput(old_rootmnt);
 	}
@@ -60,10 +62,12 @@ static inline void set_fs_pwd(struct fs_
 	write_lock(&fs->lock);
 	old_pwd = fs->pwd;
 	old_pwdmnt = fs->pwdmnt;
+	PIN(dentry, mnt, 0);
 	fs->pwdmnt = mntget(mnt);
 	fs->pwd = dget(dentry);
 	write_unlock(&fs->lock);
 	if (old_pwd) {
+		UNPIN(old_pwd, old_pwdmnt, 0);
 		dput(old_pwd);
 		mntput(old_pwdmnt);
 	}
--- linux-2.4.22-ac1/kernel/exit.c~vfs_intent-2.4.22-rh	2003-09-25 14:16:29.000000000 +0400
+++ linux-2.4.22-ac1-alexey/kernel/exit.c	2003-09-25 14:42:46.000000000 +0400
@@ -342,11 +342,14 @@ static inline void __put_fs_struct(struc
 {
 	/* No need to hold fs->lock if we are killing it */
 	if (atomic_dec_and_test(&fs->count)) {
+		UNPIN(fs->pwd, fs->pwdmnt, 0);
+		UNPIN(fs->root, fs->rootmnt, 1);
 		dput(fs->root);
 		mntput(fs->rootmnt);
 		dput(fs->pwd);
 		mntput(fs->pwdmnt);
 		if (fs->altroot) {
+			UNPIN(fs->altroot, fs->altrootmnt, 1);
 			dput(fs->altroot);
 			mntput(fs->altrootmnt);
 		}
--- linux-2.4.22-ac1/kernel/fork.c~vfs_intent-2.4.22-rh	2003-09-25 14:16:28.000000000 +0400
+++ linux-2.4.22-ac1-alexey/kernel/fork.c	2003-09-25 14:42:46.000000000 +0400
@@ -457,10 +457,13 @@ static inline struct fs_struct *__copy_f
 		fs->umask = old->umask;
 		read_lock(&old->lock);
 		fs->rootmnt = mntget(old->rootmnt);
+		PIN(old->pwd, old->pwdmnt, 0);
+		PIN(old->root, old->rootmnt, 1);
 		fs->root = dget(old->root);
 		fs->pwdmnt = mntget(old->pwdmnt);
 		fs->pwd = dget(old->pwd);
 		if (old->altroot) {
+			PIN(old->altroot, old->altrootmnt, 1);
 			fs->altrootmnt = mntget(old->altrootmnt);
 			fs->altroot = dget(old->altroot);
 		} else {
--- linux-2.4.22-ac1/kernel/ksyms.c~vfs_intent-2.4.22-rh	2003-09-25 14:39:02.000000000 +0400
+++ linux-2.4.22-ac1-alexey/kernel/ksyms.c	2003-09-25 14:42:46.000000000 +0400
@@ -295,6 +295,7 @@ EXPORT_SYMBOL(read_cache_page);
 EXPORT_SYMBOL(set_page_dirty);
 EXPORT_SYMBOL(vfs_readlink);
 EXPORT_SYMBOL(vfs_follow_link);
+EXPORT_SYMBOL(vfs_follow_link_it);
 EXPORT_SYMBOL(page_readlink);
 EXPORT_SYMBOL(page_follow_link);
 EXPORT_SYMBOL(page_symlink_inode_operations);

_
