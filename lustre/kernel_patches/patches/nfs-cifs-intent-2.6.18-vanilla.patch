Index: linux-2.6/fs/cifs/dir.c
===================================================================
--- linux-2.6.orig/fs/cifs/dir.c	2006-07-15 21:04:01.000000000 +0800
+++ linux-2.6/fs/cifs/dir.c	2006-07-15 21:04:47.000000000 +0800
@@ -146,7 +146,7 @@ cifs_create(struct inode *inode, struct 
 	}
 
 	if(nd && (nd->flags & LOOKUP_OPEN)) {
-		int oflags = nd->intent.open.flags;
+		int oflags = nd->intent.flags;
 
 		desiredAccess = 0;
 		if (oflags & FMODE_READ)
Index: linux-2.6/fs/nfs/dir.c
===================================================================
--- linux-2.6.orig/fs/nfs/dir.c	2006-07-15 21:04:01.000000000 +0800
+++ linux-2.6/fs/nfs/dir.c	2006-07-15 21:04:47.000000000 +0800
@@ -867,7 +867,7 @@ int nfs_is_exclusive_create(struct inode
 		return 0;
 	if (nd == NULL || nfs_lookup_check_intent(nd, LOOKUP_CREATE) == 0)
 		return 0;
-	return (nd->intent.open.flags & O_EXCL) != 0;
+	return (nd->intent.it_flags & O_EXCL) != 0;
 }
 
 static inline int nfs_reval_fsid(struct inode *dir,
@@ -955,7 +955,7 @@ static int is_atomic_open(struct inode *
 	if (nd->flags & LOOKUP_DIRECTORY)
 		return 0;
 	/* Are we trying to write to a read only partition? */
-	if (IS_RDONLY(dir) && (nd->intent.open.flags & (O_CREAT|O_TRUNC|FMODE_WRITE)))
+	if (IS_RDONLY(dir) && (nd->intent.it_flags & (O_CREAT|O_TRUNC|FMODE_WRITE)))
 		return 0;
 	return 1;
 }
@@ -979,7 +979,7 @@ static struct dentry *nfs_atomic_lookup(
 	dentry->d_op = NFS_PROTO(dir)->dentry_ops;
 
 	/* Let vfs_create() deal with O_EXCL */
-	if (nd->intent.open.flags & O_EXCL) {
+ 	if (nd->intent.it_flags & O_EXCL) {
 		d_add(dentry, NULL);
 		goto out;
 	}
@@ -994,7 +994,7 @@ static struct dentry *nfs_atomic_lookup(
 		goto out;
 	}
 
-	if (nd->intent.open.flags & O_CREAT) {
+	if (nd->intent.it_flags & O_CREAT) {
 		nfs_begin_data_update(dir);
 		res = nfs4_atomic_open(dir, dentry, nd);
 		nfs_end_data_update(dir);
@@ -1013,7 +1013,7 @@ static struct dentry *nfs_atomic_lookup(
 			case -ENOTDIR:
 				goto no_open;
 			case -ELOOP:
-				if (!(nd->intent.open.flags & O_NOFOLLOW))
+				if (!(nd->intent.it_flags & O_NOFOLLOW))
 					goto no_open;
 			/* case -EINVAL: */
 			default:
@@ -1049,7 +1049,7 @@ static int nfs_open_revalidate(struct de
 	/* NFS only supports OPEN on regular files */
 	if (!S_ISREG(inode->i_mode))
 		goto no_open;
-	openflags = nd->intent.open.flags;
+	openflags = nd->intent.it_flags;
 	/* We cannot do exclusive creation on a positive dentry */
 	if ((openflags & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL))
 		goto no_open;
@@ -1182,7 +1182,7 @@ static int nfs_create(struct inode *dir,
 	attr.ia_valid = ATTR_MODE;
 
 	if (nd && (nd->flags & LOOKUP_CREATE))
-		open_flags = nd->intent.open.flags;
+		open_flags = nd->intent.it_flags;
 
 	lock_kernel();
 	nfs_begin_data_update(dir);
Index: linux-2.6/fs/nfs/nfs4proc.c
===================================================================
--- linux-2.6.orig/fs/nfs/nfs4proc.c	2006-07-15 21:04:01.000000000 +0800
+++ linux-2.6/fs/nfs/nfs4proc.c	2006-07-15 21:09:29.000000000 +0800
@@ -1246,7 +1246,7 @@ static int nfs4_intent_set_file(struct n
 		ctx->state = state;
 		return 0;
 	}
-	nfs4_close_state(state, nd->intent.open.flags);
+	nfs4_close_state(state, nd->intent.flags);
 	return PTR_ERR(filp);
 }
 
@@ -1259,22 +1259,22 @@ nfs4_atomic_open(struct inode *dir, stru
 	struct dentry *res;
 
 	if (nd->flags & LOOKUP_CREATE) {
-		attr.ia_mode = nd->intent.open.create_mode;
+		attr.ia_mode = nd->intent.create_mode;
 		attr.ia_valid = ATTR_MODE;
 		if (!IS_POSIXACL(dir))
 			attr.ia_mode &= ~current->fs->umask;
 	} else {
 		attr.ia_valid = 0;
-		BUG_ON(nd->intent.open.flags & O_CREAT);
+		BUG_ON(nd->intent.flags & O_CREAT);
 	}
 
 	cred = rpcauth_lookupcred(NFS_SERVER(dir)->client->cl_auth, 0);
 	if (IS_ERR(cred))
 		return (struct dentry *)cred;
-	state = nfs4_do_open(dir, dentry, nd->intent.open.flags, &attr, cred);
+	state = nfs4_do_open(dir, dentry, nd->intent.flags, &attr, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state)) {
-		if (PTR_ERR(state) == -ENOENT)
+		ose_statef (PTR_ERR(state) == -ENOENT);
 			d_add(dentry, NULL);
 		return (struct dentry *)state;
 	}
