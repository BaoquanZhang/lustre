Index: linux/fs/jbd/journal.c
===================================================================
--- linux.orig/fs/jbd/journal.c
+++ linux/fs/jbd/journal.c
@@ -323,7 +323,7 @@ int journal_write_metadata_buffer(transa
 				  struct journal_head **jh_out,
 				  int blocknr)
 {
-	int need_copy_out = 0;
+	int need_copy_out;
 	int done_copy_out = 0;
 	int do_escape = 0;
 	char *mapped_data;
@@ -369,7 +369,8 @@ repeat:
 				cpu_to_be32(JFS_MAGIC_NUMBER)) {
 		need_copy_out = 1;
 		do_escape = 1;
-	}
+	} else
+		need_copy_out = jh_in->b_committed_data == NULL;
 	kunmap_atomic(mapped_data, KM_USER0);
 
 	/*
Index: linux/fs/jbd/transaction.c
===================================================================
--- linux.orig/fs/jbd/transaction.c
+++ linux/fs/jbd/transaction.c
@@ -817,6 +817,15 @@ int journal_get_create_access(handle_t *
 	 */
 	jbd_lock_bh_state(bh);
 	spin_lock(&journal->j_list_lock);
+	if (!((jh->b_transaction == transaction ||
+		jh->b_transaction == NULL ||
+		(jh->b_transaction == journal->j_committing_transaction &&
+		 jh->b_jlist == BJ_Forget)))) {
+		printk("%s: %p %p %p %p %i\n", __FUNCTION__,
+		       jh, jh->b_transaction, transaction,
+		       journal->j_committing_transaction, jh->b_jlist);
+		
+	}
 	J_ASSERT_JH(jh, (jh->b_transaction == transaction ||
 		jh->b_transaction == NULL ||
 		(jh->b_transaction == journal->j_committing_transaction &&
@@ -1115,6 +1124,8 @@ int journal_dirty_metadata(handle_t *han
 	journal_t *journal = transaction->t_journal;
 	struct journal_head *jh = bh2jh(bh);
 
+	BUG_ON(transaction == NULL);		
+
 	jbd_debug(5, "journal_head %p\n", jh);
 	JBUFFER_TRACE(jh, "entry");
 	if (is_handle_aborted(handle))
