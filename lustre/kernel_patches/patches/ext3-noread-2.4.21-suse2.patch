 fs/ext3/ialloc.c        |   47 ++++++++++++++++++++++-
 fs/ext3/inode.c         |   96 +++++++++++++++++++++++++++++++++++++-----------
 include/linux/ext3_fs.h |    2 +
 3 files changed, 121 insertions(+), 24 deletions(-)

--- linux-2.4.20/fs/ext3/ialloc.c~ext3-noread-2.4.20	2003-05-16 12:21:39.000000000 +0800
+++ linux-2.4.20-root/fs/ext3/ialloc.c	2003-05-16 12:21:46.000000000 +0800
@@ -289,6 +289,37 @@ error_return:
 }
 
 /*
+ * @block_group: block group of inode
+ * @offset: relative offset of inode within @block_group
+ *
+ * Check whether any of the inodes in this disk block are in use.
+ *
+ * Caller must be holding superblock lock (group/bitmap read lock in future).
+ */
+int ext3_itable_block_used(struct super_block *sb, unsigned int block_group,
+			   int offset)
+{
+	int bitmap_nr = load_inode_bitmap(sb, block_group);
+	int inodes_per_block;
+	unsigned long inum, iend;
+	struct buffer_head *ibitmap;
+
+	if (bitmap_nr < 0)
+		return 1;
+
+	inodes_per_block = sb->s_blocksize / EXT3_SB(sb)->s_inode_size;
+	inum = offset & ~(inodes_per_block - 1);
+	iend = inum + inodes_per_block;
+	ibitmap = EXT3_SB(sb)->s_inode_bitmap[bitmap_nr];
+	for (; inum < iend; inum++) {
+		if (inum != offset && ext3_test_bit(inum, ibitmap->b_data))
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
  * There are two policies for allocating an inode.  If the new inode is
  * a directory, then a forward search is made for a block group with both
  * free space and a low directory-to-inode ratio; if that fails, then of
@@ -310,6 +341,7 @@ struct inode * ext3_new_inode (handle_t 
 	struct ext3_group_desc * gdp;
 	struct ext3_group_desc * tmp;
 	struct ext3_super_block * es;
+	struct ext3_iloc iloc;
 	int err = 0;
 
 	/* Cannot create files in a deleted directory */
@@ -510,8 +542,19 @@ repeat:
 	inode->i_generation = sb->u.ext3_sb.s_next_generation++;
 
 	inode->u.ext3_i.i_state = EXT3_STATE_NEW;
-	err = ext3_mark_inode_dirty(handle, inode);
-	if (err) goto fail;
+	err = ext3_get_inode_loc_new(inode, &iloc, 1);
+	if (err) goto fail;
+	BUFFER_TRACE(iloc->bh, "get_write_access");
+	err = ext3_journal_get_write_access(handle, iloc.bh);
+	if (err) {
+		brelse(iloc.bh);
+		iloc.bh = NULL;
+		goto fail;
+	}
+	err = ext3_mark_iloc_dirty(handle, inode, &iloc);
+	if (err) goto fail;
+ 
+
 
 #ifdef CONFIG_EXT3_FS_XATTR
 	init_rwsem(&inode->u.ext3_i.xattr_sem);
--- linux-2.4.20/fs/ext3/inode.c~ext3-noread-2.4.20	2003-05-16 12:21:41.000000000 +0800
+++ linux-2.4.20-root/fs/ext3/inode.c	2003-05-16 12:22:15.000000000 +0800
@@ -2013,14 +2013,19 @@ out_stop:
 	ext3_journal_stop(handle, inode);
 }
 
-/* 
- * ext3_get_inode_loc returns with an extra refcount against the
- * inode's underlying buffer_head on success. 
- */
-
-int ext3_get_inode_loc (struct inode *inode, struct ext3_iloc *iloc)
+#define NUM_INODE_PREREAD	16
+
+/*
+ * ext3_get_inode_loc returns with an extra refcount against the inode's
+ * underlying buffer_head on success.  If this is for a new inode allocation
+ * (new is non-zero) then we may be able to optimize away the read if there
+ * are no other in-use inodes in this inode table block.  If we need to do
+ * a read, then read in a whole chunk of blocks to avoid blocking again soon
+ * if we are doing lots of creates/updates.
+ */
+int ext3_get_inode_loc_new(struct inode *inode, struct ext3_iloc *iloc, int new)
 {
-	struct buffer_head *bh = 0;
+	struct buffer_head *bh[NUM_INODE_PREREAD];
 	unsigned long block;
 	unsigned long block_group;
 	unsigned long group_desc;
@@ -2045,31 +2050,73 @@ int ext3_get_inode_loc (struct inode *in
 	}
 	group_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(inode->i_sb);
 	desc = block_group & (EXT3_DESC_PER_BLOCK(inode->i_sb) - 1);
-	bh = inode->i_sb->u.ext3_sb.s_group_desc[group_desc];
-	if (!bh) {
+	if (!(inode->i_sb->u.ext3_sb.s_group_desc[group_desc])) {
 		ext3_error (inode->i_sb, "ext3_get_inode_loc",
 			    "Descriptor not loaded");
 		goto bad_inode;
 	}
 
-	gdp = (struct ext3_group_desc *) bh->b_data;
+	gdp = (struct ext3_group_desc *)(inode->i_sb->u.ext3_sb.s_group_desc[group_desc]->b_data);
 	/*
 	 * Figure out the offset within the block group inode table
 	 */
-	offset = ((inode->i_ino - 1) % EXT3_INODES_PER_GROUP(inode->i_sb)) *
-		EXT3_INODE_SIZE(inode->i_sb);
+	offset = ((inode->i_ino - 1) % EXT3_INODES_PER_GROUP(inode->i_sb));
+
 	block = le32_to_cpu(gdp[desc].bg_inode_table) +
-		(offset >> EXT3_BLOCK_SIZE_BITS(inode->i_sb));
-	if (!(bh = sb_bread(inode->i_sb, block))) {
-		ext3_error (inode->i_sb, "ext3_get_inode_loc",
-			    "unable to read inode block - "
-			    "inode=%lu, block=%lu", inode->i_ino, block);
-		goto bad_inode;
-	}
-	offset &= (EXT3_BLOCK_SIZE(inode->i_sb) - 1);
+		(offset * EXT3_INODE_SIZE(inode->i_sb) >> EXT3_BLOCK_SIZE_BITS(inode->i_sb));
 
-	iloc->bh = bh;
-	iloc->raw_inode = (struct ext3_inode *) (bh->b_data + offset);
+	bh[0] = sb_getblk(inode->i_sb, block);
+	if (buffer_uptodate(bh[0]))
+		goto done;
+ 
+	/* If we don't really need to read this block, and it isn't already
+	 * in memory, then we just zero it out.  Otherwise, we keep the
+	 * current block contents (deleted inode data) for posterity.
+	 */
+	if (new && !ext3_itable_block_used(inode->i_sb, block_group, offset)) {
+		lock_buffer(bh[0]);
+		memset(bh[0]->b_data, 0, bh[0]->b_size);
+		mark_buffer_uptodate(bh[0], 1);
+		unlock_buffer(bh[0]);
+	} else {
+		unsigned long block_end, itable_end;
+		int count = 1;
+ 
+		itable_end = le32_to_cpu(gdp[desc].bg_inode_table) +
+				inode->i_sb->u.ext3_sb.s_itb_per_group;
+		block_end = block + NUM_INODE_PREREAD;
+		if (block_end > itable_end)
+			block_end = itable_end;
+
+		for (++block; block < block_end; block++) {
+			bh[count] = sb_getblk(inode->i_sb, block);
+			if (count && (buffer_uptodate(bh[count]) ||
+				      buffer_locked(bh[count]))) {
+				__brelse(bh[count]);
+			} else
+				count++;
+		}
+ 
+		ll_rw_block(READ, count, bh);
+ 
+		/* Release all but the block we actually need (bh[0]) */
+		while (--count > 0)
+			__brelse(bh[count]);
+ 
+		wait_on_buffer(bh[0]);
+		if (!buffer_uptodate(bh[0])) {
+			ext3_error(inode->i_sb, __FUNCTION__,
+				   "unable to read inode block - "
+				   "inode=%lu, block=%lu", inode->i_ino,
+				   bh[0]->b_blocknr);
+			goto bad_inode;
+		}
+	}
+ done:
+	offset = (offset * EXT3_INODE_SIZE(inode->i_sb)) & (EXT3_BLOCK_SIZE(inode->i_sb) - 1);
+
+	iloc->bh = bh[0];
+	iloc->raw_inode = (struct ext3_inode *)(bh[0]->b_data + offset);
 	iloc->block_group = block_group;
 	
 	return 0;
@@ -2078,6 +2125,11 @@ int ext3_get_inode_loc (struct inode *in
 	return -EIO;
 }
 
+int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)
+{
+	return ext3_get_inode_loc_new(inode, iloc, 0);
+}
+ 
 void ext3_read_inode(struct inode * inode)
 {
 	struct ext3_iloc iloc;
--- linux-2.4.20/include/linux/ext3_fs.h~ext3-noread-2.4.20	2003-05-16 12:21:39.000000000 +0800
+++ linux-2.4.20-root/include/linux/ext3_fs.h	2003-05-16 12:21:46.000000000 +0800
@@ -683,6 +683,8 @@ extern int ext3_forget(handle_t *, int, 
 extern struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);
 extern struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);
 
+extern int ext3_itable_block_used(struct super_block *sb, unsigned int, int);
+extern int ext3_get_inode_loc_new(struct inode *, struct ext3_iloc *, int);
 extern int  ext3_get_inode_loc (struct inode *, struct ext3_iloc *);
 extern void ext3_read_inode (struct inode *);
 extern void ext3_write_inode (struct inode *, int);

_
