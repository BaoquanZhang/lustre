 Documentation/filesystems/ext2.txt |   16 ++
 fs/ext3/Makefile                   |    2 
 fs/ext3/inode.c                    |    4 
 fs/ext3/iopen.c                    |  236 +++++++++++++++++++++++++++++++++++++
 fs/ext3/iopen.h                    |   15 ++
 fs/ext3/namei.c                    |   11 +
 fs/ext3/super.c                    |   11 +
 include/linux/ext3_fs.h            |    2 
 8 files changed, 295 insertions(+), 2 deletions(-)

--- linux-2.4.20/Documentation/filesystems/ext2.txt~iopen	2001-07-11 16:44:45.000000000 -0600
+++ linux-2.4.20-braam/Documentation/filesystems/ext2.txt	2003-05-11 11:06:22.000000000 -0600
@@ -35,6 +35,22 @@ resgid=n			The group ID which may use th
 
 sb=n				Use alternate superblock at this location.
 
+iopen				Makes an invisible pseudo-directory called 
+				__iopen__ available in the root directory
+				of the filesystem.  Allows open-by-inode-
+				number.  i.e., inode 3145 can be accessed
+				via /mntpt/__iopen__/3145
+
+iopen_nopriv			This option makes the iopen directory be
+				world-readable.  This may be safer since it
+				allows daemons to run as an unprivileged user,
+				however it significantly changes the security
+				model of a Unix filesystem, since previously
+				all files under a mode 700 directory were not
+				generally avilable even if the
+				permissions on the file itself is
+				world-readable.
+
 grpquota,noquota,quota,usrquota	Quota options are silently ignored by ext2.
 
 
--- linux-2.4.20/fs/ext3/Makefile~iopen	2003-05-11 11:05:55.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/Makefile	2003-05-11 11:07:31.000000000 -0600
@@ -11,7 +11,7 @@ O_TARGET := ext3.o
 
 export-objs := ext3-exports.o
 
-obj-y    := balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o \
+obj-y    := balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o iopen.o \
 		ioctl.o namei.o super.o symlink.o hash.o ext3-exports.o
 obj-m    := $(O_TARGET)
 
--- linux-2.4.20/fs/ext3/inode.c~iopen	2003-05-11 11:05:59.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/inode.c	2003-05-11 11:06:22.000000000 -0600
@@ -31,6 +31,7 @@
 #include <linux/highuid.h>
 #include <linux/quotaops.h>
 #include <linux/module.h>
+#include "iopen.h"
 
 /*
  * SEARCH_FROM_ZERO forces each block allocation to search from the start
@@ -2137,6 +2138,9 @@ void ext3_read_inode(struct inode * inod
 	struct buffer_head *bh;
 	int block;
 	
+	if (ext3_iopen_get_inode(inode))
+		return;
+	
 	if(ext3_get_inode_loc(inode, &iloc))
 		goto bad_inode;
 	bh = iloc.bh;
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-braam/fs/ext3/iopen.c	2003-05-17 10:44:42.000000000 -0600
@@ -0,0 +1,236 @@
+/*
+ * linux/fs/ext3/iopen.c
+ *
+ * Special support for open by inode number
+ *
+ * Copyright (C) 2001 by Theodore Ts'o (tytso@alum.mit.edu).
+ * 
+ * This file may be redistributed under the terms of the GNU General
+ * Public License.
+ */
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/locks.h>
+#include <linux/ext3_jbd.h>
+#include <linux/jbd.h>
+#include <linux/ext3_fs.h>
+#include <linux/smp_lock.h>
+#include "iopen.h"
+
+#ifndef assert
+#define assert(test) J_ASSERT(test)
+#endif
+
+#define IOPEN_NAME_LEN	32
+
+/*
+ * This implements looking up an inode by number.
+ */
+static struct dentry *iopen_lookup(struct inode * dir, struct dentry *dentry)
+{
+	struct inode * inode;
+	unsigned long ino;
+        struct list_head *lp;
+        struct dentry *alternate;
+	char buf[IOPEN_NAME_LEN];
+	
+	if (dentry->d_name.len >= IOPEN_NAME_LEN)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	memcpy(buf, dentry->d_name.name, dentry->d_name.len);
+	buf[dentry->d_name.len] = 0;
+
+	if (strcmp(buf, ".") == 0)
+		ino = dir->i_ino;
+	else if (strcmp(buf, "..") == 0)
+		ino = EXT3_ROOT_INO;
+	else
+		ino = simple_strtoul(buf, 0, 0);
+
+	if ((ino != EXT3_ROOT_INO &&
+	     //ino != EXT3_ACL_IDX_INO &&
+	     //ino != EXT3_ACL_DATA_INO &&
+	     ino < EXT3_FIRST_INO(dir->i_sb)) ||
+	    ino > le32_to_cpu(dir->i_sb->u.ext3_sb.s_es->s_inodes_count))
+		return ERR_PTR(-ENOENT);
+
+	inode = iget(dir->i_sb, ino);
+	if (!inode)
+		return ERR_PTR(-EACCES);
+	if (is_bad_inode(inode)) {
+		iput(inode);
+		return ERR_PTR(-ENOENT);
+	}
+
+        /* preferrably return a connected dentry */
+        spin_lock(&dcache_lock);
+        list_for_each(lp, &inode->i_dentry) {
+                alternate = list_entry(lp, struct dentry, d_alias);
+                if (!(alternate->d_flags & DCACHE_NFSD_DISCONNECTED)) {
+                        dget_locked(alternate);
+                        alternate->d_vfs_flags |= DCACHE_REFERENCED;
+                        iput(inode);
+                        spin_unlock(&dcache_lock);
+                        return alternate;
+                }
+        }
+        dentry->d_flags |= DCACHE_NFSD_DISCONNECTED;
+        spin_unlock(&dcache_lock);
+
+	d_add(dentry, inode);
+	return NULL;
+}
+
+#define do_switch(x,y) do { \
+	__typeof__ (x) __tmp = x; \
+	x = y; y = __tmp; } while (0)
+
+static inline void switch_names(struct dentry * dentry, struct dentry * target)
+{
+	const unsigned char *old_name, *new_name;
+
+	memcpy(dentry->d_iname, target->d_iname, DNAME_INLINE_LEN); 
+	old_name = target->d_name.name;
+	new_name = dentry->d_name.name;
+	if (old_name == target->d_iname)
+		old_name = dentry->d_iname;
+	if (new_name == dentry->d_iname)
+		new_name = target->d_iname;
+	target->d_name.name = new_name;
+	dentry->d_name.name = old_name;
+}
+
+
+struct dentry *iopen_connect_dentry(struct dentry *de, struct inode *inode)
+{
+        struct dentry *tmp, *goal = NULL;
+        struct list_head *lp;
+
+        /* preferrably return a connected dentry */
+        spin_lock(&dcache_lock);
+        /* verify this dentry is really new */
+        assert(list_empty(&de->d_subdirs));
+        assert(list_empty(&de->d_alias));
+        //assert(list_empty(&inode->i_dentry));
+        list_for_each(lp, &inode->i_dentry) {
+                tmp = list_entry(lp, struct dentry, d_alias);
+                if (tmp->d_flags & DCACHE_NFSD_DISCONNECTED) {
+                        goal = tmp;
+                        dget_locked(goal);
+                        break;
+                }
+        }
+        if (!goal) { 
+                spin_unlock(&dcache_lock);
+                return NULL; 
+        }
+
+        /* Move the goal to the de hash queue */
+        goal->d_flags &= ~DCACHE_NFSD_DISCONNECTED;
+	list_del(&goal->d_hash);
+	list_add(&goal->d_hash, &de->d_hash);
+
+	list_del(&goal->d_child);
+	list_del(&de->d_child);
+
+	/* Switch the parents and the names.. */
+	switch_names(goal, de);
+	do_switch(goal->d_parent, de->d_parent);
+	do_switch(goal->d_name.len, de->d_name.len);
+	do_switch(goal->d_name.hash, de->d_name.hash);
+
+	/* And add them back to the (new) parent lists */
+	list_add(&goal->d_child, &goal->d_parent->d_subdirs);
+	list_add(&de->d_child, &de->d_parent->d_subdirs);
+
+        list_for_each(lp, &inode->i_dentry) {
+                goal = list_entry(lp, struct dentry, d_alias);
+                if (goal->d_flags & DCACHE_NFSD_DISCONNECTED) {
+                        assert(1==0);
+                }
+        }
+
+        spin_unlock(&dcache_lock);
+        return goal;
+}
+
+/*
+ * These are the special structures for the iopen pseudo directory.
+ */
+
+static struct inode_operations iopen_inode_operations = {
+	lookup:		iopen_lookup,		/* BKL held */
+};
+
+static struct file_operations iopen_file_operations = {
+	read:		generic_read_dir,
+};
+
+static int match_dentry(struct dentry *dentry, const char *name)
+{
+	int	len;
+
+	len = strlen(name);
+	if (dentry->d_name.len != len)
+		return 0;
+	if (strncmp(dentry->d_name.name, name, len))
+		return 0;
+	return 1;
+}
+
+/*
+ * This function is spliced into ext3_lookup and returns 1 the file
+ * name is __iopen__ and dentry has been filled in appropriately.
+ */
+int ext3_check_for_iopen(struct inode * dir, struct dentry *dentry)
+{
+	struct inode * inode;
+
+	if (dir->i_ino != EXT3_ROOT_INO ||
+	    !test_opt(dir->i_sb, IOPEN) ||
+	    !match_dentry(dentry, "__iopen__"))
+		return 0;
+
+	inode = iget(dir->i_sb, EXT3_BAD_INO);
+
+	if (!inode) 
+		return 0;
+	d_add(dentry, inode);
+	return 1;
+}
+
+/*
+ * This function is spliced into read_inode; it returns 1 if inode
+ * number is the one for /__iopen__, in which case the inode is filled
+ * in appropriately.  Otherwise, this fuction returns 0.
+ */
+int ext3_iopen_get_inode(struct inode * inode)
+{
+	if (inode->i_ino != EXT3_BAD_INO)
+		return 0;
+
+	inode->i_mode = S_IFDIR | S_IRUSR | S_IXUSR;
+	if (test_opt(inode->i_sb, IOPEN_NOPRIV))
+		inode->i_mode |= 0777;
+	inode->i_uid = 0;
+	inode->i_gid = 0;
+	inode->i_nlink = 1;
+	inode->i_size = 4096;
+	inode->i_atime = CURRENT_TIME;
+	inode->i_ctime = CURRENT_TIME;
+	inode->i_mtime = CURRENT_TIME;
+	inode->u.ext3_i.i_dtime = 0;
+	inode->i_blksize = PAGE_SIZE;	/* This is the optimal IO size
+					 * (for stat), not the fs block
+					 * size */  
+	inode->i_blocks = 0;
+	inode->i_version = 1;
+	inode->i_generation = 0;
+
+	inode->i_op = &iopen_inode_operations;
+	inode->i_fop = &iopen_file_operations;
+	inode->i_mapping->a_ops = 0;
+
+	return 1;
+}
--- /dev/null	2003-01-30 03:24:37.000000000 -0700
+++ linux-2.4.20-braam/fs/ext3/iopen.h	2003-05-11 11:06:22.000000000 -0600
@@ -0,0 +1,15 @@
+/*
+ * iopen.h
+ *
+ * Special support for opening files by inode number.
+ * 
+ * Copyright (C) 2001 by Theodore Ts'o (tytso@alum.mit.edu).
+ * 
+ * This file may be redistributed under the terms of the GNU General
+ * Public License.
+ */
+
+extern int ext3_check_for_iopen(struct inode * dir, struct dentry *dentry);
+extern int ext3_iopen_get_inode(struct inode * inode);
+
+
--- linux-2.4.20/fs/ext3/namei.c~iopen	2003-05-11 11:05:59.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/namei.c	2003-05-11 19:41:17.000000000 -0600
@@ -35,7 +35,7 @@
 #include <linux/string.h>
 #include <linux/locks.h>
 #include <linux/quotaops.h>
-
+#include "iopen.h"
 
 /*
  * define how far ahead to read directories while searching them.
@@ -921,16 +921,21 @@ errout:
 	return NULL;
 }
 #endif
+struct dentry *iopen_connect_dentry(struct dentry *de, struct inode *inode);
 
 static struct dentry *ext3_lookup(struct inode * dir, struct dentry *dentry)
 {
 	struct inode * inode;
 	struct ext3_dir_entry_2 * de;
 	struct buffer_head * bh;
+        struct dentry *alternate = NULL;
 
 	if (dentry->d_name.len > EXT3_NAME_LEN)
 		return ERR_PTR(-ENAMETOOLONG);
 
+	if (ext3_check_for_iopen(dir, dentry))
+		return NULL;
+
 	bh = ext3_find_entry(dentry, &de);
 	inode = NULL;
 	if (bh) {
@@ -942,6 +947,10 @@ static struct dentry *ext3_lookup(struct
 			return ERR_PTR(-EACCES);
 		}
 	}
+                
+        if (inode && (alternate = iopen_connect_dentry(dentry, inode))) 
+                return alternate;
+
 	d_add(dentry, inode);
 	return NULL;
 }
--- linux-2.4.20/fs/ext3/super.c~iopen	2003-05-11 11:05:58.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/super.c	2003-05-11 11:06:22.000000000 -0600
@@ -820,6 +820,17 @@ static int parse_options (char * options
 		         || !strcmp (this_char, "quota")
 		         || !strcmp (this_char, "usrquota"))
 			/* Don't do anything ;-) */ ;
+		else if (!strcmp (this_char, "iopen")) {
+			set_opt (sbi->s_mount_opt, IOPEN);
+			clear_opt (sbi->s_mount_opt, IOPEN_NOPRIV);
+		} else if (!strcmp (this_char, "noiopen")) {
+			clear_opt (sbi->s_mount_opt, IOPEN);
+			clear_opt (sbi->s_mount_opt, IOPEN_NOPRIV);
+		}
+		else if (!strcmp (this_char, "iopen_nopriv")) {
+			set_opt (sbi->s_mount_opt, IOPEN);
+			set_opt (sbi->s_mount_opt, IOPEN_NOPRIV);
+		}
 		else if (!strcmp (this_char, "journal")) {
 			/* @@@ FIXME */
 			/* Eventually we will want to be able to create
--- linux-2.4.20/include/linux/ext3_fs.h~iopen	2003-05-11 11:05:59.000000000 -0600
+++ linux-2.4.20-braam/include/linux/ext3_fs.h	2003-05-15 13:37:54.000000000 -0600
@@ -322,6 +322,8 @@ struct ext3_inode {
 #define EXT3_MOUNT_UPDATE_JOURNAL	0x1000	/* Update the journal format */
 #define EXT3_MOUNT_NO_UID32		0x2000  /* Disable 32-bit UIDs */
 #define EXT3_MOUNT_XATTR_USER		0x4000	/* Extended user attributes */
+#define EXT3_MOUNT_IOPEN		0x4000  /* Allow access via iopen */
+#define EXT3_MOUNT_IOPEN_NOPRIV		0x8000  /* Make iopen world-readable */
 #define EXT3_MOUNT_ASYNCDEL	       0x10000  /* Delayed deletion */
 
 /* Compatibility, for having both ext2_fs.h and ext3_fs.h included at once */

_
