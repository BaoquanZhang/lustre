diff -urNp linux-700/arch/i386/config.in linux-720/arch/i386/config.in
--- linux-700/arch/i386/config.in
+++ linux-720/arch/i386/config.in
@@ -9,8 +9,6 @@ define_bool CONFIG_SBUS n
  
 define_bool CONFIG_UID16 y
  
+define_bool CONFIG_KALLSYMS y
+
 mainmenu_option next_comment
 comment 'Code maturity level options'
 bool 'Prompt for development and/or incomplete code/drivers' CONFIG_EXPERIMENTAL
diff -urNp linux-700/arch/i386/kernel/process.c linux-720/arch/i386/kernel/process.c
--- linux-700/arch/i386/kernel/process.c	
+++ linux-720/arch/i386/kernel/process.c	
@@ -33,6 +33,7 @@
 #include <linux/reboot.h>
 #include <linux/init.h>
 #include <linux/mc146818rtc.h>
+#include <linux/version.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -437,10 +438,14 @@ extern void show_trace(unsigned long* es
 void show_regs(struct pt_regs * regs)
 {
 	unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L;
+	static char buffer[512];
+
+	lookup_symbol(regs->eip,buffer,512);
 
 	printk("\n");
 	printk("Pid: %d, comm: %20s\n", current->pid, current->comm);
 	printk("EIP: %04x:[<%08lx>] CPU: %d",0xffff & regs->xcs,regs->eip, smp_processor_id());
+	printk("\nEIP is at %s (" UTS_RELEASE ")\n",buffer);
 	if (regs->xcs & 3)
 		printk(" ESP: %04x:%08lx",0xffff & regs->xss,regs->esp);
 	printk(" EFLAGS: %08lx    %s\n",regs->eflags, print_tainted());
diff -urNp linux-700/arch/i386/kernel/traps.c linux-720/arch/i386/kernel/traps.c
--- linux-700/arch/i386/kernel/traps.c	
+++ linux-720/arch/i386/kernel/traps.c	
@@ -24,6 +24,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/highmem.h>
+#include <linux/version.h>
 
 #ifdef CONFIG_MCA
 #include <linux/mca.h>
@@ -135,6 +136,8 @@ void show_trace(unsigned long * stack)
 {
 	int i;
 	unsigned long addr;
+	/* static to not take up stackspace; if we race here too bad */
+	static char buffer[512];
 
 	if (!stack)
 		stack = (unsigned long*)&stack;
@@ -144,9 +147,8 @@ void show_trace(unsigned long * stack)
 	while (((long) stack & (THREAD_SIZE-1)) != 0) {
 		addr = *stack++;
 		if (kernel_text_address(addr)) {
-			if (i && ((i % 6) == 0))
-				printk("\n ");
-			printk(" [<%08lx>]", addr);
+			lookup_symbol(addr, buffer, 512);
+			printk("[<%08lx>] %s (0x%x))\n", addr,buffer,stack-1);
 			i++;
 		}
 	}
@@ -194,12 +196,17 @@ void dump_stack(void)
 	show_stack(0);
 }
 
+
+void print_modules(void);
+
+
 void show_registers(struct pt_regs *regs)
 {
 	int i;
 	int in_kernel = 1;
 	unsigned long esp;
 	unsigned short ss;
+	static char buffer[512];
 
 	esp = (unsigned long) (&regs->esp);
 	ss = __KERNEL_DS;
@@ -208,8 +215,12 @@ void show_registers(struct pt_regs *regs
 		esp = regs->esp;
 		ss = regs->xss & 0xffff;
 	}
+
+	print_modules();
+	lookup_symbol(regs->eip, buffer, 512);
 	printk("CPU:    %d\nEIP:    %04x:[<%08lx>]    %s\nEFLAGS: %08lx\n",
 		smp_processor_id(), 0xffff & regs->xcs, regs->eip, print_tainted(), regs->eflags);
+	printk("\nEIP is at %s (" UTS_RELEASE ")\n",buffer);
 	printk("eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx\n",
 		regs->eax, regs->ebx, regs->ecx, regs->edx);
 	printk("esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx\n",
@@ -269,7 +280,7 @@ static void handle_BUG(struct pt_regs *r
 	if (__get_user(file, (char **)(eip + 4)) ||
 		(unsigned long)file < PAGE_OFFSET || __get_user(c, file))
 		file = "<bad filename>";
-
+	printk("------------[ cut here ]------------\n");
 	printk("kernel BUG at %s:%d!\n", file, line);
 
 no_bug:
diff -urNp linux-700/include/linux/kernel.h linux-720/include/linux/kernel.h
--- linux-700/include/linux/kernel.h	
+++ linux-720/include/linux/kernel.h	
@@ -110,6 +110,8 @@ extern const char *print_tainted(void);
 
 extern void dump_stack(void);
 
+extern int lookup_symbol(unsigned long address, char *buffer, int buflen);
+
 #if DEBUG
 #define pr_debug(fmt,arg...) \
 	printk(KERN_DEBUG fmt,##arg)
diff -urNp linux-700/kernel/kksymoops.c linux-720/kernel/kksymoops.c
--- linux-700/kernel/kksymoops.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-720/kernel/kksymoops.c	
@@ -0,0 +1,82 @@
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#ifdef CONFIG_KALLSYMS
+#include <linux/kallsyms.h>
+#endif
+
+
+
+int lookup_symbol(unsigned long address, char *buffer, int buflen)
+{
+	struct module *this_mod;
+	unsigned long bestsofar;
+
+	const char *mod_name = NULL, *sec_name = NULL, *sym_name = NULL;
+	unsigned long mod_start,mod_end,sec_start,sec_end,sym_start,sym_end;
+	
+	if (!buffer)
+		return -EFAULT;
+	
+	if (buflen<256)
+		return -ENOMEM;
+	
+	memset(buffer,0,buflen);
+
+#ifdef CONFIG_KALLSYMS
+	if (!kallsyms_address_to_symbol(address,&mod_name,&mod_start,&mod_end,&sec_name,
+		&sec_start, &sec_end, &sym_name, &sym_start, &sym_end)) {
+		/* kallsyms doesn't have a clue; lets try harder */
+		bestsofar = 0;
+		snprintf(buffer,buflen-1,"[unresolved]");
+		
+		this_mod = module_list;
+
+		while (this_mod != NULL) {
+			int i;
+			/* walk the symbol list of this module. Only symbols
+			   who's address is smaller than the searched for address
+			   are relevant; and only if it's better than the best so far */
+			for (i=0; i< this_mod->nsyms; i++)
+				if ((this_mod->syms[i].value<=address) &&
+					(bestsofar<this_mod->syms[i].value)) {
+					snprintf(buffer,buflen-1,"%s [%s] 0x%x",
+						this_mod->syms[i].name,
+						this_mod->name,
+						(unsigned int)(address - this_mod->syms[i].value));
+					bestsofar = this_mod->syms[i].value;
+				}
+			this_mod = this_mod->next;
+		}
+
+	} else { /* kallsyms success */
+		snprintf(buffer,buflen-1,"%s [%s] 0x%x",sym_name,mod_name,(unsigned int)(address-sym_start));
+	}
+#endif
+	return strlen(buffer);
+}
+
+static char modlist[4096];
+/* this function isn't smp safe but that's not really a problem; it's called from
+ * oops context only and any locking could actually prevent the oops from going out;
+ * the line that is generated is informational only and should NEVER prevent the real oops
+ * from going out. 
+ */
+void print_modules(void)
+{
+	struct module *this_mod;
+	int pos = 0, i;
+	memset(modlist,0,4096);
+
+#ifdef CONFIG_KALLSYMS
+	this_mod = module_list;
+	while (this_mod != NULL) {
+		if (this_mod->name != NULL)
+			pos +=snprintf(modlist+pos,160-pos-1,"%s ",this_mod->name);
+		this_mod = this_mod->next;
+	}
+	printk("%s\n",modlist);
+#endif
+}
diff -urNp linux-700/kernel/Makefile linux-720/kernel/Makefile
--- linux-700/kernel/Makefile	2001-09-17 06:22:40.000000000 +0200
+++ linux-720/kernel/Makefile	
@@ -14,7 +14,7 @@ export-objs = signal.o sys.o kmod.o cont
 obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o \
 	    module.o exit.o itimer.o info.o time.o softirq.o resource.o \
 	    sysctl.o acct.o capability.o ptrace.o timer.o user.o \
-	    signal.o sys.o kmod.o context.o
+	    signal.o sys.o kmod.o context.o kksymoops.o
 
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += ksyms.o
