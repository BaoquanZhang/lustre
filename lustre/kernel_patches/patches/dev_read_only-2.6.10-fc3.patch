Index: linux-2.6.10/drivers/block/ll_rw_blk.c
===================================================================
--- linux-2.6.10.orig/drivers/block/ll_rw_blk.c	2004-12-25 05:33:59.000000000 +0800
+++ linux-2.6.10/drivers/block/ll_rw_blk.c	2005-04-08 12:35:49.785573840 +0800
@@ -2598,6 +2598,8 @@
 	set_bit(BIO_EOF, &bio->bi_flags);
 }
 
+int dev_check_rdonly(struct block_device *bdev);
+
 /**
  * generic_make_request: hand a buffer to its device driver for I/O
  * @bio:  The bio describing the location in memory and on the device.
@@ -2681,6 +2683,13 @@
 
 		block_wait_queue_running(q);
 
+		/* this is cfs's dev_rdonly check */
+		if (bio->bi_rw == WRITE &&
+		                dev_check_rdonly(bio->bi_bdev)) {
+		        bio_endio(bio, bio->bi_size, 0);
+		        break;
+		}
+
 		/*
 		 * If this device has partitions, remap block n
 		 * of partition p to block n+start(p) of the disk.
@@ -3156,6 +3165,79 @@
 EXPORT_SYMBOL(swap_io_context);
 
 /*
+ * Debug code for turning block devices "read-only" (will discard writes
+ * silently).  This is for filesystem crash/recovery testing.
+ */
+struct deventry {
+        dev_t dev;
+        struct list_head dev_list;
+};
+static struct list_head devlist = LIST_HEAD_INIT(devlist);
+static spinlock_t devlock = SPIN_LOCK_UNLOCKED; 
+
+int dev_check_rdonly(struct block_device *bdev) 
+{
+        struct deventry *cur;
+        if (!bdev) return 0;
+        spin_lock(&devlock);
+	list_for_each_entry(cur, &devlist, dev_list) {
+                if (bdev->bd_dev == cur->dev) {
+                        spin_unlock(&devlock);
+                        return 1;
+                }
+        }
+        spin_unlock(&devlock);
+        return 0;
+}
+
+void dev_set_rdonly(struct block_device *bdev)
+{
+        struct deventry *newdev, *cur;
+
+        if (!bdev) 
+	        return;
+        newdev = kmalloc(sizeof(struct deventry), GFP_KERNEL);
+        if (!newdev) 
+	        return;
+
+        spin_lock(&devlock);
+	list_for_each_entry(cur, &devlist, dev_list) {
+                if (bdev->bd_dev == cur->dev) {
+                        spin_unlock(&devlock);
+                        kfree(newdev);
+                        return;
+                }
+        }
+        newdev->dev = bdev->bd_dev;
+	list_add(&newdev->dev_list, &devlist); 
+        spin_unlock(&devlock);
+        printk(KERN_WARNING "Turning device %s read-only\n",
+               bdev->bd_disk ? bdev->bd_disk->disk_name : "?");
+}
+
+void dev_clear_rdonly(struct block_device *bdev) 
+{
+        struct deventry *cur, *tmp;
+        if (!bdev) return;
+        spin_lock(&devlock);
+	list_for_each_entry_safe(cur, tmp, &devlist, dev_list) { 
+                if (bdev->bd_dev == cur->dev) {
+                        list_del_init(&cur->dev_list);
+			kfree(cur);
+                        spin_unlock(&devlock);
+                        printk(KERN_WARNING "Removing read-only on %s\n",
+			       bdev->bd_disk ? bdev->bd_disk->disk_name : "?");
+			return;
+                }
+        }
+        spin_unlock(&devlock);
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+
+/*
  * sysfs parts below
  */
 struct queue_sysfs_entry {
