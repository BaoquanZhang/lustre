 drivers/block/ll_rw_blk.c |   49 ++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/blkdev.h    |    1 
 2 files changed, 50 insertions(+)

Index: linux-2.6.10/drivers/block/ll_rw_blk.c
===================================================================
--- linux-2.6.10.orig/drivers/block/ll_rw_blk.c	2004-12-25 05:33:59.000000000 +0800
+++ linux-2.6.10/drivers/block/ll_rw_blk.c	2005-04-05 15:42:58.075467024 +0800
@@ -2679,6 +2679,13 @@
 		if (test_bit(QUEUE_FLAG_DEAD, &q->queue_flags))
 			goto end_io;
 
+                /* this is cfs's dev_rdonly check */
+                if (bio->bi_rw == WRITE &&
+                                dev_check_rdonly(bio->bi_bdev->bd_dev)) {
+                        bio_endio(bio, bio->bi_size, 0);
+                        break;
+                }
+
 		block_wait_queue_running(q);
 
 		/*
@@ -3287,6 +3294,58 @@
 	return queue_var_show(max_hw_sectors_kb, (page));
 }
 
+#define MAX_RDONLY_DEVS		16
+
+static dev_t rdonly_devs[MAX_RDONLY_DEVS] = {0, };
+
+/*
+ * Debug code for turning block devices "read-only" (will discard writes
+ * silently).  This is for filesystem crash/recovery testing.
+ */
+void dev_set_rdonly(struct block_device *bdev, int no_write)
+{
+	if (no_write >= MAX_RDONLY_DEVS) {
+		printk(KERN_ALERT "%s:%d illegal arg %d (max %d)\n",
+				__FILE__, __LINE__, no_write, MAX_RDONLY_DEVS);
+		return;
+	}
+
+	if (bdev) {
+		printk(KERN_WARNING "Turning device %s read-only at %d\n",
+				bdev->bd_disk ? bdev->bd_disk->disk_name : "?",
+				no_write);
+		rdonly_devs[no_write] = bdev->bd_dev;
+	}
+}
+
+void dev_clear_rdonly(int no_write)
+{
+	if (no_write >= MAX_RDONLY_DEVS) {
+		printk(KERN_ALERT "%s:%d illegal arg %d (max %d)\n",
+				__FILE__, __LINE__, no_write, MAX_RDONLY_DEVS);
+		return;
+	}
+
+	if (rdonly_devs[no_write] == 0)
+		return;
+	
+	printk(KERN_WARNING "Clearing read-only at %d\n", no_write);
+	rdonly_devs[no_write] = 0;
+}
+
+int dev_check_rdonly(dev_t dev)
+{
+	int i;
+
+	for (i = 0; i < MAX_RDONLY_DEVS; i++)
+		if (rdonly_devs[i] == dev)
+			return 1;
+	return 0;
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
 
 static struct queue_sysfs_entry queue_requests_entry = {
 	.attr = {.name = "nr_requests", .mode = S_IRUGO | S_IWUSR },
