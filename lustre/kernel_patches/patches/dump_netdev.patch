diff -ruN -X /home/bharata/dontdiff 2569/drivers/net/3c59x.c 2569+lkcd/drivers/net/3c59x.c
--- 2569/drivers/net/3c59x.c	Mon May  5 05:22:48 2003
+++ 2569+lkcd/drivers/net/3c59x.c	Mon Jun 16 10:22:57 2003
@@ -895,6 +895,7 @@
 static int vortex_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static void vortex_tx_timeout(struct net_device *dev);
 static void acpi_set_WOL(struct net_device *dev);
+static void vorboom_poll(struct net_device *dev);
 
 /* This driver uses 'options' to pass the media type, full-duplex flag, etc. */
 /* Option count limit only -- unlimited interfaces are supported. */
@@ -1450,6 +1451,9 @@
 	dev->set_multicast_list = set_rx_mode;
 	dev->tx_timeout = vortex_tx_timeout;
 	dev->watchdog_timeo = (watchdog * HZ) / 1000;
+#ifdef HAVE_POLL_CONTROLLER
+	dev->poll_controller = &vorboom_poll;
+#endif
 	if (pdev && vp->enable_wol) {
 		vp->pm_state_valid = 1;
  		pci_save_state(VORTEX_PCI(vp), vp->power_state);
@@ -2445,6 +2449,29 @@
 	return IRQ_RETVAL(handled);
 }
 
+#ifdef HAVE_POLL_CONTROLLER
+
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+
+static void vorboom_poll (struct net_device *dev)
+{
+	struct vortex_private *vp = (struct vortex_private *)dev->priv;
+
+	disable_irq(dev->irq);
+	if (vp->full_bus_master_tx)
+		boomerang_interrupt(dev->irq, dev, 0);
+	else
+		vortex_interrupt(dev->irq, dev, 0);
+	enable_irq(dev->irq);
+}
+
+#endif
+
+
 static int vortex_rx(struct net_device *dev)
 {
 	struct vortex_private *vp = (struct vortex_private *)dev->priv;
diff -ruN -X /home/bharata/dontdiff 2569/drivers/net/e100/e100_main.c 2569+lkcd/drivers/net/e100/e100_main.c
--- 2569/drivers/net/e100/e100_main.c	Mon May  5 05:23:14 2003
+++ 2569+lkcd/drivers/net/e100/e100_main.c	Mon Jun 16 10:22:57 2003
@@ -560,6 +560,22 @@
 	readw(&(bdp->scb->scb_status));	/* flushes last write, read-safe */
 }
 
+#ifdef HAVE_POLL_CONTROLLER
+
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void
+e100_poll(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	e100intr(dev->irq, dev, NULL);
+	enable_irq(dev->irq);
+}
+#endif
+
 static int __devinit
 e100_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
 {
@@ -578,6 +594,9 @@
 
 	SET_MODULE_OWNER(dev);
 
+#ifdef HAVE_POLL_CONTROLLER
+	dev->poll_controller = &e100_poll;
+#endif
 	if (first_time) {
 		first_time = false;
         	printk(KERN_NOTICE "%s - version %s\n",
diff -ruN -X /home/bharata/dontdiff 2569/drivers/net/e1000/e1000_main.c 2569+lkcd/drivers/net/e1000/e1000_main.c
--- 2569/drivers/net/e1000/e1000_main.c	Mon May  5 05:23:12 2003
+++ 2569+lkcd/drivers/net/e1000/e1000_main.c	Mon Jun 16 10:22:57 2003
@@ -172,6 +172,7 @@
 static inline void e1000_rx_checksum(struct e1000_adapter *adapter,
                                      struct e1000_rx_desc *rx_desc,
                                      struct sk_buff *skb);
+static void e1000_Poll(struct net_device *dev);
 static void e1000_tx_timeout(struct net_device *dev);
 static void e1000_tx_timeout_task(struct net_device *dev);
 static void e1000_smartspeed(struct e1000_adapter *adapter);
@@ -440,6 +441,9 @@
 	adapter->bd_number = cards_found;
 	adapter->id_string = e1000_strings[ent->driver_data];
 
+#ifdef HAVE_POLL_CONTROLLER
+	netdev->poll_controller = &e1000_Poll;
+#endif
 	/* setup the private structure */
 
 	if(e1000_sw_init(adapter))
@@ -2009,6 +2013,15 @@
 		mod_timer(&adapter->watchdog_timer, jiffies);
 	}
 
+#ifdef HAVE_POLL_CONTROLLER
+static void e1000_Poll(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	e1000_intr(dev->irq, dev, NULL);
+	enable_irq(dev->irq);
+}
+#endif
+
 #ifdef CONFIG_E1000_NAPI
 	if(netif_rx_schedule_prep(netdev)) {
 
diff -ruN -X /home/bharata/dontdiff 2569/drivers/net/eepro100.c 2569+lkcd/drivers/net/eepro100.c
--- 2569/drivers/net/eepro100.c	Mon May  5 05:23:33 2003
+++ 2569+lkcd/drivers/net/eepro100.c	Mon Jun 16 10:24:02 2003
@@ -542,6 +542,7 @@
 static int speedo_rx(struct net_device *dev);
 static void speedo_tx_buffer_gc(struct net_device *dev);
 static irqreturn_t speedo_interrupt(int irq, void *dev_instance, struct pt_regs *regs);
+static void poll_speedo (struct net_device *dev);
 static int speedo_close(struct net_device *dev);
 static struct net_device_stats *speedo_get_stats(struct net_device *dev);
 static int speedo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
@@ -878,6 +879,9 @@
 	dev->get_stats = &speedo_get_stats;
 	dev->set_multicast_list = &set_rx_mode;
 	dev->do_ioctl = &speedo_ioctl;
+#ifdef HAVE_POLL_CONTROLLER
+	dev->poll_controller = &poll_speedo;
+#endif
 
 	return 0;
 }
@@ -1659,6 +1663,23 @@
 	return IRQ_RETVAL(handled);
 }
 
+#ifdef HAVE_POLL_CONTROLLER
+
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+
+static void poll_speedo (struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	speedo_interrupt (dev->irq, dev, NULL);
+	enable_irq(dev->irq);
+}
+
+#endif
+
 static inline struct RxFD *speedo_rx_alloc(struct net_device *dev, int entry)
 {
 	struct speedo_private *sp = (struct speedo_private *)dev->priv;
diff -ruN -X /home/bharata/dontdiff 2569/drivers/net/smc-ultra.c 2569+lkcd/drivers/net/smc-ultra.c
--- 2569/drivers/net/smc-ultra.c	Mon May  5 05:23:02 2003
+++ 2569+lkcd/drivers/net/smc-ultra.c	Mon Jun 16 10:22:57 2003
@@ -122,6 +122,14 @@
 #define ULTRA_IO_EXTENT 32
 #define EN0_ERWCNT		0x08	/* Early receive warning count. */
 
+
+static void ultra_poll(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	ei_interrupt(dev->irq, dev, NULL);
+	enable_irq(dev->irq);
+}
+
 /*	Probe for the Ultra.  This looks like a 8013 with the station
 	address PROM at I/O ports <base>+8 to <base>+13, with a checksum
 	following.
@@ -134,6 +142,9 @@
 
 	SET_MODULE_OWNER(dev);
 
+#ifdef HAVE_POLL_CONTROLLER
+	dev->poll_controller = &ultra_poll;
+#endif
 	if (base_addr > 0x1ff)		/* Check a single specified location. */
 		return ultra_probe1(dev, base_addr);
 	else if (base_addr != 0)	/* Don't probe at all. */
diff -ruN -X /home/bharata/dontdiff 2569/drivers/net/tlan.c 2569+lkcd/drivers/net/tlan.c
--- 2569/drivers/net/tlan.c	Mon May  5 05:23:02 2003
+++ 2569+lkcd/drivers/net/tlan.c	Mon Jun 16 10:22:57 2003
@@ -345,6 +345,8 @@
 static void	TLan_EeReceiveByte( u16, u8 *, int );
 static int	TLan_EeReadByte( struct net_device *, u8, u8 * );
 
+static void	TLan_Poll(struct net_device *);
+
 
 static TLanIntVectorFunc *TLanIntVector[TLAN_INT_NUMBER_OF_INTS] = {
 	TLan_HandleInvalid,
@@ -854,6 +856,9 @@
 	dev->get_stats = &TLan_GetStats;
 	dev->set_multicast_list = &TLan_SetMulticastList;
 	dev->do_ioctl = &TLan_ioctl;
+#ifdef HAVE_POLL_CONTROLLER
+	dev->poll_controller = &TLan_Poll;
+#endif
 	dev->tx_timeout = &TLan_tx_timeout;
 	dev->watchdog_timeo = TX_TIMEOUT;
 
@@ -1137,7 +1142,14 @@
 	return IRQ_HANDLED;
 } /* TLan_HandleInterrupts */
 
-
+#ifdef HAVE_POLL_CONTROLLER
+static void TLan_Poll(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	TLan_HandleInterrupt(dev->irq, dev, NULL);
+	enable_irq(dev->irq);
+}
+#endif
 
 
 	/***************************************************************
diff -ruN -X /home/bharata/dontdiff 2569/drivers/net/tulip/tulip_core.c 2569+lkcd/drivers/net/tulip/tulip_core.c
--- 2569/drivers/net/tulip/tulip_core.c	Mon May  5 05:23:32 2003
+++ 2569+lkcd/drivers/net/tulip/tulip_core.c	Mon Jun 16 10:22:57 2003
@@ -242,6 +242,7 @@
 static struct net_device_stats *tulip_get_stats(struct net_device *dev);
 static int private_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static void set_rx_mode(struct net_device *dev);
+static void poll_tulip(struct net_device *dev);
 
 
 
@@ -1614,6 +1615,9 @@
 	dev->get_stats = tulip_get_stats;
 	dev->do_ioctl = private_ioctl;
 	dev->set_multicast_list = set_rx_mode;
+#ifdef HAVE_POLL_CONTROLLER
+	dev->poll_controller = &poll_tulip;
+#endif
 
 	if (register_netdev(dev))
 		goto err_out_free_ring;
@@ -1771,6 +1775,24 @@
 }
 
 
+#ifdef HAVE_POLL_CONTROLLER
+
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+
+static void poll_tulip (struct net_device *dev)
+{
+       disable_irq(dev->irq);
+       tulip_interrupt (dev->irq, dev, NULL);
+       enable_irq(dev->irq);
+}
+
+#endif
+
+
 static struct pci_driver tulip_driver = {
 	.name		= DRV_NAME,
 	.id_table	= tulip_pci_tbl,
diff -ruN -X /home/bharata/dontdiff 2569/include/linux/netdevice.h 2569+lkcd/include/linux/netdevice.h
--- 2569/include/linux/netdevice.h	Mon May  5 05:23:41 2003
+++ 2569+lkcd/include/linux/netdevice.h	Mon Jun 16 10:22:57 2003
@@ -426,6 +426,9 @@
 						     unsigned char *haddr);
 	int			(*neigh_setup)(struct net_device *dev, struct neigh_parms *);
 	int			(*accept_fastpath)(struct net_device *, struct dst_entry*);
+#define HAVE_POLL_CONTROLLER
+ 	void			(*poll_controller)(struct net_device *dev);
+	int			(*rx_hook)(struct sk_buff *skb);
 
 	/* open/release and usage marking */
 	struct module *owner;
diff -ruN -X /home/bharata/dontdiff 2569/net/core/dev.c 2569+lkcd/net/core/dev.c
--- 2569/net/core/dev.c	Mon May  5 05:23:29 2003
+++ 2569+lkcd/net/core/dev.c	Mon Jun 16 10:22:57 2003
@@ -1294,8 +1294,6 @@
 	struct softnet_data *queue;
 	unsigned long flags;
 
-	if (!skb->stamp.tv_sec)
-		do_gettimeofday(&skb->stamp);
 
 	/*
 	 * The code is rearranged so that the path is the most
@@ -1305,6 +1303,13 @@
 	this_cpu = smp_processor_id();
 	queue = &softnet_data[this_cpu];
 
+	if (skb->dev->rx_hook)
+		goto rx_hook;
+rx_hook_continue:
+
+	if (!skb->stamp.tv_sec )
+		do_gettimeofday(&skb->stamp);
+
 	netdev_rx_stat[this_cpu].total++;
 	if (queue->input_pkt_queue.qlen <= netdev_max_backlog) {
 		if (queue->input_pkt_queue.qlen) {
@@ -1347,6 +1352,15 @@
 
 	kfree_skb(skb);
 	return NET_RX_DROP;
+rx_hook:
+	{
+		int ret;
+
+		ret = skb->dev->rx_hook(skb);
+		if (ret == NET_RX_DROP)
+			goto drop;
+		goto rx_hook_continue;
+	}
 }
 
 /* Deliver skb to an old protocol, which is not threaded well
