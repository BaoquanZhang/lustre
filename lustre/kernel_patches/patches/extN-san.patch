 fs/ext3/inode.c |   82 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 82 insertions(+)

--- linux-2.4.20/fs/ext3/inode.c~extN-san	2003-04-08 23:35:59.000000000 -0600
+++ linux-2.4.20-braam/fs/ext3/inode.c	2003-04-08 23:35:59.000000000 -0600
@@ -2734,3 +2734,85 @@ int ext3_change_inode_journal_flag(struc
  * here, in ext3_aops_journal_start() to ensure that the forthcoming "see if we
  * need to extend" test in ext3_prepare_write() succeeds.  
  */
+
+/* for each block: 1 ind + 1 dind + 1 tind
+ * for each block: 3 bitmap blocks
+ * for each block: 3 group descriptor blocks
+ * i inode block
+ * 1 superblock
+ * 2 * EXT3_SINGLEDATA_TRANS_BLOCKS for the quote files
+ * ((1+1+1) * 3 * nblocks) + 1 + 1 + 2 * EXT3_SINGLEDATA_TRANS_BLOCKS
+ *
+ * XXX assuming:
+ * (1) fs logic block size == page size
+ * (2) ext3 in writeback mode
+ */
+static inline int ext3_san_write_trans_blocks(int nblocks)
+{
+	int ret;
+	
+	ret = (1 + 1 + 1) * 3 * nblocks + 1 + 1;
+
+#ifdef CONFIG_QUOTA
+	ret += 2 * EXT3_SINGLEDATA_TRANS_BLOCKS;
+#endif
+
+	return ret;
+}
+
+/* Alloc blocks for an inode, while don't create any buffer/page
+ * for data I/O; set the inode size if file is extended.
+ *
+ * @inode:    target inode
+ * @blocks:   array of logic block number
+ * @nblocks:  how many blocks need be alloced
+ * @newsize:  new filesize we should set
+ *
+ * return:    0 success, otherwise failed
+ *            (*blocks) contains physical block number alloced
+ *
+ * XXX this assume the fs block size == page size
+ */
+int ext3_prep_san_write(struct inode *inode, long *blocks,
+			int nblocks, loff_t newsize)
+{
+	handle_t *handle;
+	struct buffer_head bh_tmp;
+	int needed_blocks;
+	int i, ret = 0, ret2;
+
+	needed_blocks = ext3_san_write_trans_blocks(nblocks);
+
+	lock_kernel();
+	handle = ext3_journal_start(inode, needed_blocks);
+	if (IS_ERR(handle)) {
+		unlock_kernel();
+		return PTR_ERR(handle);
+	}
+	unlock_kernel();
+
+	/* alloc blocks one by one */
+	for (i = 0; i < nblocks; i++) {
+		ret = ext3_get_block_handle(handle, inode, blocks[i],
+						&bh_tmp, 1);
+		if (ret)
+			break;
+
+		blocks[i] = bh_tmp.b_blocknr;
+	}
+
+	/* set inode size if needed */
+	if (!ret && (newsize > inode->i_size)) {
+		inode->i_size = newsize;
+		ext3_mark_inode_dirty(handle, inode);
+	}
+
+	lock_kernel();
+	ret2 = ext3_journal_stop(handle, inode);
+	unlock_kernel();
+
+	if (!ret)
+		ret = ret2;
+	return ret;
+}
+EXPORT_SYMBOL(ext3_prep_san_write);

_
