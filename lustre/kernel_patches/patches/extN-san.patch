 fs/ext3/inode.c |   81 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 fs/ext3/super.c |    4 ++
 2 files changed, 85 insertions(+)

--- linux-2.4.18-18.8.0-l18/fs/ext3/inode.c~extN-san	Sun May 18 12:58:13 2003
+++ linux-2.4.18-18.8.0-l18-phil/fs/ext3/inode.c	Sun May 18 13:24:49 2003
@@ -2781,3 +2781,84 @@ int ext3_change_inode_journal_flag(struc
  * here, in ext3_aops_journal_start() to ensure that the forthcoming "see if we
  * need to extend" test in ext3_prepare_write() succeeds.  
  */
+
+/* for each block: 1 ind + 1 dind + 1 tind
+ * for each block: 3 bitmap blocks
+ * for each block: 3 group descriptor blocks
+ * i inode block
+ * 1 superblock
+ * 2 * EXT3_SINGLEDATA_TRANS_BLOCKS for the quote files
+ * ((1+1+1) * 3 * nblocks) + 1 + 1 + 2 * EXT3_SINGLEDATA_TRANS_BLOCKS
+ *
+ * XXX assuming:
+ * (1) fs logic block size == page size
+ * (2) ext3 in writeback mode
+ */
+static inline int ext3_san_write_trans_blocks(int nblocks)
+{
+	int ret;
+	
+	ret = (1 + 1 + 1) * 3 * nblocks + 1 + 1;
+
+#ifdef CONFIG_QUOTA
+	ret += 2 * EXT3_SINGLEDATA_TRANS_BLOCKS;
+#endif
+
+	return ret;
+}
+
+/* Alloc blocks for an inode, while don't create any buffer/page
+ * for data I/O; set the inode size if file is extended.
+ *
+ * @inode:    target inode
+ * @blocks:   array of logic block number
+ * @nblocks:  how many blocks need be alloced
+ * @newsize:  new filesize we should set
+ *
+ * return:    0 success, otherwise failed
+ *            (*blocks) contains physical block number alloced
+ *
+ * XXX this assume the fs block size == page size
+ */
+int ext3_prep_san_write(struct inode *inode, long *blocks,
+			int nblocks, loff_t newsize)
+{
+	handle_t *handle;
+	struct buffer_head bh_tmp;
+	int needed_blocks;
+	int i, ret = 0, ret2;
+
+	needed_blocks = ext3_san_write_trans_blocks(nblocks);
+
+	lock_kernel();
+	handle = ext3_journal_start(inode, needed_blocks);
+	if (IS_ERR(handle)) {
+		unlock_kernel();
+		return PTR_ERR(handle);
+	}
+	unlock_kernel();
+
+	/* alloc blocks one by one */
+	for (i = 0; i < nblocks; i++) {
+		ret = ext3_get_block_handle(handle, inode, blocks[i],
+						&bh_tmp, 1);
+		if (ret)
+			break;
+
+		blocks[i] = bh_tmp.b_blocknr;
+	}
+
+	/* set inode size if needed */
+	if (!ret && (newsize > inode->i_size)) {
+		inode->i_size = newsize;
+		ext3_mark_inode_dirty(handle, inode);
+	}
+
+	lock_kernel();
+	ret2 = ext3_journal_stop(handle, inode);
+	unlock_kernel();
+
+	if (!ret)
+		ret = ret2;
+	return ret;
+}
--- linux-2.4.18-18.8.0-l18/fs/ext3/super.c~extN-san	Sun May 18 13:24:35 2003
+++ linux-2.4.18-18.8.0-l18-phil/fs/ext3/super.c	Sun May 18 13:24:55 2003
@@ -1774,6 +1774,10 @@ static int __init init_ext3_fs(void)
 
 EXPORT_SYMBOL(ext3_bread);
 
+int ext3_prep_san_write(struct inode *inode, long *blocks,
+                        int nblocks, loff_t newsize);
+EXPORT_SYMBOL(ext3_prep_san_write);
+
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");
 MODULE_DESCRIPTION("Second Extended Filesystem with journaling extensions");
 MODULE_LICENSE("GPL");

_
