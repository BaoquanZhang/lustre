# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
# This patch format is intended for GNU patch command version 2.5 or higher.
# This patch includes the following deltas:
#	           ChangeSet	1.810   -> 1.811  
#	      kernel/ksyms.c	1.149   -> 1.150  
#	 fs/driverfs/inode.c	1.52    -> 1.53   
#	  include/linux/fs.h	1.175   -> 1.176  
#	include/linux/namei.h	1.3     -> 1.4    
#	          fs/namei.c	1.56    -> 1.57   
#	       fs/nfsd/vfs.c	1.44    -> 1.45   
#	arch/um/kernel/mem.c	1.5     -> 1.6    
#	  net/unix/af_unix.c	1.29    -> 1.30   
#	           mm/slab.c	1.33    -> 1.34   
#	    fs/sysfs/inode.c	1.55    -> 1.56   
#	include/linux/slab.h	1.13    -> 1.14   
#	include/linux/dcache.h	1.19    -> 1.20   
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 02/10/20	braam@clusterfs.com	1.811
# Changes for Lustre
# --------------------------------------------
#
diff -Nru a/arch/um/kernel/mem.c b/arch/um/kernel/mem.c
--- a/arch/um/kernel/mem.c	Sun Dec  8 02:49:38 2002
+++ b/arch/um/kernel/mem.c	Sun Dec  8 02:49:38 2002
@@ -656,6 +656,22 @@
 	return(phys_mem_map(pte_val(pte)));
 }
 
+struct page *check_get_page(unsigned long kaddr)
+{
+        struct page *page;
+        struct mem_region *mr;
+        unsigned long phys = __pa(kaddr);
+	unsigned int n = phys_region_index(phys);
+
+	if(regions[n] == NULL) 
+                return NULL; 
+
+        mr = regions[n];
+        page = (struct page *) mr->mem_map;
+	return page + ((phys_addr(phys)) >> PAGE_SHIFT);
+}
+
+
 struct mem_region *page_region(struct page *page, int *index_out)
 {
 	int i;
@@ -743,7 +759,7 @@
 		   (addr <= region->start + region->len))
 			return(mk_phys(addr - region->start, i));
 	}
-	panic("region_pa : no region for virtual address");
+	//panic("region_pa : no region for virtual address");
 	return(0);
 }
 
diff -Nru a/fs/driverfs/inode.c b/fs/driverfs/inode.c
--- a/fs/driverfs/inode.c	Sun Dec  8 02:49:38 2002
+++ b/fs/driverfs/inode.c	Sun Dec  8 02:49:38 2002
@@ -523,7 +523,7 @@
 	qstr.name = name;
 	qstr.len = strlen(name);
 	qstr.hash = full_name_hash(name,qstr.len);
-	return lookup_hash(&qstr,parent);
+	return lookup_hash(&qstr,parent, NULL);
 }
 
 /**
diff -Nru a/fs/namei.c b/fs/namei.c
--- a/fs/namei.c	Sun Dec  8 02:49:38 2002
+++ b/fs/namei.c	Sun Dec  8 02:49:38 2002
@@ -265,6 +265,9 @@
 
 void path_release(struct nameidata *nd)
 {
+        if (nd->dentry && nd->dentry->d_op && 
+            nd->dentry->d_op->d_intent_release)
+                nd->dentry->d_op->d_intent_release(nd->dentry, &nd->it);
 	dput(nd->dentry);
 	mntput(nd->mnt);
 }
@@ -273,10 +276,18 @@
  * Internal lookup() using the new generic dcache.
  * SMP-safe
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags, struct lookup_intent *it)
 {
 	struct dentry * dentry = d_lookup(parent, name);
 	
+	if (dentry && dentry->d_op && dentry->d_op->d_revalidate2) {
+		if (!dentry->d_op->d_revalidate2(dentry, flags, it) &&
+		    !d_invalidate(dentry)) {
+			dput(dentry);
+			dentry = NULL;
+		}
+		return dentry;
+	} else
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
@@ -351,7 +362,7 @@
  * make sure that nobody added the entry to the dcache in the meantime..
  * SMP-safe
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags, struct lookup_intent *it)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
@@ -369,7 +380,10 @@
 		struct dentry * dentry = d_alloc(parent, name);
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
-			result = dir->i_op->lookup(dir, dentry);
+			if (dir->i_op->lookup2)
+				result = dir->i_op->lookup2(dir, dentry, it);
+			else
+                                result = dir->i_op->lookup(dir, dentry);
 			if (result)
 				dput(dentry);
 			else {
@@ -391,6 +405,12 @@
 			dput(result);
 			result = ERR_PTR(-ENOENT);
 		}
+	} else if (result->d_op && result->d_op->d_revalidate2) {
+		if (!result->d_op->d_revalidate2(result, flags, it) &&
+		    !d_invalidate(result)) {
+			dput(result);
+			result = ERR_PTR(-ENOENT);
+		}
 	}
 	return result;
 }
@@ -534,7 +554,7 @@
 	unlock_nd(nd);
 
 need_lookup:
-	dentry = real_lookup(nd->dentry, name, LOOKUP_CONTINUE);
+	dentry = real_lookup(nd->dentry, name, LOOKUP_CONTINUE, &nd->it);
 	if (IS_ERR(dentry))
 		goto fail;
 	mntget(mnt);
@@ -684,7 +704,7 @@
 			nd->dentry = next.dentry;
 		}
 		err = -ENOTDIR; 
-		if (!inode->i_op->lookup)
+		if (!inode->i_op->lookup && !inode->i_op->lookup2)
 			break;
 		continue;
 		/* here ends the main loop */
@@ -737,7 +757,8 @@
 			break;
 		if (lookup_flags & LOOKUP_DIRECTORY) {
 			err = -ENOTDIR; 
-			if (!inode->i_op || !inode->i_op->lookup)
+			if (!inode->i_op || 
+                            (!inode->i_op->lookup && !inode->i_op->lookup2))
 				break;
 		}
 		goto return_base;
@@ -886,7 +907,8 @@
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+struct dentry * lookup_hash(struct qstr *name, struct dentry * base, 
+                            struct lookup_intent *it)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -909,13 +931,16 @@
 			goto out;
 	}
 
-	dentry = cached_lookup(base, name, 0);
+	dentry = cached_lookup(base, name, 0, it);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
-		dentry = inode->i_op->lookup(inode, new);
+                if (inode->i_op->lookup2) 
+                        dentry = inode->i_op->lookup2(inode, new, it);
+                else 
+                        dentry = inode->i_op->lookup(inode, new);
 		if (!dentry) {
 			dentry = new;
 			security_ops->inode_post_lookup(inode, dentry);
@@ -927,7 +952,7 @@
 }
 
 /* SMP-safe */
-struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+struct dentry * lookup_one_len_it(const char * name, struct dentry * base, int len, struct lookup_intent *it)
 {
 	unsigned long hash;
 	struct qstr this;
@@ -947,11 +972,16 @@
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return lookup_hash(&this, base, it);
 access:
 	return ERR_PTR(-EACCES);
 }
 
+struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+{
+        return lookup_one_len_it(name, base, len, NULL);
+}
+
 /*
  *	namei()
  *
@@ -1268,7 +1298,7 @@
 
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash(&nd->last, nd->dentry, &nd->it);
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1370,7 +1400,7 @@
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash(&nd->last, nd->dentry, &nd->it);
 	putname(nd->last.name);
 	goto do_last;
 }
@@ -1384,7 +1414,7 @@
 	dentry = ERR_PTR(-EEXIST);
 	if (nd->last_type != LAST_NORM)
 		goto fail;
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash(&nd->last, nd->dentry, &nd->it);
 	if (IS_ERR(dentry))
 		goto fail;
 	if (!is_dir && nd->last.name[nd->last.len] && !dentry->d_inode)
@@ -1614,7 +1644,7 @@
 			goto exit1;
 	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, &nd.it);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1675,7 +1705,7 @@
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, &nd.it);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -1949,7 +1979,8 @@
 }
 
 int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry, 
+               struct lookup_intent *it)
 {
 	int error;
 	int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
@@ -2020,7 +2051,7 @@
 
 	trap = lock_rename(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = lookup_hash(&oldnd.last, old_dir, &oldnd.it);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -2040,7 +2071,7 @@
 	error = -EINVAL;
 	if (old_dentry == trap)
 		goto exit4;
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = lookup_hash(&newnd.last, new_dir, &newnd.it);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
@@ -2050,7 +2081,7 @@
 		goto exit5;
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+				   new_dir->d_inode, new_dentry, NULL);
 exit5:
 	dput(new_dentry);
 exit4:
diff -Nru a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
--- a/fs/nfsd/vfs.c	Sun Dec  8 02:49:38 2002
+++ b/fs/nfsd/vfs.c	Sun Dec  8 02:49:38 2002
@@ -1292,7 +1292,7 @@
 			err = nfserr_perm;
 	} else
 #endif
-	err = vfs_rename(fdir, odentry, tdir, ndentry);
+	err = vfs_rename(fdir, odentry, tdir, ndentry, NULL);
 	if (!err && EX_ISSYNC(tfhp->fh_export)) {
 		nfsd_sync_dir(tdentry);
 		nfsd_sync_dir(fdentry);
diff -Nru a/fs/sysfs/inode.c b/fs/sysfs/inode.c
--- a/fs/sysfs/inode.c	Sun Dec  8 02:49:39 2002
+++ b/fs/sysfs/inode.c	Sun Dec  8 02:49:39 2002
@@ -471,7 +471,7 @@
 	qstr.name = name;
 	qstr.len = strlen(name);
 	qstr.hash = full_name_hash(name,qstr.len);
-	return lookup_hash(&qstr,parent);
+	return lookup_hash(&qstr,parent,NULL);
 }
 
 /**
diff -Nru a/include/linux/dcache.h b/include/linux/dcache.h
--- a/include/linux/dcache.h	Sun Dec  8 02:49:39 2002
+++ b/include/linux/dcache.h	Sun Dec  8 02:49:39 2002
@@ -9,6 +9,24 @@
 #include <linux/spinlock.h>
 #include <asm/page.h>			/* for BUG() */
 
+#define IT_OPEN  (1)
+#define IT_CREAT  (1<<1)
+#define IT_MKDIR  (1<<2)
+#define IT_LINK  (1<<3)
+#define IT_LINK2  (1<<4)
+#define IT_SYMLINK  (1<<5)
+#define IT_UNLINK  (1<<6)
+#define IT_RMDIR  (1<<7)
+#define IT_RENAME  (1<<8)
+#define IT_RENAME2  (1<<9)
+#define IT_READDIR  (1<<10)
+#define IT_GETATTR  (1<<11)
+#define IT_SETATTR  (1<<12)
+#define IT_READLINK  (1<<13)
+#define IT_MKNOD  (1<<14)
+#define IT_LOOKUP  (1<<15)
+
+
 /*
  * linux/include/linux/dcache.h
  *
@@ -30,6 +48,8 @@
 	unsigned int hash;
 };
 
+#include <linux/namei.h>
+
 struct dentry_stat_t {
 	int nr_dentry;
 	int nr_unused;
@@ -79,6 +99,7 @@
 	struct list_head d_subdirs;	/* our children */
 	struct list_head d_alias;	/* inode alias list */
 	int d_mounted;
+        struct lookup_intent *d_it;
 	struct qstr d_name;
 	unsigned long d_time;		/* used by d_revalidate */
 	struct dentry_operations  *d_op;
@@ -96,6 +117,8 @@
 	int (*d_delete)(struct dentry *);
 	void (*d_release)(struct dentry *);
 	void (*d_iput)(struct dentry *, struct inode *);
+	int (*d_revalidate2)(struct dentry *, int, struct lookup_intent *);
+	void (*d_intent_release)(struct  dentry *, struct lookup_intent *);
 };
 
 /* the dentry parameter passed to d_hash and d_compare is the parent
diff -Nru a/include/linux/fs.h b/include/linux/fs.h
--- a/include/linux/fs.h	Sun Dec  8 02:49:38 2002
+++ b/include/linux/fs.h	Sun Dec  8 02:49:38 2002
@@ -700,7 +700,7 @@
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct lookup_intent *it);
 
 /*
  * File types
@@ -769,6 +769,8 @@
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
+	struct dentry * (*lookup2) (struct inode *,struct dentry *, 
+                                    struct lookup_intent *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
@@ -995,6 +997,7 @@
 extern int unregister_filesystem(struct file_system_type *);
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount(struct vfsmount *);
+struct vfsmount *do_kern_mount(const char *type, int flags, char *name, void *data);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 
 #define kern_umount mntput
diff -Nru a/include/linux/namei.h b/include/linux/namei.h
--- a/include/linux/namei.h	Sun Dec  8 02:49:38 2002
+++ b/include/linux/namei.h	Sun Dec  8 02:49:38 2002
@@ -5,6 +5,17 @@
 
 struct vfsmount;
 
+struct lookup_intent {
+	int it_op;
+	int it_mode;
+	int it_disposition;
+	int it_status;
+	struct iattr *it_iattr;
+	__u64 it_lock_handle[2];
+	int it_lock_mode;
+	void *it_data;
+};
+
 struct nameidata {
 	struct dentry	*dentry;
 	struct vfsmount *mnt;
@@ -13,6 +24,7 @@
 	int		last_type;
 	struct dentry	*old_dentry;
 	struct vfsmount	*old_mnt;
+        struct lookup_intent it;
 };
 
 /*
@@ -46,7 +58,7 @@
 extern void path_release(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
+extern struct dentry * lookup_hash(struct qstr *, struct dentry *, struct lookup_intent *);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);
diff -Nru a/include/linux/slab.h b/include/linux/slab.h
--- a/include/linux/slab.h	Sun Dec  8 02:49:39 2002
+++ b/include/linux/slab.h	Sun Dec  8 02:49:39 2002
@@ -56,6 +56,7 @@
 extern int kmem_cache_shrink(kmem_cache_t *);
 extern void *kmem_cache_alloc(kmem_cache_t *, int);
 extern void kmem_cache_free(kmem_cache_t *, void *);
+extern int kmem_cache_validate(kmem_cache_t *cachep, void *objp);
 extern unsigned int kmem_cache_size(kmem_cache_t *);
 
 extern void *kmalloc(size_t, int);
diff -Nru a/kernel/ksyms.c b/kernel/ksyms.c
--- a/kernel/ksyms.c	Sun Dec  8 02:49:38 2002
+++ b/kernel/ksyms.c	Sun Dec  8 02:49:38 2002
@@ -365,6 +365,13 @@
 EXPORT_SYMBOL(tty_get_baud_rate);
 EXPORT_SYMBOL(do_SAK);
 
+/* lustre */
+EXPORT_SYMBOL(panic_notifier_list);
+//EXPORT_SYMBOL(pagecache_lock_cacheline);
+EXPORT_SYMBOL(do_kern_mount);
+EXPORT_SYMBOL(exit_files);
+EXPORT_SYMBOL(kmem_cache_validate);
+
 /* filesystem registration */
 EXPORT_SYMBOL(register_filesystem);
 EXPORT_SYMBOL(unregister_filesystem);
diff -Nru a/mm/slab.c b/mm/slab.c
--- a/mm/slab.c	Sun Dec  8 02:49:39 2002
+++ b/mm/slab.c	Sun Dec  8 02:49:39 2002
@@ -1236,6 +1236,59 @@
  * Called with the cache-lock held.
  */
 
+extern struct page *check_get_page(unsigned long kaddr);
+struct page *page_mem_map(struct page *page);
+static int kmem_check_cache_obj (kmem_cache_t * cachep,
+				 slab_t *slabp, void * objp)
+{
+	int i;
+	unsigned int objnr;
+
+#if DEBUG
+	if (cachep->flags & SLAB_RED_ZONE) {
+		objp -= BYTES_PER_WORD;
+		if ( *(unsigned long *)objp != RED_MAGIC2)
+			/* Either write before start, or a double free. */
+			return 0;
+		if (*(unsigned long *)(objp+cachep->objsize -
+				BYTES_PER_WORD) != RED_MAGIC2)
+			/* Either write past end, or a double free. */
+			return 0;
+	}
+#endif
+
+	objnr = (objp-slabp->s_mem)/cachep->objsize;
+	if (objnr >= cachep->num)
+		return 0;
+	if (objp != slabp->s_mem + objnr*cachep->objsize)
+		return 0;
+
+	/* Check slab's freelist to see if this obj is there. */
+	for (i = slabp->free; i != BUFCTL_END; i = slab_bufctl(slabp)[i]) {
+		if (i == objnr)
+			return 0;
+	}
+	return 1;
+}
+
+
+int kmem_cache_validate(kmem_cache_t *cachep, void *objp)
+{
+	struct page *page = check_get_page((unsigned long)objp);
+
+	if (!page_mem_map(page))
+		return 0;
+
+	if (!PageSlab(page))
+		return 0;
+
+	/* XXX check for freed slab objects ? */
+	if (!kmem_check_cache_obj(cachep, GET_PAGE_SLAB(page), objp))
+		return 0;
+
+	return (cachep == GET_PAGE_CACHE(page));
+}
+
 #if DEBUG
 static int kmem_extra_free_checks (kmem_cache_t * cachep,
 			slab_t *slabp, void * objp)
diff -Nru a/net/unix/af_unix.c b/net/unix/af_unix.c
--- a/net/unix/af_unix.c	Sun Dec  8 02:49:38 2002
+++ b/net/unix/af_unix.c	Sun Dec  8 02:49:38 2002
@@ -715,7 +715,7 @@
 		/*
 		 * Do the final lookup.
 		 */
-		dentry = lookup_hash(&nd.last, nd.dentry);
+		dentry = lookup_hash(&nd.last, nd.dentry, NULL);
 		err = PTR_ERR(dentry);
 		if (IS_ERR(dentry))
 			goto out_mknod_unlock;
