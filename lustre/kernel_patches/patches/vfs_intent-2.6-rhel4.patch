Index: linux-2.6.9-78.0.22/fs/cifs/dir.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/cifs/dir.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/cifs/dir.c	2009-05-11 23:20:11.000000000 -0600
@@ -167,11 +167,7 @@
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
 	if(nd && (nd->flags & LOOKUP_OPEN)) {
-#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,5) /* SUSE included Lustre patch */
 		int oflags = nd->intent.it_flags;
-#else
-		int oflags = nd->intent.open.flags;
-#endif
 
 		desiredAccess = 0;
 		if (oflags & FMODE_READ)
Index: linux-2.6.9-78.0.22/fs/exec.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/exec.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/exec.c	2009-05-11 23:20:11.000000000 -0600
@@ -126,9 +126,10 @@
 	struct file * file;
 	struct nameidata nd;
 	int error;
-
-	nd.intent.open.flags = FMODE_READ|FMODE_EXEC;
-	error = __user_walk(library, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
+	intent_init(&nd.intent, IT_OPEN);
+  
+	nd.intent.it_flags = FMODE_READ|FMODE_EXEC;
+	error = __user_walk_it(library, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
 	if (error)
 		goto out;
 
@@ -140,7 +141,7 @@
 	if (error)
 		goto exit;
 
-	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+	file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &nd.intent);
 	error = PTR_ERR(file);
 	if (IS_ERR(file))
 		goto out;
@@ -484,8 +485,9 @@
 	int err;
 	struct file *file;
 
-	nd.intent.open.flags = FMODE_READ|FMODE_EXEC;
-	err = path_lookup(name, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
+	intent_init(&nd.intent, IT_OPEN);
+	nd.intent.it_flags = FMODE_READ|FMODE_EXEC;
+	err = path_lookup_it(name, LOOKUP_FOLLOW, &nd);
 	file = ERR_PTR(err);
 
 	if (!err) {
@@ -496,9 +498,10 @@
 			int err = permission(inode, MAY_EXEC, &nd);
 			file = ERR_PTR(err);
 			if (!err) {
-				file = dentry_open(nd.dentry, nd.mnt, 
+				file = dentry_open_it(nd.dentry, nd.mnt, 
 					force_o_largefile() ? 
-					O_RDONLY|O_LARGEFILE : O_RDONLY);
+					O_RDONLY|O_LARGEFILE : O_RDONLY,
+                                       &nd.intent);
 				if (!IS_ERR(file)) {
 					err = deny_write_access(file);
 					if (err) {
Index: linux-2.6.9-78.0.22/fs/inode.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/inode.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/inode.c	2009-05-11 23:20:11.000000000 -0600
@@ -235,6 +235,7 @@
 	inodes_stat.nr_unused--;
 }
 
+EXPORT_SYMBOL(__iget);
 /**
  * clear_inode - clear an inode
  * @inode: inode to clear
Index: linux-2.6.9-78.0.22/fs/namei.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/namei.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/namei.c	2009-05-11 23:20:11.000000000 -0600
@@ -282,8 +282,19 @@
 	return 0;
 }
 
+void intent_release(struct lookup_intent *it)
+{
+	if (!it)
+		return;
+	if (it->it_magic != INTENT_MAGIC)
+		return;
+	if (it->it_op_release)
+		it->it_op_release(it);
+}
+
 void path_release(struct nameidata *nd)
 {
+	intent_release(&nd->intent);
 	dput(nd->dentry);
 	mntput(nd->mnt);
 }
@@ -395,8 +406,12 @@
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
-
+	int counter = 0;
+	
+again:
 	down(&dir->i_sem);
+	counter++;
+
 	/*
 	 * First re-do the cached lookup just in case it was created
 	 * while we waited for the directory semaphore..
@@ -441,8 +456,12 @@
 	up(&dir->i_sem);
 	if (result->d_op && result->d_op->d_revalidate) {
 		result = do_revalidate(result, nd);
-		if (!result)
-			result = ERR_PTR(-ENOENT);
+		if (!result) {
+			if (counter > 10)
+				result = ERR_PTR(-ESTALE);
+			if (!IS_ERR(result))
+				goto again;
+		}
 	}
 	return result;
 }
@@ -472,6 +491,7 @@
 {
 	int res = 0;
 	char *name;
+
 	if (IS_ERR(link))
 		goto fail;
 
@@ -481,6 +501,7 @@
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
+	intent_reset_fs_part(&nd->intent);
 	res = link_path_walk(link, nd);
 out:
 	if (nd->depth || res || nd->last_type!=LAST_NORM)
@@ -691,6 +712,33 @@
 	return PTR_ERR(dentry);
 }
 
+static int revalidate_special(struct nameidata *nd)
+{
+	struct dentry *dentry = nd->dentry;
+	int err, counter = 0;
+
+ revalidate_again:
+	if (!dentry->d_op || !dentry->d_op->d_revalidate)
+		return 0;
+	if (!dentry->d_op->d_revalidate(dentry, nd)) {
+		struct dentry *new;
+		if ((err = permission(dentry->d_parent->d_inode, MAY_EXEC, nd)))
+			return err;
+		new = real_lookup(dentry->d_parent, &dentry->d_name, nd);
+		if (IS_ERR(new))
+			return PTR_ERR(new);
+		d_invalidate(dentry);
+		dput(dentry);
+		nd->dentry = dentry = new;
+		counter++;
+		if (counter < 10)
+			goto revalidate_again;
+		//printk("excessive revalidate_it loops\n");
+		return -ESTALE;
+	}
+	return 0;
+}
+
 /*
  * Name resolution.
  * This is the basic name resolution function, turning a pathname into
@@ -792,13 +840,17 @@
 			goto out_dput;
 
 		if (inode->i_op->follow_link) {
+			int save_flags = nd->flags;
 			mntget(next.mnt);
 			if (next.mnt != nd->mnt) {
 				dput(nd->dentry);
 				nd->mnt = next.mnt;
 				nd->dentry = dget(next.dentry);
 			}
+			nd->flags |= LOOKUP_LINK_NOTLAST;
 			err = do_follow_link(next.dentry, nd);
+			if (!(save_flags & LOOKUP_LINK_NOTLAST))
+				nd->flags &= ~LOOKUP_LINK_NOTLAST;
 			dput(next.dentry);
 			mntput(next.mnt);
 			if (err)
@@ -838,14 +890,34 @@
 				inode = nd->dentry->d_inode;
 				/* fallthrough */
 			case 1:
+				nd->flags |= LOOKUP_LAST;
+				err = revalidate_special(nd);
+				nd->flags &= ~LOOKUP_LAST;
+				if (!nd->dentry->d_inode)
+					err = -ENOENT;
+				if (err) {
+					path_release(nd);
+					goto return_err;
+				}
+				if (lookup_flags & LOOKUP_DIRECTORY) {
+					err = -ENOTDIR;
+					if (!nd->dentry->d_inode->i_op ||
+					    !nd->dentry->d_inode->i_op->lookup){
+						path_release(nd);
+						goto return_err;
+					}
+				}
 				goto return_reval;
 		}
+		
 		if (nd->dentry->d_op && nd->dentry->d_op->d_hash) {
 			err = nd->dentry->d_op->d_hash(nd->dentry, &this);
 			if (err < 0)
 				break;
 		}
+		nd->flags |= LOOKUP_LAST;
 		err = do_lookup(nd, &this, &next, atomic);
+		nd->flags &= ~LOOKUP_LAST;
 		if (err)
 			break;
 		follow_mount(&next.mnt, &next.dentry);
@@ -1019,7 +1091,7 @@
 }
 
 /* Returns 0 and nd will be valid on success; Retuns error, otherwise. */
-int fastcall path_lookup(const char *name, unsigned int flags, struct nameidata *nd)
+int fastcall path_lookup_it(const char *name, unsigned int flags, struct nameidata *nd)
 {
 	int retval = 0;
 
@@ -1053,6 +1125,12 @@
 	return retval;
 }
 
+int fastcall path_lookup(const char *name, unsigned int flags, struct nameidata *nd)
+{
+	intent_init(&nd->intent, IT_GETATTR);
+	return path_lookup_it(name, flags, nd);
+}
+
 /*
  * Restricted form of lookup. Doesn't follow links, single-component only,
  * needs parent already locked. Doesn't follow mounts.
@@ -1110,7 +1188,7 @@
 }
 
 /* SMP-safe */
-struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+struct dentry * lookup_one_len_it(const char * name, struct dentry * base, int len, struct nameidata *nd)
 {
 	unsigned long hash;
 	struct qstr this;
@@ -1130,11 +1208,16 @@
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return __lookup_hash(&this, base, nd);
 access:
 	return ERR_PTR(-EACCES);
 }
 
+struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+{
+	return lookup_one_len_it(name, base, len, NULL);
+}
+
 /*
  *	namei()
  *
@@ -1146,18 +1229,24 @@
  * that namei follows links, while lnamei does not.
  * SMP-safe
  */
-int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd)
+int fastcall __user_walk_it(const char __user *name, unsigned flags, struct nameidata *nd)
 {
 	char *tmp = getname(name);
 	int err = PTR_ERR(tmp);
 
 	if (!IS_ERR(tmp)) {
-		err = path_lookup(tmp, flags, nd);
+		err = path_lookup_it(tmp, flags, nd);
 		putname(tmp);
 	}
 	return err;
 }
 
+int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd)
+{
+	intent_init(&nd->intent, IT_LOOKUP);
+	return __user_walk_it(name, flags, nd);
+}
+
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -1401,7 +1490,7 @@
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0, ATTR_MTIME|ATTR_CTIME);
+			error = do_truncate(dentry, 0, ATTR_MTIME|ATTR_CTIME|ATTR_FROM_OPEN);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1447,14 +1536,14 @@
 		acc_mode |= MAY_APPEND;
 
 	/* Fill in the open() intent data */
-	nd->intent.open.flags = flag;
-	nd->intent.open.create_mode = mode;
+	nd->intent.it_flags = flag;
+	nd->intent.it_create_mode = mode;
 
 	/*
 	 * The simplest case - just a plain lookup.
 	 */
 	if (!(flag & O_CREAT)) {
-		error = path_lookup(pathname, lookup_flags(flag)|LOOKUP_OPEN, nd);
+		error = path_lookup_it(pathname, lookup_flags(flag)|LOOKUP_OPEN, nd);
 		if (error)
 			return error;
 		goto ok;
@@ -1463,7 +1552,8 @@
 	/*
 	 * Create - we need to know the parent.
 	 */
-	error = path_lookup(pathname, LOOKUP_PARENT|LOOKUP_OPEN|LOOKUP_CREATE, nd);
+	nd->intent.it_op |= IT_CREAT;
+	error = path_lookup_it(pathname, LOOKUP_PARENT|LOOKUP_OPEN|LOOKUP_CREATE, nd);
 	if (error)
 		return error;
 
@@ -1479,7 +1569,9 @@
 	dir = nd->dentry;
 	nd->flags &= ~LOOKUP_PARENT;
 	down(&dir->d_inode->i_sem);
+	nd->flags |= LOOKUP_LAST;
 	dentry = __lookup_hash(&nd->last, nd->dentry, nd);
+	nd->flags &= ~LOOKUP_LAST;
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1595,7 +1687,9 @@
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
+	nd->flags |= LOOKUP_LAST;
 	dentry = __lookup_hash(&nd->last, nd->dentry, nd);
+	nd->flags &= ~LOOKUP_LAST;
 	__putname(nd->last.name);
 	goto do_last;
 }
@@ -1669,10 +1763,20 @@
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
-
-	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
+		
+	intent_init(&nd.intent, IT_LOOKUP);
+	error = path_lookup_it(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
+
+	if (nd.dentry->d_inode->i_op->mknod_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->mknod_raw(&nd, mode, dev);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out2;
+	}
+
 	dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(dentry);
 
@@ -1699,6 +1803,7 @@
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
+out2:
 	path_release(&nd);
 out:
 	putname(tmp);
@@ -1741,10 +1846,20 @@
 	if (!IS_ERR(tmp)) {
 		struct dentry *dentry;
 		struct nameidata nd;
+		intent_init(&nd.intent, IT_LOOKUP);
 
-		error = path_lookup(tmp, LOOKUP_PARENT, &nd);
+		error = path_lookup_it(tmp, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
+
+		if (nd.dentry->d_inode->i_op->mkdir_raw) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->mkdir_raw(&nd, mode);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
+
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
@@ -1754,6 +1869,7 @@
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 		putname(tmp);
@@ -1839,7 +1955,8 @@
 	if(IS_ERR(name))
 		return PTR_ERR(name);
 
-	error = path_lookup(name, LOOKUP_PARENT, &nd);
+	intent_init(&nd.intent, IT_LOOKUP);
+	error = path_lookup_it(name, LOOKUP_PARENT, &nd);
 	if (error)
 		goto exit;
 
@@ -1854,6 +1971,16 @@
 			error = -EBUSY;
 			goto exit1;
 	}
+
+	if (nd.dentry->d_inode->i_op->rmdir_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		error = op->rmdir_raw(&nd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
+
 	down(&nd.dentry->d_inode->i_sem);
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
@@ -1917,12 +2044,22 @@
 	if(IS_ERR(name))
 		return PTR_ERR(name);
 
-	error = path_lookup(name, LOOKUP_PARENT, &nd);
+	intent_init(&nd.intent, IT_LOOKUP);
+	error = path_lookup_it(name, LOOKUP_PARENT, &nd);
 	if (error)
 		goto exit;
 	error = -EISDIR;
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
+	
+	if (nd.dentry->d_inode->i_op->unlink_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->unlink_raw(&nd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
+
 	down(&nd.dentry->d_inode->i_sem);
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
@@ -1990,10 +2127,20 @@
 	if (!IS_ERR(to)) {
 		struct dentry *dentry;
 		struct nameidata nd;
+		intent_init(&nd.intent, IT_LOOKUP);
 
-		error = path_lookup(to, LOOKUP_PARENT, &nd);
+		error = path_lookup_it(to, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
+
+		if (nd.dentry->d_inode->i_op->symlink_raw) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->symlink_raw(&nd, from);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
+
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
@@ -2001,6 +2148,7 @@
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 		putname(to);
@@ -2070,15 +2218,26 @@
 	if (IS_ERR(to))
 		return PTR_ERR(to);
 
-	error = __user_walk(oldname, 0, &old_nd);
+	intent_init(&old_nd.intent, IT_LOOKUP);
+	error = __user_walk_it(oldname, 0, &old_nd);
 	if (error)
 		goto exit;
-	error = path_lookup(to, LOOKUP_PARENT, &nd);
+		
+	intent_init(&nd.intent, IT_LOOKUP);		
+	error = path_lookup_it(to, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
 	error = -EXDEV;
 	if (old_nd.mnt != nd.mnt)
 		goto out_release;
+	if (nd.dentry->d_inode->i_op->link_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->link_raw(&old_nd, &nd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out_release;
+	}
+
 	new_dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
@@ -2254,11 +2413,13 @@
 	struct dentry * trap;
 	struct nameidata oldnd, newnd;
 
-	error = path_lookup(oldname, LOOKUP_PARENT, &oldnd);
+	intent_init(&oldnd.intent, IT_LOOKUP);
+	error = path_lookup_it(oldname, LOOKUP_PARENT, &oldnd);
 	if (error)
 		goto exit;
 
-	error = path_lookup(newname, LOOKUP_PARENT, &newnd);
+	intent_init(&newnd.intent, IT_LOOKUP);
+	error = path_lookup_it(newname, LOOKUP_PARENT, &newnd);
 	if (error)
 		goto exit1;
 
@@ -2275,6 +2436,13 @@
 	if (newnd.last_type != LAST_NORM)
 		goto exit2;
 
+	if (old_dir->d_inode->i_op->rename_raw) {
+		error = old_dir->d_inode->i_op->rename_raw(&oldnd, &newnd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit2;
+	}
+
 	trap = lock_rename(new_dir, old_dir);
 
 	old_dentry = lookup_hash(&oldnd.last, old_dir);
@@ -2306,8 +2474,7 @@
 	if (new_dentry == trap)
 		goto exit5;
 
-	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+	error = vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry);
 exit5:
 	dput(new_dentry);
 exit4:
@@ -2507,6 +2674,7 @@
 EXPORT_SYMBOL(page_symlink);
 EXPORT_SYMBOL(page_symlink_inode_operations);
 EXPORT_SYMBOL(path_lookup);
+EXPORT_SYMBOL(path_lookup_it);
 EXPORT_SYMBOL(path_release);
 EXPORT_SYMBOL(path_walk);
 EXPORT_SYMBOL(permission);
Index: linux-2.6.9-78.0.22/fs/namespace.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/namespace.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/namespace.c	2009-05-11 23:20:11.000000000 -0600
@@ -114,6 +114,7 @@
 
 static void detach_mnt(struct vfsmount *mnt, struct nameidata *old_nd)
 {
+	memset(old_nd, 0, sizeof(*old_nd));
 	old_nd->dentry = mnt->mnt_mountpoint;
 	old_nd->mnt = mnt->mnt_parent;
 	mnt->mnt_parent = mnt;
@@ -441,6 +442,8 @@
 	 */
 
 	lock_kernel();
+	if (sb->s_op->umount_lustre)
+		sb->s_op->umount_lustre(sb);
 	if( (flags&MNT_FORCE) && sb->s_op->umount_begin)
 		sb->s_op->umount_begin(sb);
 	unlock_kernel();
@@ -665,7 +668,8 @@
 		return err;
 	if (!old_name || !*old_name)
 		return -EINVAL;
-	err = path_lookup(old_name, LOOKUP_FOLLOW, &old_nd);
+	intent_init(&old_nd.intent, IT_LOOKUP);
+	err = path_lookup_it(old_name, LOOKUP_FOLLOW, &old_nd);
 	if (err)
 		return err;
 
@@ -739,7 +743,8 @@
 		return -EPERM;
 	if (!old_name || !*old_name)
 		return -EINVAL;
-	err = path_lookup(old_name, LOOKUP_FOLLOW, &old_nd);
+	intent_init(&old_nd.intent, IT_LOOKUP);
+	err = path_lookup_it(old_name, LOOKUP_FOLLOW, &old_nd);
 	if (err)
 		return err;
 
@@ -1074,7 +1079,8 @@
 	flags &= ~(MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_ACTIVE);
 
 	/* ... and get the mountpoint */
-	retval = path_lookup(dir_name, LOOKUP_FOLLOW, &nd);
+	intent_init(&nd.intent, IT_LOOKUP);	
+	retval = path_lookup_it(dir_name, LOOKUP_FOLLOW, &nd);
 	if (retval)
 		return retval;
 
Index: linux-2.6.9-78.0.22/fs/nfs/dir.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/nfs/dir.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/nfs/dir.c	2009-05-11 23:20:11.000000000 -0600
@@ -935,7 +935,7 @@
 		return 0;
 	if (!nd || (nd->flags & LOOKUP_CONTINUE) || !(nd->flags & LOOKUP_CREATE))
 		return 0;
-	return (nd->intent.open.flags & O_EXCL) != 0;
+	return (nd->intent.it_flags & O_EXCL) != 0;
 }
 
 static struct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)
@@ -1032,7 +1032,7 @@
 	if (nd->flags & LOOKUP_DIRECTORY)
 		return 0;
 	/* Are we trying to write to a read only partition? */
-	if (IS_RDONLY(dir) && (nd->intent.open.flags & (O_CREAT|O_TRUNC|FMODE_WRITE)))
+	if (IS_RDONLY(dir) && (nd->intent.it_flags & (O_CREAT|O_TRUNC|FMODE_WRITE)))
 		return 0;
 	return 1;
 }
@@ -1053,7 +1053,7 @@
 	dentry->d_op = NFS_PROTO(dir)->dentry_ops;
 
 	/* Let vfs_create() deal with O_EXCL */
-	if (nd->intent.open.flags & O_EXCL)
+	if (nd->intent.it_flags & O_EXCL)
 		goto no_entry;
 
 	/* Open the file on the server */
@@ -1065,7 +1065,7 @@
 		goto out;
 	}
 
-	if (nd->intent.open.flags & O_CREAT) {
+	if (nd->intent.it_flags & O_CREAT) {
 		nfs_begin_data_update(dir);
 		inode = nfs4_atomic_open(dir, dentry, nd);
 		nfs_end_data_update(dir);
@@ -1084,7 +1084,7 @@
 			case -ENOTDIR:
 				goto no_open;
 			case -ELOOP:
-				if (!(nd->intent.open.flags & O_NOFOLLOW))
+				if (!(nd->intent.it_flags & O_NOFOLLOW))
 					goto no_open;
 			/* case -EINVAL: */
 			default:
@@ -1122,7 +1122,7 @@
 	/* NFS only supports OPEN on regular files */
 	if (!S_ISREG(inode->i_mode))
 		goto no_open;
-	openflags = nd->intent.open.flags;
+	openflags = nd->intent.it_flags;
 	/* We cannot do exclusive creation on a positive dentry */
 	if ((openflags & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL))
 		goto no_open;
@@ -1338,7 +1338,7 @@
 	attr.ia_valid = ATTR_MODE;
 
 	if (nd && (nd->flags & LOOKUP_CREATE))
-		open_flags = nd->intent.open.flags;
+		open_flags = nd->intent.it_flags;
 
 	/*
 	 * The 0 argument passed into the create function should one day
Index: linux-2.6.9-78.0.22/fs/nfs/nfs4proc.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/nfs/nfs4proc.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/nfs/nfs4proc.c	2009-05-11 23:20:11.000000000 -0600
@@ -838,27 +838,27 @@
 	struct nfs4_inc_open *inc_open;
 
 	if (nd->flags & LOOKUP_CREATE) {
-		attr.ia_mode = nd->intent.open.create_mode;
+		attr.ia_mode = nd->intent.it_create_mode;
 		attr.ia_valid = ATTR_MODE;
 		if (!IS_POSIXACL(dir))
 			attr.ia_mode &= ~current->fs->umask;
 	} else {
 		attr.ia_valid = 0;
-		BUG_ON(nd->intent.open.flags & O_CREAT);
+		BUG_ON(nd->intent.it_flags & O_CREAT);
 	}
 
 	/* track info in case the open never completes */
 	if (!(inc_open = kmalloc(sizeof(*inc_open), GFP_KERNEL)))
 		return ERR_PTR(-ENOMEM);
 	cred = rpcauth_lookupcred(NFS_SERVER(dir)->client->cl_auth, 0);
-	state = nfs4_do_open(dir, &dentry->d_name, nd->intent.open.flags, &attr, cred);
+	state = nfs4_do_open(dir, &dentry->d_name, nd->intent.it_flags, &attr, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state)) {
 		kfree(inc_open);
 		return (struct inode *)state;
 	}
 	inc_open->task = current;
-	inc_open->flags = nd->intent.open.flags;
+	inc_open->flags = nd->intent.it_flags;
 	INIT_LIST_HEAD(&inc_open->state);
 	spin_lock(&state->inode->i_lock);
 	list_add(&inc_open->state, &state->inc_open);
Index: linux-2.6.9-78.0.22/fs/open.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/open.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/open.c	2009-05-11 23:20:11.000000000 -0600
@@ -195,6 +195,7 @@
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs)
 {
 	int err;
+	struct inode_operations *op = dentry->d_inode->i_op;
 	struct iattr newattrs;
 
 	/* Not pretty: "inode->i_size" shouldn't really be signed. But it is. */
@@ -208,8 +209,16 @@
 	newattrs.ia_valid |= should_remove_suid(dentry);
 
 	down(&dentry->d_inode->i_sem);
-	err = notify_change(dentry, &newattrs);
-	up(&dentry->d_inode->i_sem);
+	if (op->setattr_raw) {
+		newattrs.ia_valid |= ATTR_RAW;
+		newattrs.ia_ctime = CURRENT_TIME;
+		down_write(&dentry->d_inode->i_alloc_sem);
+		err = op->setattr_raw(dentry->d_inode, &newattrs);
+		up_write(&dentry->d_inode->i_alloc_sem);
+	} else
+		err = notify_change(dentry, &newattrs);
+	up(&dentry->d_inode->i_sem);		
+
 	return err;
 }
 
@@ -218,12 +227,13 @@
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
-
+	
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
-
-	error = user_path_walk(path, &nd);
+		
+	intent_init(&nd.intent, IT_GETATTR);
+	error = user_path_walk_it(path, &nd);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
@@ -394,9 +404,19 @@
 		    (error = permission(inode,MAY_WRITE,&nd)) != 0)
 			goto dput_and_out;
 	}
-	down(&inode->i_sem);
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	} else {
+		down(&inode->i_sem);
+		error = notify_change(nd.dentry, &newattrs);
+		up(&inode->i_sem);
+	}
 dput_and_out:
 	path_release(&nd);
 out:
@@ -447,9 +467,19 @@
 		    (error = permission(inode,MAY_WRITE,&nd)) != 0)
 			goto dput_and_out;
 	}
-	down(&inode->i_sem);
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	} else {
+		down(&inode->i_sem);
+		error = notify_change(nd.dentry, &newattrs);
+		up(&inode->i_sem);
+	}
 dput_and_out:
 	path_release(&nd);
 out:
@@ -477,6 +507,7 @@
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -501,13 +532,14 @@
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_ACCESS, &nd);
+	res = __user_walk_it(filename, LOOKUP_FOLLOW|LOOKUP_ACCESS, &nd);
 	if (!res) {
 		res = permission(nd.dentry->d_inode, mode, &nd);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+
 		path_release(&nd);
 	}
 
@@ -522,8 +554,9 @@
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
-	error = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
+	error = __user_walk_it(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
 	if (error)
 		goto out;
 
@@ -575,8 +608,9 @@
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
-	error = __user_walk(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
+	error = __user_walk_it(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
 	if (error)
 		goto out;
 
@@ -599,36 +633,52 @@
 
 EXPORT_SYMBOL_GPL(sys_chroot);
 
-asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
+int chmod_common(struct dentry *dentry, mode_t mode)
 {
-	struct inode * inode;
-	struct dentry * dentry;
-	struct file * file;
-	int err = -EBADF;
+	struct inode * inode = dentry->d_inode;
 	struct iattr newattrs;
+	int error = -EROFS;
 
-	file = fget(fd);
-	if (!file)
+	if (IS_RDONLY(inode))
 		goto out;
+	
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = dentry->d_inode->i_op;
 
-	dentry = file->f_dentry;
-	inode = dentry->d_inode;
+		newattrs.ia_mode = mode;
+		newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use the normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out;
+	}
 
-	err = -EROFS;
-	if (IS_RDONLY(inode))
-		goto out_putf;
-	err = -EPERM;
+	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
-		goto out_putf;
+		goto out;
+
 	down(&inode->i_sem);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
-	err = notify_change(dentry, &newattrs);
+	error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
+out:
+	return error;
+}
 
-out_putf:
+asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
+{
+	struct file * file;
+	int err = -EBADF;
+
+	file = fget(fd);
+	if (!file)
+		goto out;
+
+	err = chmod_common(file->f_dentry, mode);
 	fput(file);
 out:
 	return err;
@@ -637,32 +687,13 @@
 asmlinkage long sys_chmod(const char __user * filename, mode_t mode)
 {
 	struct nameidata nd;
-	struct inode * inode;
 	int error;
-	struct iattr newattrs;
 
 	error = user_path_walk(filename, &nd);
 	if (error)
 		goto out;
-	inode = nd.dentry->d_inode;
 
-	error = -EROFS;
-	if (IS_RDONLY(inode))
-		goto dput_and_out;
-
-	error = -EPERM;
-	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
-		goto dput_and_out;
-
-	down(&inode->i_sem);
-	if (mode == (mode_t) -1)
-		mode = inode->i_mode;
-	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
-	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
-
-dput_and_out:
+	error = chmod_common(nd.dentry, mode);
 	path_release(&nd);
 out:
 	return error;
@@ -683,6 +714,18 @@
 	if (IS_RDONLY(inode))
 		goto out;
 	error = -EPERM;
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = dentry->d_inode->i_op;
+
+		newattrs.ia_uid = user;
+		newattrs.ia_gid = group;
+		newattrs.ia_valid = ATTR_UID | ATTR_GID | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			return error;
+	}
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
 	newattrs.ia_valid =  ATTR_CTIME;
@@ -696,6 +739,7 @@
 	}
 	if (!S_ISDIR(inode->i_mode))
 		newattrs.ia_valid |= ATTR_KILL_SUID|ATTR_KILL_SGID;
+
 	down(&inode->i_sem);
 	error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
@@ -743,8 +787,6 @@
 	return error;
 }
 
-static struct file *__dentry_open(struct dentry *, struct vfsmount *, int, struct file *);
-
 /*
  * Note that while the flag value (low two bits) for sys_open means:
  *	00 - read-only
@@ -762,23 +804,19 @@
 struct file *filp_open(const char * filename, int flags, int mode)
 {
 	int namei_flags, error;
+	struct file * temp_filp;
 	struct nameidata nd;
-	struct file *f;
+	intent_init(&nd.intent, IT_OPEN);
 
 	namei_flags = flags;
 	if ((namei_flags+1) & O_ACCMODE)
 		namei_flags++;
 
-	error = -ENFILE;
-	f = get_empty_filp();
-	if (f == NULL)
-		return ERR_PTR(error);
-
 	error = open_namei(filename, namei_flags, mode, &nd);
-	if (!error)
-		return __dentry_open(nd.dentry, nd.mnt, flags, f);
-
-	put_filp(f);
+	if (!error) {
+		temp_filp = dentry_open_it(nd.dentry, nd.mnt, flags, &nd.intent);
+		return temp_filp;
+	}	
 	return ERR_PTR(error);
 }
 
@@ -786,29 +824,27 @@
 
 struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
 {
-	int error;
-	struct file *f;
+	struct lookup_intent it;
+	intent_init(&it, IT_LOOKUP);
 
-	error = -ENFILE;
-	f = get_empty_filp();
-	if (f == NULL) {
-		dput(dentry);
-		mntput(mnt);
-		return ERR_PTR(error);
-	}
-
-	return __dentry_open(dentry, mnt, flags, f);
+	return dentry_open_it(dentry, mnt, flags, &it);
 }
 
 EXPORT_SYMBOL(dentry_open);
 
-static struct file *__dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags, struct file *f)
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt, int flags, struct lookup_intent *it)
 {
+	struct file *f;
 	struct inode *inode;
 	int error;
 
+	error = -ENFILE;
+	f = get_empty_filp();
+	if (!f)
+		goto cleanup_dentry;
 	f->f_flags = flags;
 	f->f_mode = ((flags+1) & O_ACCMODE) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;
+	f->f_it = it;
 	inode = dentry->d_inode;
 	if (f->f_mode & FMODE_WRITE) {
 		error = get_write_access(inode);
@@ -827,6 +863,7 @@
 		error = f->f_op->open(inode,f);
 		if (error)
 			goto cleanup_all;
+		intent_release(it);
 	}
 	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);
 
@@ -851,6 +888,8 @@
 	f->f_vfsmnt = NULL;
 cleanup_file:
 	put_filp(f);
+cleanup_dentry:
+	intent_release(it);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
Index: linux-2.6.9-78.0.22/fs/stat.c
===================================================================
--- linux-2.6.9-78.0.22.orig/fs/stat.c	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/fs/stat.c	2009-05-11 23:20:11.000000000 -0600
@@ -37,7 +37,7 @@
 
 EXPORT_SYMBOL(generic_fillattr);
 
-int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+int vfs_getattr_it(struct vfsmount *mnt, struct dentry *dentry, struct lookup_intent *it, struct kstat *stat)
 {
 	struct inode *inode = dentry->d_inode;
 	int retval;
@@ -46,6 +46,8 @@
 	if (retval)
 		return retval;
 
+	if (inode->i_op->getattr_it)
+		return inode->i_op->getattr_it(mnt, dentry, it, stat);
 	if (inode->i_op->getattr)
 		return inode->i_op->getattr(mnt, dentry, stat);
 
@@ -62,7 +64,7 @@
 
 EXPORT_SYMBOL(vfs_getattr);
 
-int vfs_getattr64(struct vfsmount *mnt, struct dentry *dentry, struct kstat64 *stat)
+int vfs_getattr64_it(struct vfsmount *mnt, struct dentry *dentry, struct lookup_intent *it, struct kstat64 *stat)
 {
 	struct inode *inode = dentry->d_inode;
 	int retval;
@@ -79,6 +81,13 @@
 		return ixop->getattr64(mnt, dentry, stat);
 	}
 
+	if (inode->i_op->getattr_it) {
+		retval = inode->i_op->getattr_it(mnt, dentry, it, (struct kstat *) stat);
+		if (retval == 0)
+			stat->ino64 = stat->ino;
+		return retval;
+	}
+
 	if (inode->i_op->getattr) {
 		retval = inode->i_op->getattr(mnt, dentry, (struct kstat *) stat);
 		if (retval == 0)
@@ -98,16 +107,28 @@
 	return 0;
 }
 
+
 EXPORT_SYMBOL(vfs_getattr64);
 
+int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+	return vfs_getattr_it(mnt, dentry, NULL, stat);
+}
+
+int vfs_getattr64(struct vfsmount *mnt, struct dentry *dentry, struct kstat64 *stat)
+{
+	return vfs_getattr64_it(mnt, dentry, NULL, stat);
+}
+
 int vfs_stat(char __user *name, struct kstat *stat)
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
-	error = user_path_walk(name, &nd);
+	error = user_path_walk_it(name, &nd);
 	if (!error) {
-		error = vfs_getattr(nd.mnt, nd.dentry, stat);
+		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.intent, stat);
 		path_release(&nd);
 	}
 	return error;
@@ -119,10 +140,11 @@
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
-	error = user_path_walk_link(name, &nd);
+	error = user_path_walk_link_it(name, &nd);
 	if (!error) {
-		error = vfs_getattr(nd.mnt, nd.dentry, stat);
+		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.intent, stat);
 		path_release(&nd);
 	}
 	return error;
@@ -134,9 +156,12 @@
 {
 	struct file *f = fget(fd);
 	int error = -EBADF;
+	struct nameidata nd;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	if (f) {
-		error = vfs_getattr(f->f_vfsmnt, f->f_dentry, stat);
+		error = vfs_getattr_it(f->f_vfsmnt, f->f_dentry, &nd.intent, stat);
+		intent_release(&nd.intent);
 		fput(f);
 	}
 	return error;
@@ -148,10 +173,11 @@
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
-	error = user_path_walk(name, &nd);
+	error = user_path_walk_it(name, &nd);
 	if (!error) {
-		error = vfs_getattr64(nd.mnt, nd.dentry, stat);
+		error = vfs_getattr64_it(nd.mnt, nd.dentry, &nd.intent, stat);
 		path_release(&nd);
 	}
 	return error;
@@ -163,10 +189,11 @@
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
-	error = user_path_walk_link(name, &nd);
+	error = user_path_walk_link_it(name, &nd);
 	if (!error) {
-		error = vfs_getattr64(nd.mnt, nd.dentry, stat);
+		error = vfs_getattr64_it(nd.mnt, nd.dentry, &nd.intent, stat);
 		path_release(&nd);
 	}
 	return error;
@@ -178,9 +205,11 @@
 {
 	struct file *f = fget(fd);
 	int error = -EBADF;
+	struct nameidata nd;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	if (f) {
-		error = vfs_getattr64(f->f_vfsmnt, f->f_dentry, stat);
+		error = vfs_getattr64_it(f->f_vfsmnt, f->f_dentry, &nd.intent, stat);
 		fput(f);
 	}
 	return error;
Index: linux-2.6.9-78.0.22/include/linux/dcache.h
===================================================================
--- linux-2.6.9-78.0.22.orig/include/linux/dcache.h	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/include/linux/dcache.h	2009-05-11 23:20:11.000000000 -0600
@@ -4,6 +4,7 @@
 #ifdef __KERNEL__
 
 #include <asm/atomic.h>
+#include <linux/string.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/cache.h>
@@ -37,6 +38,8 @@
 	const unsigned char *name;
 };
 
+#include <linux/namei.h>
+
 struct dentry_stat_t {
 	int nr_dentry;
 	int nr_unused;
Index: linux-2.6.9-78.0.22/include/linux/fs.h
===================================================================
--- linux-2.6.9-78.0.22.orig/include/linux/fs.h	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/include/linux/fs.h	2009-05-11 23:20:11.000000000 -0600
@@ -271,6 +271,8 @@
 #define ATTR_ATTR_FLAG	1024
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
+#define ATTR_RAW       	8192    /* file system, not vfs will massage attrs */
+#define ATTR_FROM_OPEN 	16384    /* called from open path, ie O_TRUNC */
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -469,6 +471,7 @@
 	struct block_device	*i_bdev;
 	struct cdev		*i_cdev;
 	int			i_cindex;
+	void			*i_filterdata;
 
 	__u32			i_generation;
 
@@ -602,6 +605,7 @@
 	spinlock_t		f_ep_lock;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
+ 	struct lookup_intent    *f_it;
 };
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
@@ -972,20 +976,29 @@
 	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*link_raw) (struct nameidata *,struct nameidata *);
 	int (*unlink) (struct inode *,struct dentry *);
+	int (*unlink_raw) (struct nameidata *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*symlink_raw) (struct nameidata *,const char *);
 	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*mkdir_raw) (struct nameidata *,int);
 	int (*rmdir) (struct inode *,struct dentry *);
+	int (*rmdir_raw) (struct nameidata *);
 	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+	int (*mknod_raw) (struct nameidata *,int,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename_raw) (struct nameidata *, struct nameidata *);
 	int (*readlink) (struct dentry *, char __user *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
 	void (*put_link) (struct dentry *, struct nameidata *);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int, struct nameidata *);
 	int (*setattr) (struct dentry *, struct iattr *);
+	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+	int (*getattr_it) (struct vfsmount *, struct dentry *, struct lookup_intent *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
@@ -1030,6 +1043,7 @@
 	int (*remount_fs) (struct super_block *, int *, char *);
 	void (*clear_inode) (struct inode *);
 	void (*umount_begin) (struct super_block *);
+	void (*umount_lustre) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
 };
@@ -1222,6 +1236,7 @@
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
+struct vfsmount *do_kern_mount(const char *type, int flags, const char *name, void *data);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 
 extern int vfs_statfs(struct super_block *, struct kstatfs *);
@@ -1282,10 +1297,10 @@
 }
 
 /* fs/open.c */
-
 extern int do_truncate(struct dentry *, loff_t start, unsigned int);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern struct file * dentry_open_it(struct dentry *, struct vfsmount *, int, struct lookup_intent *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 
Index: linux-2.6.9-78.0.22/include/linux/mount.h
===================================================================
--- linux-2.6.9-78.0.22.orig/include/linux/mount.h	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/include/linux/mount.h	2009-05-11 23:20:11.000000000 -0600
@@ -34,6 +34,7 @@
 	struct list_head mnt_list;
 	struct list_head mnt_fslink;	/* link in fs-specific expiry list */
 	struct namespace *mnt_namespace; /* containing namespace */
+	unsigned long mnt_last_used;	/* for GNS auto-umount (jiffies) */
 };
 
 static inline struct vfsmount *mntget(struct vfsmount *mnt)
Index: linux-2.6.9-78.0.22/include/linux/namei.h
===================================================================
--- linux-2.6.9-78.0.22.orig/include/linux/namei.h	2009-05-08 09:59:03.000000000 -0600
+++ linux-2.6.9-78.0.22/include/linux/namei.h	2009-05-11 23:20:11.000000000 -0600
@@ -2,14 +2,55 @@
 #define _LINUX_NAMEI_H
 
 #include <linux/linkage.h>
+#include <linux/string.h>
 
 struct vfsmount;
+struct nameidata;
 
-struct open_intent {
-	int	flags;
-	int	create_mode;
+/* intent opcodes */
+#define IT_OPEN		(1)
+#define IT_CREAT	(1<<1)
+#define IT_READDIR	(1<<2)
+#define IT_GETATTR	(1<<3)
+#define IT_LOOKUP	(1<<4)
+#define IT_UNLINK	(1<<5)
+#define IT_TRUNC	(1<<6)
+#define IT_GETXATTR	(1<<7)
+
+struct lustre_intent_data {
+	int	it_disposition;
+	int	it_status;
+	__u64	it_lock_handle;
+	void	*it_data;
+	int	it_lock_mode;
 };
 
+#define INTENT_MAGIC 0x19620323
+struct lookup_intent {
+	int	it_magic;
+	void	(*it_op_release)(struct lookup_intent *);
+	int	it_op;
+	int	it_flags;
+	int	it_create_mode;
+	union {
+		struct lustre_intent_data lustre;
+	} d;
+};
+
+static inline void intent_reset_fs_part(struct lookup_intent *it)
+{
+        memset(&it->d, 0, sizeof(it->d));
+        it->it_magic = INTENT_MAGIC;
+        it->it_op_release = NULL;
+}
+
+static inline void intent_init(struct lookup_intent *it, int op)
+{
+	memset(it, 0, sizeof(*it));
+	it->it_magic = INTENT_MAGIC;
+	it->it_op = op;
+}
+
 enum { MAX_NESTED_LINKS = 8 };
 
 struct nameidata {
@@ -21,10 +62,7 @@
 	unsigned	depth;
 	char *saved_names[MAX_NESTED_LINKS + 1];
 
-	/* Intent data */
-	union {
-		struct open_intent open;
-	} intent;
+	struct lookup_intent intent;
 };
 
 /*
@@ -47,6 +85,8 @@
 #define LOOKUP_NOALT		32
 #define LOOKUP_ATOMIC		64
 #define LOOKUP_REVAL		128
+#define LOOKUP_LAST		(0x1000)
+#define LOOKUP_LINK_NOTLAST	(0x2000)
 
 /*
  * Intent data
@@ -56,11 +96,18 @@
 #define LOOKUP_ACCESS		(0x0400)
 
 extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_it(const char __user *name, unsigned flags, struct nameidata *nd));
+#define user_path_walk_it(name,nd) \
+	__user_walk_it(name, LOOKUP_FOLLOW, nd)
+#define user_path_walk_link_it(name,nd) \
+	__user_walk_it(name, 0, nd)
+extern void intent_release(struct lookup_intent *);
 #define user_path_walk(name,nd) \
 	__user_walk(name, LOOKUP_FOLLOW, nd)
 #define user_path_walk_link(name,nd) \
 	__user_walk(name, 0, nd)
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
+extern int FASTCALL(path_lookup_it(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
 extern void path_release(struct nameidata *);
