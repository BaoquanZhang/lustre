Index: linux/arch/i386/kernel/traps.c
===================================================================
--- linux.orig/arch/i386/kernel/traps.c	2004-11-05 19:00:03.000000000 -0800
+++ linux/arch/i386/kernel/traps.c	2004-11-05 19:00:06.000000000 -0800
@@ -133,141 +133,48 @@
 
 #endif
 
-void scan_stack (unsigned long *stack)
+void show_trace(unsigned long * stack)
 {
+#if !CONFIG_FRAME_POINTER
 	int i;
+#endif
 	unsigned long addr;
-	/* static to not take up stackspace */
-	static char buffer[NR_CPUS][512], *bufp;
+	/* static to not take up stackspace; if we race here too bad */
+	static char buffer[512];
 
-	bufp = buffer[smp_processor_id()];
+	if (!stack)
+		stack = (unsigned long*)&stack;
 
+	printk("Call Trace:   ");
 	/*
 	 * If we have frame pointers then use them to get
 	 * a 100% exact backtrace, up until the entry frame:
 	 */
+#if CONFIG_FRAME_POINTER
+#define DO(n) \
+	addr = (int)__builtin_return_address(n);	\
+	if (!kernel_text_address(addr))			\
+		goto out;				\
+	lookup_symbol(addr, buffer, 512);		\
+	printk("[<%08lx>] %s\n", addr, buffer);
+
+	DO(0); DO(1); DO(2); DO(3); DO(4); DO(5); DO(7); DO(8); DO(9);
+	DO(10); DO(11); DO(12); DO(13); DO(14); DO(15); DO(17); DO(18); DO(19);
+out:
+#else
 	i = 1;
 	while (((long) stack & (THREAD_SIZE-1)) != 0) {
 		addr = *stack++;
 		if (kernel_text_address(addr)) {
-			lookup_symbol(addr, bufp, 512);
-			printk("[<%08lx>] %s (0x%p)\n", addr,bufp,stack-1);
+			lookup_symbol(addr, buffer, 512);
+			printk("[<%08lx>] %s (0x%p)\n", addr,buffer,stack-1);
 			i++;
 		}
 	}
-}
-
-#if CONFIG_FRAME_POINTER
-void show_stack_frame_params (int param_count, unsigned long params[])
-{
-	int i;
-	unsigned long *p, task_addr, stack_base;
-
-	if (param_count <= 0)
-		return;
-
-	task_addr = (unsigned long) current;
-	stack_base = task_addr + THREAD_SIZE - 1;
-
-	printk("             (");
-
-	for (i = 0, p = params;
-	     ((param_count - i) > 1) && (p >= task_addr) && (p <= stack_base);
-	     i++, p++) {
-		printk("0x%x, ", *p);
-
-		if ((i % 4) == 3)
-			printk("\n              ");
-	}
-
-	if ((p >= task_addr) && (p <= stack_base))
-		printk("0x%x)\n", *p);
-}
-
-/* Display a stack trace for the currently executing task.  The 'dummy'
- * parameter serves a purpose although its value is unused.  We use the
- * address of 'dummy' as a reference point for finding the saved %ebp register
- * value on the stack.
- */
-void frame_pointer_walk (void *dummy)
-{
-	int i;
-	unsigned long addr, task_addr, *frame_ptr, *next_frame_ptr, *eip_ptr,
-		      eip, stack_base;
-	/* static to not take up stackspace */
-	static char buffer[NR_CPUS][512], *bufp;
-
-	bufp = buffer[smp_processor_id()];
-	task_addr = (unsigned long) current;
-	stack_base = task_addr + THREAD_SIZE - 1;
-	frame_ptr = (unsigned long *) (&dummy - 2);
-
-	for (; ; ) {
-		next_frame_ptr = (unsigned long *) (*frame_ptr);
-		addr = (unsigned long) next_frame_ptr;
-
-		/* Stop when we reach a frame pointer that points to a
-		 * location clearly outside our own kernel stack.
-		 */
-		if ((addr < task_addr) || (addr > stack_base))
-			break;
-
-		eip_ptr = frame_ptr + 1;
-		eip = *eip_ptr;
-
-		if (kernel_text_address(eip)) {
-			lookup_symbol(eip, bufp, 512);
-			show_stack_frame_params(4, frame_ptr + 2);
-			printk("[<%08lx>] %s (0x%x)\n", eip, bufp,
-			       eip_ptr);
-		}
-
-		frame_ptr = next_frame_ptr;
-	}
-}
-
-typedef void (*stack_trace_fn_t) (unsigned long *stack);
-
-void show_trace(unsigned long * stack)
-{
-	static const stack_trace_fn_t trace_fn_vector[] =
-		{ scan_stack, frame_pointer_walk };
-	unsigned long addr, task_addr, stack_base;
-	int task_is_current;
-
-	if (!stack)
-		stack = (unsigned long*)&stack;
-
-	printk("Call Trace:\n");
-	addr = (unsigned long) stack;
-	task_addr = (unsigned long) current;
-	stack_base = task_addr + THREAD_SIZE - 1;
-	task_is_current = (addr >= task_addr) && (addr <= stack_base);
-
-	/* We may use frame pointers to do a stack trace only if the current
-	 * task is being traced.  Tracing some other task in this manner
-	 * would require a saved %ebp register value.  Perhaps in the future
-	 * I'll consider providing a means of obtaining this.
-	 */
-	trace_fn_vector[task_is_current](stack);
-
-	printk("\n");
-}
-
-#else /* CONFIG_FRAME_POINTER */
-
-void show_trace(unsigned long * stack)
-{
-	if (!stack)
-		stack = (unsigned long*)&stack;
-
-	printk("Call Trace:\n");
-	scan_stack(stack);
+#endif
 	printk("\n");
 }
 
-#endif /* CONFIG_FRAME_POINTER */
-
 void show_trace_task(struct task_struct *tsk)
 {
 	unsigned long esp = tsk->thread.esp;
Index: linux/fs/namei.c
===================================================================
--- linux.orig/fs/namei.c	2004-11-05 19:00:03.000000000 -0800
+++ linux/fs/namei.c	2004-11-05 19:00:06.000000000 -0800
@@ -1022,7 +1022,7 @@
 	 * The simplest case - just a plain lookup.
 	 */
 	if (!(flag & O_CREAT)) {
-		error = path_lookup_it(pathname, lookup_flags(flag), nd);
+		error = path_lookup(pathname, lookup_flags(flag), nd);
 		if (error)
 			return error;
 		dentry = nd->dentry;
Index: linux/include/asm-i386/hw_irq.h
===================================================================
--- linux.orig/include/asm-i386/hw_irq.h	2004-11-05 19:00:03.000000000 -0800
+++ linux/include/asm-i386/hw_irq.h	2004-11-05 19:00:06.000000000 -0800
@@ -158,9 +158,6 @@
 	/* there is a second layer of macro just to get the symbolic
 	   name for the vector evaluated. This change is for RTLinux */
 #define BUILD_SMP_INTERRUPT(x,v) XBUILD_SMP_INTERRUPT(x,v)
-
-#if CONFIG_X86_HIGH_ENTRY
-
 #define XBUILD_SMP_INTERRUPT(x,v)\
 asmlinkage void x(void); \
 asmlinkage void call_##x(void); \
@@ -173,26 +170,7 @@
 	"movl $"SYMBOL_NAME_STR(smp_##x)", %ebp; call *%ebp\n\t" \
 	"jmp ret_from_intr; .previous\n");
 
-#else
-
-#define XBUILD_SMP_INTERRUPT(x,v)\
-asmlinkage void x(void); \
-asmlinkage void call_##x(void); \
-__asm__( \
-".section .entry.text,\"ax\"\n"__ALIGN_STR"\n" \
-SYMBOL_NAME_STR(x) ":\n\t" \
-	"pushl $"#v"-256\n\t" \
-	SAVE_ALL_SWITCH \
-	SYMBOL_NAME_STR(call_##x)":\n\t" \
-	"call "SYMBOL_NAME_STR(smp_##x)"\n\t" \
-	"jmp ret_from_intr; .previous\n");
-
-#endif
-
 #define BUILD_SMP_TIMER_INTERRUPT(x,v) XBUILD_SMP_TIMER_INTERRUPT(x,v)
-
-#if CONFIG_X86_HIGH_ENTRY
-
 #define XBUILD_SMP_TIMER_INTERRUPT(x,v) \
 asmlinkage void x(struct pt_regs * regs); \
 asmlinkage void call_##x(void); \
@@ -208,27 +186,6 @@
 	"addl $4,%esp\n\t" \
 	"jmp ret_from_intr; .previous\n");
 
-#else
-
-#define XBUILD_SMP_TIMER_INTERRUPT(x,v) \
-asmlinkage void x(struct pt_regs * regs); \
-asmlinkage void call_##x(void); \
-__asm__( \
-".section .entry.text,\"ax\"\n"__ALIGN_STR"\n" \
-SYMBOL_NAME_STR(x) ":\n\t" \
-	"pushl $"#v"-256\n\t" \
-	SAVE_ALL_SWITCH \
-	"movl %esp,%eax\n\t" \
-	"pushl %eax\n\t" \
-	SYMBOL_NAME_STR(call_##x)":\n\t" \
-	"call "SYMBOL_NAME_STR(smp_##x)"\n\t" \
-	"addl $4,%esp\n\t" \
-	"jmp ret_from_intr; .previous\n");
-
-#endif
-
-#if CONFIG_X86_HIGH_ENTRY
-
 #define BUILD_COMMON_IRQ() \
 asmlinkage void call_do_IRQ(void); \
 __asm__( \
@@ -239,20 +196,6 @@
 	"movl $"SYMBOL_NAME_STR(do_IRQ)", %ebp; call *%ebp\n\t" \
 	"jmp ret_from_intr; .previous\n");
 
-#else
-
-#define BUILD_COMMON_IRQ() \
-asmlinkage void call_do_IRQ(void); \
-__asm__( \
-	".section .entry.text,\"ax\"\n" __ALIGN_STR"\n" \
-	"common_interrupt:\n\t" \
-	SAVE_ALL_SWITCH \
-	SYMBOL_NAME_STR(call_do_IRQ)":\n\t" \
-	"call "SYMBOL_NAME_STR(do_IRQ)"\n\t" \
-	"jmp ret_from_intr; .previous\n");
-
-#endif
-
 /* 
  * subtle. orig_eax is used by the signal code to distinct between
  * system calls and interrupted 'random user-space'. Thus we have
Index: linux/mm/highmem.c
===================================================================
--- linux.orig/mm/highmem.c	2004-11-05 08:59:32.000000000 -0800
+++ linux/mm/highmem.c	2004-11-05 19:00:06.000000000 -0800
@@ -465,11 +465,7 @@
 /*
  * FIXME: assuming PAGE_SIZE buffer_heads
  */
-
-/*
- * don't allow SUPERBH_MAX_USERS to go < 1 - mag
- */
-#define SUPERBH_MAX_USERS	max(POOL_SIZE * PAGE_SIZE / MAX_SUPERBH, 1)
+#define SUPERBH_MAX_USERS	(POOL_SIZE * PAGE_SIZE / MAX_SUPERBH)
 
 static int superbh_users;
 static DECLARE_WAIT_QUEUE_HEAD(superbh_wait);
