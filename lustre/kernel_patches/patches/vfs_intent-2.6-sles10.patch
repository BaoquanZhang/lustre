---
 fs/9p/vfs_inode.c      |    2 
 fs/exec.c              |    8 ++
 fs/fuse/dir.c          |    2 
 fs/inode.c             |    1 
 fs/namei.c             |  137 ++++++++++++++++++++++++++++++++++++++++++-------
 fs/namespace.c         |   10 +++
 fs/nfsctl.c            |    1 
 fs/open.c              |   31 ++++++-----
 fs/stat.c              |   24 ++++++--
 include/linux/dcache.h |    3 +
 include/linux/fs.h     |   10 +++
 include/linux/mount.h  |    2 
 include/linux/namei.h  |   65 ++++++++++++++++++++---
 13 files changed, 248 insertions(+), 48 deletions(-)

--- linux-2.6.16.21-0.8.orig/fs/inode.c
+++ linux-2.6.16.21-0.8/fs/inode.c
@@ -236,6 +236,7 @@ void __iget(struct inode * inode)
 	inodes_stat.nr_unused--;
 }
 
+EXPORT_SYMBOL(__iget);
 /**
  * clear_inode - clear an inode
  * @inode: inode to clear
--- linux-2.6.16.21-0.8.orig/fs/open.c
+++ linux-2.6.16.21-0.8/fs/open.c
@@ -224,12 +224,12 @@ static long do_sys_truncate(const char _
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
-
+	intent_init(&nd.intent, IT_GETATTR);
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path_walk(path, &nd);
+	error = user_path_walk_it(path, &nd);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
@@ -494,6 +494,7 @@ asmlinkage long sys_faccessat(int dfd, c
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -518,7 +519,7 @@ asmlinkage long sys_faccessat(int dfd, c
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = __user_walk_fd(dfd, filename, LOOKUP_FOLLOW|LOOKUP_ACCESS, &nd);
+	res = __user_walk_fd_it(dfd, filename, LOOKUP_FOLLOW|LOOKUP_ACCESS, &nd);
 	if (!res) {
 		res = vfs_permission(&nd, mode);
 		/* SuS v2 requires we report a read only fs too */
@@ -544,8 +545,9 @@ asmlinkage long sys_chdir(const char __u
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
-	error = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
+	error = __user_walk_it(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
 	if (error)
 		goto out;
 
@@ -595,8 +597,9 @@ asmlinkage long sys_chroot(const char __
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
-	error = __user_walk(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
+	error = __user_walk_it(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
 	if (error)
 		goto out;
 
@@ -817,6 +820,7 @@ static struct file *__dentry_open(struct
 		error = open(inode, f);
 		if (error)
 			goto cleanup_all;
+		intent_release(f->f_it);
 	}
 
 	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);
@@ -843,6 +847,7 @@ cleanup_all:
 	f->f_dentry = NULL;
 	f->f_vfsmnt = NULL;
 cleanup_file:
+	intent_release(f->f_it);
 	put_filp(f);
 	dput(dentry);
 	mntput(mnt);
@@ -868,6 +873,7 @@ static struct file *do_filp_open(int dfd
 {
 	int namei_flags, error;
 	struct nameidata nd;
+	intent_init(&nd.intent, IT_OPEN);
 
 	namei_flags = flags;
 	if ((namei_flags+1) & O_ACCMODE)
@@ -904,19 +910,19 @@ EXPORT_SYMBOL(filp_open);
 struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *))
 {
-	if (IS_ERR(nd->intent.open.file))
+	if (IS_ERR(nd->intent.file))
 		goto out;
 	if (IS_ERR(dentry))
 		goto out_err;
-	nd->intent.open.file = __dentry_open(dget(dentry), mntget(nd->mnt),
-					     nd->intent.open.flags - 1,
-					     nd->intent.open.file,
+	nd->intent.file = __dentry_open(dget(dentry), mntget(nd->mnt),
+					     nd->intent.flags - 1,
+					     nd->intent.file,
 					     open);
 out:
-	return nd->intent.open.file;
+	return nd->intent.file;
 out_err:
 	release_open_intent(nd);
-	nd->intent.open.file = (struct file *)dentry;
+	nd->intent.file = (struct file *)dentry;
 	goto out;
 }
 EXPORT_SYMBOL_GPL(lookup_instantiate_filp);
@@ -933,7 +939,8 @@ struct file *nameidata_to_filp(struct na
 	struct file *filp;
 
 	/* Pick up the filp from the open intent */
-	filp = nd->intent.open.file;
+	filp = nd->intent.file;
+	filp->f_it = &nd->intent;
 	/* Has the filesystem initialised the file for us? */
 	if (filp->f_dentry == NULL)
 		filp = __dentry_open(nd->dentry, nd->mnt, flags, filp, NULL);
--- linux-2.6.16.21-0.8.orig/fs/nfsctl.c
+++ linux-2.6.16.21-0.8/fs/nfsctl.c
@@ -26,6 +26,7 @@ static struct file *do_open(char *name, 
 	struct nameidata nd;
 	int error;
 
+	intent_init(&nd.intent, IT_OPEN);
 	nd.mnt = do_kern_mount("nfsd", 0, "nfsd", NULL);
 
 	if (IS_ERR(nd.mnt))
--- linux-2.6.16.21-0.8.orig/fs/namei.c
+++ linux-2.6.16.21-0.8/fs/namei.c
@@ -337,8 +337,19 @@ int deny_write_access(struct file * file
 	return 0;
 }
 
+void intent_release(struct lookup_intent *it)
+{
+	if (!it)
+		return;
+	if (it->it_magic != INTENT_MAGIC)
+		return;
+	if (it->it_op_release)
+		it->it_op_release(it);
+}
+
 void path_release(struct nameidata *nd)
 {
+	intent_release(&nd->intent);
 	dput(nd->dentry);
 	mntput(nd->mnt);
 }
@@ -359,10 +370,10 @@ void path_release_on_umount(struct namei
  */
 void release_open_intent(struct nameidata *nd)
 {
-	if (nd->intent.open.file->f_dentry == NULL)
-		put_filp(nd->intent.open.file);
+	if (nd->intent.file->f_dentry == NULL)
+		put_filp(nd->intent.file);
 	else
-		fput(nd->intent.open.file);
+		fput(nd->intent.file);
 }
 
 /*
@@ -440,8 +451,12 @@ static struct dentry * real_lookup(struc
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
+	int counter = 0;
 
 	mutex_lock(&dir->i_mutex);
+again:
+	counter++;
+
 	/*
 	 * First re-do the cached lookup just in case it was created
 	 * while we waited for the directory semaphore..
@@ -475,13 +490,16 @@ static struct dentry * real_lookup(struc
 	 * Uhhuh! Nasty case: the cache was re-populated while
 	 * we waited on the semaphore. Need to revalidate.
 	 */
-	mutex_unlock(&dir->i_mutex);
 	if (result->d_op && result->d_op->d_revalidate) {
 		if (!result->d_op->d_revalidate(result, nd) && !d_invalidate(result)) {
 			dput(result);
-			result = ERR_PTR(-ENOENT);
+			if (counter > 10)
+				result = ERR_PTR(-ESTALE);
+			if (!IS_ERR(result))
+				goto again;
 		}
 	}
+	mutex_unlock(&dir->i_mutex);
 	return result;
 }
 
@@ -510,6 +528,7 @@ static __always_inline int __vfs_follow_
 {
 	int res = 0;
 	char *name;
+
 	if (IS_ERR(link))
 		goto fail;
 
@@ -519,6 +538,7 @@ static __always_inline int __vfs_follow_
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
+	intent_reset_fs_part(&nd->intent);
 	res = link_path_walk(link, nd);
 out:
 	if (nd->depth || res || nd->last_type!=LAST_NORM)
@@ -768,6 +788,33 @@ fail:
 	return PTR_ERR(dentry);
 }
 
+static int revalidate_special(struct nameidata *nd)
+{
+	struct dentry *dentry = nd->dentry;
+	int err, counter = 0;
+
+ revalidate_again:
+	if (!dentry->d_op || !dentry->d_op->d_revalidate)
+		return 0;
+	if (!dentry->d_op->d_revalidate(dentry, nd)) {
+		struct dentry *new;
+		if ((err = permission(dentry->d_parent->d_inode, MAY_EXEC, nd)))
+			return err;
+		new = real_lookup(dentry->d_parent, &dentry->d_name, nd);
+		if (IS_ERR(new))
+			return PTR_ERR(new);
+		d_invalidate(dentry);
+		dput(dentry);
+		nd->dentry = dentry = new;
+		counter++;
+		if (counter < 10)
+			goto revalidate_again;
+		printk("excessive revalidate_it loops\n");
+		return -ESTALE;
+	}
+	return 0;
+}
+
 /*
  * Name resolution.
  * This is the basic name resolution function, turning a pathname into
@@ -864,7 +911,11 @@ static fastcall int __link_path_walk(con
 			goto out_dput;
 
 		if (inode->i_op->follow_link) {
+			int save_flags = nd->flags;
+			nd->flags |= LOOKUP_LINK_NOTLAST;
 			err = do_follow_link(&next, nd);
+			if (!(save_flags & LOOKUP_LINK_NOTLAST))
+				nd->flags &= ~LOOKUP_LINK_NOTLAST;
 			if (err)
 				goto return_err;
 			err = -ENOENT;
@@ -899,6 +950,23 @@ last_component:
 				inode = nd->dentry->d_inode;
 				/* fallthrough */
 			case 1:
+				nd->flags |= LOOKUP_LAST;
+				err = revalidate_special(nd);
+				nd->flags &= ~LOOKUP_LAST;
+				if (!nd->dentry->d_inode)
+					err = -ENOENT;
+				if (err) {
+					path_release(nd);
+					goto return_err;
+				}
+				if (lookup_flags & LOOKUP_DIRECTORY) {
+					err = -ENOTDIR;
+					if(!nd->dentry->d_inode->i_op ||
+					  !nd->dentry->d_inode->i_op->lookup) {
+						path_release(nd);
+						goto return_err;
+					}
+				}
 				goto return_reval;
 		}
 		if (nd->dentry->d_op && nd->dentry->d_op->d_hash) {
@@ -906,7 +974,9 @@ last_component:
 			if (err < 0)
 				break;
 		}
+		nd->flags |= LOOKUP_LAST;
 		err = do_lookup(nd, &this, &next);
+		nd->flags &= ~LOOKUP_LAST;
 		if (err)
 			break;
 		inode = next.dentry->d_inode;
@@ -1148,13 +1218,13 @@ static int __path_lookup_intent_open(int
 
 	if (filp == NULL)
 		return -ENFILE;
-	nd->intent.open.file = filp;
-	nd->intent.open.flags = open_flags;
-	nd->intent.open.create_mode = create_mode;
+	nd->intent.file = filp;
+	nd->intent.flags = open_flags;
+	nd->intent.create_mode = create_mode;
 	err = do_path_lookup(dfd, name, lookup_flags|LOOKUP_OPEN, nd);
-	if (IS_ERR(nd->intent.open.file)) {
+	if (IS_ERR(nd->intent.file)) {
 		if (err == 0) {
-			err = PTR_ERR(nd->intent.open.file);
+			err = PTR_ERR(nd->intent.file);
 			path_release(nd);
 		}
 	} else if (err != 0)
@@ -1257,7 +1327,7 @@ struct dentry * lookup_hash(struct namei
 }
 
 /* SMP-safe */
-struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+struct dentry * lookup_one_len_it(const char * name, struct dentry * base, int len, struct nameidata *nd)
 {
 	unsigned long hash;
 	struct qstr this;
@@ -1277,11 +1347,17 @@ struct dentry * lookup_one_len(const cha
 	}
 	this.hash = end_name_hash(hash);
 
-	return __lookup_hash(&this, base, NULL);
+	return __lookup_hash(&this, base, nd);
 access:
 	return ERR_PTR(-EACCES);
 }
 
+struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+{
+ 	return lookup_one_len_it(name, base, len, NULL);
+}
+
+
 /*
  *	namei()
  *
@@ -1293,8 +1369,9 @@ access:
  * that namei follows links, while lnamei does not.
  * SMP-safe
  */
-int fastcall __user_walk_fd(int dfd, const char __user *name, unsigned flags,
-			    struct nameidata *nd)
+
+int fastcall __user_walk_fd_it(int dfd, const char __user *name, unsigned flags,
+			       struct nameidata *nd)
 {
 	char *tmp = getname(name);
 	int err = PTR_ERR(tmp);
@@ -1306,9 +1383,22 @@ int fastcall __user_walk_fd(int dfd, con
 	return err;
 }
 
+int fastcall __user_walk_fd(int dfd, const char __user *name, unsigned flags,
+			    struct nameidata *nd)
+{
+	intent_init(&nd->intent, IT_LOOKUP);
+	return __user_walk_fd_it(dfd, name, flags, nd);
+}
+
+int fastcall __user_walk_it(const char __user *name, unsigned flags, struct nameidata *nd)
+{
+	return __user_walk_fd_it(AT_FDCWD, name, flags, nd);
+}
+
 int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd)
 {
-	return __user_walk_fd(AT_FDCWD, name, flags, nd);
+	intent_init(&nd->intent, IT_LOOKUP);
+	return __user_walk_it(name, flags, nd);
 }
 
 /*
@@ -1588,6 +1678,8 @@ int open_namei(int dfd, const char *path
 	if (flag & O_APPEND)
 		acc_mode |= MAY_APPEND;
 
+ 	nd->intent.it_flags = flag;
+ 	nd->intent.it_create_mode = mode;
 	/*
 	 * The simplest case - just a plain lookup.
 	 */
@@ -1602,6 +1694,7 @@ int open_namei(int dfd, const char *path
 	/*
 	 * Create - we need to know the parent.
 	 */
+ 	nd->intent.it_op |= IT_CREAT;
 	error = path_lookup_create(dfd,pathname,LOOKUP_PARENT,nd,flag,mode);
 	if (error)
 		return error;
@@ -1618,7 +1711,9 @@ int open_namei(int dfd, const char *path
 	dir = nd->dentry;
 	nd->flags &= ~LOOKUP_PARENT;
 	mutex_lock(&dir->d_inode->i_mutex);
+	nd->flags |= LOOKUP_LAST;
 	path.dentry = lookup_hash(nd);
+	nd->flags &= ~LOOKUP_LAST;
 	path.mnt = nd->mnt;
 
 do_last:
@@ -1628,9 +1723,9 @@ do_last:
 		goto exit;
 	}
 
-	if (IS_ERR(nd->intent.open.file)) {
+	if (IS_ERR(nd->intent.file)) {
 		mutex_unlock(&dir->d_inode->i_mutex);
-		error = PTR_ERR(nd->intent.open.file);
+		error = PTR_ERR(nd->intent.file);
 		goto exit_dput;
 	}
 
@@ -1683,7 +1778,7 @@ ok:
 exit_dput:
 	dput_path(&path, nd);
 exit:
-	if (!IS_ERR(nd->intent.open.file))
+	if (!IS_ERR(nd->intent.file))
 		release_open_intent(nd);
 	path_release(nd);
 	return error;
@@ -1726,7 +1821,9 @@ do_link:
 	}
 	dir = nd->dentry;
 	mutex_lock(&dir->d_inode->i_mutex);
+	nd->flags |= LOOKUP_LAST;
 	path.dentry = lookup_hash(nd);
+	nd->flags &= ~LOOKUP_LAST;
 	path.mnt = nd->mnt;
 	__putname(nd->last.name);
 	goto do_last;
@@ -2238,6 +2335,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	int error;
 	char * to;
 
+	intent_init(&nd.intent, IT_LOOKUP);
+        intent_init(&old_nd.intent, IT_LOOKUP);
 	if (flags != 0)
 		return -EINVAL;
 
@@ -2245,7 +2344,7 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(to))
 		return PTR_ERR(to);
 
-	error = __user_walk_fd(olddfd, oldname, 0, &old_nd);
+	error = __user_walk_fd_it(olddfd, oldname, 0, &old_nd);
 	if (error)
 		goto exit;
 	error = do_path_lookup(newdfd, to, LOOKUP_PARENT, &nd);
--- linux-2.6.16.21-0.8.orig/fs/stat.c
+++ linux-2.6.16.21-0.8/fs/stat.c
@@ -38,7 +38,7 @@ void generic_fillattr(struct inode *inod
 
 EXPORT_SYMBOL(generic_fillattr);
 
-int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+int vfs_getattr_it(struct vfsmount *mnt, struct dentry *dentry, struct lookup_intent *it, struct kstat *stat)
 {
 	struct inode *inode = dentry->d_inode;
 	int retval;
@@ -47,6 +47,8 @@ int vfs_getattr(struct vfsmount *mnt, st
 	if (retval)
 		return retval;
 
+	if (inode->i_op->getattr_it)
+		return inode->i_op->getattr_it(mnt, dentry, it, stat);
 	if (inode->i_op->getattr)
 		return inode->i_op->getattr(mnt, dentry, stat);
 
@@ -61,6 +63,11 @@ int vfs_getattr(struct vfsmount *mnt, st
 	return 0;
 }
 
+int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+	return vfs_getattr_it(mnt, dentry, NULL, stat);
+}
+
 EXPORT_SYMBOL(vfs_getattr);
 
 int vfs_stat_fd(int dfd, char __user *name, struct kstat *stat)
@@ -68,9 +75,10 @@ int vfs_stat_fd(int dfd, char __user *na
 	struct nameidata nd;
 	int error;
 
-	error = __user_walk_fd(dfd, name, LOOKUP_FOLLOW, &nd);
+ 	intent_init(&nd.intent, IT_GETATTR);
+	error = __user_walk_fd_it(dfd, name, LOOKUP_FOLLOW, &nd);
 	if (!error) {
-		error = vfs_getattr(nd.mnt, nd.dentry, stat);
+ 		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.intent, stat);
 		path_release(&nd);
 	}
 	return error;
@@ -88,9 +96,10 @@ int vfs_lstat_fd(int dfd, char __user *n
 	struct nameidata nd;
 	int error;
 
-	error = __user_walk_fd(dfd, name, 0, &nd);
+ 	intent_init(&nd.intent, IT_GETATTR);
+	error = __user_walk_fd_it(dfd, name, 0, &nd);
 	if (!error) {
-		error = vfs_getattr(nd.mnt, nd.dentry, stat);
+ 		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.intent, stat);
 		path_release(&nd);
 	}
 	return error;
@@ -107,9 +116,12 @@ int vfs_fstat(unsigned int fd, struct ks
 {
 	struct file *f = fget(fd);
 	int error = -EBADF;
+	struct nameidata nd;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	if (f) {
-		error = vfs_getattr(f->f_vfsmnt, f->f_dentry, stat);
+		error = vfs_getattr_it(f->f_vfsmnt, f->f_dentry, &nd.intent, stat);
+		intent_release(&nd.intent);
 		fput(f);
 	}
 	return error;
--- linux-2.6.16.21-0.8.orig/fs/namespace.c
+++ linux-2.6.16.21-0.8/fs/namespace.c
@@ -75,6 +75,7 @@ struct vfsmount *alloc_vfsmnt(const char
 		INIT_LIST_HEAD(&mnt->mnt_share);
 		INIT_LIST_HEAD(&mnt->mnt_slave_list);
 		INIT_LIST_HEAD(&mnt->mnt_slave);
+		INIT_LIST_HEAD(&mnt->mnt_lustre_list);
 		if (name) {
 			int size = strlen(name) + 1;
 			char *newname = kmalloc(size, GFP_KERNEL);
@@ -155,6 +156,7 @@ static void __touch_namespace(struct nam
 
 static void detach_mnt(struct vfsmount *mnt, struct nameidata *old_nd)
 {
+	memset(old_nd, 0, sizeof(*old_nd));
 	old_nd->dentry = mnt->mnt_mountpoint;
 	old_nd->mnt = mnt->mnt_parent;
 	mnt->mnt_parent = mnt;
@@ -273,6 +275,9 @@ static inline void __mntput(struct vfsmo
 {
 	struct super_block *sb = mnt->mnt_sb;
 	dput(mnt->mnt_root);
+	spin_lock(&dcache_lock);
+	list_del(&mnt->mnt_lustre_list);
+	spin_unlock(&dcache_lock);
 	free_vfsmnt(mnt);
 	deactivate_super(sb);
 }
@@ -539,6 +544,8 @@ static int do_umount(struct vfsmount *mn
 	 */
 
 	lock_kernel();
+ 	if (sb->s_op->umount_lustre)
+ 		sb->s_op->umount_lustre(sb);
 	if ((flags & MNT_FORCE) && sb->s_op->umount_begin)
 		sb->s_op->umount_begin(sb);
 	unlock_kernel();
@@ -871,6 +878,7 @@ static int do_loopback(struct nameidata 
 		return err;
 	if (!old_name || !*old_name)
 		return -EINVAL;
+	intent_init(&old_nd.intent, IT_LOOKUP);
 	err = path_lookup(old_name, LOOKUP_FOLLOW, &old_nd);
 	if (err)
 		return err;
@@ -956,6 +964,7 @@ static int do_move_mount(struct nameidat
 		return -EPERM;
 	if (!old_name || !*old_name)
 		return -EINVAL;
+	intent_init(&old_nd.intent, IT_LOOKUP);
 	err = path_lookup(old_name, LOOKUP_FOLLOW, &old_nd);
 	if (err)
 		return err;
@@ -1271,6 +1280,7 @@ long do_mount(char *dev_name, char *dir_
 	int retval = 0;
 	int mnt_flags = 0;
 
+	intent_init(&nd.intent, IT_LOOKUP);
 	/* Discard magic */
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
 		flags &= ~MS_MGC_MSK;
--- linux-2.6.16.21-0.8.orig/fs/exec.c
+++ linux-2.6.16.21-0.8/fs/exec.c
@@ -128,7 +128,9 @@ asmlinkage long sys_uselib(const char __
 	struct nameidata nd;
 	int error;
 
-	error = __user_path_lookup_open(library, LOOKUP_FOLLOW, &nd, FMODE_READ);
+ 	intent_init(&nd.intent, IT_OPEN);
+	error = __user_path_lookup_open(library, LOOKUP_FOLLOW, &nd,
+					FMODE_READ | FMODE_EXEC);
 	if (error)
 		goto out;
 
@@ -478,7 +480,9 @@ struct file *open_exec(const char *name)
 	int err;
 	struct file *file;
 
-	err = path_lookup_open(AT_FDCWD, name, LOOKUP_FOLLOW, &nd, FMODE_READ);
+ 	intent_init(&nd.intent, IT_OPEN);
+	err = path_lookup_open(AT_FDCWD, name, LOOKUP_FOLLOW, &nd,
+			       FMODE_READ | FMODE_EXEC);
 	file = ERR_PTR(err);
 
 	if (!err) {
--- linux-2.6.16.21-0.8.orig/include/linux/dcache.h
+++ linux-2.6.16.21-0.8/include/linux/dcache.h
@@ -36,6 +36,9 @@ struct qstr {
 	const unsigned char *name;
 };
 
+struct inode;
+#include <linux/namei.h>
+
 struct dentry_stat_t {
 	int nr_dentry;
 	int nr_unused;
--- linux-2.6.16.21-0.8.orig/include/linux/fs.h
+++ linux-2.6.16.21-0.8/include/linux/fs.h
@@ -59,6 +59,7 @@ extern int dir_notify_enable;
 
 #define FMODE_READ 1
 #define FMODE_WRITE 2
+#define FMODE_EXEC 16
 
 /* Internal kernel extensions */
 #define FMODE_LSEEK	4
@@ -265,6 +266,8 @@ typedef void (dio_iodone_t)(struct kiocb
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
 #define ATTR_FILE	8192
+#define ATTR_RAW       	16384	/* file system, not vfs will massage attrs */
+#define ATTR_FROM_OPEN 	65536	/* called from open path, ie O_TRUNC */
 #define ATTR_NO_BLOCK	32768	/* Return EAGAIN and don't block on long truncates */
 
 /*
@@ -500,6 +503,7 @@ struct inode {
 	struct block_device	*i_bdev;
 	struct cdev		*i_cdev;
 	int			i_cindex;
+	void			*i_filterdata;
 
 	__u32			i_generation;
 
@@ -647,6 +651,7 @@ struct file {
 	spinlock_t		f_ep_lock;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
+ 	struct lookup_intent    *f_it;
 };
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
@@ -1049,7 +1054,9 @@ struct inode_operations {
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int, struct nameidata *);
 	int (*setattr) (struct dentry *, struct iattr *);
+	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+	int (*getattr_it) (struct vfsmount *, struct dentry *, struct lookup_intent *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
@@ -1090,6 +1097,7 @@ struct super_operations {
 	int (*remount_fs) (struct super_block *, int *, char *);
 	void (*clear_inode) (struct inode *);
 	void (*umount_begin) (struct super_block *);
+	void (*umount_lustre) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
 
@@ -1292,6 +1300,7 @@ extern int may_umount_tree(struct vfsmou
 extern int may_umount(struct vfsmount *);
 extern void umount_tree(struct vfsmount *, int, struct list_head *);
 extern void release_mounts(struct list_head *);
+struct vfsmount *do_kern_mount(const char *type, int flags, const char *name, void *data);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
@@ -1353,6 +1362,7 @@ extern long do_sys_open(int fdf, const c
 			int mode);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern struct file * dentry_open_it(struct dentry *, struct vfsmount *, int, struct lookup_intent *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 
--- linux-2.6.16.21-0.8.orig/include/linux/namei.h
+++ linux-2.6.16.21-0.8/include/linux/namei.h
@@ -5,10 +5,39 @@
 
 struct vfsmount;
 
+#define IT_OPEN                (1)
+#define IT_CREAT       (1<<1)
+#define IT_READDIR     (1<<2)
+#define IT_GETATTR     (1<<3)
+#define IT_LOOKUP      (1<<4)
+#define IT_UNLINK      (1<<5)
+#define IT_TRUNC       (1<<6)
+#define IT_GETXATTR    (1<<7)
+
+struct lustre_intent_data {
+	int     it_disposition;
+	int     it_status;
+	__u64   it_lock_handle;
+	void    *it_data;
+	int     it_lock_mode;
+};
+
+#define INTENT_MAGIC 0x19620323
+
+#define it_flags flags
+#define it_create_mode create_mode
+#define lookup_intent open_intent
+
 struct open_intent {
-	int	flags;
-	int	create_mode;
-	struct file *file;
+       	int     it_magic;
+       	void    (*it_op_release)(struct open_intent *);
+       	int     it_op;
+       	int     flags;
+       	int     create_mode;
+	struct  file *file;
+       	union {
+                struct lustre_intent_data lustre;
+       	} d;
 };
 
 enum { MAX_NESTED_LINKS = 8 };
@@ -22,12 +51,23 @@ struct nameidata {
 	unsigned	depth;
 	char *saved_names[MAX_NESTED_LINKS + 1];
 
-	/* Intent data */
-	union {
-		struct open_intent open;
-	} intent;
+	struct lookup_intent intent;
 };
 
+static inline void intent_reset_fs_part(struct lookup_intent *it)
+{
+        memset(&it->d, 0, sizeof(it->d));
+        it->it_magic = INTENT_MAGIC;
+        it->it_op_release = NULL;
+}
+
+static inline void intent_init(struct lookup_intent *it, int op)
+{
+	memset(it, 0, sizeof(*it));
+	it->it_magic = INTENT_MAGIC;
+	it->it_op = op;
+}
+
 /*
  * Type of the last component on LOOKUP_PARENT
  */
@@ -48,6 +88,8 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LA
 #define LOOKUP_PARENT		16
 #define LOOKUP_NOALT		32
 #define LOOKUP_REVAL		64
+#define LOOKUP_LAST		(0x1000)
+#define LOOKUP_LINK_NOTLAST	(0x2000)
 /*
  * Intent data
  */
@@ -57,10 +99,19 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LA
 
 extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
 extern int FASTCALL(__user_walk_fd(int dfd, const char __user *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_fd_it(int dfd, const char __user *, unsigned, struct nameidata *));
 #define user_path_walk(name,nd) \
 	__user_walk_fd(AT_FDCWD, name, LOOKUP_FOLLOW, nd)
 #define user_path_walk_link(name,nd) \
 	__user_walk_fd(AT_FDCWD, name, 0, nd)
+
+extern int FASTCALL(__user_walk_it(const char __user *name, unsigned flags, struct nameidata *nd));
+#define user_path_walk_it(name,nd) \
+ 	__user_walk_it(name, LOOKUP_FOLLOW, nd)
+#define user_path_walk_link_it(name,nd) \
+ 	__user_walk_it(name, 0, nd)
+extern void intent_release(struct lookup_intent *);
+
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
--- linux-2.6.16.21-0.8.orig/include/linux/mount.h
+++ linux-2.6.16.21-0.8/include/linux/mount.h
@@ -46,6 +46,8 @@ struct vfsmount {
 	struct list_head mnt_slave;	/* slave list entry */
 	struct vfsmount *mnt_master;	/* slave is on master->mnt_slave_list */
 	struct namespace *mnt_namespace; /* containing namespace */
+ 	struct list_head mnt_lustre_list; /* GNS mount list */
+ 	unsigned long mnt_last_used;	/* for GNS auto-umount (jiffies) */
 	int mnt_pinned;
 };
 
--- linux-2.6.16.21-0.8.orig/fs/9p/vfs_inode.c
+++ linux-2.6.16.21-0.8/fs/9p/vfs_inode.c
@@ -469,7 +469,7 @@ v9fs_vfs_create(struct inode *dir, struc
 	perm = unixmode2p9mode(v9ses, mode);
 
 	if (nd && nd->flags & LOOKUP_OPEN)
-		flags = nd->intent.open.flags - 1;
+		flags = nd->intent.flags - 1;
 	else
 		flags = O_RDWR;
 
--- linux-2.6.16.21-0.8.orig/fs/fuse/dir.c
+++ linux-2.6.16.21-0.8/fs/fuse/dir.c
@@ -242,7 +242,7 @@ static int fuse_create_open(struct inode
 	struct fuse_entry_out outentry;
 	struct fuse_file *ff;
 	struct file *file;
-	int flags = nd->intent.open.flags - 1;
+	int flags = nd->intent.flags - 1;
 
 	err = -ENOSYS;
 	if (fc->no_create)
