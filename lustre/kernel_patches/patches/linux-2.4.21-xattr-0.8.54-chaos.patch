 Documentation/Configure.help  |   66 ++
 arch/alpha/defconfig          |    7 
 arch/alpha/kernel/entry.S     |   12 
 arch/arm/defconfig            |    7 
 arch/arm/kernel/calls.S       |   24 
 arch/i386/defconfig           |    7 
 arch/ia64/defconfig           |    7 
 arch/ia64/kernel/entry.S      |   24 
 arch/m68k/defconfig           |    7 
 arch/mips/defconfig           |    7 
 arch/mips64/defconfig         |    7 
 arch/ppc/defconfig            |   14 
 arch/ppc64/kernel/misc.S      |    2 
 arch/s390/defconfig           |    7 
 arch/s390/kernel/entry.S      |   24 
 arch/s390x/defconfig          |    7 
 arch/s390x/kernel/entry.S     |   24 
 arch/s390x/kernel/wrapper32.S |   92 +++
 arch/sparc/defconfig          |    7 
 arch/sparc/kernel/systbls.S   |   10 
 arch/sparc64/defconfig        |    7 
 arch/sparc64/kernel/systbls.S |   20 
 fs/Config.in                  |   14 
 fs/Makefile                   |    3 
 fs/ext2/Makefile              |    4 
 fs/ext2/file.c                |    5 
 fs/ext2/ialloc.c              |    2 
 fs/ext2/inode.c               |   34 -
 fs/ext2/namei.c               |   14 
 fs/ext2/super.c               |   29 
 fs/ext2/symlink.c             |   14 
 fs/ext2/xattr.c               | 1212 +++++++++++++++++++++++++++++++++++++++++
 fs/ext2/xattr_user.c          |  103 +++
 fs/ext3/Makefile              |   10 
 fs/ext3/file.c                |    5 
 fs/ext3/ialloc.c              |    2 
 fs/ext3/inode.c               |   35 -
 fs/ext3/namei.c               |   21 
 fs/ext3/super.c               |   36 +
 fs/ext3/symlink.c             |   14 
 fs/ext3/xattr.c               | 1225 ++++++++++++++++++++++++++++++++++++++++++
 fs/ext3/xattr_user.c          |  111 +++
 fs/jfs/jfs_xattr.h            |    6 
 fs/jfs/xattr.c                |    6 
 fs/mbcache.c                  |  648 ++++++++++++++++++++++
 include/asm-arm/unistd.h      |    2 
 include/asm-ia64/unistd.h     |   13 
 include/asm-ppc64/unistd.h    |    2 
 include/asm-s390/unistd.h     |   15 
 include/asm-s390x/unistd.h    |   15 
 include/asm-sparc/unistd.h    |   24 
 include/asm-sparc64/unistd.h  |   24 
 include/linux/cache_def.h     |   15 
 include/linux/errno.h         |    4 
 include/linux/ext2_fs.h       |   31 -
 include/linux/ext2_xattr.h    |  157 +++++
 include/linux/ext3_fs.h       |   31 -
 include/linux/ext3_jbd.h      |    8 
 include/linux/ext3_xattr.h    |  157 +++++
 include/linux/fs.h            |    2 
 include/linux/mbcache.h       |   69 ++
 kernel/ksyms.c                |    4 
 mm/vmscan.c                   |   35 +
 fs/ext3/ext3-exports.c        |   14 +  
 64 files changed, 4355 insertions(+), 195 deletions(-)

Index: linux-2.4.21-chaos/Documentation/Configure.help
===================================================================
--- linux-2.4.21-chaos.orig/Documentation/Configure.help	2003-10-04 01:18:57.000000000 +0400
+++ linux-2.4.21-chaos/Documentation/Configure.help	2003-12-14 15:11:46.000000000 +0300
@@ -15939,6 +15939,39 @@
   be compiled as a module, and so this could be dangerous.  Most
   everyone wants to say Y here.
 
+Ext2 extended attributes
+CONFIG_EXT2_FS_XATTR
+  Extended attributes are name:value pairs associated with inodes by
+  the kernel or by users (see the attr(5) manual page, or visit
+  <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+Ext2 extended attribute block sharing
+CONFIG_EXT2_FS_XATTR_SHARING
+  This options enables code for sharing identical extended attribute
+  blocks among multiple inodes.
+
+  Usually, say Y.
+
+Ext2 extended user attributes
+CONFIG_EXT2_FS_XATTR_USER
+  This option enables extended user attributes on ext2. Processes can
+  associate extended user attributes with inodes to store additional
+  information such as the character encoding of files, etc. (see the
+  attr(5) manual page, or visit <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+Ext2 trusted extended attributes
+CONFIG_EXT2_FS_XATTR_TRUSTED
+  This option enables extended attributes on ext2 that are accessible
+  (and visible) only to users capable of CAP_SYS_ADMIN. Usually this
+  is only the super user. Trusted extended attributes are meant for
+  implementing system/security services.
+
+  If unsure, say N.
+
 Ext3 journalling file system support (EXPERIMENTAL)
 CONFIG_EXT3_FS
   This is the journalling version of the Second extended file system
@@ -16008,6 +16041,39 @@
 
   If unsure, say N.
 
+Ext3 extended attributes
+CONFIG_EXT3_FS_XATTR
+  Extended attributes are name:value pairs associated with inodes by
+  the kernel or by users (see the attr(5) manual page, or visit
+  <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+Ext3 extended attribute block sharing
+CONFIG_EXT3_FS_XATTR_SHARING
+  This options enables code for sharing identical extended attribute
+  blocks among multiple inodes.
+
+  Usually, say Y.
+
+Ext3 extended user attributes
+CONFIG_EXT3_FS_XATTR_USER
+  This option enables extended user attributes on ext3. Processes can
+  associate extended user attributes with inodes to store additional
+  information such as the character encoding of files, etc. (see the
+  attr(5) manual page, or visit <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+Ext3 trusted extended attributes
+CONFIG_EXT3_FS_XATTR_TRUSTED
+  This option enables extended attributes on ext3 that are accessible
+  (and visible) only to users capable of CAP_SYS_ADMIN. Usually this
+  is only the super user. Trusted extended attributes are meant for
+  implementing system/security services.
+
+  If unsure, say N.
+
 Journal Block Device support (JBD for ext3) (EXPERIMENTAL)
 CONFIG_JBD
   This is a generic journalling layer for block devices.  It is
Index: linux-2.4.21-chaos/fs/Config.in
===================================================================
--- linux-2.4.21-chaos.orig/fs/Config.in	2003-09-19 03:49:54.000000000 +0400
+++ linux-2.4.21-chaos/fs/Config.in	2003-12-14 15:11:46.000000000 +0300
@@ -108,6 +108,11 @@
 tristate 'ROM file system support' CONFIG_ROMFS_FS
 
 tristate 'Second extended fs support' CONFIG_EXT2_FS
+dep_mbool '  Ext2 extended attributes' CONFIG_EXT2_FS_XATTR $CONFIG_EXT2_FS
+dep_bool '    Ext2 extended attribute block sharing' \
+    CONFIG_EXT2_FS_XATTR_SHARING $CONFIG_EXT2_FS_XATTR
+dep_bool '    Ext2 extended user attributes' \
+    CONFIG_EXT2_FS_XATTR_USER $CONFIG_EXT2_FS_XATTR
 
 tristate 'System V/Xenix/V7/Coherent file system support' CONFIG_SYSV_FS
 
@@ -196,6 +201,10 @@
    bool "POSIX ACL helper functions" CONFIG_FS_POSIX_ACL
 fi
 
+# Meta block cache for Extended Attributes (ext2/ext3)
+#tristate 'Meta block cache' CONFIG_FS_MBCACHE
+define_tristate CONFIG_FS_MBCACHE y 
+
 mainmenu_option next_comment
 comment 'Partition Types'
 source fs/partitions/Config.in
Index: linux-2.4.21-chaos/fs/Makefile
===================================================================
--- linux-2.4.21-chaos.orig/fs/Makefile	2003-12-14 15:09:27.000000000 +0300
+++ linux-2.4.21-chaos/fs/Makefile	2003-12-14 15:11:46.000000000 +0300
@@ -95,6 +95,9 @@
 obj-$(CONFIG_NFS_ACL)		+= solaris_acl.o
 obj-$(CONFIG_NFSD_ACL)		+= solaris_acl.o
 
+export-objs += mbcache.o
+obj-$(CONFIG_FS_MBCACHE)	+= mbcache.o
+
 # persistent filesystems
 obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
 
Index: linux-2.4.21-chaos/fs/ext2/Makefile
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/Makefile	2002-05-08 01:53:46.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext2/Makefile	2003-12-14 15:11:46.000000000 +0300
@@ -13,4 +13,8 @@
 		ioctl.o namei.o super.o symlink.o
 obj-m    := $(O_TARGET)
 
+export-objs += xattr.o
+obj-$(CONFIG_EXT2_FS_XATTR) += xattr.o
+obj-$(CONFIG_EXT2_FS_XATTR_USER) += xattr_user.o
+
 include $(TOPDIR)/Rules.make
Index: linux-2.4.21-chaos/fs/ext2/file.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/file.c	2003-07-15 04:41:01.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext2/file.c	2003-12-14 15:11:46.000000000 +0300
@@ -20,6 +20,7 @@
 
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 #include <linux/sched.h>
 
 /*
@@ -55,4 +56,8 @@
 
 struct inode_operations ext2_file_inode_operations = {
 	truncate:	ext2_truncate,
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
 };
Index: linux-2.4.21-chaos/fs/ext2/ialloc.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/ialloc.c	2003-07-15 02:09:35.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext2/ialloc.c	2003-12-14 15:11:46.000000000 +0300
@@ -15,6 +15,7 @@
 #include <linux/config.h>
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 #include <linux/locks.h>
 #include <linux/quotaops.h>
 
@@ -167,6 +168,7 @@
 	 */
 	if (!is_bad_inode(inode)) {
 		/* Quota is already initialized in iput() */
+		ext2_xattr_delete_inode(inode);
 	    	DQUOT_FREE_INODE(inode);
 		DQUOT_DROP(inode);
 	}
Index: linux-2.4.21-chaos/fs/ext2/inode.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/inode.c	2003-07-15 04:41:01.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext2/inode.c	2003-12-14 15:11:46.000000000 +0300
@@ -53,9 +65,7 @@
 {
 	lock_kernel();
 
-	if (is_bad_inode(inode) ||
-	    inode->i_ino == EXT2_ACL_IDX_INO ||
-	    inode->i_ino == EXT2_ACL_DATA_INO)
+	if (is_bad_inode(inode))
 		goto no_delete;
 	inode->u.ext2_i.i_dtime	= CURRENT_TIME;
 	mark_inode_dirty(inode);
@@ -802,6 +812,8 @@
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode)))
 		return;
+	if (ext2_inode_is_fast_symlink(inode))
+		return;
 	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
 		return;
 
@@ -904,8 +916,7 @@
 	unsigned long offset;
 	struct ext2_group_desc * gdp;
 
-	if ((inode->i_ino != EXT2_ROOT_INO && inode->i_ino != EXT2_ACL_IDX_INO &&
-	     inode->i_ino != EXT2_ACL_DATA_INO &&
+	if ((inode->i_ino != EXT2_ROOT_INO &&
 	     inode->i_ino < EXT2_FIRST_INO(inode->i_sb)) ||
 	    inode->i_ino > le32_to_cpu(inode->i_sb->u.ext2_sb.s_es->s_inodes_count)) {
 		ext2_error (inode->i_sb, "ext2_read_inode",
@@ -990,10 +1001,7 @@
 	for (block = 0; block < EXT2_N_BLOCKS; block++)
 		inode->u.ext2_i.i_data[block] = raw_inode->i_block[block];
 
-	if (inode->i_ino == EXT2_ACL_IDX_INO ||
-	    inode->i_ino == EXT2_ACL_DATA_INO)
-		/* Nothing to do */ ;
-	else if (S_ISREG(inode->i_mode)) {
+	if (S_ISREG(inode->i_mode)) {
 		inode->i_op = &ext2_file_inode_operations;
 		inode->i_fop = &ext2_file_operations;
 		inode->i_mapping->a_ops = &ext2_aops;
@@ -1002,12 +1010,14 @@
		if (ext2_inode_is_fast_symlink(inode))
 			inode->i_op = &ext2_fast_symlink_inode_operations;
 		else {
-			inode->i_op = &page_symlink_inode_operations;
+			inode->i_op = &ext2_symlink_inode_operations;
 			inode->i_mapping->a_ops = &ext2_aops;
 		}
-	} else 
+	} else {
+		inode->i_op = &ext2_special_inode_operations;
 		init_special_inode(inode, inode->i_mode,
 				   le32_to_cpu(raw_inode->i_block[0]));
+	}
 	brelse (bh);
 	inode->i_attr_flags = 0;
 	ext2_set_inode_flags(inode);
Index: linux-2.4.21-chaos/fs/ext2/namei.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/namei.c	2002-05-08 01:53:46.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext2/namei.c	2003-12-14 15:11:46.000000000 +0300
@@ -31,6 +31,7 @@
 
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 #include <linux/pagemap.h>
 
 /*
@@ -136,7 +137,7 @@
 
 	if (l > sizeof (inode->u.ext2_i.i_data)) {
 		/* slow symlink */
-		inode->i_op = &page_symlink_inode_operations;
+		inode->i_op = &ext2_symlink_inode_operations;
 		inode->i_mapping->a_ops = &ext2_aops;
 		err = block_symlink(inode, symname, l);
 		if (err)
@@ -345,4 +346,15 @@
 	rmdir:		ext2_rmdir,
 	mknod:		ext2_mknod,
 	rename:		ext2_rename,
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
+};
+
+struct inode_operations ext2_special_inode_operations = {
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
 };
Index: linux-2.4.21-chaos/fs/ext2/super.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/super.c	2003-02-15 01:59:09.000000000 +0300
+++ linux-2.4.21-chaos/fs/ext2/super.c	2003-12-14 15:11:46.000000000 +0300
@@ -21,6 +21,7 @@
 #include <linux/string.h>
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/locks.h>
@@ -125,6 +126,7 @@
 	int db_count;
 	int i;
 
+	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = EXT2_SB(sb)->s_es;
 
@@ -175,6 +177,13 @@
 	     this_char = strtok (NULL, ",")) {
 		if ((value = strchr (this_char, '=')) != NULL)
 			*value++ = 0;
+#ifdef CONFIG_EXT2_FS_XATTR_USER
+		if (!strcmp (this_char, "user_xattr"))
+			set_opt (*mount_options, XATTR_USER);
+		else if (!strcmp (this_char, "nouser_xattr"))
+			clear_opt (*mount_options, XATTR_USER);
+		else
+#endif
 		if (!strcmp (this_char, "bsddf"))
 			clear_opt (*mount_options, MINIX_DF);
 		else if (!strcmp (this_char, "nouid32")) {
@@ -424,6 +433,9 @@
 	    blocksize = BLOCK_SIZE;
 
 	sb->u.ext2_sb.s_mount_opt = 0;
+#ifdef CONFIG_EXT2_FS_XATTR_USER
+	/* set_opt (sb->u.ext2_sb.s_mount_opt, XATTR_USER); */
+#endif
 	if (!parse_options ((char *) data, &sb_block, &resuid, &resgid,
 	    &sb->u.ext2_sb.s_mount_opt)) {
 		return NULL;
@@ -813,12 +825,27 @@
 
 static int __init init_ext2_fs(void)
 {
-        return register_filesystem(&ext2_fs_type);
+	int error = init_ext2_xattr();
+	if (error)
+		return error;
+	error = init_ext2_xattr_user();
+	if (error)
+		goto fail;
+	error = register_filesystem(&ext2_fs_type);
+	if (!error)
+		return 0;
+
+	exit_ext2_xattr_user();
+fail:
+	exit_ext2_xattr();
+	return error;
 }
 
 static void __exit exit_ext2_fs(void)
 {
 	unregister_filesystem(&ext2_fs_type);
+	exit_ext2_xattr_user();
+	exit_ext2_xattr();
 }
 
 EXPORT_NO_SYMBOLS;
Index: linux-2.4.21-chaos/fs/ext2/symlink.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/symlink.c	2002-05-08 01:53:46.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext2/symlink.c	2003-12-14 15:11:46.000000000 +0300
@@ -19,6 +19,7 @@
 
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
 
 static int ext2_readlink(struct dentry *dentry, char *buffer, int buflen)
 {
@@ -32,7 +33,20 @@
 	return vfs_follow_link(nd, s);
 }
 
+struct inode_operations ext2_symlink_inode_operations = {
+	readlink:	page_readlink,
+	follow_link:	page_follow_link,
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
+};
+
 struct inode_operations ext2_fast_symlink_inode_operations = {
 	readlink:	ext2_readlink,
 	follow_link:	ext2_follow_link,
+	setxattr:	ext2_setxattr,
+	getxattr:	ext2_getxattr,
+	listxattr:	ext2_listxattr,
+	removexattr:	ext2_removexattr,
 };
Index: linux-2.4.21-chaos/fs/ext2/xattr.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/xattr.c	2003-01-30 13:24:37.000000000 +0300
+++ linux-2.4.21-chaos/fs/ext2/xattr.c	2003-12-14 15:11:46.000000000 +0300
@@ -0,0 +1,1212 @@
+/*
+ * linux/fs/ext2/xattr.c
+ *
+ * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ *
+ * Fix by Harrison Xing <harrison@mountainviewdata.com>.
+ * Extended attributes for symlinks and special files added per
+ *  suggestion of Luka Renko <luka.renko@hermes.si>.
+ */
+
+/*
+ * Extended attributes are stored on disk blocks allocated outside of
+ * any inode. The i_file_acl field is then made to point to this allocated
+ * block. If all extended attributes of an inode are identical, these
+ * inodes may share the same extended attribute block. Such situations
+ * are automatically detected by keeping a cache of recent attribute block
+ * numbers and hashes over the block's contents in memory.
+ *
+ *
+ * Extended attribute block layout:
+ *
+ *   +------------------+
+ *   | header           |
+ *   | entry 1          | |
+ *   | entry 2          | | growing downwards
+ *   | entry 3          | v
+ *   | four null bytes  |
+ *   | . . .            |
+ *   | value 1          | ^
+ *   | value 3          | | growing upwards
+ *   | value 2          | |
+ *   +------------------+
+ *
+ * The block header is followed by multiple entry descriptors. These entry
+ * descriptors are variable in size, and alligned to EXT2_XATTR_PAD
+ * byte boundaries. The entry descriptors are sorted by attribute name,
+ * so that two extended attribute blocks can be compared efficiently.
+ *
+ * Attribute values are aligned to the end of the block, stored in
+ * no specific order. They are also padded to EXT2_XATTR_PAD byte
+ * boundaries. No additional gaps are left between them.
+ *
+ * Locking strategy
+ * ----------------
+ * The VFS already holds the BKL and the inode->i_sem semaphore when any of
+ * the xattr inode operations are called, so we are guaranteed that only one
+ * processes accesses extended attributes of an inode at any time.
+ *
+ * For writing we also grab the ext2_xattr_sem semaphore. This ensures that
+ * only a single process is modifying an extended attribute block, even
+ * if the block is shared among inodes.
+ *
+ * Note for porting to 2.5
+ * -----------------------
+ * The BKL will no longer be held in the xattr inode operations.
+ */
+
+#include <linux/module.h>
+#include <linux/locks.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
+#include <linux/mbcache.h>
+#include <linux/quotaops.h>
+#include <asm/semaphore.h>
+#include <linux/compatmac.h>
+
+/* These symbols may be needed by a module. */
+EXPORT_SYMBOL(ext2_xattr_register);
+EXPORT_SYMBOL(ext2_xattr_unregister);
+EXPORT_SYMBOL(ext2_xattr_get);
+EXPORT_SYMBOL(ext2_xattr_list);
+EXPORT_SYMBOL(ext2_xattr_set);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+# define mark_buffer_dirty(bh) mark_buffer_dirty(bh, 1)
+#endif
+
+#define HDR(bh) ((struct ext2_xattr_header *)((bh)->b_data))
+#define ENTRY(ptr) ((struct ext2_xattr_entry *)(ptr))
+#define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)
+#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
+
+#ifdef EXT2_XATTR_DEBUG
+# define ea_idebug(inode, f...) do { \
+		printk(KERN_DEBUG "inode %s:%ld: ", \
+			kdevname(inode->i_dev), inode->i_ino); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+# define ea_bdebug(bh, f...) do { \
+		printk(KERN_DEBUG "block %s:%ld: ", \
+			kdevname(bh->b_dev), bh->b_blocknr); \
+		printk(f); \
+		printk("\n"); \
+	} while (0)
+#else
+# define ea_idebug(f...)
+# define ea_bdebug(f...)
+#endif
+
+static int ext2_xattr_set2(struct inode *, struct buffer_head *,
+			   struct ext2_xattr_header *);
+
+#ifdef CONFIG_EXT2_FS_XATTR_SHARING
+
+static int ext2_xattr_cache_insert(struct buffer_head *);
+static struct buffer_head *ext2_xattr_cache_find(struct inode *,
+						 struct ext2_xattr_header *);
+static void ext2_xattr_cache_remove(struct buffer_head *);
+static void ext2_xattr_rehash(struct ext2_xattr_header *,
+			      struct ext2_xattr_entry *);
+
+static struct mb_cache *ext2_xattr_cache;
+
+#else
+# define ext2_xattr_cache_insert(bh) 0
+# define ext2_xattr_cache_find(inode, header) NULL
+# define ext2_xattr_cache_remove(bh) while(0) {}
+# define ext2_xattr_rehash(header, entry) while(0) {}
+#endif
+
+/*
+ * If a file system does not share extended attributes among inodes,
+ * we should not need the ext2_xattr_sem semaphore. However, the
+ * filesystem may still contain shared blocks, so we always take
+ * the lock.
+ */
+
+DECLARE_MUTEX(ext2_xattr_sem);
+
+static inline int
+ext2_xattr_new_block(struct inode *inode, int * errp, int force)
+{
+	struct super_block *sb = inode->i_sb;
+	int goal = le32_to_cpu(EXT2_SB(sb)->s_es->s_first_data_block) +
+		EXT2_I(inode)->i_block_group * EXT2_BLOCKS_PER_GROUP(sb);
+
+	/* How can we enforce the allocation? */
+	int block = ext2_new_block(inode, goal, 0, 0, errp);
+#ifdef OLD_QUOTAS
+	if (!*errp)
+		inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+#endif
+	return block;
+}
+
+static inline int
+ext2_xattr_quota_alloc(struct inode *inode, int force)
+{
+	/* How can we enforce the allocation? */
+#ifdef OLD_QUOTAS
+	int error = DQUOT_ALLOC_BLOCK(inode->i_sb, inode, 1);
+	if (!error)
+		inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+#else
+	int error = DQUOT_ALLOC_BLOCK(inode, 1);
+#endif
+	return error;
+}
+
+#ifdef OLD_QUOTAS
+
+static inline void
+ext2_xattr_quota_free(struct inode *inode)
+{
+	DQUOT_FREE_BLOCK(inode->i_sb, inode, 1);
+	inode->i_blocks -= inode->i_sb->s_blocksize >> 9;
+}
+
+static inline void
+ext2_xattr_free_block(struct inode * inode, unsigned long block)
+{
+	ext2_free_blocks(inode, block, 1);
+	inode->i_blocks -= inode->i_sb->s_blocksize >> 9;
+}
+
+#else
+# define ext2_xattr_quota_free(inode) \
+	DQUOT_FREE_BLOCK(inode, 1)
+# define ext2_xattr_free_block(inode, block) \
+	ext2_free_blocks(inode, block, 1)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
+
+static inline struct buffer_head *
+sb_bread(struct super_block *sb, int block)
+{
+	return bread(sb->s_dev, block, sb->s_blocksize);
+}
+
+static inline struct buffer_head *
+sb_getblk(struct super_block *sb, int block)
+{
+	return getblk(sb->s_dev, block, sb->s_blocksize);
+}
+
+#endif
+
+struct ext2_xattr_handler *ext2_xattr_handlers[EXT2_XATTR_INDEX_MAX];
+rwlock_t ext2_handler_lock = RW_LOCK_UNLOCKED;
+
+int
+ext2_xattr_register(int name_index, struct ext2_xattr_handler *handler)
+{
+	int error = -EINVAL;
+
+	if (name_index > 0 && name_index <= EXT2_XATTR_INDEX_MAX) {
+		write_lock(&ext2_handler_lock);
+		if (!ext2_xattr_handlers[name_index-1]) {
+			ext2_xattr_handlers[name_index-1] = handler;
+			error = 0;
+		}
+		write_unlock(&ext2_handler_lock);
+	}
+	return error;
+}
+
+void
+ext2_xattr_unregister(int name_index, struct ext2_xattr_handler *handler)
+{
+	if (name_index > 0 && name_index <= EXT2_XATTR_INDEX_MAX) {
+		write_lock(&ext2_handler_lock);
+		ext2_xattr_handlers[name_index-1] = NULL;
+		write_unlock(&ext2_handler_lock);
+	}
+}
+
+static inline const char *
+strcmp_prefix(const char *a, const char *a_prefix)
+{
+	while (*a_prefix && *a == *a_prefix) {
+		a++;
+		a_prefix++;
+	}
+	return *a_prefix ? NULL : a;
+}
+
+/*
+ * Decode the extended attribute name, and translate it into
+ * the name_index and name suffix.
+ */
+static struct ext2_xattr_handler *
+ext2_xattr_resolve_name(const char **name)
+{
+	struct ext2_xattr_handler *handler = NULL;
+	int i;
+
+	if (!*name)
+		return NULL;
+	read_lock(&ext2_handler_lock);
+	for (i=0; i<EXT2_XATTR_INDEX_MAX; i++) {
+		if (ext2_xattr_handlers[i]) {
+			const char *n = strcmp_prefix(*name,
+				ext2_xattr_handlers[i]->prefix);
+			if (n) {
+				handler = ext2_xattr_handlers[i];
+				*name = n;
+				break;
+			}
+		}
+	}
+	read_unlock(&ext2_handler_lock);
+	return handler;
+}
+
+static inline struct ext2_xattr_handler *
+ext2_xattr_handler(int name_index)
+{
+	struct ext2_xattr_handler *handler = NULL;
+	if (name_index > 0 && name_index <= EXT2_XATTR_INDEX_MAX) {
+		read_lock(&ext2_handler_lock);
+		handler = ext2_xattr_handlers[name_index-1];
+		read_unlock(&ext2_handler_lock);
+	}
+	return handler;
+}
+
+/*
+ * Inode operation getxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+ext2_getxattr(struct dentry *dentry, const char *name,
+	      void *buffer, size_t size)
+{
+	struct ext2_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = ext2_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->get(inode, name, buffer, size);
+}
+
+/*
+ * Inode operation listxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+ssize_t
+ext2_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+	return ext2_xattr_list(dentry->d_inode, buffer, size);
+}
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+ext2_setxattr(struct dentry *dentry, const char *name,
+	      const void *value, size_t size, int flags)
+{
+	struct ext2_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	if (size == 0)
+		value = "";  /* empty EA, do not remove */
+	handler = ext2_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->set(inode, name, value, size, flags);
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ * BKL held [before 2.5.x]
+ */
+int
+ext2_removexattr(struct dentry *dentry, const char *name)
+{
+	struct ext2_xattr_handler *handler;
+	struct inode *inode = dentry->d_inode;
+
+	handler = ext2_xattr_resolve_name(&name);
+	if (!handler)
+		return -ENOTSUP;
+	return handler->set(inode, name, NULL, 0, XATTR_REPLACE);
+}
+
+/*
+ * ext2_xattr_get()
+ *
+ * Copy an extended attribute into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+ext2_xattr_get(struct inode *inode, int name_index, const char *name,
+	       void *buffer, size_t buffer_size)
+{
+	struct buffer_head *bh = NULL;
+	struct ext2_xattr_entry *entry;
+	unsigned int block, size;
+	char *end;
+	int name_len, error;
+
+	ea_idebug(inode, "name=%d.%s, buffer=%p, buffer_size=%ld",
+		  name_index, name, buffer, (long)buffer_size);
+
+	if (name == NULL)
+		return -EINVAL;
+	if (!EXT2_I(inode)->i_file_acl)
+		return -ENOATTR;
+	block = EXT2_I(inode)->i_file_acl;
+	ea_idebug(inode, "reading block %d", block);
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		return -EIO;
+	ea_bdebug(bh, "b_count=%d, refcount=%d",
+		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
+	end = bh->b_data + bh->b_size;
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+bad_block:	ext2_error(inode->i_sb, "ext2_xattr_get",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* find named attribute */
+	name_len = strlen(name);
+
+	error = -ERANGE;
+	if (name_len > 255)
+		goto cleanup;
+	entry = FIRST_ENTRY(bh);
+	while (!IS_LAST_ENTRY(entry)) {
+		struct ext2_xattr_entry *next =
+			EXT2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		if (name_index == entry->e_name_index &&
+		    name_len == entry->e_name_len &&
+		    memcmp(name, entry->e_name, name_len) == 0)
+			goto found;
+		entry = next;
+	}
+	/* Check the remaining name entries */
+	while (!IS_LAST_ENTRY(entry)) {
+		struct ext2_xattr_entry *next =
+			EXT2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+		entry = next;
+	}
+	if (ext2_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	error = -ENOATTR;
+	goto cleanup;
+found:
+	/* check the buffer size */
+	if (entry->e_value_block != 0)
+		goto bad_block;
+	size = le32_to_cpu(entry->e_value_size);
+	if (size > inode->i_sb->s_blocksize ||
+	    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)
+		goto bad_block;
+
+	if (ext2_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	if (buffer) {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+		/* return value of attribute */
+		memcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),
+			size);
+	}
+	error = size;
+
+cleanup:
+	brelse(bh);
+
+	return error;
+}
+
+/*
+ * ext2_xattr_list()
+ *
+ * Copy a list of attribute names into the buffer
+ * provided, or compute the buffer size required.
+ * Buffer is NULL to compute the size of the buffer required.
+ *
+ * Returns a negative error number on failure, or the number of bytes
+ * used / required on success.
+ */
+int
+ext2_xattr_list(struct inode *inode, char *buffer, size_t buffer_size)
+{
+	struct buffer_head *bh = NULL;
+	struct ext2_xattr_entry *entry;
+	unsigned int block, size = 0;
+	char *buf, *end;
+	int error;
+
+	ea_idebug(inode, "buffer=%p, buffer_size=%ld",
+		  buffer, (long)buffer_size);
+
+	if (!EXT2_I(inode)->i_file_acl)
+		return 0;
+	block = EXT2_I(inode)->i_file_acl;
+	ea_idebug(inode, "reading block %d", block);
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		return -EIO;
+	ea_bdebug(bh, "b_count=%d, refcount=%d",
+		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
+	end = bh->b_data + bh->b_size;
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+bad_block:	ext2_error(inode->i_sb, "ext2_xattr_list",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		error = -EIO;
+		goto cleanup;
+	}
+	/* compute the size required for the list of attribute names */
+	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
+	     entry = EXT2_XATTR_NEXT(entry)) {
+		struct ext2_xattr_handler *handler;
+		struct ext2_xattr_entry *next =
+			EXT2_XATTR_NEXT(entry);
+		if ((char *)next >= end)
+			goto bad_block;
+
+		handler = ext2_xattr_handler(entry->e_name_index);
+		if (handler)
+			size += handler->list(NULL, inode, entry->e_name,
+					      entry->e_name_len);
+	}
+
+	if (ext2_xattr_cache_insert(bh))
+		ea_idebug(inode, "cache insert failed");
+	if (!buffer) {
+		error = size;
+		goto cleanup;
+	} else {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto cleanup;
+	}
+
+	/* list the attribute names */
+	buf = buffer;
+	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
+	     entry = EXT2_XATTR_NEXT(entry)) {
+		struct ext2_xattr_handler *handler;
+		
+		handler = ext2_xattr_handler(entry->e_name_index);
+		if (handler)
+			buf += handler->list(buf, inode, entry->e_name,
+					     entry->e_name_len);
+	}
+	error = size;
+
+cleanup:
+	brelse(bh);
+
+	return error;
+}
+
+/*
+ * If the EXT2_FEATURE_COMPAT_EXT_ATTR feature of this file system is
+ * not set, set it.
+ */
+static void ext2_xattr_update_super_block(struct super_block *sb)
+{
+	if (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))
+		return;
+
+	lock_super(sb);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	EXT2_SB(sb)->s_feature_compat |= EXT2_FEATURE_COMPAT_EXT_ATTR;
+#endif
+	EXT2_SB(sb)->s_es->s_feature_compat |=
+		cpu_to_le32(EXT2_FEATURE_COMPAT_EXT_ATTR);
+	sb->s_dirt = 1;
+	mark_buffer_dirty(EXT2_SB(sb)->s_sbh);
+	unlock_super(sb);
+}
+
+/*
+ * ext2_xattr_set()
+ *
+ * Create, replace or remove an extended attribute for this inode. Buffer
+ * is NULL to remove an existing extended attribute, and non-NULL to
+ * either replace an existing extended attribute, or create a new extended
+ * attribute. The flags XATTR_REPLACE and XATTR_CREATE
+ * specify that an extended attribute must exist and must not exist
+ * previous to the call, respectively.
+ *
+ * Returns 0, or a negative error number on failure.
+ */
+int
+ext2_xattr_set(struct inode *inode, int name_index, const char *name,
+	       const void *value, size_t value_len, int flags)
+{
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *bh = NULL;
+	struct ext2_xattr_header *header = NULL;
+	struct ext2_xattr_entry *here, *last;
+	unsigned int name_len;
+	int block = EXT2_I(inode)->i_file_acl;
+	int min_offs = sb->s_blocksize, not_found = 1, free, error;
+	char *end;
+	
+	/*
+	 * header -- Points either into bh, or to a temporarily
+	 *           allocated buffer.
+	 * here -- The named entry found, or the place for inserting, within
+	 *         the block pointed to by header.
+	 * last -- Points right after the last named entry within the block
+	 *         pointed to by header.
+	 * min_offs -- The offset of the first value (values are aligned
+	 *             towards the end of the block).
+	 * end -- Points right after the block pointed to by header.
+	 */
+	
+	ea_idebug(inode, "name=%d.%s, value=%p, value_len=%ld",
+		  name_index, name, value, (long)value_len);
+
+	if (IS_RDONLY(inode))
+		return -EROFS;
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		return -EPERM;
+	if (value == NULL)
+		value_len = 0;
+	if (name == NULL)
+		return -EINVAL;
+	name_len = strlen(name);
+	if (name_len > 255 || value_len > sb->s_blocksize)
+		return -ERANGE;
+	down(&ext2_xattr_sem);
+
+	if (block) {
+		/* The inode already has an extended attribute block. */
+
+		bh = sb_bread(sb, block);
+		error = -EIO;
+		if (!bh)
+			goto cleanup;
+		ea_bdebug(bh, "b_count=%d, refcount=%d",
+			atomic_read(&(bh->b_count)),
+			le32_to_cpu(HDR(bh)->h_refcount));
+		header = HDR(bh);
+		end = bh->b_data + bh->b_size;
+		if (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
+		    header->h_blocks != cpu_to_le32(1)) {
+bad_block:		ext2_error(sb, "ext2_xattr_set",
+				"inode %ld: bad block %d", inode->i_ino, block);
+			error = -EIO;
+			goto cleanup;
+		}
+		/* Find the named attribute. */
+		here = FIRST_ENTRY(bh);
+		while (!IS_LAST_ENTRY(here)) {
+			struct ext2_xattr_entry *next = EXT2_XATTR_NEXT(here);
+			if ((char *)next >= end)
+				goto bad_block;
+			if (!here->e_value_block && here->e_value_size) {
+				int offs = le16_to_cpu(here->e_value_offs);
+				if (offs < min_offs)
+					min_offs = offs;
+			}
+			not_found = name_index - here->e_name_index;
+			if (!not_found)
+				not_found = name_len - here->e_name_len;
+			if (!not_found)
+				not_found = memcmp(name, here->e_name,name_len);
+			if (not_found <= 0)
+				break;
+			here = next;
+		}
+		last = here;
+		/* We still need to compute min_offs and last. */
+		while (!IS_LAST_ENTRY(last)) {
+			struct ext2_xattr_entry *next = EXT2_XATTR_NEXT(last);
+			if ((char *)next >= end)
+				goto bad_block;
+			if (!last->e_value_block && last->e_value_size) {
+				int offs = le16_to_cpu(last->e_value_offs);
+				if (offs < min_offs)
+					min_offs = offs;
+			}
+			last = next;
+		}
+
+		/* Check whether we have enough space left. */
+		free = min_offs - ((char*)last - (char*)header) - sizeof(__u32);
+	} else {
+		/* We will use a new extended attribute block. */
+		free = sb->s_blocksize -
+			sizeof(struct ext2_xattr_header) - sizeof(__u32);
+		here = last = NULL;  /* avoid gcc uninitialized warning. */
+	}
+
+	if (not_found) {
+		/* Request to remove a nonexistent attribute? */
+		error = -ENOATTR;
+		if (flags & XATTR_REPLACE)
+			goto cleanup;
+		error = 0;
+		if (value == NULL)
+			goto cleanup;
+		else
+			free -= EXT2_XATTR_LEN(name_len);
+	} else {
+		/* Request to create an existing attribute? */
+		error = -EEXIST;
+		if (flags & XATTR_CREATE)
+			goto cleanup;
+		if (!here->e_value_block && here->e_value_size) {
+			unsigned int size = le32_to_cpu(here->e_value_size);
+
+			if (le16_to_cpu(here->e_value_offs) + size > 
+			    sb->s_blocksize || size > sb->s_blocksize)
+				goto bad_block;
+			free += EXT2_XATTR_SIZE(size);
+		}
+	}
+	free -= EXT2_XATTR_SIZE(value_len);
+	error = -ENOSPC;
+	if (free < 0)
+		goto cleanup;
+
+	/* Here we know that we can set the new attribute. */
+
+	if (header) {
+		if (header->h_refcount == cpu_to_le32(1)) {
+			ea_bdebug(bh, "modifying in-place");
+			ext2_xattr_cache_remove(bh);
+		} else {
+			int offset;
+
+			ea_bdebug(bh, "cloning");
+			header = kmalloc(bh->b_size, GFP_KERNEL);
+			error = -ENOMEM;
+			if (header == NULL)
+				goto cleanup;
+			memcpy(header, HDR(bh), bh->b_size);
+			header->h_refcount = cpu_to_le32(1);
+			offset = (char *)header - bh->b_data;
+			here = ENTRY((char *)here + offset);
+			last = ENTRY((char *)last + offset);
+		}
+	} else {
+		/* Allocate a buffer where we construct the new block. */
+		header = kmalloc(sb->s_blocksize, GFP_KERNEL);
+		error = -ENOMEM;
+		if (header == NULL)
+			goto cleanup;
+		memset(header, 0, sb->s_blocksize);
+		end = (char *)header + sb->s_blocksize;
+		header->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);
+		header->h_blocks = header->h_refcount = cpu_to_le32(1);
+		last = here = ENTRY(header+1);
+	}
+
+	if (not_found) {
+		/* Insert the new name. */
+		int size = EXT2_XATTR_LEN(name_len);
+		int rest = (char *)last - (char *)here;
+		memmove((char *)here + size, here, rest);
+		memset(here, 0, size);
+		here->e_name_index = name_index;
+		here->e_name_len = name_len;
+		memcpy(here->e_name, name, name_len);
+	} else {
+		/* Remove the old value. */
+		if (!here->e_value_block && here->e_value_size) {
+			char *first_val = (char *)header + min_offs;
+			int offs = le16_to_cpu(here->e_value_offs);
+			char *val = (char *)header + offs;
+			size_t size = EXT2_XATTR_SIZE(
+				le32_to_cpu(here->e_value_size));
+			memmove(first_val + size, first_val, val - first_val);
+			memset(first_val, 0, size);
+			here->e_value_offs = 0;
+			min_offs += size;
+
+			/* Adjust all value offsets. */
+			last = ENTRY(header+1);
+			while (!IS_LAST_ENTRY(last)) {
+				int o = le16_to_cpu(last->e_value_offs);
+				if (!last->e_value_block && o < offs)
+					last->e_value_offs =
+						cpu_to_le16(o + size);
+				last = EXT2_XATTR_NEXT(last);
+			}
+		}
+		if (value == NULL) {
+			/* Remove this attribute. */
+			if (EXT2_XATTR_NEXT(ENTRY(header+1)) == last) {
+				/* This block is now empty. */
+				error = ext2_xattr_set2(inode, bh, NULL);
+				goto cleanup;
+			} else {
+				/* Remove the old name. */
+				int size = EXT2_XATTR_LEN(name_len);
+				last = ENTRY((char *)last - size);
+				memmove(here, (char*)here + size,
+					(char*)last - (char*)here);
+				memset(last, 0, size);
+			}
+		}
+	}
+
+	if (value != NULL) {
+		/* Insert the new value. */
+		here->e_value_size = cpu_to_le32(value_len);
+		if (value_len) {
+			size_t size = EXT2_XATTR_SIZE(value_len);
+			char *val = (char *)header + min_offs - size;
+			here->e_value_offs =
+				cpu_to_le16((char *)val - (char *)header);
+			memset(val + size - EXT2_XATTR_PAD, 0,
+			       EXT2_XATTR_PAD); /* Clear the pad bytes. */
+			memcpy(val, value, value_len);
+		}
+	}
+	ext2_xattr_rehash(header, here);
+
+	error = ext2_xattr_set2(inode, bh, header);
+
+cleanup:
+	brelse(bh);
+	if (!(bh && header == HDR(bh)))
+		kfree(header);
+	up(&ext2_xattr_sem);
+
+	return error;
+}
+
+/*
+ * Second half of ext2_xattr_set(): Update the file system.
+ */
+static int
+ext2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,
+		struct ext2_xattr_header *header)
+{
+	struct super_block *sb = inode->i_sb;
+	struct buffer_head *new_bh = NULL;
+	int error;
+
+	if (header) {
+		new_bh = ext2_xattr_cache_find(inode, header);
+		if (new_bh) {
+			/*
+			 * We found an identical block in the cache.
+			 * The old block will be released after updating
+			 * the inode.
+			 */
+			ea_bdebug(old_bh, "reusing block %ld",
+				new_bh->b_blocknr);
+			
+			error = -EDQUOT;
+			if (ext2_xattr_quota_alloc(inode, 1))
+				goto cleanup;
+			
+			HDR(new_bh)->h_refcount = cpu_to_le32(
+				le32_to_cpu(HDR(new_bh)->h_refcount) + 1);
+			ea_bdebug(new_bh, "refcount now=%d",
+				le32_to_cpu(HDR(new_bh)->h_refcount));
+		} else if (old_bh && header == HDR(old_bh)) {
+			/* Keep this block. */
+			new_bh = old_bh;
+			(void)ext2_xattr_cache_insert(new_bh);
+		} else {
+			/* We need to allocate a new block */
+			int force = EXT2_I(inode)->i_file_acl != 0;
+			int block = ext2_xattr_new_block(inode, &error, force);
+			if (error)
+				goto cleanup;
+			ea_idebug(inode, "creating block %d", block);
+
+			new_bh = sb_getblk(sb, block);
+			if (!new_bh) {
+				ext2_xattr_free_block(inode, block);
+				error = -EIO;
+				goto cleanup;
+			}
+			lock_buffer(new_bh);
+			memcpy(new_bh->b_data, header, new_bh->b_size);
+			mark_buffer_uptodate(new_bh, 1);
+			unlock_buffer(new_bh);
+			(void)ext2_xattr_cache_insert(new_bh);
+			
+			ext2_xattr_update_super_block(sb);
+		}
+		mark_buffer_dirty(new_bh);
+		if (IS_SYNC(inode)) {
+			ll_rw_block(WRITE, 1, &new_bh);
+			wait_on_buffer(new_bh); 
+			error = -EIO;
+			if (buffer_req(new_bh) && !buffer_uptodate(new_bh))
+				goto cleanup;
+		}
+	}
+
+	/* Update the inode. */
+	EXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;
+	inode->i_ctime = CURRENT_TIME;
+	if (IS_SYNC(inode)) {
+		error = ext2_sync_inode (inode);
+		if (error)
+			goto cleanup;
+	} else
+		mark_inode_dirty(inode);
+
+	error = 0;
+	if (old_bh && old_bh != new_bh) {
+		/*
+		 * If there was an old block, and we are not still using it,
+		 * we now release the old block.
+		*/
+		unsigned int refcount = le32_to_cpu(HDR(old_bh)->h_refcount);
+
+		if (refcount == 1) {
+			/* Free the old block. */
+			ea_bdebug(old_bh, "freeing");
+			ext2_xattr_free_block(inode, old_bh->b_blocknr);
+			mark_buffer_clean(old_bh);
+		} else {
+			/* Decrement the refcount only. */
+			refcount--;
+			HDR(old_bh)->h_refcount = cpu_to_le32(refcount);
+			ext2_xattr_quota_free(inode);
+			mark_buffer_dirty(old_bh);
+			ea_bdebug(old_bh, "refcount now=%d", refcount);
+		}
+	}
+
+cleanup:
+	if (old_bh != new_bh)
+		brelse(new_bh);
+
+	return error;
+}
+
+/*
+ * ext2_xattr_delete_inode()
+ *
+ * Free extended attribute resources associated with this inode. This
+ * is called immediately before an inode is freed.
+ */
+void
+ext2_xattr_delete_inode(struct inode *inode)
+{
+	struct buffer_head *bh;
+	unsigned int block = EXT2_I(inode)->i_file_acl;
+
+	if (!block)
+		return;
+	down(&ext2_xattr_sem);
+
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh) {
+		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
+			"inode %ld: block %d read error", inode->i_ino, block);
+		goto cleanup;
+	}
+	ea_bdebug(bh, "b_count=%d", atomic_read(&(bh->b_count)));
+	if (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
+	    HDR(bh)->h_blocks != cpu_to_le32(1)) {
+		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
+			"inode %ld: bad block %d", inode->i_ino, block);
+		goto cleanup;
+	}
+	ea_bdebug(bh, "refcount now=%d", le32_to_cpu(HDR(bh)->h_refcount) - 1);
+	if (HDR(bh)->h_refcount == cpu_to_le32(1)) {
+		ext2_xattr_cache_remove(bh);
+		ext2_xattr_free_block(inode, block);
+		bforget(bh);
+		bh = NULL;
+	} else {
+		HDR(bh)->h_refcount = cpu_to_le32(
+			le32_to_cpu(HDR(bh)->h_refcount) - 1);
+		mark_buffer_dirty(bh);
+		if (IS_SYNC(inode)) {
+			ll_rw_block(WRITE, 1, &bh);
+			wait_on_buffer(bh);
+		}
+		ext2_xattr_quota_free(inode);
+	}
+	EXT2_I(inode)->i_file_acl = 0;
+
+cleanup:
+	brelse(bh);
+	up(&ext2_xattr_sem);
+}
+
+/*
+ * ext2_xattr_put_super()
+ *
+ * This is called when a file system is unmounted.
+ */
+void
+ext2_xattr_put_super(struct super_block *sb)
+{
+#ifdef CONFIG_EXT2_FS_XATTR_SHARING
+	mb_cache_shrink(ext2_xattr_cache, sb->s_dev);
+#endif
+}
+
+#ifdef CONFIG_EXT2_FS_XATTR_SHARING
+
+/*
+ * ext2_xattr_cache_insert()
+ *
+ * Create a new entry in the extended attribute cache, and insert
+ * it unless such an entry is already in the cache.
+ *
+ * Returns 0, or a negative error number on failure.
+ */
+static int
+ext2_xattr_cache_insert(struct buffer_head *bh)
+{
+	__u32 hash = le32_to_cpu(HDR(bh)->h_hash);
+	struct mb_cache_entry *ce;
+	int error;
+
+	ce = mb_cache_entry_alloc(ext2_xattr_cache);
+	if (!ce)
+		return -ENOMEM;
+	error = mb_cache_entry_insert(ce, bh->b_dev, bh->b_blocknr, &hash);
+	if (error) {
+		mb_cache_entry_free(ce);
+		if (error == -EBUSY) {
+			ea_bdebug(bh, "already in cache (%d cache entries)",
+				atomic_read(&ext2_xattr_cache->c_entry_count));
+			error = 0;
+		}
+	} else {
+		ea_bdebug(bh, "inserting [%x] (%d cache entries)", (int)hash,
+			  atomic_read(&ext2_xattr_cache->c_entry_count));
+		mb_cache_entry_release(ce);
+	}
+	return error;
+}
+
+/*
+ * ext2_xattr_cmp()
+ *
+ * Compare two extended attribute blocks for equality.
+ *
+ * Returns 0 if the blocks are equal, 1 if they differ, and
+ * a negative error number on errors.
+ */
+static int
+ext2_xattr_cmp(struct ext2_xattr_header *header1,
+	       struct ext2_xattr_header *header2)
+{
+	struct ext2_xattr_entry *entry1, *entry2;
+
+	entry1 = ENTRY(header1+1);
+	entry2 = ENTRY(header2+1);
+	while (!IS_LAST_ENTRY(entry1)) {
+		if (IS_LAST_ENTRY(entry2))
+			return 1;
+		if (entry1->e_hash != entry2->e_hash ||
+		    entry1->e_name_len != entry2->e_name_len ||
+		    entry1->e_value_size != entry2->e_value_size ||
+		    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))
+			return 1;
+		if (entry1->e_value_block != 0 || entry2->e_value_block != 0)
+			return -EIO;
+		if (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),
+			   (char *)header2 + le16_to_cpu(entry2->e_value_offs),
+			   le32_to_cpu(entry1->e_value_size)))
+			return 1;
+
+		entry1 = EXT2_XATTR_NEXT(entry1);
+		entry2 = EXT2_XATTR_NEXT(entry2);
+	}
+	if (!IS_LAST_ENTRY(entry2))
+		return 1;
+	return 0;
+}
+
+/*
+ * ext2_xattr_cache_find()
+ *
+ * Find an identical extended attribute block.
+ *
+ * Returns a pointer to the block found, or NULL if such a block was
+ * not found or an error occurred.
+ */
+static struct buffer_head *
+ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)
+{
+	__u32 hash = le32_to_cpu(header->h_hash);
+	struct mb_cache_entry *ce;
+
+	if (!header->h_hash)
+		return NULL;  /* never share */
+	ea_idebug(inode, "looking for cached blocks [%x]", (int)hash);
+	ce = mb_cache_entry_find_first(ext2_xattr_cache, 0, inode->i_dev, hash);
+	while (ce) {
+		struct buffer_head *bh = sb_bread(inode->i_sb, ce->e_block);
+
+		if (!bh) {
+			ext2_error(inode->i_sb, "ext2_xattr_cache_find",
+				"inode %ld: block %ld read error",
+				inode->i_ino, ce->e_block);
+		} else if (le32_to_cpu(HDR(bh)->h_refcount) >
+			   EXT2_XATTR_REFCOUNT_MAX) {
+			ea_idebug(inode, "block %ld refcount %d>%d",ce->e_block,
+				le32_to_cpu(HDR(bh)->h_refcount),
+				EXT2_XATTR_REFCOUNT_MAX);
+		} else if (!ext2_xattr_cmp(header, HDR(bh))) {
+			ea_bdebug(bh, "b_count=%d",atomic_read(&(bh->b_count)));
+			mb_cache_entry_release(ce);
+			return bh;
+		}
+		brelse(bh);
+		ce = mb_cache_entry_find_next(ce, 0, inode->i_dev, hash);
+	}
+	return NULL;
+}
+
+/*
+ * ext2_xattr_cache_remove()
+ *
+ * Remove the cache entry of a block from the cache. Called when a
+ * block becomes invalid.
+ */
+static void
+ext2_xattr_cache_remove(struct buffer_head *bh)
+{
+	struct mb_cache_entry *ce;
+
+	ce = mb_cache_entry_get(ext2_xattr_cache, bh->b_dev, bh->b_blocknr);
+	if (ce) {
+		ea_bdebug(bh, "removing (%d cache entries remaining)",
+			  atomic_read(&ext2_xattr_cache->c_entry_count)-1);
+		mb_cache_entry_free(ce);
+	} else 
+		ea_bdebug(bh, "no cache entry");
+}
+
+#define NAME_HASH_SHIFT 5
+#define VALUE_HASH_SHIFT 16
+
+/*
+ * ext2_xattr_hash_entry()
+ *
+ * Compute the hash of an extended attribute.
+ */
+static inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,
+					 struct ext2_xattr_entry *entry)
+{
+	__u32 hash = 0;
+	char *name = entry->e_name;
+	int n;
+
+	for (n=0; n < entry->e_name_len; n++) {
+		hash = (hash << NAME_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^
+		       *name++;
+	}
+
+	if (entry->e_value_block == 0 && entry->e_value_size != 0) {
+		__u32 *value = (__u32 *)((char *)header +
+			le16_to_cpu(entry->e_value_offs));
+		for (n = (le32_to_cpu(entry->e_value_size) +
+		     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {
+			hash = (hash << VALUE_HASH_SHIFT) ^
+			       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^
+			       le32_to_cpu(*value++);
+		}
+	}
+	entry->e_hash = cpu_to_le32(hash);
+}
+
+#undef NAME_HASH_SHIFT
+#undef VALUE_HASH_SHIFT
+
+#define BLOCK_HASH_SHIFT 16
+
+/*
+ * ext2_xattr_rehash()
+ *
+ * Re-compute the extended attribute hash value after an entry has changed.
+ */
+static void ext2_xattr_rehash(struct ext2_xattr_header *header,
+			      struct ext2_xattr_entry *entry)
+{
+	struct ext2_xattr_entry *here;
+	__u32 hash = 0;
+	
+	ext2_xattr_hash_entry(header, entry);
+	here = ENTRY(header+1);
+	while (!IS_LAST_ENTRY(here)) {
+		if (!here->e_hash) {
+			/* Block is not shared if an entry's hash value == 0 */
+			hash = 0;
+			break;
+		}
+		hash = (hash << BLOCK_HASH_SHIFT) ^
+		       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^
+		       le32_to_cpu(here->e_hash);
+		here = EXT2_XATTR_NEXT(here);
+	}
+	header->h_hash = cpu_to_le32(hash);
+}
+
+#undef BLOCK_HASH_SHIFT
+
+int __init
+init_ext2_xattr(void)
+{
+	ext2_xattr_cache = mb_cache_create("ext2_xattr", NULL,
+		sizeof(struct mb_cache_entry) +
+		sizeof(struct mb_cache_entry_index), 1, 61);
+	if (!ext2_xattr_cache)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void
+exit_ext2_xattr(void)
+{
+	mb_cache_destroy(ext2_xattr_cache);
+}
+
+#else  /* CONFIG_EXT2_FS_XATTR_SHARING */
+
+int __init
+init_ext2_xattr(void)
+{
+	return 0;
+}
+
+void
+exit_ext2_xattr(void)
+{
+}
+
+#endif  /* CONFIG_EXT2_FS_XATTR_SHARING */
Index: linux-2.4.21-chaos/fs/ext2/xattr_user.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext2/xattr_user.c	2003-01-30 13:24:37.000000000 +0300
+++ linux-2.4.21-chaos/fs/ext2/xattr_user.c	2003-12-14 15:11:46.000000000 +0300
@@ -0,0 +1,103 @@
+/*
+ * linux/fs/ext2/xattr_user.c
+ * Handler for extended user attributes.
+ *
+ * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fs.h>
+#include <linux/ext2_fs.h>
+#include <linux/ext2_xattr.h>
+
+#ifdef CONFIG_EXT2_FS_POSIX_ACL
+# include <linux/ext2_acl.h>
+#endif
+
+#define XATTR_USER_PREFIX "user."
+
+static size_t
+ext2_xattr_user_list(char *list, struct inode *inode,
+		     const char *name, int name_len)
+{
+	const int prefix_len = sizeof(XATTR_USER_PREFIX)-1;
+
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return 0;
+
+	if (list) {
+		memcpy(list, XATTR_USER_PREFIX, prefix_len);
+		memcpy(list+prefix_len, name, name_len);
+		list[prefix_len + name_len] = '\0';
+	}
+	return prefix_len + name_len + 1;
+}
+
+static int
+ext2_xattr_user_get(struct inode *inode, const char *name,
+		    void *buffer, size_t size)
+{
+	int error;
+
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return -ENOTSUP;
+#ifdef CONFIG_EXT2_FS_POSIX_ACL
+	error = ext2_permission_locked(inode, MAY_READ);
+#else
+	error = permission(inode, MAY_READ);
+#endif
+	if (error)
+		return error;
+
+	return ext2_xattr_get(inode, EXT2_XATTR_INDEX_USER, name,
+			      buffer, size);
+}
+
+static int
+ext2_xattr_user_set(struct inode *inode, const char *name,
+		    const void *value, size_t size, int flags)
+{
+	int error;
+
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	if (!test_opt(inode->i_sb, XATTR_USER))
+		return -ENOTSUP;
+	if ( !S_ISREG(inode->i_mode) &&
+	    (!S_ISDIR(inode->i_mode) || inode->i_mode & S_ISVTX))
+		return -EPERM;
+#ifdef CONFIG_EXT2_FS_POSIX_ACL
+	error = ext2_permission_locked(inode, MAY_WRITE);
+#else
+	error = permission(inode, MAY_WRITE);
+#endif
+	if (error)
+		return error;
+
+	return ext2_xattr_set(inode, EXT2_XATTR_INDEX_USER, name,
+			      value, size, flags);
+}
+
+struct ext2_xattr_handler ext2_xattr_user_handler = {
+	prefix:	XATTR_USER_PREFIX,
+	list:	ext2_xattr_user_list,
+	get:	ext2_xattr_user_get,
+	set:	ext2_xattr_user_set,
+};
+
+int __init
+init_ext2_xattr_user(void)
+{
+	return ext2_xattr_register(EXT2_XATTR_INDEX_USER,
+				   &ext2_xattr_user_handler);
+}
+
+void
+exit_ext2_xattr_user(void)
+{
+	ext2_xattr_unregister(EXT2_XATTR_INDEX_USER,
+			      &ext2_xattr_user_handler);
+}
Index: linux-2.4.21-chaos/fs/ext3/Makefile
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext3/Makefile	2003-12-14 15:09:30.000000000 +0300
+++ linux-2.4.21-chaos/fs/ext3/Makefile	2003-12-14 15:11:46.000000000 +0300
@@ -9,10 +9,10 @@
 
 O_TARGET := ext3.o
 
-export-objs :=	super.o inode.o
+export-objs := ext3-exports.o
 
 obj-y    := balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o \
-		ioctl.o namei.o super.o symlink.o hash.o
+		ioctl.o namei.o super.o symlink.o hash.o ext3-exports.o
 obj-m    := $(O_TARGET)
 
 export-objs += xattr.o
Index: linux-2.4.21-chaos/fs/ext3/super.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext3/super.c	2003-12-14 15:09:30.000000000 +0300
+++ linux-2.4.21-chaos/fs/ext3/super.c	2003-12-14 15:11:46.000000000 +0300
@@ -1944,9 +1944,6 @@
 	unregister_filesystem(&ext3_fs_type);
 }
 
-EXPORT_SYMBOL(ext3_force_commit);
-EXPORT_SYMBOL(ext3_bread);
-
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");
 MODULE_DESCRIPTION("Second Extended Filesystem with journaling extensions");
 MODULE_LICENSE("GPL");
Index: linux-2.4.21-chaos/fs/ext3/ext3-exports.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext3/ext3-exports.c	2003-01-30 13:24:37.000000000 +0300
+++ linux-2.4.21-chaos/fs/ext3/ext3-exports.c	2003-12-14 15:11:46.000000000 +0300
@@ -0,0 +1,14 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/ext3_fs.h>
+#include <linux/ext3_jbd.h>
+#include <linux/ext3_xattr.h>
+
+EXPORT_SYMBOL(ext3_force_commit);
+EXPORT_SYMBOL(ext3_bread);
+EXPORT_SYMBOL(ext3_journal_abort_handle);
+EXPORT_SYMBOL(ext3_xattr_register);
+EXPORT_SYMBOL(ext3_xattr_unregister);
+EXPORT_SYMBOL(ext3_xattr_get);
+EXPORT_SYMBOL(ext3_xattr_list);
+EXPORT_SYMBOL(ext3_xattr_set);
Index: linux-2.4.21-chaos/fs/ext3/xattr_trusted.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext3/xattr_trusted.c	2003-07-15 04:41:01.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext3/xattr_trusted.c	2003-12-14 15:11:46.000000000 +0300
@@ -50,7 +50,7 @@
 		return -EINVAL;
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
-	return ext3_xattr_set(inode, EXT3_XATTR_INDEX_TRUSTED, name,
+	return ext3_xattr_set_trans(inode, EXT3_XATTR_INDEX_TRUSTED, name,
 			      value, size, flags);
 }
 
Index: linux-2.4.21-chaos/fs/ext3/xattr.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext3/xattr.c	2003-07-30 04:11:55.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext3/xattr.c	2003-12-14 15:11:46.000000000 +0300
@@ -868,7 +868,7 @@
 }
 
 /*
- * ext3_xattr_set()
+ * ext3_xattr_set_trans()
  *
  * Like ext3_xattr_set_handle, but start from an inode. This extended
  * attribute modification is a filesystem transaction by itself.
@@ -876,7 +876,7 @@
  * Returns 0, or a negative error number on failure.
  */
 int
-ext3_xattr_set(struct inode *inode, int name_index, const char *name,
+ext3_xattr_set_trans(struct inode *inode, int name_index, const char *name,
                const void *value, size_t value_len, int flags)
 {
 	handle_t *handle;
@@ -895,6 +895,20 @@
 	return error ? error : error2;
 }
 
+int
+ext3_xattr_set(handle_t *handle, struct inode *inode, int name_index,
+		const char *name, const void *value, size_t value_len,
+		int flags)
+{
+	int error;
+
+	lock_kernel();
+	error = ext3_xattr_set_handle(handle, inode, name_index, name,
+					      value, value_len, flags);
+	unlock_kernel();
+	return error;
+}
+
 /*
  * ext3_xattr_delete_inode()
  *
Index: linux-2.4.21-chaos/fs/ext3/xattr_user.c
===================================================================
--- linux-2.4.21-chaos.orig/fs/ext3/xattr_user.c	2003-07-30 04:11:55.000000000 +0400
+++ linux-2.4.21-chaos/fs/ext3/xattr_user.c	2003-12-14 15:26:58.000000000 +0300
@@ -70,7 +70,7 @@
 	if (error)
 		return error;
   
-	return ext3_xattr_set(inode, EXT3_XATTR_INDEX_USER, name,
+	return ext3_xattr_set_trans(inode, EXT3_XATTR_INDEX_USER, name,
 			      value, size, flags);
 }
 
Index: linux-2.4.21-chaos/include/linux/errno.h
===================================================================
--- linux-2.4.21-chaos.orig/include/linux/errno.h	2003-07-15 04:41:12.000000000 +0400
+++ linux-2.4.21-chaos/include/linux/errno.h	2003-12-14 15:11:46.000000000 +0300
@@ -26,4 +26,8 @@
 
 #endif
 
+/* Defined for extended attributes */
+#define ENOATTR ENODATA		/* No such attribute */
+#define ENOTSUP EOPNOTSUPP	/* Operation not supported */
+
 #endif
Index: linux-2.4.21-chaos/include/linux/ext2_fs.h
===================================================================
--- linux-2.4.21-chaos.orig/include/linux/ext2_fs.h	2003-12-05 16:54:33.000000000 +0300
+++ linux-2.4.21-chaos/include/linux/ext2_fs.h	2003-12-14 15:13:54.000000000 +0300
@@ -57,8 +57,6 @@
  */
 #define	EXT2_BAD_INO		 1	/* Bad blocks inode */
 #define EXT2_ROOT_INO		 2	/* Root inode */
-#define EXT2_ACL_IDX_INO	 3	/* ACL inode */
-#define EXT2_ACL_DATA_INO	 4	/* ACL inode */
 #define EXT2_BOOT_LOADER_INO	 5	/* Boot loader inode */
 #define EXT2_UNDEL_DIR_INO	 6	/* Undelete directory inode */
 
@@ -86,7 +84,6 @@
 #else
 # define EXT2_BLOCK_SIZE(s)		(EXT2_MIN_BLOCK_SIZE << (s)->s_log_block_size)
 #endif
-#define EXT2_ACLE_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (struct ext2_acl_entry))
 #define	EXT2_ADDR_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (__u32))
 #ifdef __KERNEL__
 # define EXT2_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
@@ -121,28 +118,6 @@
 #endif
 
 /*
- * ACL structures
- */
-struct ext2_acl_header	/* Header of Access Control Lists */
-{
-	__u32	aclh_size;
-	__u32	aclh_file_count;
-	__u32	aclh_acle_count;
-	__u32	aclh_first_acle;
-};
-
-struct ext2_acl_entry	/* Access Control List Entry */
-{
-	__u32	acle_size;
-	__u16	acle_perms;	/* Access permissions */
-	__u16	acle_type;	/* Type of entry */
-	__u16	acle_tag;	/* User or group identity */
-	__u16	acle_pad1;
-	__u32	acle_next;	/* Pointer on next entry for the */
-					/* same inode or on next free entry */
-};
-
-/*
  * Structure of a blocks group descriptor
  */
 struct ext2_group_desc
@@ -314,6 +289,7 @@
 #define EXT2_MOUNT_ERRORS_PANIC		0x0040	/* Panic on errors */
 #define EXT2_MOUNT_MINIX_DF		0x0080	/* Mimics the Minix statfs */
 #define EXT2_MOUNT_NO_UID32		0x0200  /* Disable 32-bit UIDs */
+#define EXT2_MOUNT_XATTR_USER		0x4000	/* Extended user attributes */
 
 #define clear_opt(o, opt)		o &= ~EXT2_MOUNT_##opt
 #define set_opt(o, opt)			o |= EXT2_MOUNT_##opt
@@ -397,6 +373,7 @@
 
 #ifdef __KERNEL__
 #define EXT2_SB(sb)	(&((sb)->u.ext2_sb))
+#define EXT2_I(inode)	(&((inode)->u.ext2_i))
 #else
 /* Assume that user mode programs are passing in an ext2fs superblock, not
  * a kernel struct super_block.  This will allow us to call the feature-test
@@ -466,7 +443,7 @@
 #define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008
 #define EXT2_FEATURE_INCOMPAT_ANY		0xffffffff
 
-#define EXT2_FEATURE_COMPAT_SUPP	0
+#define EXT2_FEATURE_COMPAT_SUPP	EXT2_FEATURE_COMPAT_EXT_ATTR
 #define EXT2_FEATURE_INCOMPAT_SUPP	EXT2_FEATURE_INCOMPAT_FILETYPE
 #define EXT2_FEATURE_RO_COMPAT_SUPP	(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \
 					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \
@@ -624,8 +601,10 @@
 
 /* namei.c */
 extern struct inode_operations ext2_dir_inode_operations;
+extern struct inode_operations ext2_special_inode_operations;
 
 /* symlink.c */
+extern struct inode_operations ext2_symlink_inode_operations;
 extern struct inode_operations ext2_fast_symlink_inode_operations;
 
 #endif	/* __KERNEL__ */
Index: linux-2.4.21-chaos/include/linux/ext2_xattr.h
===================================================================
--- linux-2.4.21-chaos.orig/include/linux/ext2_xattr.h	2003-01-30 13:24:37.000000000 +0300
+++ linux-2.4.21-chaos/include/linux/ext2_xattr.h	2003-12-14 15:13:54.000000000 +0300
@@ -0,0 +1,157 @@
+/*
+  File: linux/ext2_xattr.h
+
+  On-disk format of extended attributes for the ext2 filesystem.
+
+  (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+
+/* Magic value in attribute blocks */
+#define EXT2_XATTR_MAGIC		0xEA020000
+
+/* Maximum number of references to one attribute block */
+#define EXT2_XATTR_REFCOUNT_MAX		1024
+
+/* Name indexes */
+#define EXT2_XATTR_INDEX_MAX			10
+#define EXT2_XATTR_INDEX_USER			1
+#define EXT2_XATTR_INDEX_POSIX_ACL_ACCESS	2
+#define EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT	3
+
+struct ext2_xattr_header {
+	__u32	h_magic;	/* magic number for identification */
+	__u32	h_refcount;	/* reference count */
+	__u32	h_blocks;	/* number of disk blocks used */
+	__u32	h_hash;		/* hash value of all attributes */
+	__u32	h_reserved[4];	/* zero right now */
+};
+
+struct ext2_xattr_entry {
+	__u8	e_name_len;	/* length of name */
+	__u8	e_name_index;	/* attribute name index */
+	__u16	e_value_offs;	/* offset in disk block of value */
+	__u32	e_value_block;	/* disk block attribute is stored on (n/i) */
+	__u32	e_value_size;	/* size of attribute value */
+	__u32	e_hash;		/* hash value of name and value */
+	char	e_name[0];	/* attribute name */
+};
+
+#define EXT2_XATTR_PAD_BITS		2
+#define EXT2_XATTR_PAD		(1<<EXT2_XATTR_PAD_BITS)
+#define EXT2_XATTR_ROUND		(EXT2_XATTR_PAD-1)
+#define EXT2_XATTR_LEN(name_len) \
+	(((name_len) + EXT2_XATTR_ROUND + \
+	sizeof(struct ext2_xattr_entry)) & ~EXT2_XATTR_ROUND)
+#define EXT2_XATTR_NEXT(entry) \
+	( (struct ext2_xattr_entry *)( \
+	  (char *)(entry) + EXT2_XATTR_LEN((entry)->e_name_len)) )
+#define EXT2_XATTR_SIZE(size) \
+	(((size) + EXT2_XATTR_ROUND) & ~EXT2_XATTR_ROUND)
+
+#ifdef __KERNEL__
+
+# ifdef CONFIG_EXT2_FS_XATTR
+
+struct ext2_xattr_handler {
+	char *prefix;
+	size_t (*list)(char *list, struct inode *inode, const char *name,
+		       int name_len);
+	int (*get)(struct inode *inode, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct inode *inode, const char *name, const void *buffer,
+		   size_t size, int flags);
+};
+
+extern int ext2_xattr_register(int, struct ext2_xattr_handler *);
+extern void ext2_xattr_unregister(int, struct ext2_xattr_handler *);
+
+extern int ext2_setxattr(struct dentry *, const char *, const void *, size_t, int);
+extern ssize_t ext2_getxattr(struct dentry *, const char *, void *, size_t);
+extern ssize_t ext2_listxattr(struct dentry *, char *, size_t);
+extern int ext2_removexattr(struct dentry *, const char *);
+
+extern int ext2_xattr_get(struct inode *, int, const char *, void *, size_t);
+extern int ext2_xattr_list(struct inode *, char *, size_t);
+extern int ext2_xattr_set(struct inode *, int, const char *, const void *, size_t, int);
+
+extern void ext2_xattr_delete_inode(struct inode *);
+extern void ext2_xattr_put_super(struct super_block *);
+
+extern int init_ext2_xattr(void) __init;
+extern void exit_ext2_xattr(void);
+
+# else  /* CONFIG_EXT2_FS_XATTR */
+#  define ext2_setxattr		NULL
+#  define ext2_getxattr		NULL
+#  define ext2_listxattr	NULL
+#  define ext2_removexattr	NULL
+
+static inline int
+ext2_xattr_get(struct inode *inode, int name_index,
+	       const char *name, void *buffer, size_t size)
+{
+	return -ENOTSUP;
+}
+
+static inline int
+ext2_xattr_list(struct inode *inode, char *buffer, size_t size)
+{
+	return -ENOTSUP;
+}
+
+static inline int
+ext2_xattr_set(struct inode *inode, int name_index, const char *name,
+	       const void *value, size_t size, int flags)
+{
+	return -ENOTSUP;
+}
+
+static inline void
+ext2_xattr_delete_inode(struct inode *inode)
+{
+}
+
+static inline void
+ext2_xattr_put_super(struct super_block *sb)
+{
+}
+
+static inline int
+init_ext2_xattr(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ext2_xattr(void)
+{
+}
+
+# endif  /* CONFIG_EXT2_FS_XATTR */
+
+# ifdef CONFIG_EXT2_FS_XATTR_USER
+
+extern int init_ext2_xattr_user(void) __init;
+extern void exit_ext2_xattr_user(void);
+
+# else  /* CONFIG_EXT2_FS_XATTR_USER */
+
+static inline int
+init_ext2_xattr_user(void)
+{
+	return 0;
+}
+
+static inline void
+exit_ext2_xattr_user(void)
+{
+}
+
+# endif  /* CONFIG_EXT2_FS_XATTR_USER */
+
+#endif  /* __KERNEL__ */
+
Index: linux-2.4.21-chaos/include/linux/ext3_xattr.h
===================================================================
--- linux-2.4.21-chaos.orig/include/linux/ext3_xattr.h	2003-12-05 16:54:33.000000000 +0300
+++ linux-2.4.21-chaos/include/linux/ext3_xattr.h	2003-12-14 15:21:13.000000000 +0300
@@ -82,8 +82,10 @@
 extern int ext3_xattr_list(struct inode *, char *, size_t);
 extern int ext3_xattr_set_handle(handle_t *handle, struct inode *, int,
 				 const char *, const void *, size_t, int);
-extern int ext3_xattr_set(struct inode *, int, const char *, const void *,
+extern int ext3_xattr_set_trans(struct inode *, int, const char *, const void *,
 			  size_t, int);
+extern int ext3_xattr_set(handle_t *, struct inode *, int, const char *,
+				const void *, size_t, int);
 
 extern void ext3_xattr_delete_inode(handle_t *, struct inode *);
 extern void ext3_xattr_put_super(struct super_block *);
