 fs/ext3/ialloc.c        |   36 +++++++++++++++++++++++++++++++++++-
 fs/ext3/ioctl.c         |   25 +++++++++++++++++++++++++
 fs/ext3/namei.c         |   12 ++++++++----
 include/linux/ext3_fs.h |    5 ++++-
 4 files changed, 72 insertions(+), 6 deletions(-)

--- linux-2.4.18-18/fs/ext3/namei.c~extN-wantedi	Sat Apr  5 02:51:31 2003
+++ linux-2.4.18-18-braam/fs/ext3/namei.c	Sat Apr  5 02:51:31 2003
@@ -1212,7 +1212,8 @@ static int ext3_create (struct inode * d
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, mode);
+	inode = ext3_new_inode (handle, dir, mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		inode->i_op = &ext3_file_inode_operations;
@@ -1240,7 +1241,8 @@ static int ext3_mknod (struct inode * di
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, mode);
+	inode = ext3_new_inode (handle, dir, mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		init_special_inode(inode, mode, rdev);
@@ -1270,7 +1272,8 @@ static int ext3_mkdir(struct inode * dir
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, S_IFDIR | mode);
+	inode = ext3_new_inode (handle, dir, S_IFDIR | mode,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
@@ -1663,7 +1666,8 @@ static int ext3_symlink (struct inode * 
 	if (IS_SYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext3_new_inode (handle, dir, S_IFLNK|S_IRWXUGO);
+	inode = ext3_new_inode (handle, dir, S_IFLNK|S_IRWXUGO,
+				(unsigned long)dentry->d_fsdata);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
--- linux-2.4.18-18/fs/ext3/ialloc.c~extN-wantedi	Sat Apr  5 02:51:31 2003
+++ linux-2.4.18-18-braam/fs/ext3/ialloc.c	Sat Apr  5 02:51:31 2003
@@ -330,7 +330,8 @@ int ext3_itable_block_used(struct super_
  * group to find a free inode.
  */
 struct inode * ext3_new_inode (handle_t *handle,
-				const struct inode * dir, int mode)
+				const struct inode * dir, int mode,
+                               unsigned long goal)
 {
 	struct super_block * sb;
 	struct buffer_head * bh;
@@ -360,6 +361,38 @@ struct inode * ext3_new_inode (handle_t 
 
 	lock_super (sb);
-	es = sb->u.ext3_sb.s_es;
+	es = EXT3_SB(sb)->s_es;
+ 
+ 	if (goal) {
+ 		i = (goal - 1) / EXT3_INODES_PER_GROUP(sb);
+ 		j = (goal - 1) % EXT3_INODES_PER_GROUP(sb);
+ 		gdp = ext3_get_group_desc(sb, i, &bh2);
+ 
+ 		bitmap_nr = load_inode_bitmap (sb, i);
+ 		if (bitmap_nr < 0)
+ 			goto fail;
+ 
+ 		bh = sbi->s_inode_bitmap[bitmap_nr];
+ 
+ 		BUFFER_TRACE(bh, "get_write_access");
+ 		err = ext3_journal_get_write_access(handle, bh);
+ 		if (err) goto fail;
+ 
+ 		if (ext3_set_bit(j, bh->b_data)) {
+ 			printk(KERN_ERR "goal inode %lu unavailable\n", goal);
+ 			/* Oh well, we tried. */
+ 			goto repeat;
+ 		}
+ 
+ 		BUFFER_TRACE(bh, "call ext3_journal_dirty_metadata");
+ 		err = ext3_journal_dirty_metadata(handle, bh);
+ 		if (err) goto fail;
+ 
+ 		/* We've shortcircuited the allocation system successfully,
+ 		 * now finish filling in the inode.
+ 		 */
+ 		goto have_bit_and_group;
+ 	}
+ 
 repeat:
 	gdp = NULL;
 	i = 0;
@@ -474,6 +507,7 @@ repeat:
 		}
 		goto repeat;
 	}
+ have_bit_and_group:
	j += i * EXT3_INODES_PER_GROUP(sb) + 1;
	if (j < EXT3_FIRST_INO(sb) || j > le32_to_cpu(es->s_inodes_count)) {
 		ext3_error (sb, "ext3_new_inode",
--- linux-2.4.18-18/fs/ext3/ioctl.c~extN-wantedi	Sat Apr  5 02:51:31 2003
+++ linux-2.4.18-18-braam/fs/ext3/ioctl.c	Sat Apr  5 02:51:31 2003
@@ -24,6 +24,31 @@ int ext3_ioctl (struct inode * inode, st
 	ext3_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
+ 	case EXT3_IOC_CREATE_INUM: {
+ 		char name[32];
+ 		struct dentry *dchild, *dparent;
+ 		int rc = 0;
+ 
+ 		dparent = list_entry(inode->i_dentry.next, struct dentry,
+ 				     d_alias);
+ 		snprintf(name, sizeof name, "%lu", arg);
+ 		dchild = lookup_one_len(name, dparent, strlen(name));
+ 		if (dchild->d_inode) {
+ 			printk(KERN_ERR "%*s/%lu already exists (ino %lu)\n",
+ 			       dparent->d_name.len, dparent->d_name.name, arg,
+ 			       dchild->d_inode->i_ino);
+ 			rc = -EEXIST;
+ 		} else {
+ 			dchild->d_fsdata = (void *)arg;
+ 			rc = vfs_create(inode, dchild, 0644);
+ 			if (rc)
+ 				printk(KERN_ERR "vfs_create: %d\n", rc);
+ 			else if (dchild->d_inode->i_ino != arg)
+ 				rc = -EEXIST;
+ 		}
+ 		dput(dchild);
+ 		return rc;
+ 	}
 	case EXT3_IOC_GETFLAGS:
 		flags = ei->i_flags & EXT3_FL_USER_VISIBLE;
 		return put_user(flags, (int *) arg);
--- linux-2.4.18-18/include/linux/ext3_fs.h~extN-wantedi	Sat Apr  5 02:51:31 2003
+++ linux-2.4.18-18-braam/include/linux/ext3_fs.h	Sat Apr  5 02:52:43 2003
@@ -198,6 +198,7 @@ struct ext3_group_desc
 #define	EXT3_IOC_SETFLAGS		_IOW('f', 2, long)
 #define	EXT3_IOC_GETVERSION		_IOR('f', 3, long)
 #define	EXT3_IOC_SETVERSION		_IOW('f', 4, long)
+/* EXT3_IOC_CREATE_INUM at bottom of file (visible to kernel and user). */
 #define	EXT3_IOC_GETVERSION_OLD		_IOR('v', 1, long)
 #define	EXT3_IOC_SETVERSION_OLD		_IOW('v', 2, long)
 #ifdef CONFIG_JBD_DEBUG
@@ -628,7 +629,8 @@ extern int ext3_check_dir_entry(const ch
 extern int ext3_sync_file (struct file *, struct dentry *, int);
 
 /* ialloc.c */
-extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int);
+extern struct inode * ext3_new_inode (handle_t *, const struct inode *, int,
+ 				      unsigned long);
 extern void ext3_free_inode (handle_t *, struct inode *);
 extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);
 extern unsigned long ext3_count_free_inodes (struct super_block *);
@@ -712,4 +714,5 @@ extern struct inode_operations ext3_fast
 
 #endif	/* __KERNEL__ */
 
+#define EXT3_IOC_CREATE_INUM			_IOW('f', 5, long)
 #endif	/* _LINUX_EXT3_FS_H */

_
