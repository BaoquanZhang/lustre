Index: iam/fs/ext3/Makefile
===================================================================
--- iam.orig/fs/ext3/Makefile	2006-06-08 21:50:42.000000000 +0400
+++ iam/fs/ext3/Makefile	2006-06-08 21:50:42.000000000 +0400
@@ -6,7 +6,7 @@ obj-$(CONFIG_EXT3_FS) += ext3.o
 
 ext3-y	:= balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o iopen.o \
 	   ioctl.o namei.o super.o symlink.o hash.o resize.o \
-	   extents.o mballoc.o iam.o iam_lfix.o
+	   extents.o mballoc.o iam.o iam_lfix.o iam_uapi.o
 
 ext3-$(CONFIG_EXT3_FS_XATTR)	 += xattr.o xattr_user.o xattr_trusted.o
 ext3-$(CONFIG_EXT3_FS_POSIX_ACL) += acl.o
Index: iam/fs/ext3/file.c
===================================================================
--- iam.orig/fs/ext3/file.c	2006-06-08 21:50:42.000000000 +0400
+++ iam/fs/ext3/file.c	2006-06-08 21:50:42.000000000 +0400
@@ -23,6 +23,7 @@
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
+#include <linux/lustre_iam.h>
 #include "xattr.h"
 #include "acl.h"
 
@@ -37,8 +38,12 @@ static int ext3_release_file (struct ino
 	if ((filp->f_mode & FMODE_WRITE) &&
 			(atomic_read(&inode->i_writecount) == 1))
 		ext3_discard_reservation(inode);
-	if (is_dx(inode) && filp->private_data)
-		ext3_htree_free_dir_info(filp->private_data);
+	if (is_dx(inode) && filp->private_data) {
+		if (S_ISDIR(inode->i_mode))
+			ext3_htree_free_dir_info(filp->private_data);
+		else
+			ext3_iam_release(filp, inode);
+	}
 
 	return 0;
 }
@@ -110,7 +115,7 @@ ext3_file_write(struct kiocb *iocb, cons
 
 force_commit:
 	err = ext3_force_commit(inode->i_sb);
-	if (err) 
+	if (err)
 		return err;
 	return ret;
 }
Index: iam/fs/ext3/iam-uapi.c
===================================================================
--- iam.orig/fs/ext3/iam-uapi.c	2004-04-06 17:27:52.000000000 +0400
+++ iam/fs/ext3/iam-uapi.c	2006-06-08 21:50:42.000000000 +0400
@@ -0,0 +1,349 @@
+/* -*- mode: c; c-basic-offset: 8; indent-tabs-mode: nil; -*-
+ * vim:expandtab:shiftwidth=8:tabstop=8:
+ *
+ *  iam_uapi.c
+ *  User-level interface to iam (ioctl based)
+ *
+ *  Copyright (c) 2006 Cluster File Systems, Inc.
+ *   Author: Nikita Danilov <nikita@clusterfs.com>
+ *
+ *   This file is part of the Lustre file system, http://www.lustre.org
+ *   Lustre is a trademark of Cluster File Systems, Inc.
+ *
+ *   You may have signed or agreed to another license before downloading
+ *   this software.  If so, you are bound by the terms and conditions
+ *   of that agreement, and the following does not apply to you.  See the
+ *   LICENSE file included with this distribution for more information.
+ *
+ *   If you did not agree to a different license, then this copy of Lustre
+ *   is open source software; you can redistribute it and/or modify it
+ *   under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   In either case, Lustre is distributed in the hope that it will be
+ *   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   license text for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/jbd.h>
+/* ext3_error() */
+#include <linux/ext3_fs.h>
+#include <linux/ext3_jbd.h>
+
+#include <linux/lustre_iam.h>
+
+#include <libcfs/libcfs.h>
+#include <libcfs/kp30.h>
+
+struct iam_private_info {
+        struct iam_container   ipi_bag;
+        struct iam_descr       ipi_descr;
+        struct iam_iterator    ipi_it;
+        struct iam_path_descr *ipi_ipd;
+};
+
+enum {
+        IAM_INSERT_CREDITS = 10
+};
+
+static struct iam_private_info *get_ipi(struct file *filp)
+{
+        return filp->private_data;
+}
+
+static int iam_uapi_it(int cmd, struct inode *inode,
+                       struct file *filp, struct iam_uapi_it *itop)
+{
+        struct iam_private_info *ipi;
+        struct iam_iterator     *it;
+        enum iam_it_state        st;
+        int result = 0;
+
+        ipi = get_ipi(filp);
+        it = &ipi->ipi_it;
+        st = it->ii_state;
+        switch (cmd) {
+        case IAM_IOC_IT_START:
+                result = iam_it_init(it, &ipi->ipi_bag,
+                                     IAM_IT_MOVE, ipi->ipi_ipd);
+                if (result == 0)
+                        result = iam_it_get(it, itop->iui_op.iul_key);
+                break;
+        case IAM_IOC_IT_NEXT:
+                if (st == IAM_IT_ATTACHED ||
+                    st == IAM_IT_BEFORE || st == IAM_IT_EMPTY)
+                        result = iam_it_next(it);
+                else
+                        result = -EBUSY;
+                break;
+        case IAM_IOC_IT_STOP:
+                iam_it_put(it);
+                iam_it_fini(it);
+                result = 0;
+                break;
+        }
+        st = it->ii_state;
+        if (st == IAM_IT_ATTACHED || st == IAM_IT_BEFORE)
+                iam_keycpy0(&ipi->ipi_bag, itop->iui_op.iul_key,
+                            iam_it_key_get(it, itop->iui_op.iul_key));
+        if (st == IAM_IT_ATTACHED)
+                iam_reccpy(&it->ii_path,
+                           itop->iui_op.iul_rec, iam_it_rec_get(it));
+        itop->iui_state = st;
+        return result;
+}
+
+static int iam_uapi_op(int cmd, struct inode *inode,
+                       struct file *filp, struct iam_uapi_op *op)
+{
+        int result;
+        struct iam_private_info *ipi;
+
+        ipi = get_ipi(filp);
+        if (cmd == IAM_IOC_INSERT || cmd == IAM_IOC_DELETE) {
+                handle_t *h;
+
+                h = ext3_journal_start(inode, IAM_INSERT_CREDITS);
+                if (!IS_ERR(h)) {
+                        if (cmd == IAM_IOC_INSERT)
+                                result = iam_insert(h, &ipi->ipi_bag,
+                                                    op->iul_key,
+                                                    op->iul_rec, ipi->ipi_ipd);
+                        else
+                                result = iam_delete(h, &ipi->ipi_bag,
+                                                    op->iul_key, ipi->ipi_ipd);
+                        ext3_journal_stop(h);
+                } else {
+                        result = PTR_ERR(h);
+                        ext3_std_error(inode->i_sb, result);
+                }
+        } else
+                result = iam_lookup(&ipi->ipi_bag, op->iul_key,
+                                    op->iul_rec, ipi->ipi_ipd);
+        return result;
+}
+
+static struct iam_private_info *ext3_iam_alloc_info(int flags)
+{
+        struct iam_private_info *info;
+
+        info = kmalloc(sizeof *info, flags);
+        if (info != NULL)
+                memset(info, 0, sizeof *info);
+        return info;
+}
+
+void ext3_iam_release(struct file *filp, struct inode *inode)
+{
+        struct iam_private_info *info;
+
+        info = filp->private_data;
+        iam_it_put(&info->ipi_it);
+        iam_it_fini(&info->ipi_it);
+        iam_container_fini(&info->ipi_bag);
+        if (info->ipi_ipd != NULL)
+                iam_ipd_free(info->ipi_ipd);
+
+        kfree(info);
+        EXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;
+}
+
+static int iam_uapi_init(struct inode *inode,
+                         struct file *filp, struct iam_uapi_info *ua)
+{
+        int result;
+        struct iam_private_info *info;
+
+        info = ext3_iam_alloc_info(GFP_KERNEL);
+        if (info != NULL) {
+                struct iam_container *bag;
+                struct iam_descr     *des;
+
+                bag = &info->ipi_bag;
+                des = &info->ipi_descr;
+                result = iam_container_init(bag, des, inode);
+                if (result == 0) {
+                        result = iam_container_setup(bag);
+                        if (result == 0) {
+                                info->ipi_ipd = iam_ipd_alloc(des->id_key_size);
+                                if (info->ipi_ipd != NULL) {
+                                        filp->private_data = info;
+                                        EXT3_I(inode)->i_flags |= EXT3_INDEX_FL;
+                                } else
+                                        result = -ENOMEM;
+                        }
+                }
+        } else
+                result = -ENOMEM;
+        return result;
+}
+
+
+static int getua(struct iam_uapi_info *ua, unsigned long arg)
+{
+        if (copy_from_user(ua, (struct iam_uapi_info __user *)arg, sizeof *ua))
+                return -EFAULT;
+        else
+                return 0;
+}
+
+static int putua(struct iam_uapi_info *ua, unsigned long arg)
+{
+        if (copy_to_user((struct iam_uapi_info __user *)arg, ua, sizeof *ua))
+                return -EFAULT;
+        else
+                return 0;
+}
+
+enum outop_t {
+        KEY   = 1 << 0,
+        REC   = 1 << 1,
+        STATE = 1 << 2
+};
+
+static int outop(struct iam_uapi_op *op, struct iam_uapi_op *uop,
+                 struct iam_descr *des, enum outop_t opt)
+{
+        int result;
+
+        if (((opt & REC) && copy_to_user((void __user *)uop->iul_rec,
+                                         op->iul_rec, des->id_rec_size)) ||
+            ((opt & KEY) && copy_to_user((void __user *)uop->iul_key,
+                                         op->iul_key, des->id_key_size)))
+                result = -EFAULT;
+        else
+                result = 0;
+        return result;
+}
+
+static void putop(struct iam_uapi_op *op)
+{
+        kfree(op->iul_key);
+        kfree(op->iul_rec);
+}
+
+static int getop(struct iam_uapi_op *op, struct iam_uapi_op *uop,
+                 struct iam_descr *des, unsigned long arg)
+{
+        int result;
+        int ks;
+        int rs;
+
+        ks = des->id_key_size;
+        rs = des->id_rec_size;
+        op->iul_key = kmalloc(ks, GFP_KERNEL);
+        op->iul_rec = kmalloc(rs, GFP_KERNEL);
+        if (!copy_from_user(uop,
+                            (struct iam_uapi_op __user *)arg, sizeof *uop) &&
+            op->iul_key != NULL && op->iul_rec != NULL &&
+            !copy_from_user(op->iul_key, (void __user *)uop->iul_key, ks) &&
+            !copy_from_user(op->iul_rec, (void __user *)uop->iul_rec, rs))
+                result = 0;
+        else {
+                result = -EFAULT;
+                putop(op);
+        }
+        return result;
+}
+
+static int outit(struct iam_uapi_it *it, struct iam_uapi_it *uit,
+                 struct iam_descr *des, enum outop_t opt, unsigned long arg)
+{
+        int result;
+
+        result = outop(&it->iui_op, &uit->iui_op, des, opt);
+        if (result == 0 && (opt&STATE))
+                result = put_user(it->iui_state, (int __user *) arg);
+        return result;
+}
+
+static void putit(struct iam_uapi_it *it)
+{
+        putop(&it->iui_op);
+}
+
+static int getit(struct iam_uapi_it *it, struct iam_uapi_it *uit,
+                 struct iam_descr *des, unsigned long arg)
+{
+        return getop(&it->iui_op, &uit->iui_op, des,
+                     (unsigned long)&((struct iam_uapi_it *)arg)->iui_op);
+}
+
+int iam_uapi_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+                   unsigned long arg)
+{
+        int result;
+        struct iam_uapi_info ua;
+        struct iam_uapi_op   uop;
+        struct iam_uapi_op   op;
+        struct iam_uapi_it   uit;
+        struct iam_uapi_it   it;
+        enum outop_t opt;
+
+        if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
+                result = -EACCES;
+        else if (!S_ISREG(inode->i_mode))
+                result = -EBADF;
+        else if (cmd == IAM_IOC_INIT) {
+                if (filp->private_data == NULL) {
+                        result = getua(&ua, arg);
+                        if (result == 0)
+                                result = iam_uapi_init(inode, filp, &ua);
+                } else
+                        result = -EBUSY;
+        } else if (is_dx(inode) && filp->private_data != NULL) {
+                struct iam_descr *des;
+
+                switch (cmd) {
+                case IAM_IOC_IT_START:
+                case IAM_IOC_IT_NEXT:
+                        opt = KEY|REC|STATE;
+                        break;
+                case IAM_IOC_LOOKUP:
+                        opt = REC;
+                        break;
+                default:
+                        opt = 0;
+                        break;
+                }
+
+                des = &get_ipi(filp)->ipi_descr;
+                if (cmd == IAM_IOC_GETINFO) {
+                        ua.iui_keysize = des->id_key_size;
+                        ua.iui_recsize = des->id_rec_size;
+                        ua.iui_ptrsize = des->id_ptr_size;
+                        ua.iui_height  = 0; /* not yet */
+                        memcpy(ua.iui_fmt_name, des->id_ops->id_name,
+                               ARRAY_SIZE(ua.iui_fmt_name));
+                        result = putua(&ua, arg);
+                } else if (cmd == IAM_IOC_INSERT || cmd == IAM_IOC_LOOKUP ||
+                           cmd == IAM_IOC_DELETE) {
+                        result = getop(&op, &uop, des, arg);
+                        if (result == 0) {
+                                int res2;
+                                result = iam_uapi_op(cmd, inode, filp, &op);
+
+                                res2 = outop(&op, &uop, des, opt);
+                                result = result ? : res2;
+                                putop(&op);
+                        }
+                } else if (cmd == IAM_IOC_IT_START || cmd == IAM_IOC_IT_NEXT ||
+                           cmd == IAM_IOC_IT_STOP) {
+                        result = getit(&it, &uit, des, arg);
+                        if (result == 0) {
+                                int res2;
+
+                                result = iam_uapi_it(cmd, inode, filp, &it);
+
+                                res2 = outit(&it, &uit, des, opt, arg);
+                                result = result ? : res2;
+                                putit(&it);
+                        }
+                } else
+                        result = -EINVAL;
+        } else
+                result = -ENOENT;
+        return result;
+}
Index: iam/include/linux/lustre_iam.h
===================================================================
--- iam.orig/include/linux/lustre_iam.h	2006-06-08 21:50:42.000000000 +0400
+++ iam/include/linux/lustre_iam.h	2006-06-08 21:50:42.000000000 +0400
@@ -30,9 +30,6 @@
 #ifndef __LINUX_LUSTRE_IAM_H__
 #define __LINUX_LUSTRE_IAM_H__
 
-/* handle_t, journal_start(), journal_stop() */
-#include <linux/jbd.h>
-
 /*
  *  linux/include/linux/lustre_iam.h
  */
@@ -65,6 +62,10 @@ enum {
         DX_FMT_NAME_LEN    = 16
 };
 
+#ifdef __KERNEL__
+/* handle_t, journal_start(), journal_stop() */
+#include <linux/jbd.h>
+
 /*
  * Entry within index tree node. Consists of a key immediately followed
  * (without padding) by a pointer to the child node.
@@ -89,11 +90,11 @@ struct iam_key;
 /* Incomplete type use to refer to the records stored in iam containers. */
 struct iam_rec;
 
-struct iam_cookie {
-	struct iam_key *ic_key;
-	struct iam_rec *ic_rec;
-};
-
+/*
+ * Scalar type into which certain iam_key's can be uniquely mapped. Used to
+ * support interfaces like readdir(), where iteration over index has to be
+ * re-startable.
+ */
 typedef __u64 iam_ptr_t;
 
 /*
@@ -123,6 +124,21 @@ struct iam_leaf {
 	void               *il_descr_data;
 };
 
+enum iam_lookup_t {
+        /*
+         * lookup positioned leaf on some record
+         */
+        IAM_LOOKUP_OK,
+        /*
+         * leaf was empty
+         */
+        IAM_LOOKUP_EMPTY,
+        /*
+         * lookup positioned leaf before first record
+         */
+        IAM_LOOKUP_BEFORE
+};
+
 struct iam_operations {
 	/*
 	 * Returns pointer (in the same sense as pointer in index entry) to
@@ -131,11 +147,15 @@ struct iam_operations {
 	__u32 (*id_root_ptr)(struct iam_container *c);
 
 	/*
-	 * Check validity and consistency of index node. This is called when
-	 * iam just loaded new node into frame.
+	 * Check validity and consistency of index node.
 	 */
 	int (*id_node_check)(struct iam_path *path, struct iam_frame *frame);
 	/*
+	 * Copy some data from node header into frame. This is called when
+	 * new node is loaded into frame.
+	 */
+	int (*id_node_load)(struct iam_path *path, struct iam_frame *frame);
+	/*
 	 * Initialize new node (stored in @bh) that is going to be added into
 	 * tree.
 	 */
@@ -155,6 +175,10 @@ struct iam_operations {
 	 * contains single record with the smallest possible key.
 	 */
 	int (*id_create)(struct iam_container *c);
+	/*
+         * Modify root node when tree height increases.
+	 */
+	void (*id_root_inc)(struct iam_container *c, struct iam_frame *frame);
         /*
          * Format name.
          */
@@ -226,7 +250,8 @@ struct iam_leaf_operations {
          * split leaf node, moving some entries into @bh (the latter currently
          * is assumed to be empty).
          */
-        void (*split)(struct iam_leaf *l, struct buffer_head *bh);
+        void (*split)(struct iam_leaf *l, struct buffer_head **bh,
+                      iam_ptr_t newblknr);
 };
 
 struct iam_path *iam_leaf_path(const struct iam_leaf *leaf);
@@ -347,7 +372,13 @@ enum iam_it_state {
 	/* initial state */
 	IAM_IT_DETACHED,
 	/* iterator is above particular record in the container */
-	IAM_IT_ATTACHED
+	IAM_IT_ATTACHED,
+        /* iterator landed into empty leaf */
+        IAM_IT_EMPTY,
+        /* iterator is positioned before first record in the leaf */
+        IAM_IT_BEFORE,
+        /* end of container reached */
+        IAM_IT_EOC
 };
 
 /*
@@ -468,7 +499,7 @@ int iam_it_next(struct iam_iterator *it)
 /*
  * Return pointer to the record under iterator.
  *
- * precondition:  it_state(it) == IAM_IT_ATTACHED
+ * precondition:  it_state(it) == IAM_IT_ATTACHED && it_at_rec(it)
  * postcondition: it_state(it) == IAM_IT_ATTACHED
  */
 struct iam_rec *iam_it_rec_get(const struct iam_iterator *it);
@@ -476,7 +507,9 @@ struct iam_rec *iam_it_rec_get(const str
 /*
  * Replace contents of record under iterator.
  *
- * precondition:  it_state(it) == IAM_IT_ATTACHED && it->ii_flags&IAM_IT_WRITE
+ * precondition:  it_state(it) == IAM_IT_ATTACHED &&
+ *                it->ii_flags&IAM_IT_WRITE &&
+ *                it_at_rec(it)
  * postcondition: it_state(it) == IAM_IT_ATTACHED &&
  *                ergo(result == 0, !memcmp(iam_it_rec_get(it), r, ...))
  */
@@ -485,7 +518,7 @@ int iam_it_rec_set(handle_t *h, struct i
 /*
  * Place key under iterator in @k, return @k
  *
- * precondition:  it_state(it) == IAM_IT_ATTACHED
+ * precondition:  it_state(it) == IAM_IT_ATTACHED && it_at_rec(it)
  * postcondition: it_state(it) == IAM_IT_ATTACHED
  */
 struct iam_key *iam_it_key_get(const struct iam_iterator *it,
@@ -497,7 +530,8 @@ struct iam_key *iam_it_key_get(const str
  *
  * precondition:  it_state(it) == IAM_IT_ATTACHED &&
  *                it->ii_flags&IAM_IT_WRITE &&
- *                it_keycmp(it, iam_it_key_get(it, *), k) < 0
+ *                ergo(it_at_rec(it),
+ *                     it_keycmp(it, iam_it_key_get(it, *), k) < 0)
  * postcondition: it_state(it) == IAM_IT_ATTACHED &&
  *                ergo(result == 0,
  *                     it_keycmp(it, iam_it_key_get(it, *), k) == 0 &&
@@ -508,7 +542,9 @@ int iam_it_rec_insert(handle_t *h, struc
 /*
  * Delete record under iterator.
  *
- * precondition:  it_state(it) == IAM_IT_ATTACHED && it->ii_flags&IAM_IT_WRITE
+ * precondition:  it_state(it) == IAM_IT_ATTACHED &&
+ *                it->ii_flags&IAM_IT_WRITE &&
+ *                it_at_rec(it)
  * postcondition: it_state(it) == IAM_IT_ATTACHED
  */
 int iam_it_rec_delete(handle_t *h, struct iam_iterator *it);
@@ -519,7 +555,8 @@ typedef __u64 iam_pos_t;
  * Convert iterator to cookie.
  *
  * precondition:  it_state(it) == IAM_IT_ATTACHED &&
- *                path_descr(it->ii_path)->id_key_size <= sizeof(iam_pos_t)
+ *                path_descr(it->ii_path)->id_key_size <= sizeof(iam_pos_t) &&
+ *                it_at_rec(it)
  * postcondition: it_state(it) == IAM_IT_ATTACHED
  */
 iam_pos_t iam_it_store(const struct iam_iterator *it);
@@ -583,6 +620,17 @@ static inline void iam_keycpy(const stru
 	memcpy(k1, k2, c->ic_descr->id_key_size);
 }
 
+/*
+ * Helper for the frequent case, where key was already placed into @k1 by
+ * callback.
+ */
+static inline void iam_keycpy0(const struct iam_container *c,
+                               struct iam_key *k1, const struct iam_key *k2)
+{
+        if (k1 != k2)
+                iam_keycpy(c, k1, k2);
+}
+
 static inline int iam_keycmp(const struct iam_container *c,
 			     const struct iam_key *k1, const struct iam_key *k2)
 {
@@ -650,6 +698,15 @@ static inline unsigned dx_node_limit(str
 	return entry_space / (param->id_key_size + param->id_ptr_size);
 }
 
+static inline unsigned dx_root_limit(struct iam_path *p)
+{
+	struct iam_descr *param = iam_path_descr(p);
+	unsigned entry_space = iam_path_obj(p)->i_sb->s_blocksize -
+		param->id_root_gap;
+	return entry_space / (param->id_key_size + param->id_ptr_size);
+}
+
+
 static inline struct iam_entry *dx_get_entries(struct iam_path *path,
 					       void *data, int root)
 {
@@ -702,6 +759,8 @@ void iam_insert_key(struct iam_path *pat
 
 int  iam_leaf_at_end(const struct iam_leaf *l);
 void iam_leaf_next(struct iam_leaf *folio);
+int iam_leaf_can_add(const struct iam_leaf *l,
+                     const struct iam_key *k, const struct iam_rec *r);
 
 struct iam_path *iam_leaf_path(const struct iam_leaf *leaf);
 struct iam_container *iam_leaf_container(const struct iam_leaf *leaf);
@@ -718,5 +777,48 @@ void iam_format_register(struct iam_form
 
 void iam_lfix_format_init(void);
 
+struct iam_private_info;
+
+void ext3_iam_release(struct file *filp, struct inode *inode);
+
+int iam_uapi_ioctl(struct inode * inode, struct file * filp, unsigned int cmd,
+                   unsigned long arg);
+
+/* __KERNEL__ */
+#endif
+
+/*
+ * User level API. Copy exists in lustre/lustre/tests/iam_ut.c
+ */
+
+struct iam_uapi_info {
+        __u16 iui_keysize;
+        __u16 iui_recsize;
+        __u16 iui_ptrsize;
+        __u16 iui_height;
+        char  iui_fmt_name[DX_FMT_NAME_LEN];
+};
+
+struct iam_uapi_op {
+        void *iul_key;
+        void *iul_rec;
+};
+
+struct iam_uapi_it {
+        struct iam_uapi_op iui_op;
+        __u16              iui_state;
+};
+
+enum iam_ioctl_cmd {
+        IAM_IOC_INIT     = _IOW('i', 1, struct iam_uapi_info),
+        IAM_IOC_GETINFO  = _IOR('i', 2, struct iam_uapi_info),
+        IAM_IOC_INSERT   = _IOR('i', 3, struct iam_uapi_op),
+        IAM_IOC_LOOKUP   = _IOWR('i', 4, struct iam_uapi_op),
+        IAM_IOC_DELETE   = _IOR('i', 5, struct iam_uapi_op),
+        IAM_IOC_IT_START = _IOR('i', 6, struct iam_uapi_it),
+        IAM_IOC_IT_NEXT  = _IOW('i', 7, struct iam_uapi_it),
+        IAM_IOC_IT_STOP  = _IOR('i', 8, struct iam_uapi_it)
+};
+
 /* __LINUX_LUSTRE_IAM_H__ */
 #endif
