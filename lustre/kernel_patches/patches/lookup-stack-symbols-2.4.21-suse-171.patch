Index: linux-2.4.21-273/arch/i386/kernel/process.c
===================================================================
--- linux-2.4.21-273.orig/arch/i386/kernel/process.c	2005-01-17 07:08:16.000000000 -0500
+++ linux-2.4.21-273/arch/i386/kernel/process.c	2005-04-05 20:11:38.391253492 -0400
@@ -36,6 +36,7 @@
 #ifdef	CONFIG_KDB
 #include <linux/kdb.h>
 #endif	/* CONFIG_KDB */
+#include <linux/version.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -772,10 +773,14 @@
 void show_regs(struct pt_regs * regs)
 {
 	unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L;
+	static char buffer[512]; 
+
+	lookup_symbol(regs->eip, buffer, 512);
 
 	printk("\n");
 	printk("Pid: %d, comm: %20s\n", current->pid, current->comm);
 	printk("EIP: %04x:[<%08lx>] CPU: %d",0xffff & regs->xcs,regs->eip, smp_processor_id());
+	printk("\nEIP is at %s (" UTS_RELEASE ")\n", buffer);
 	if (regs->xcs & 3)
 		printk(" ESP: %04x:%08lx",0xffff & regs->xss,regs->esp);
 	printk(" EFLAGS: %08lx    %s\n",regs->eflags, print_tainted());
Index: linux-2.4.21-273/arch/i386/kernel/traps.c
===================================================================
--- linux-2.4.21-273.orig/arch/i386/kernel/traps.c	2005-04-05 20:11:27.381848523 -0400
+++ linux-2.4.21-273/arch/i386/kernel/traps.c	2005-04-05 20:11:38.392253347 -0400
@@ -25,6 +25,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/highmem.h>
+#include <linux/version.h>
 
 #include <linux/rashooks.h>
 
@@ -275,7 +276,8 @@
 {
 	int i;
 	unsigned long addr;
-	unsigned long *prev = NULL;
+	/* static to not take up stackspace; if we race here too bad */
+	static char buffer[512];
 
 	if (!stack)
 		stack = (unsigned long*)&stack;
@@ -285,17 +287,12 @@
 	while (((long) stack & (THREAD_SIZE-1)) != 0) {
 		addr = *stack++;
 		if (kernel_text_address(addr)) {
-			if (prev)
-				printk(" (%02d)", (stack-prev)*sizeof(*stack));
-			prev = stack;
-			if ((i % 4) == 0)
-				printk("\n ");
-			printk(" [<%08lx>]", addr);
+			lookup_symbol(addr, buffer, 512);
+			printk(" [<%08lx>] %s (0x%p)\n",
+			       addr, buffer, stack - 1);
 			i++;
 		}
 	}
-	if (prev)
-		printk(" (%02d)", (stack-prev)*sizeof(*stack));
 	printk("\n");
 }
 
@@ -341,12 +338,19 @@
 	printk("Code: <0>\n");	/* tell ksymoops trace ends here */
 }
 
+#ifdef CONFIG_MK7
+#define ARCHIT "/athlon"
+#else
+#define ARCHIT "/i686"
+#endif
+
 void show_registers(struct pt_regs *regs)
 {
 	int i;
 	int in_kernel = 1;
 	unsigned long esp;
 	unsigned short ss;
+	static char buffer[512];
 
 	esp = (unsigned long) (&regs->esp);
 	ss = __KERNEL_DS;
@@ -355,10 +359,13 @@
 		esp = regs->esp;
 		ss = regs->xss & 0xffff;
 	}
+	print_modules();
+	lookup_symbol(regs->eip, buffer, 512);
 	module_oops_tracking_init();
 	kernel_text_address(regs->eip);
 	printk("CPU:    %d\nEIP:    %04x:[<%08lx>]    %s\nEFLAGS: %08lx\n",
 		smp_processor_id(), 0xffff & regs->xcs, regs->eip, print_tainted(), regs->eflags);
+	printk("\nEIP is at %s (" UTS_RELEASE ARCHIT ")\n", buffer);
 	printk("eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx\n",
 		regs->eax, regs->ebx, regs->ecx, regs->edx);
 	printk("esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx\n",
@@ -420,6 +427,7 @@
 		(unsigned long)file < PAGE_OFFSET || __get_user(c, file))
 		file = "<bad filename>";
 
+	printk("-----------[ cut here ]------------\n");
 	printk("kernel BUG at %s:%d!\n", file, line);
 
 no_bug:
Index: linux-2.4.21-273/include/linux/kernel.h
===================================================================
--- linux-2.4.21-273.orig/include/linux/kernel.h	2005-01-17 07:09:09.000000000 -0500
+++ linux-2.4.21-273/include/linux/kernel.h	2005-04-05 20:11:38.393253203 -0400
@@ -132,6 +132,9 @@
 
 extern void dump_stack(void);
 
+extern int lookup_symbol(unsigned long address, char *buffer, int buflen);
+extern void print_modules(void);
+
 extern char *oops_id;
 
 #if DEBUG
Index: linux-2.4.21-273/kernel/Makefile
===================================================================
--- linux-2.4.21-273.orig/kernel/Makefile	2005-01-17 07:08:59.000000000 -0500
+++ linux-2.4.21-273/kernel/Makefile	2005-04-05 20:12:04.410483855 -0400
@@ -11,12 +11,13 @@
 
 export-objs = signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o \
 	      printk.o cpufreq.o rcupdate.o syscall_ksyms.o fork.o hook.o \
-	      rashooks.o module.o
+	      rashooks.o module.o kksymoops.o
 
 obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o \
 	    module.o exit.o itimer.o info.o time.o softirq.o resource.o \
 	    sysctl.o acct.o capability.o ptrace.o timer.o user.o \
-	    signal.o sys.o kmod.o context.o rcupdate.o futex.o syscall_ksyms.o
+	    signal.o sys.o kmod.o context.o rcupdate.o futex.o \
+	    syscall_ksyms.o kksymoops.o
 
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += ksyms.o
Index: linux-2.4.21-273/kernel/kksymoops.c
===================================================================
--- linux-2.4.21-273.orig/kernel/kksymoops.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.4.21-273/kernel/kksymoops.c	2005-04-05 20:11:38.394253058 -0400
@@ -0,0 +1,83 @@
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#ifdef CONFIG_KALLSYMS
+#include <linux/kallsyms.h>
+#endif
+
+
+
+int lookup_symbol(unsigned long address, char *buffer, int buflen)
+{
+	struct module *this_mod;
+	unsigned long bestsofar;
+
+	const char *mod_name = NULL, *sec_name = NULL, *sym_name = NULL;
+	unsigned long mod_start,mod_end,sec_start,sec_end,sym_start,sym_end;
+	
+	if (!buffer)
+		return -EFAULT;
+	
+	if (buflen<256)
+		return -ENOMEM;
+	
+	memset(buffer,0,buflen);
+
+#ifdef CONFIG_KALLSYMS
+	if (!kallsyms_address_to_symbol(address,&mod_name,&mod_start,&mod_end,&sec_name,
+		&sec_start, &sec_end, &sym_name, &sym_start, &sym_end)) {
+		/* kallsyms doesn't have a clue; lets try harder */
+		bestsofar = 0;
+		snprintf(buffer,buflen-1,"[unresolved]");
+		
+		this_mod = module_list;
+
+		while (this_mod != NULL) {
+			int i;
+			/* walk the symbol list of this module. Only symbols
+			   who's address is smaller than the searched for address
+			   are relevant; and only if it's better than the best so far */
+			for (i=0; i< this_mod->nsyms; i++)
+				if ((this_mod->syms[i].value<=address) &&
+					(bestsofar<this_mod->syms[i].value)) {
+					snprintf(buffer,buflen-1,"%s [%s] 0x%x",
+						this_mod->syms[i].name,
+						this_mod->name,
+						(unsigned int)(address - this_mod->syms[i].value));
+					bestsofar = this_mod->syms[i].value;
+				}
+			this_mod = this_mod->next;
+		}
+
+	} else { /* kallsyms success */
+		snprintf(buffer,buflen-1,"%s [%s] 0x%x",sym_name,mod_name,(unsigned int)(address-sym_start));
+	}
+#endif
+	return strlen(buffer);
+}
+EXPORT_SYMBOL(lookup_symbol);
+
+static char modlist[4096];
+/* this function isn't smp safe but that's not really a problem; it's called from
+ * oops context only and any locking could actually prevent the oops from going out;
+ * the line that is generated is informational only and should NEVER prevent the real oops
+ * from going out. 
+ */
+void print_modules(void)
+{
+	struct module *this_mod;
+	int pos = 0, i;
+	memset(modlist,0,4096);
+
+#ifdef CONFIG_KALLSYMS
+	this_mod = module_list;
+	while (this_mod != NULL) {
+		if (this_mod->name != NULL)
+			pos +=snprintf(modlist+pos,160-pos-1,"%s ",this_mod->name);
+		this_mod = this_mod->next;
+	}
+	printk("%s\n",modlist);
+#endif
+}
