 0 files changed

--- linux-2.4.20-rh/drivers/net/tg3.c~tg3_netconsole	2003-04-11 14:04:56.000000000 +0800
+++ linux-2.4.20-rh-root/drivers/net/tg3.c	2003-07-01 11:27:46.000000000 +0800
@@ -170,6 +170,10 @@ static void tg3_write_indirect_reg32(str
 	}
 }
 
+#ifdef HAVE_POLL_CONTROLLER
+static void     Poll_tg3(struct net_device *);
+#endif
+
 #define tw32(reg,val)		tg3_write_indirect_reg32(tp,(reg),(val))
 #define tw32_mailbox(reg, val)	writel(((val) & 0xffffffff), tp->regs + (reg))
 #define tw16(reg,val)		writew(((val) & 0xffff), tp->regs + (reg))
@@ -1899,7 +1903,138 @@ static int tg3_vlan_rx(struct tg3 *tp, s
 	return vlan_hwaccel_receive_skb(skb, tp->vlgrp, vlan_tag);
 }
 #endif
+/* for netconsole */
+static int upcall_rx_hook(struct net_device *dev)
+{
+ 	struct tg3 *tp = dev->priv;	
+	u32 work_mask;
+	u32 rx_rcb_ptr = tp->rx_rcb_ptr;
+	u16 hw_idx, sw_idx;
+	int received;
+
+	hw_idx = tp->hw_status->idx[0].rx_producer;
+	sw_idx = rx_rcb_ptr % TG3_RX_RCB_RING_SIZE;
+	work_mask = 0;
+	received = 0;
+	while (sw_idx != hw_idx) {
+		struct tg3_rx_buffer_desc *desc = &tp->rx_rcb[sw_idx];
+		unsigned int len;
+		struct sk_buff *skb;
+		dma_addr_t dma_addr;
+		u32 opaque_key, desc_idx, *post_ptr;
+
+		desc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;
+		opaque_key = desc->opaque & RXD_OPAQUE_RING_MASK;
+		if (opaque_key == RXD_OPAQUE_RING_STD) {
+			dma_addr = pci_unmap_addr(&tp->rx_std_buffers[desc_idx],
+						  mapping);
+			skb = tp->rx_std_buffers[desc_idx].skb;
+			post_ptr = &tp->rx_std_ptr;
+		} else if (opaque_key == RXD_OPAQUE_RING_JUMBO) {
+			dma_addr = pci_unmap_addr(&tp->rx_jumbo_buffers[desc_idx],
+						  mapping);
+			skb = tp->rx_jumbo_buffers[desc_idx].skb;
+			post_ptr = &tp->rx_jumbo_ptr;
+		}
+		else {
+			goto next_pkt_nopost;
+		}
+
+		work_mask |= opaque_key;
+
+		if ((desc->err_vlan & RXD_ERR_MASK) != 0 &&
+		    (desc->err_vlan != RXD_ERR_ODD_NIBBLE_RCVD_MII)) {
+		drop_it:
+			tg3_recycle_rx(tp, opaque_key,
+				       desc_idx, *post_ptr);
+		drop_it_no_recycle:
+			/* Other statistics kept track of by card. */
+			tp->net_stats.rx_dropped++;
+			goto next_pkt;
+		}
+
+		len = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT) - 4; /* omit crc */
+
+		if (len > RX_COPY_THRESHOLD) {
+			int skb_size;
+
+			skb_size = tg3_alloc_rx_skb(tp, opaque_key,
+						    desc_idx, *post_ptr);
+			if (skb_size < 0)
+				goto drop_it;
+
+			pci_unmap_single(tp->pdev, dma_addr,
+					 skb_size - tp->rx_offset,
+					 PCI_DMA_FROMDEVICE);
+
+			skb_put(skb, len);
+		} else {
+			struct sk_buff *copy_skb;
+
+			tg3_recycle_rx(tp, opaque_key,
+				       desc_idx, *post_ptr);
+
+			copy_skb = dev_alloc_skb(len + 2);
+			if (copy_skb == NULL)
+				goto drop_it_no_recycle;
+
+			copy_skb->dev = tp->dev;
+			skb_reserve(copy_skb, 2);
+			skb_put(copy_skb, len);
+			pci_dma_sync_single(tp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);
+			memcpy(copy_skb->data, skb->data, len);
+
+			/* We'll reuse the original ring buffer. */
+			skb = copy_skb;
+		}
+		
+		if ((tp->tg3_flags & TG3_FLAG_RX_CHECKSUMS) &&
+		    (desc->type_flags & RXD_FLAG_TCPUDP_CSUM) &&
+		    (((desc->ip_tcp_csum & RXD_TCPCSUM_MASK)
+		      >> RXD_TCPCSUM_SHIFT) == 0xffff))
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+		else
+			skb->ip_summed = CHECKSUM_NONE;
+
+		skb->protocol = eth_type_trans(skb, tp->dev);
+/*into netconsole driver*/	
+		dev->rx_hook(skb);
+               	kfree_skb(skb);
+		tp->dev->last_rx = jiffies;
+		received++;
+next_pkt:
+		(*post_ptr)++;
+next_pkt_nopost:
+		rx_rcb_ptr++;
+		sw_idx = rx_rcb_ptr % TG3_RX_RCB_RING_SIZE;
+	}
+
+	/* ACK the status ring. */
+	tp->rx_rcb_ptr = rx_rcb_ptr;
+	tw32_mailbox(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW,
+		     (rx_rcb_ptr % TG3_RX_RCB_RING_SIZE));
+	if (tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER)
+		tr32(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW);
 
+	/* Refill RX ring(s). */
+	if (work_mask & RXD_OPAQUE_RING_STD) {
+		sw_idx = tp->rx_std_ptr % TG3_RX_RING_SIZE;
+		tw32_mailbox(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW,
+			     sw_idx);
+		if (tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER)
+			tr32(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW);
+	}
+	if (work_mask & RXD_OPAQUE_RING_JUMBO) {
+		sw_idx = tp->rx_jumbo_ptr % TG3_RX_JUMBO_RING_SIZE;
+		tw32_mailbox(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW,
+			     sw_idx);
+		if (tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER)
+			tr32(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW);
+	}
+
+	return received;
+
+}
 /* The RX ring scheme is composed of multiple rings which post fresh
  * buffers to the chip, and one special ring the chip uses to report
  * status back to the host.
@@ -2006,7 +2141,7 @@ static int tg3_rx(struct tg3 *tp, int bu
 			/* We'll reuse the original ring buffer. */
 			skb = copy_skb;
 		}
-
+		
 		if ((tp->tg3_flags & TG3_FLAG_RX_CHECKSUMS) &&
 		    (desc->type_flags & RXD_FLAG_TCPUDP_CSUM) &&
 		    (((desc->ip_tcp_csum & RXD_TCPCSUM_MASK)
@@ -2016,6 +2151,8 @@ static int tg3_rx(struct tg3 *tp, int bu
 			skb->ip_summed = CHECKSUM_NONE;
 
 		skb->protocol = eth_type_trans(skb, tp->dev);
+
+					
 #if TG3_VLAN_TAG_USED
 		if (tp->vlgrp != NULL &&
 		    desc->type_flags & RXD_FLAG_VLAN) {
@@ -2058,7 +2195,6 @@ next_pkt_nopost:
 		if (tp->tg3_flags & TG3_FLAG_MBOX_WRITE_REORDER)
 			tr32(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW);
 	}
-
 	return received;
 }
 
@@ -2151,7 +2287,6 @@ static void tg3_interrupt(int irq, void 
 	unsigned long flags;
 
 	spin_lock_irqsave(&tp->lock, flags);
-
 	if (sblk->status & SD_STATUS_UPDATED) {
 		/*
 		 * writing any value to intr-mbox-0 clears PCI INTA# and
@@ -2169,8 +2304,17 @@ static void tg3_interrupt(int irq, void 
 		tr32(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW);
 		sblk->status &= ~SD_STATUS_UPDATED;
 
-		if (likely(tg3_has_work(dev, tp)))
-			netif_rx_schedule(dev);		/* schedule NAPI poll */
+		if (likely(tg3_has_work(dev, tp))){
+	 		if (unlikely(dev->rx_hook != NULL) && netdump_mode) {
+                		int ret;
+				struct sk_buff *skb;
+				ret = upcall_rx_hook(dev);
+				if (!ret){
+					goto out;
+				}
+			}
+			 netif_rx_schedule(dev);		/* schedule NAPI poll */
+		}
 		else {
 			/* no work, shared interrupt perhaps?  re-enable
 			 * interrupts, and flush that PCI write
@@ -2180,7 +2324,7 @@ static void tg3_interrupt(int irq, void 
 			tr32(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW);
 		}
 	}
-
+out:
 	spin_unlock_irqrestore(&tp->lock, flags);
 }
 
@@ -6804,7 +6948,10 @@ static int __devinit tg3_init_one(struct
 	dev->watchdog_timeo = TG3_TX_TIMEOUT;
 	dev->change_mtu = tg3_change_mtu;
 	dev->irq = pdev->irq;
-
+#ifdef HAVE_POLL_CONTROLLER
+	dev->poll_controller = &Poll_tg3;
+#endif
+		
 	err = tg3_get_invariants(tp);
 	if (err) {
 		printk(KERN_ERR PFX "Problem fetching invariants of chip, "
@@ -6882,6 +7029,15 @@ err_out_disable_pdev:
 	return err;
 }
 
+#ifdef HAVE_POLL_CONTROLLER
+static void Poll_tg3(struct net_device *dev)
+{
+	if (!netdump_mode) disable_irq(dev->irq);
+	tg3_interrupt(dev->irq, dev, NULL);
+	if (!netdump_mode) enable_irq(dev->irq);
+}
+#endif
+
 static void __devexit tg3_remove_one(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);

_
