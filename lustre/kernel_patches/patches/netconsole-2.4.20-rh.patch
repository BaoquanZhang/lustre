Index: linux-2.4.20-rh/drivers/net/netconsole.c
===================================================================
--- linux-2.4.20-rh.orig/drivers/net/netconsole.c	2003-07-22 16:02:23.000000000 +0800
+++ linux-2.4.20-rh/drivers/net/netconsole.c	2003-10-30 06:52:41.000000000 +0800
@@ -12,6 +12,8 @@
  *
  * 2001-09-17    started by Ingo Molnar.
  * 2002-03-14    simultaneous syslog packet option by Michael K. Johnson
+ * 2003-10-30    Add sysrq command processing by Wangdi <wangdi@clusterfs.com>
+ * 
  */
 
 /****************************************************************
@@ -51,6 +53,7 @@
 #include <linux/tty_driver.h>
 #include <linux/etherdevice.h>
 #include <linux/elf.h>
+#include "netconsole.h"
 
 static struct net_device *netconsole_dev;
 static u16 source_port, netdump_target_port, netlog_target_port, syslog_target_port;
@@ -62,7 +65,6 @@
 static unsigned int mhz = 500, idle_timeout;
 static unsigned long long mhz_cycles, jiffy_cycles;
 
-#include "netconsole.h"
 
 #define MAX_UDP_CHUNK 1460
 #define MAX_PRINT_CHUNK (MAX_UDP_CHUNK-HEADER_LEN)
@@ -426,13 +428,38 @@
 static spinlock_t sequence_lock = SPIN_LOCK_UNLOCKED;
 static unsigned int log_offset;
 
+/*for sysrq mode */
+static int sysrq_mode = 0;
+static int stop_sysrq_thread = 0;
+#define Set_Sysrq_mode()       (sysrq_mode = 1)
+#define Clear_Sysrq_mode()     (sysrq_mode = 0)
+static char send_cache[MAX_PRINT_CHUNK];
+static unsigned int send_cache_pos = 0;
+wait_queue_head_t sysrq_thread_queue;
+wait_queue_head_t sysrq_thread_waiter_queue;
+void netconsole_do_sysrq(req_t *req)
+{
+        struct pt_regs regs;
+	struct net_device *dev = netconsole_dev;
+
+	if (!dev)
+		return;
+	Set_Sysrq_mode();
+	get_current_regs(&regs);
+	if (req->from != 'c'){
+		handle_sysrq((int)req->from, &regs, NULL);
+	}else{
+		printk(KERN_INFO"We still not implemented netdump in sysrq\n"); 
+	}
+	Clear_Sysrq_mode();
+}
 static void write_netconsole_msg(struct console *con, const char *msg0, unsigned int msg_len)
 {
 	int len, left, i;
 	struct net_device *dev;
 	const char *msg = msg0;
 	reply_t reply;
-
+	
 	dev = netconsole_dev;
 	if (!dev || netdump_mode)
 		return;
@@ -567,8 +594,6 @@
 	req_t *req;
 	struct net_device *dev;
 
-	if (!netdump_mode)
-		return NET_RX_SUCCESS;
 #if DEBUG
 	{
 		static int packet_count;
@@ -722,8 +747,16 @@
 	Dprintk("... netdump from:    %08x.\n", req->from);
 	Dprintk("... netdump to:      %08x.\n", req->to);
 
-	add_new_req(req);
+	if (netdump_mode) 
+		add_new_req(req);
+	else if (req->command == COMM_SYSRQ){
+		add_new_req(req);
+		wake_up(&sysrq_thread_queue);	
+		return NET_RX_DROP;
+	}
 out:
+	if (!netdump_mode)
+		return NET_RX_SUCCESS;
 	return NET_RX_DROP;
 }
 
@@ -1009,6 +1042,33 @@
 	printk("NETDUMP END!\n");
 	__restore_flags(flags);
 }
+static thread_stopped = 0;
+static int netconsole_sysrq_schedule(void *arg) 
+{
+	struct task_struct *tsk = current;
+
+	sprintf(tsk->comm, "sysrq_schedule");
+	sigfillset(&tsk->blocked);
+
+	/* main loop */
+	thread_stopped = 0;	
+	for (;;) {
+		wait_event_interruptible(sysrq_thread_queue,
+					 !list_empty(&request_list) || stop_sysrq_thread);
+		while (!list_empty(&request_list)) {
+			req_t *req = get_new_req();
+			if (req->command == COMM_SYSRQ)
+				netconsole_do_sysrq(req);	
+		}
+		if (stop_sysrq_thread)
+			break;
+		wake_up(&sysrq_thread_waiter_queue);
+	}
+	thread_stopped = 1;	
+	wake_up(&sysrq_thread_waiter_queue);
+	return 0;
+}
+
 
 static char *dev;
 static int netdump_target_eth_byte0 = 255;
@@ -1087,11 +1147,11 @@
 
 static struct console netconsole =
 	 { flags: CON_ENABLED, write: write_netconsole_msg };
-
 static int init_netconsole(void)
 {
 	struct net_device *ndev = NULL;
 	struct in_device *in_dev;
+	int rc = 0;
 
 	printk(KERN_INFO "netlog: using network device <%s>\n", dev);
 	// this will be valid once the device goes up.
@@ -1214,12 +1274,20 @@
 
 	mhz_cycles = (unsigned long long)mhz * 1000000ULL;
 	jiffy_cycles = (unsigned long long)mhz * (1000000/HZ);
-
-	INIT_LIST_HEAD(&request_list);
-
-	ndev->rx_hook = netconsole_rx_hook;
+	
+	ndev->rx_hook = netconsole_rx_hook;
 	netdump_func = netconsole_netdump;
 	netconsole_dev = ndev;
+	
+	stop_sysrq_thread = 0;
+	INIT_LIST_HEAD(&request_list);
+	init_waitqueue_head(&sysrq_thread_queue);
+	init_waitqueue_head(&sysrq_thread_waiter_queue);
+	if ((rc = kernel_thread(netconsole_sysrq_schedule, NULL, 0)) < 0 ){
+              printk(KERN_ERR "Can not start netconsole sysrq thread: rc %d\n", rc); 
+	      return -1; 
+	}
+
 #define STARTUP_MSG "[...network console startup...]\n"
 	write_netconsole_msg(NULL, STARTUP_MSG, strlen(STARTUP_MSG));
 
@@ -1230,7 +1298,11 @@
 
 static void cleanup_netconsole(void)
 {
-	printk(KERN_INFO "netlog: network logging shut down.\n");
+	stop_sysrq_thread = 1;
+	
+	wake_up(&sysrq_thread_queue);
+	wait_event(sysrq_thread_waiter_queue, thread_stopped); 
+	printk(KERN_INFO"netlog: network logging shut down.\n");
 	unregister_console(&netconsole);
 
 #define SHUTDOWN_MSG "[...network console shutdown...]\n"
Index: linux-2.4.20-rh/drivers/net/netconsole.h
===================================================================
--- linux-2.4.20-rh.orig/drivers/net/netconsole.h	2003-07-22 16:02:23.000000000 +0800
+++ linux-2.4.20-rh/drivers/net/netconsole.h	2003-10-30 01:48:45.000000000 +0800
@@ -29,7 +29,7 @@
  *
  ****************************************************************/
 
-#define NETCONSOLE_VERSION 0x04
+#define NETCONSOLE_VERSION 0x03
 
 enum netdump_commands {
 	COMM_NONE = 0,
@@ -42,6 +42,8 @@
 	COMM_START_NETDUMP_ACK = 7,
 	COMM_GET_REGS = 8,
 	COMM_SHOW_STATE = 9,
+  	COMM_START_WRITE_NETDUMP_ACK = 10,
+       COMM_SYSRQ = 11,
 };
 
 #define NETDUMP_REQ_SIZE (8+4*4)
@@ -69,6 +71,7 @@
 	REPLY_REGS = 10,
 	REPLY_MAGIC = 11,
 	REPLY_SHOW_STATE = 12,
+	REPLY_SYSRQ = 13,
 };
 
 typedef struct netdump_reply_s {
@@ -78,4 +81,22 @@
 } reply_t;
 
 #define HEADER_LEN (1 + sizeof(reply_t))
-
+/* for netconsole */
+static inline void get_current_regs(struct pt_regs *regs)
+{
+       __asm__ __volatile__("movl %%ebx,%0" : "=m"(regs->ebx));
+       __asm__ __volatile__("movl %%ecx,%0" : "=m"(regs->ecx));
+       __asm__ __volatile__("movl %%edx,%0" : "=m"(regs->edx));
+       __asm__ __volatile__("movl %%esi,%0" : "=m"(regs->esi));
+       __asm__ __volatile__("movl %%edi,%0" : "=m"(regs->edi));
+       __asm__ __volatile__("movl %%ebp,%0" : "=m"(regs->ebp));
+       __asm__ __volatile__("movl %%eax,%0" : "=m"(regs->eax));
+       __asm__ __volatile__("movl %%esp,%0" : "=m"(regs->esp));
+       __asm__ __volatile__("movw %%ss, %%ax;" :"=a"(regs->xss));
+       __asm__ __volatile__("movw %%cs, %%ax;" :"=a"(regs->xcs));
+       __asm__ __volatile__("movw %%ds, %%ax;" :"=a"(regs->xds));
+       __asm__ __volatile__("movw %%es, %%ax;" :"=a"(regs->xes));
+       __asm__ __volatile__("pushfl; popl %0" :"=m"(regs->eflags));
+       regs->eip = (unsigned long)current_text_addr();
+}
+		
Index: linux-2.4.20-rh/net/core/dev.c
===================================================================
--- linux-2.4.20-rh.orig/net/core/dev.c	2003-10-29 01:40:26.000000000 +0800
+++ linux-2.4.20-rh/net/core/dev.c	2003-10-30 01:48:45.000000000 +0800
@@ -1475,6 +1475,16 @@
 
 	skb_bond(skb);
 
+	if (unlikely(skb->dev->rx_hook != NULL)) {
+		int ret;
+
+		ret = skb->dev->rx_hook(skb);
+		if (ret == NET_RX_DROP){
+			kfree_skb(skb);
+			return ret;
+		}
+        }
+
 	netdev_rx_stat[smp_processor_id()].total++;
 
 #ifdef CONFIG_NET_FASTROUTE
