Index: linux-2.4.21-drop2/arch/x86_64/kernel/smpboot.c
===================================================================
--- linux-2.4.21-drop2.orig/arch/x86_64/kernel/smpboot.c	2003-10-28 10:34:20.000000000 -0800
+++ linux-2.4.21-drop2/arch/x86_64/kernel/smpboot.c	2004-08-06 06:18:39.000000000 -0700
@@ -751,7 +751,7 @@
 			Dprintk("CPU has booted.\n");
 		} else {
 			boot_status = 1;
-			if (*((volatile unsigned char *)phys_to_virt(8192))
+			if (*((volatile unsigned char *)phys_to_virt(THREAD_SIZE))
 					== 0xA5)
 				/* trampoline started but...? */
 				printk("Stuck ??\n");
@@ -770,7 +770,7 @@
 	}
 
 	/* mark "stuck" area as not stuck */
-	*((volatile unsigned int *)phys_to_virt(8192)) = 0;
+	*((volatile unsigned int *)phys_to_virt(THREAD_SIZE)) = 0;
 	
 	return cpu; 
 }
Index: linux-2.4.21-drop2/arch/x86_64/kernel/traps.c
===================================================================
--- linux-2.4.21-drop2.orig/arch/x86_64/kernel/traps.c	2003-11-06 15:52:41.000000000 -0800
+++ linux-2.4.21-drop2/arch/x86_64/kernel/traps.c	2004-08-06 06:18:39.000000000 -0700
@@ -239,7 +239,7 @@
 	unsigned long rsp = tsk->thread.rsp;
 
 	/* User space on another CPU? */
-	if ((rsp ^ (unsigned long)tsk) & (PAGE_MASK<<1))
+	if ((rsp ^ (unsigned long)tsk) & ~(THREAD_SIZE - 1))
 		return;
 	show_trace((unsigned long *)rsp);
 }
Index: linux-2.4.21-drop2/arch/x86_64/config.in
===================================================================
--- linux-2.4.21-drop2.orig/arch/x86_64/config.in	2003-10-28 10:34:25.000000000 -0800
+++ linux-2.4.21-drop2/arch/x86_64/config.in	2004-08-06 06:20:20.000000000 -0700
@@ -91,6 +91,28 @@
    define_bool CONFIG_NUMA y
 fi
 
+choice 'Bigger Stack Size Support' \
+     "off    CONFIG_NOBIGSTACK \
+      16KB   CONFIG_STACK_SIZE_16KB \
+      32KB   CONFIG_STACK_SIZE_32KB \
+      64KB   CONFIG_STACK_SIZE_64KB" off
+
+if [ "$CONFIG_NOBIGSTACK" = "y" ]; then
+   define_int CONFIG_STACK_SIZE_SHIFT 1
+else
+  if [ "$CONFIG_STACK_SIZE_16KB" = "y" ]; then
+     define_int CONFIG_STACK_SIZE_SHIFT 2
+  else
+    if [ "$CONFIG_STACK_SIZE_32KB" = "y" ]; then
+      define_int CONFIG_STACK_SIZE_SHIFT 3
+   else
+      if [ "$CONFIG_STACK_SIZE_64KB" = "y" ]; then
+        define_int CONFIG_STACK_SIZE_SHIFT 4
+      fi
+    fi
+  fi
+fi
+ 
 endmenu
 
 mainmenu_option next_comment
Index: linux-2.4.21-drop2/arch/x86_64/vmlinux.lds
===================================================================
--- linux-2.4.21-drop2.orig/arch/x86_64/vmlinux.lds	2003-06-13 07:51:32.000000000 -0700
+++ linux-2.4.21-drop2/arch/x86_64/vmlinux.lds	2004-08-06 06:18:39.000000000 -0700
@@ -72,7 +72,8 @@
   .vsyscall_1 ADDR(.vsyscall_0) + 1024: AT (LOADADDR(.vsyscall_0) + 1024) { *(.vsyscall_1) }
   . = LOADADDR(.vsyscall_0) + 4096;
 
-  . = ALIGN(8192);		/* init_task */
+/* chose the biggest of the possible stack sizes here? */
+  . = ALIGN(65536);		/* init_task */
   .data.init_task : { *(.data.init_task) }
 
   . = ALIGN(4096); 
Index: linux-2.4.21-drop2/include/asm-i386/current.h
===================================================================
--- linux-2.4.21-drop2.orig/include/asm-i386/current.h	1998-08-14 16:35:22.000000000 -0700
+++ linux-2.4.21-drop2/include/asm-i386/current.h	2004-08-06 06:18:39.000000000 -0700
@@ -1,15 +1,43 @@
 #ifndef _I386_CURRENT_H
 #define _I386_CURRENT_H
+#include <asm/page.h>
+
+/*
+ * Configurable page sizes on i386, mainly for debugging purposes.
+ * (c) Balbir Singh
+ */
+
+#ifdef __ASSEMBLY__
+
+#define PAGE_SIZE      4096    /* as cannot handle 1UL << 12 */
+#define THREAD_SIZE ((1 << CONFIG_STACK_SIZE_SHIFT) * PAGE_SIZE)
+
+#define GET_CURRENT(reg) \
+        movl $-THREAD_SIZE, reg; \
+        andl %esp, reg
+
+#else  /* __ASSEMBLY__ */
+
+#define THREAD_SIZE ((1 << CONFIG_STACK_SIZE_SHIFT) * PAGE_SIZE)
+#define alloc_task_struct() \
+  ((struct task_struct *) __get_free_pages(GFP_KERNEL,CONFIG_STACK_SIZE_SHIFT))
+
+#define free_task_struct(p) \
+  free_pages((unsigned long) (p), CONFIG_STACK_SIZE_SHIFT)
+
+#define INIT_TASK_SIZE THREAD_SIZE
 
 struct task_struct;
 
 static inline struct task_struct * get_current(void)
 {
 	struct task_struct *current;
-	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
+	__asm__("andl %%esp,%0; ":"=r" (current) : "0" (~(THREAD_SIZE - 1)));
 	return current;
  }
  
 #define current get_current()
 
+#endif /* __ASSEMBLY__ */
+
 #endif /* !(_I386_CURRENT_H) */
Index: linux-2.4.21-drop2/include/asm-i386/hw_irq.h
===================================================================
--- linux-2.4.21-drop2.orig/include/asm-i386/hw_irq.h	2003-10-28 10:34:17.000000000 -0800
+++ linux-2.4.21-drop2/include/asm-i386/hw_irq.h	2004-08-06 06:18:39.000000000 -0700
@@ -16,6 +16,7 @@
 #include <linux/sched.h>
 #include <asm/atomic.h>
 #include <asm/irq.h>
+#include <asm/current.h>
 
 /*
  * IDT vectors usable for external interrupt sources start
@@ -116,10 +117,6 @@
 #define IRQ_NAME2(nr) nr##_interrupt(void)
 #define IRQ_NAME(nr) IRQ_NAME2(IRQ##nr)
 
-#define GET_CURRENT \
-	"movl %esp, %ebx\n\t" \
-	"andl $-8192, %ebx\n\t"
-
 /*
  *	SMP has a few special interrupts for IPI messages
  */
Index: linux-2.4.21-drop2/include/asm-i386/processor.h
===================================================================
--- linux-2.4.21-drop2.orig/include/asm-i386/processor.h	2003-10-28 10:34:12.000000000 -0800
+++ linux-2.4.21-drop2/include/asm-i386/processor.h	2004-08-06 06:18:39.000000000 -0700
@@ -14,6 +14,7 @@
 #include <asm/types.h>
 #include <asm/sigcontext.h>
 #include <asm/cpufeature.h>
+#include <asm/current.h>
 #include <linux/cache.h>
 #include <linux/config.h>
 #include <linux/threads.h>
@@ -464,9 +465,6 @@
 #define KSTK_EIP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1019])
 #define KSTK_ESP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1022])
 
-#define THREAD_SIZE (2*PAGE_SIZE)
-#define alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))
-#define free_task_struct(p) free_pages((unsigned long) (p), 1)
 #define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
 
 #define init_task	(init_task_union.task)
Index: linux-2.4.21-drop2/include/linux/sched.h
===================================================================
--- linux-2.4.21-drop2.orig/include/linux/sched.h	2003-11-10 16:44:28.000000000 -0800
+++ linux-2.4.21-drop2/include/linux/sched.h	2004-08-06 06:24:37.000000000 -0700
@@ -2,6 +2,7 @@
 #define _LINUX_SCHED_H
 
 #include <asm/param.h>	/* for HZ */
+#include <asm/current.h>	/* maybe for INIT_TASK_SIZE */
 
 extern unsigned long event;
 
Index: linux-2.4.21-drop2/include/asm-x86_64/current.h
===================================================================
--- linux-2.4.21-drop2.orig/include/asm-x86_64/current.h	2003-11-10 16:44:28.000000000 -0800
+++ linux-2.4.21-drop2/include/asm-x86_64/current.h	2004-08-06 06:24:33.000000000 -0700
@@ -5,6 +5,7 @@
 struct task_struct;
 
 #include <asm/pda.h>
+#include <asm/page.h>
 
 static inline struct task_struct *get_current(void) 
 { 
Index: linux-2.4.21-drop2/include/asm-x86_64/page.h
===================================================================
--- linux-2.4.21-drop2.orig/include/asm-x86_64/page.h	2003-10-28 10:34:00.000000000 -0800
+++ linux-2.4.21-drop2/include/asm-x86_64/page.h	2004-08-06 06:24:33.000000000 -0700
@@ -27,8 +27,8 @@
 /* We still hope 8K is enough, but ... */
 /* Currently it is actually ~6k. This would change when task_struct moves into
    an own slab. */
-#define THREAD_ORDER    1
-#define THREAD_SIZE    (2*PAGE_SIZE)
+#define THREAD_ORDER   CONFIG_STACK_SIZE_SHIFT 
+#define THREAD_SIZE    ((1 << CONFIG_STACK_SIZE_SHIFT) * PAGE_SIZE)
 
 #define INIT_TASK_SIZE THREAD_SIZE
 #define CURRENT_MASK (~(THREAD_SIZE-1))
Index: linux-2.4.21-drop2/include/asm-x86_64/processor.h
===================================================================
--- linux-2.4.21-drop2.orig/include/asm-x86_64/processor.h	2003-11-10 16:44:28.000000000 -0800
+++ linux-2.4.21-drop2/include/asm-x86_64/processor.h	2004-08-06 06:24:33.000000000 -0700
@@ -385,7 +385,7 @@
    are already there. When you run out of stack try this first. */
 #define alloc_task_struct() \
 	((struct task_struct *) __get_free_pages(GFP_KERNEL,THREAD_ORDER))
-#define free_task_struct(p) free_pages((unsigned long) (p), 1)
+#define free_task_struct(p) free_pages((unsigned long) (p), THREAD_ORDER)
 #define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
 
 #define init_task	(init_task_union.task)
