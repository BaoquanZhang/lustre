diff -ur linux-2.6.5-lnxi.orig/drivers/block/ll_rw_blk.c linux-2.6.5-lnxi/drivers/block/ll_rw_blk.c
--- linux-2.6.5-lnxi.orig/drivers/block/ll_rw_blk.c	2004-11-11 07:28:51.000000000 -0800
+++ linux-2.6.5-lnxi/drivers/block/ll_rw_blk.c	2005-04-11 09:42:22.750936924 -0700
@@ -2458,7 +2458,7 @@ static inline void blk_partition_remap(s
 	}
 }
 
-int dev_check_rdonly(dev_t dev);
+int dev_check_rdonly(struct block_device *bdev);
 
 /**
  * generic_make_request: hand a buffer to its device driver for I/O
@@ -2550,7 +2550,7 @@ end_io:
 
 		/* this is cfs's dev_rdonly check */
 		if (bio->bi_rw == WRITE &&
-				dev_check_rdonly(bio->bi_bdev->bd_dev)) {
+		                dev_check_rdonly(bio->bi_bdev)) {
 			bio_endio(bio, bio->bi_size, 0);
 			break;
 		}
@@ -3086,53 +3086,85 @@ void swap_io_context(struct io_context *
 	*ioc2 = temp;
 }
 
-#define MAX_RDONLY_DEVS		16
-
-static dev_t rdonly_devs[MAX_RDONLY_DEVS] = {0, };
-
 /*
  * Debug code for turning block devices "read-only" (will discard writes
  * silently).  This is for filesystem crash/recovery testing.
  */
-void dev_set_rdonly(struct block_device *bdev, int no_write)
+struct deventry {
+        dev_t dev;
+        struct deventry *next;
+};
+
+static struct deventry *devlist = NULL;
+static spinlock_t devlock = SPIN_LOCK_UNLOCKED; 
+
+int dev_check_rdonly(struct block_device *bdev) 
 {
-	if (no_write >= MAX_RDONLY_DEVS) {
-		printk(KERN_ALERT "%s:%d illegal arg %d (max %d)\n",
-				__FILE__, __LINE__, no_write, MAX_RDONLY_DEVS);
-		return;
+        struct deventry *cur;
+        if (!bdev) return 0;
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (bdev->bd_dev == cur->dev) {
+                        spin_unlock(&devlock);
+                        return 1;
 	}
-
-	if (bdev) {
-		printk(KERN_WARNING "Turning device %s read-only at %d\n",
-				bdev->bd_disk ? bdev->bd_disk->disk_name : "?",
-				no_write);
-		rdonly_devs[no_write] = bdev->bd_dev;
+                cur = cur->next;
 	}
+        spin_unlock(&devlock);
+        return 0;
 }
 
-void dev_clear_rdonly(int no_write)
+void dev_set_rdonly(struct block_device *bdev)
 {
-	if (no_write >= MAX_RDONLY_DEVS) {
-		printk(KERN_ALERT "%s:%d illegal arg %d (max %d)\n",
-				__FILE__, __LINE__, no_write, MAX_RDONLY_DEVS);
-		return;
-	}
+        struct deventry *newdev, *cur;
 
-	if (rdonly_devs[no_write] == 0)
+        if (!bdev) 
+	        return;
+        newdev = kmalloc(sizeof(struct deventry), GFP_KERNEL);
+        if (!newdev) 
 		return;
 	
-	printk(KERN_WARNING "Clearing read-only at %d\n", no_write);
-	rdonly_devs[no_write] = 0;
-}
-
-int dev_check_rdonly(dev_t dev)
-{
-	int i;
-
-	for (i = 0; i < MAX_RDONLY_DEVS; i++)
-		if (rdonly_devs[i] == dev)
-			return 1;
-	return 0;
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (bdev->bd_dev == cur->dev) {
+                        spin_unlock(&devlock);
+                        kfree(newdev);
+                        return;
+}
+                cur = cur->next;
+        }
+        newdev->dev = bdev->bd_dev;
+        newdev->next = devlist;
+        devlist = newdev;
+        spin_unlock(&devlock);
+        printk(KERN_WARNING "Turning device %s read-only\n",
+               bdev->bd_disk ? bdev->bd_disk->disk_name : "?");
+}
+
+void dev_clear_rdonly(struct block_device *bdev) 
+{
+        struct deventry *cur, *last = NULL;
+        if (!bdev) return;
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (bdev->bd_dev == cur->dev) {
+                        if (last) 
+                                last->next = cur->next;
+                        else
+                                devlist = cur->next;
+                        spin_unlock(&devlock);
+                        kfree(cur);
+                        printk(KERN_WARNING "Removing read-only on %s\n",
+			       bdev->bd_disk ? bdev->bd_disk->disk_name : "?");
+			return;
+                }
+                last = cur;
+                cur = cur->next;
+        }
+        spin_unlock(&devlock);
 }
 
 EXPORT_SYMBOL(dev_set_rdonly);
diff -ur linux-2.6.5-lnxi.orig/fs/block_dev.c linux-2.6.5-lnxi/fs/block_dev.c
--- linux-2.6.5-lnxi.orig/fs/block_dev.c	2004-11-11 07:28:30.000000000 -0800
+++ linux-2.6.5-lnxi/fs/block_dev.c	2005-04-11 09:49:01.891407856 -0700
@@ -739,6 +739,7 @@ int blkdev_put(struct block_device *bdev
 	}
 	unlock_kernel();
 	up(&bdev->bd_sem);
+	dev_clear_rdonly(bdev);
 	bdput(bdev);
 	return ret;
 }
diff -ur linux-2.6.5-lnxi.orig/include/linux/fs.h linux-2.6.5-lnxi/include/linux/fs.h
--- linux-2.6.5-lnxi.orig/include/linux/fs.h	2004-11-11 07:28:45.000000000 -0800
+++ linux-2.6.5-lnxi/include/linux/fs.h	2005-04-11 09:43:27.423116140 -0700
@@ -1385,6 +1385,10 @@ extern void file_kill(struct file *f);
 struct bio;
 extern int submit_bio(int, struct bio *);
 extern int bdev_read_only(struct block_device *);
+#define HAVE_CLEAR_RDONLY_ON_PUT
+void dev_set_rdonly(struct block_device *bdev);
+int dev_check_rdonly(struct block_device *bdev);
+void dev_clear_rdonly(struct block_device *bdev);
 extern int set_blocksize(struct block_device *, int);
 extern int sb_set_blocksize(struct super_block *, int);
 extern int sb_min_blocksize(struct super_block *, int);
