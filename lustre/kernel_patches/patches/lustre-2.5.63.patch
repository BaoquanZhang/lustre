 arch/um/kernel/mem.c   |   18 ++++++
 fs/dcache.c            |   12 +++-
 fs/namei.c             |  132 ++++++++++++++++++++++++++++++++++++++-----------
 fs/namespace.c         |    1 
 fs/nfsd/vfs.c          |    2 
 fs/open.c              |   39 ++++++++++++--
 fs/stat.c              |    2 
 fs/sysfs/inode.c       |    2 
 include/linux/dcache.h |   28 ++++++++++
 include/linux/fs.h     |   20 +++++++
 include/linux/namei.h  |    3 -
 include/linux/slab.h   |    1 
 kernel/ksyms.c         |    7 ++
 mm/slab.c              |    5 +
 net/unix/af_unix.c     |    2 
 15 files changed, 231 insertions(+), 43 deletions(-)

--- linux-2.5.63-nointent/arch/um/kernel/mem.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/arch/um/kernel/mem.c	Tue Mar 18 15:02:10 2003
@@ -660,6 +660,22 @@ struct page *pte_mem_map(pte_t pte)
 	return(phys_mem_map(pte_val(pte)));
 }
 
+struct page *check_get_page(unsigned long kaddr)
+{
+        struct page *page;
+        struct mem_region *mr;
+        unsigned long phys = __pa(kaddr);
+	unsigned int n = phys_region_index(phys);
+
+	if(regions[n] == NULL) 
+                return NULL; 
+
+        mr = regions[n];
+        page = (struct page *) mr->mem_map;
+	return page + ((phys_addr(phys)) >> PAGE_SHIFT);
+}
+
+
 struct mem_region *page_region(struct page *page, int *index_out)
 {
 	int i;
@@ -747,7 +763,7 @@ extern unsigned long region_pa(void *vir
 		   (addr <= region->start + region->len))
 			return(mk_phys(addr - region->start, i));
 	}
-	panic("region_pa : no region for virtual address");
+	//panic("region_pa : no region for virtual address");
 	return(0);
 }
 
--- linux-2.5.63-nointent/fs/namei.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/fs/namei.c	Mon Mar 24 17:08:18 2003
@@ -101,6 +101,14 @@
  * any extra contention...
  */
 
+void intent_release(struct dentry *de, struct lookup_intent *it)
+{
+	if (it && de->d_op && de->d_op->d_intent_release)
+		de->d_op->d_intent_release(de, it);
+
+}
+
+
 /* In order to reduce some races, while at the same time doing additional
  * checking and hopefully speeding things up, we copy filenames to the
  * kernel data space before using them..
@@ -273,10 +281,18 @@ void path_release(struct nameidata *nd)
  * Internal lookup() using the new generic dcache.
  * SMP-safe
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags, struct lookup_intent *it)
 {
 	struct dentry * dentry = d_lookup(parent, name);
 	
+	if (dentry && dentry->d_op && dentry->d_op->d_revalidate2) {
+		if (!dentry->d_op->d_revalidate2(dentry, flags, it) &&
+		    !d_invalidate(dentry)) {
+			dput(dentry);
+			dentry = NULL;
+		}
+		return dentry;
+	} else
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
@@ -330,7 +346,7 @@ ok:
  * make sure that nobody added the entry to the dcache in the meantime..
  * SMP-safe
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags, struct lookup_intent *it)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
@@ -348,7 +364,10 @@ static struct dentry * real_lookup(struc
 		struct dentry * dentry = d_alloc(parent, name);
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
-			result = dir->i_op->lookup(dir, dentry);
+			if (dir->i_op->lookup2)
+				result = dir->i_op->lookup2(dir, dentry, it);
+			else
+                                result = dir->i_op->lookup(dir, dentry);
 			if (result)
 				dput(dentry);
 			else {
@@ -370,6 +389,12 @@ static struct dentry * real_lookup(struc
 			dput(result);
 			result = ERR_PTR(-ENOENT);
 		}
+	} else if (result->d_op && result->d_op->d_revalidate2) {
+		if (!result->d_op->d_revalidate2(result, flags, it) &&
+		    !d_invalidate(result)) {
+			dput(result);
+			result = ERR_PTR(-ENOENT);
+		}
 	}
 	return result;
 }
@@ -402,6 +427,7 @@ static inline int do_follow_link(struct 
 	current->link_count--;
 	return err;
 loop:
+	intent_release(dentry, &nd->it);
 	path_release(nd);
 	return err;
 }
@@ -447,15 +473,26 @@ static int follow_mount(struct vfsmount 
 	return res;
 }
 
-static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry)
+static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry,
+                              struct lookup_intent *it)
 {
 	struct vfsmount *mounted;
 
 	spin_lock(&dcache_lock);
 	mounted = lookup_mnt(*mnt, *dentry);
 	if (mounted) {
+		int opc = 0, mode = 0;
 		*mnt = mntget(mounted);
 		spin_unlock(&dcache_lock);
+		if (it) {
+			opc = it->it_op;
+			mode = it->it_mode;
+		}
+		intent_release(*dentry, it);
+		if (it) {
+			it->it_op = opc;
+			it->it_mode = mode;
+		}
 		dput(*dentry);
 		mntput(mounted->mnt_parent);
 		*dentry = dget(mounted->mnt_root);
@@ -467,7 +504,7 @@ static inline int __follow_down(struct v
 
 int follow_down(struct vfsmount **mnt, struct dentry **dentry)
 {
-	return __follow_down(mnt,dentry);
+	return __follow_down(mnt,dentry,NULL);
 }
  
 static inline void follow_dotdot(struct vfsmount **mnt, struct dentry **dentry)
@@ -531,7 +568,7 @@ done:
 	return 0;
 
 need_lookup:
-	dentry = real_lookup(nd->dentry, name, LOOKUP_CONTINUE);
+	dentry = real_lookup(nd->dentry, name, LOOKUP_CONTINUE, &nd->it);
 	if (IS_ERR(dentry))
 		goto fail;
 	goto done;
@@ -665,7 +702,7 @@ int link_path_walk(const char * name, st
 			nd->dentry = next.dentry;
 		}
 		err = -ENOTDIR; 
-		if (!inode->i_op->lookup)
+		if (!inode->i_op->lookup && !inode->i_op->lookup2)
 			break;
 		continue;
 		/* here ends the main loop */
@@ -716,7 +753,8 @@ last_component:
 			break;
 		if (lookup_flags & LOOKUP_DIRECTORY) {
 			err = -ENOTDIR; 
-			if (!inode->i_op || !inode->i_op->lookup)
+			if (!inode->i_op || 
+                            (!inode->i_op->lookup && !inode->i_op->lookup2))
 				break;
 		}
 		goto return_base;
@@ -735,6 +773,7 @@ out_dput:
 		dput(next.dentry);
 		break;
 	}
+	intent_release(nd->dentry, &nd->it);
 	path_release(nd);
 return_err:
 	return err;
@@ -857,7 +896,8 @@ int path_lookup(const char *name, unsign
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+struct dentry * lookup_hash(struct qstr *name, struct dentry * base, 
+                            struct lookup_intent *it)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -880,13 +920,16 @@ struct dentry * lookup_hash(struct qstr 
 			goto out;
 	}
 
-	dentry = cached_lookup(base, name, 0);
+	dentry = cached_lookup(base, name, 0, it);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
-		dentry = inode->i_op->lookup(inode, new);
+                if (inode->i_op->lookup2) 
+                        dentry = inode->i_op->lookup2(inode, new, it);
+                else 
+                        dentry = inode->i_op->lookup(inode, new);
 		if (!dentry) {
 			dentry = new;
 			security_inode_post_lookup(inode, dentry);
@@ -898,7 +941,7 @@ out:
 }
 
 /* SMP-safe */
-struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+struct dentry * lookup_one_len_it(const char * name, struct dentry * base, int len, struct lookup_intent *it)
 {
 	unsigned long hash;
 	struct qstr this;
@@ -918,11 +961,16 @@ struct dentry * lookup_one_len(const cha
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return lookup_hash(&this, base, it);
 access:
 	return ERR_PTR(-EACCES);
 }
 
+struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+{
+        return lookup_one_len_it(name, base, len, NULL);
+}
+
 /*
  *	namei()
  *
@@ -1224,6 +1272,9 @@ int open_namei(const char * pathname, in
 	/*
 	 * Create - we need to know the parent.
 	 */
+	nd->it.it_mode = mode;
+	nd->it.it_op |= IT_CREAT;
+		
 	error = path_lookup(pathname, LOOKUP_PARENT, nd);
 	if (error)
 		return error;
@@ -1239,7 +1290,7 @@ int open_namei(const char * pathname, in
 
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash(&nd->last, nd->dentry, &nd->it);
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1247,7 +1298,8 @@ do_last:
 		up(&dir->d_inode->i_sem);
 		goto exit;
 	}
-
+        
+	nd->it.it_mode = mode;
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
@@ -1277,7 +1329,7 @@ do_last:
 		error = -ELOOP;
 		if (flag & O_NOFOLLOW)
 			goto exit_dput;
-		while (__follow_down(&nd->mnt,&dentry) && d_mountpoint(dentry));
+		while (__follow_down(&nd->mnt,&dentry,&nd->it) && d_mountpoint(dentry));
 	}
 	error = -ENOENT;
 	if (!dentry->d_inode)
@@ -1297,8 +1349,10 @@ ok:
 	return 0;
 
 exit_dput:
+	intent_release(dentry, &nd->it);
 	dput(dentry);
 exit:
+	intent_release(nd->dentry, &nd->it);
 	path_release(nd);
 	return error;
 
@@ -1320,7 +1374,12 @@ do_link:
 	if (error)
 		goto exit_dput;
 	UPDATE_ATIME(dentry->d_inode);
-	error = dentry->d_inode->i_op->follow_link(dentry, nd);
+	if (dentry->d_inode->i_op->follow_link2)
+		error = dentry->d_inode->i_op->follow_link2(dentry, nd, &nd->it);
+	else
+		error = dentry->d_inode->i_op->follow_link(dentry, nd);
+        if (error)
+		intent_release(dentry, &nd->it);
 	dput(dentry);
 	if (error)
 		return error;
@@ -1342,7 +1401,7 @@ do_link:
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash(&nd->last, nd->dentry, &nd->it);
 	putname(nd->last.name);
 	goto do_last;
 }
@@ -1356,7 +1415,7 @@ static struct dentry *lookup_create(stru
 	dentry = ERR_PTR(-EEXIST);
 	if (nd->last_type != LAST_NORM)
 		goto fail;
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash(&nd->last, nd->dentry, &nd->it);
 	if (IS_ERR(dentry))
 		goto fail;
 	if (!is_dir && nd->last.name[nd->last.len] && !dentry->d_inode)
@@ -1588,7 +1647,7 @@ asmlinkage long sys_rmdir(const char * p
 			goto exit1;
 	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, &nd.it);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1654,8 +1713,18 @@ asmlinkage long sys_unlink(const char * 
 	error = -EISDIR;
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
+	if (nd.dentry->d_inode->i_op->unlink2) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->unlink2(nd.dentry->d_inode,
+				nd.last.name,
+				nd.last.len);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+//	dentry = lookup_hash(&nd.last, nd.dentry, &nd.it);
+	dentry = lookup_hash(&nd.last, nd.dentry, NULL);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -1859,7 +1928,8 @@ exit:
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry,
+	                          struct lookup_intent *it)
 {
 	int error = 0;
 	struct inode *target;
@@ -1887,6 +1957,7 @@ int vfs_rename_dir(struct inode *old_dir
 		error = -EBUSY;
 	else 
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry, it);
 	if (target) {
 		if (!error)
 			target->i_flags |= S_DEAD;
@@ -1904,7 +1975,8 @@ int vfs_rename_dir(struct inode *old_dir
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry,
+               struct lookup_intent *it)
 {
 	struct inode *target;
 	int error;
@@ -1921,6 +1993,7 @@ int vfs_rename_other(struct inode *old_d
 		error = -EBUSY;
 	else
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+        intent_release(new_dentry, it);
 	if (!error) {
 		/* The following d_move() should become unconditional */
 		if (!(old_dir->i_sb->s_type->fs_flags & FS_ODD_RENAME))
@@ -1934,7 +2007,8 @@ int vfs_rename_other(struct inode *old_d
 }
 
 int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry, 
+               struct lookup_intent *it)
 {
 	int error;
 	int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
@@ -1960,9 +2034,9 @@ int vfs_rename(struct inode *old_dir, st
 	DQUOT_INIT(new_dir);
 
 	if (is_dir)
-		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry, it);
 	else
-		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry, it);
 	if (!error) {
 		if (old_dir == new_dir)
 			inode_dir_notify(old_dir, DN_RENAME);
@@ -2005,7 +2079,7 @@ static inline int do_rename(const char *
 
 	trap = lock_rename(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = lookup_hash(&oldnd.last, old_dir, &oldnd.it);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -2025,7 +2099,7 @@ static inline int do_rename(const char *
 	error = -EINVAL;
 	if (old_dentry == trap)
 		goto exit4;
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = lookup_hash(&newnd.last, new_dir, &newnd.it);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
@@ -2035,7 +2109,7 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+				   new_dir->d_inode, new_dentry, NULL);
 exit5:
 	dput(new_dentry);
 exit4:
--- linux-2.5.63-nointent/fs/nfsd/vfs.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/fs/nfsd/vfs.c	Tue Mar 18 15:02:10 2003
@@ -1337,7 +1337,7 @@ nfsd_rename(struct svc_rqst *rqstp, stru
 			err = nfserr_perm;
 	} else
 #endif
-	err = vfs_rename(fdir, odentry, tdir, ndentry);
+	err = vfs_rename(fdir, odentry, tdir, ndentry, NULL);
 	if (!err && EX_ISSYNC(tfhp->fh_export)) {
 		nfsd_sync_dir(tdentry);
 		nfsd_sync_dir(fdentry);
--- linux-2.5.63-nointent/fs/sysfs/inode.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/fs/sysfs/inode.c	Tue Mar 18 15:02:10 2003
@@ -540,7 +540,7 @@ static struct dentry * get_dentry(struct
 	qstr.name = name;
 	qstr.len = strlen(name);
 	qstr.hash = full_name_hash(name,qstr.len);
-	return lookup_hash(&qstr,parent);
+	return lookup_hash(&qstr,parent,NULL);
 }
 
 
--- linux-2.5.63-nointent/include/linux/dcache.h~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/include/linux/dcache.h	Tue Mar 18 15:02:10 2003
@@ -12,6 +12,27 @@
 
 struct vfsmount;
 
+#define IT_OPEN     (1)
+#define IT_CREAT    (1<<1)
+#define IT_READDIR  (1<<2)
+#define IT_GETATTR  (1<<3)
+#define IT_LOOKUP   (1<<4)
+#define IT_UNLINK   (1<<5)
+
+
+struct lookup_intent {
+       int it_op;
+       int it_mode;
+       int it_flags;
+       int it_disposition;
+       int it_status;
+       struct iattr *it_iattr;
+       __u64 it_lock_handle[2];
+       int it_lock_mode;
+       void *it_data;
+};
+
+
 /*
  * linux/include/linux/dcache.h
  *
@@ -34,6 +55,8 @@ struct qstr {
 	char name_str[0];
 };
 
+#include <linux/namei.h>
+
 struct dentry_stat_t {
 	int nr_dentry;
 	int nr_unused;
@@ -87,6 +110,7 @@ struct dentry {
 	struct list_head d_subdirs;	/* our children */
 	struct list_head d_alias;	/* inode alias list */
 	int d_mounted;
+        struct lookup_intent *d_it;
 	struct qstr d_name;
 	struct qstr * d_qstr;		/* quick str ptr used in lockless lookup and concurrent d_move */
 	unsigned long d_time;		/* used by d_revalidate */
@@ -107,6 +131,8 @@ struct dentry_operations {
 	int (*d_delete)(struct dentry *);
 	void (*d_release)(struct dentry *);
 	void (*d_iput)(struct dentry *, struct inode *);
+	int (*d_revalidate2)(struct dentry *, int, struct lookup_intent *);
+	void (*d_intent_release)(struct  dentry *, struct lookup_intent *);
 };
 
 /* the dentry parameter passed to d_hash and d_compare is the parent
@@ -147,6 +173,8 @@ d_iput:		no		no		yes
 
 #define DCACHE_REFERENCED	0x0008  /* Recently used, don't discard. */
 #define DCACHE_UNHASHED		0x0010	
+#define DCACHE_LUSTRE_INVALID     0x0011  /* Lustre invalidated */
+
 
 extern spinlock_t dcache_lock;
 extern rwlock_t dparent_lock;
--- linux-2.5.63-nointent/include/linux/fs.h~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/include/linux/fs.h	Tue Mar 18 15:02:10 2003
@@ -234,6 +234,9 @@ typedef int (get_blocks_t)(struct inode 
 #define ATTR_ATTR_FLAG	1024
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
+#define ATTR_RAW       	8192    /* file system, not vfs will massage attrs */
+#define ATTR_FROM_OPEN 	16384    /* called from open path, ie O_TRUNC */
+
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -642,7 +645,7 @@ extern int vfs_symlink(struct inode *, s
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct lookup_intent *it);
 
 /*
  * File types
@@ -728,19 +731,33 @@ struct file_operations {
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
+	struct dentry * (*lookup2) (struct inode *,struct dentry *, 
+                                    struct lookup_intent *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*link2) (struct inode *,struct inode *, const char *, int);
 	int (*unlink) (struct inode *,struct dentry *);
+	int (*unlink2) (struct inode *, const char *, int);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*symlink2) (struct inode *, const char *, int, const char *);
 	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*mkdir2) (struct inode *, const char *, int,int);
 	int (*rmdir) (struct inode *,struct dentry *);
+	int (*rmdir2) (struct inode *, const char *, int);
 	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+	int (*mknod2) (struct inode *, const char *, int,int,int);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename2) (struct inode *, struct inode *,
+			const char *oldname, int oldlen,
+			const char *newname, int newlen);
 	int (*readlink) (struct dentry *, char *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
+	int (*follow_link2) (struct dentry *, struct nameidata *,
+				struct lookup_intent *it);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int);
 	int (*setattr) (struct dentry *, struct iattr *);
+	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t,int);
@@ -953,6 +970,7 @@ extern int register_filesystem(struct fi
 extern int unregister_filesystem(struct file_system_type *);
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount(struct vfsmount *);
+struct vfsmount *do_kern_mount(const char *type, int flags, char *name, void *data);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 
 extern int vfs_statfs(struct super_block *, struct statfs *);
--- linux-2.5.63-nointent/include/linux/namei.h~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/include/linux/namei.h	Tue Mar 18 15:02:10 2003
@@ -11,6 +11,7 @@ struct nameidata {
 	struct qstr	last;
 	unsigned int	flags;
 	int		last_type;
+   struct lookup_intent it;
 };
 
 /*
@@ -44,7 +45,7 @@ extern int FASTCALL(link_path_walk(const
 extern void path_release(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
+extern struct dentry * lookup_hash(struct qstr *, struct dentry *, struct lookup_intent *);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);
--- linux-2.5.63-nointent/include/linux/slab.h~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/include/linux/slab.h	Tue Mar 18 15:02:10 2003
@@ -55,6 +55,7 @@ extern int kmem_cache_destroy(kmem_cache
 extern int kmem_cache_shrink(kmem_cache_t *);
 extern void *kmem_cache_alloc(kmem_cache_t *, int);
 extern void kmem_cache_free(kmem_cache_t *, void *);
+extern int kmem_cache_validate(kmem_cache_t *cachep, void *objp);
 extern unsigned int kmem_cache_size(kmem_cache_t *);
 
 extern void *kmalloc(size_t, int);
--- linux-2.5.63-nointent/kernel/ksyms.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/kernel/ksyms.c	Tue Mar 18 15:02:10 2003
@@ -377,6 +377,7 @@ EXPORT_SYMBOL(unregister_filesystem);
 EXPORT_SYMBOL(kern_mount);
 EXPORT_SYMBOL(__mntput);
 EXPORT_SYMBOL(may_umount);
+EXPORT_SYMBOL(reparent_to_init);
 
 /* executable format registration */
 EXPORT_SYMBOL(register_binfmt);
@@ -407,6 +408,12 @@ EXPORT_SYMBOL(request_irq);
 EXPORT_SYMBOL(free_irq);
 EXPORT_SYMBOL(irq_stat);
 
+/* lustre */
+EXPORT_SYMBOL(do_kern_mount);
+EXPORT_SYMBOL(exit_files);
+EXPORT_SYMBOL(kmem_cache_validate);
+
+
 /* waitqueue handling */
 EXPORT_SYMBOL(add_wait_queue);
 EXPORT_SYMBOL(add_wait_queue_exclusive);
--- linux-2.5.63-nointent/mm/slab.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/mm/slab.c	Tue Mar 18 15:02:10 2003
@@ -1792,6 +1792,11 @@ static inline void __cache_free (kmem_ca
 	}
 }
 
+int kmem_cache_validate(kmem_cache_t *cachep, void *objp)
+{
+	return 1;
+}
+
 /**
  * kmem_cache_alloc - Allocate an object
  * @cachep: The cache to allocate from.
--- linux-2.5.63-nointent/net/unix/af_unix.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/net/unix/af_unix.c	Tue Mar 18 15:02:10 2003
@@ -720,7 +720,7 @@ static int unix_bind(struct socket *sock
 		/*
 		 * Do the final lookup.
 		 */
-		dentry = lookup_hash(&nd.last, nd.dentry);
+		dentry = lookup_hash(&nd.last, nd.dentry, NULL);
 		err = PTR_ERR(dentry);
 		if (IS_ERR(dentry))
 			goto out_mknod_unlock;
--- linux-2.5.63-nointent/fs/dcache.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/fs/dcache.c	Tue Mar 18 15:02:10 2003
@@ -1111,15 +1111,21 @@ void d_delete(struct dentry * dentry)
  * Adds a dentry to the hash according to its name.
  */
  
-void d_rehash(struct dentry * entry)
+void __d_rehash(struct dentry * entry, int lock)
 {
 	struct list_head *list = d_hash(entry->d_parent, entry->d_name.hash);
-	spin_lock(&dcache_lock);
+	if (lock) spin_lock(&dcache_lock);
  	if (!list_empty(&entry->d_hash) && !d_unhashed(entry)) BUG();
  	entry->d_vfs_flags &= ~DCACHE_UNHASHED;
 	entry->d_bucket = list;
  	list_add_rcu(&entry->d_hash, list);
-	spin_unlock(&dcache_lock);
+	if (lock) spin_unlock(&dcache_lock);
+}
+EXPORT_SYMBOL(__d_rehash);
+
+void d_rehash(struct dentry * entry)
+{
+	__d_rehash(entry, 1);
 }
 
 #define do_switch(x,y) do { \
--- linux-2.5.63-nointent/fs/namespace.c~lustre-2.5.63	Tue Mar 18 15:02:10 2003
+++ linux-2.5.63-nointent-root/fs/namespace.c	Tue Mar 18 15:02:10 2003
@@ -925,6 +925,7 @@ void set_fs_pwd(struct fs_struct *fs, st
 		mntput(old_pwdmnt);
 	}
 }
+EXPORT_SYMBOL(set_fs_pwd);
 
 static void chroot_fs_refs(struct nameidata *old_nd, struct nameidata *new_nd)
 {
--- linux-2.5.63-nointent/fs/open.c~lustre-2.5.63	Thu Mar 20 12:43:39 2003
+++ linux-2.5.63-nointent-root/fs/open.c	Mon Mar 24 16:25:47 2003
@@ -97,7 +97,8 @@ static inline long do_sys_truncate(const
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
-
+        struct lookup_intent it = { .it_op = IT_GETATTR };
+	nd.it=it;
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
@@ -142,11 +143,13 @@ static inline long do_sys_truncate(const
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
+		intent_release(nd.dentry, &nd.it);
 		error = do_truncate(nd.dentry, length);
 	}
 	put_write_access(inode);
 
 dput_and_out:
+	intent_release(nd.dentry, &nd.it);
 	path_release(&nd);
 out:
 	return error;
@@ -340,6 +343,8 @@ asmlinkage long sys_access(const char * 
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
+	nd.it=it;	
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -371,6 +376,8 @@ asmlinkage long sys_access(const char * 
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+		                
+		intent_release(nd.dentry, &nd.it);
 		path_release(&nd);
 	}
 
@@ -385,6 +392,8 @@ asmlinkage long sys_chdir(const char * f
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
+	nd.it=it;	
 
 	error = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
 	if (error)
@@ -397,6 +406,7 @@ asmlinkage long sys_chdir(const char * f
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
+	intent_release(nd.dentry, &nd.it);
 	path_release(&nd);
 out:
 	return error;
@@ -436,6 +446,8 @@ asmlinkage long sys_chroot(const char * 
 {
 	struct nameidata nd;
 	int error;
+        struct lookup_intent it = { .it_op = IT_GETATTR };
+	nd.it=it;
 
 	error = __user_walk(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
 	if (error)
@@ -508,6 +520,18 @@ asmlinkage long sys_chmod(const char * f
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
+	
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_mode = mode;
+		newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
 
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
@@ -619,7 +643,10 @@ asmlinkage long sys_fchown(unsigned int 
 struct file *filp_open(const char * filename, int flags, int mode)
 {
 	int namei_flags, error;
+	struct file * temp_filp;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_OPEN, .it_flags = flags };
+	nd.it=it;	
 
 	namei_flags = flags;
 	if ((namei_flags+1) & O_ACCMODE)
@@ -628,9 +655,11 @@ struct file *filp_open(const char * file
 		namei_flags |= 2;
 
 	error = open_namei(filename, namei_flags, mode, &nd);
-	if (!error)
-		return dentry_open(nd.dentry, nd.mnt, flags);
-
+	if (!error) {
+		temp_filp = dentry_open(nd.dentry, nd.mnt, flags);
+		intent_release(nd.dentry,&nd.it);
+		return temp_filp;
+	}	
 	return ERR_PTR(error);
 }
 
@@ -675,7 +704,7 @@ struct file *dentry_open(struct dentry *
 				goto cleanup_all;
 		}
 	}
-
+        
 	return f;
 
 cleanup_all:
--- linux-2.5.63-nointent/fs/stat.c~lustre-2.5.63	Fri Mar 21 21:15:40 2003
+++ linux-2.5.63-nointent-root/fs/stat.c	Fri Mar 21 21:16:53 2003
@@ -65,6 +65,7 @@ int vfs_stat(char *name, struct kstat *s
 	error = user_path_walk(name, &nd);
 	if (!error) {
 		error = vfs_getattr(nd.mnt, nd.dentry, stat);
+		intent_release(nd.dentry, &nd.it);
 		path_release(&nd);
 	}
 	return error;
@@ -80,6 +81,7 @@ int vfs_lstat(char *name, struct kstat *
 	error = user_path_walk_link(name, &nd);
 	if (!error) {
 		error = vfs_getattr(nd.mnt, nd.dentry, stat);
+		intent_release(nd.dentry, &nd.it);
 		path_release(&nd);
 	}
 	return error;

_
