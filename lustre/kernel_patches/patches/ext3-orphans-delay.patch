Index: iam/fs/ext3/super.c
===================================================================
--- iam.orig/fs/ext3/super.c
+++ iam/fs/ext3/super.c
@@ -147,6 +147,8 @@ static void ext3_handle_error(struct sup
 	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
 	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);
 
+	dump_stack();
+
 	if (sb->s_flags & MS_RDONLY)
 		return;
 
@@ -1168,7 +1170,7 @@ static int ext3_check_descriptors (struc
  * e2fsck was run on this filesystem, and it must have already done the orphan
  * inode cleanup for us, so we can safely abort without any further action.
  */
-static void ext3_orphan_cleanup (struct super_block * sb,
+void ext3_orphan_cleanup (struct super_block * sb,
 				 struct ext3_super_block * es)
 {
 	unsigned int s_flags = sb->s_flags;
@@ -1256,7 +1258,9 @@ static void ext3_orphan_cleanup (struct 
 	}
 #endif
 	sb->s_flags = s_flags; /* Restore MS_RDONLY status */
+        EXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;
 }
+EXPORT_SYMBOL(ext3_orphan_cleanup);
 
 #define log2(n) ffz(~(n))
 
@@ -1682,8 +1686,7 @@ static int ext3_fill_super (struct super
 	 * superblock lock.
 	 */
 	EXT3_SB(sb)->s_mount_state |= EXT3_ORPHAN_FS;
-	ext3_orphan_cleanup(sb, es);
-	EXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;
+
 	if (needs_recovery)
 		printk (KERN_INFO "EXT3-fs: recovery complete.\n");
 	ext3_mark_recovery_complete(sb, es);
