 fs/ext3/ext3-exports.c |    9 ++++-
 fs/ext3/inode.c        |   81 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 89 insertions(+), 1 deletion(-)

--- linux/fs/ext3/inode.c~ext3-san-2.4.20-hp	Tue Apr 29 11:01:52 2003
+++ linux-mmonroe/fs/ext3/inode.c	Tue Apr 29 11:01:53 2003
@@ -2734,3 +2734,84 @@ int ext3_change_inode_journal_flag(struc
  * here, in ext3_aops_journal_start() to ensure that the forthcoming "see if we
  * need to extend" test in ext3_prepare_write() succeeds.  
  */
+
+/* for each block: 1 ind + 1 dind + 1 tind
+ * for each block: 3 bitmap blocks
+ * for each block: 3 group descriptor blocks
+ * i inode block
+ * 1 superblock
+ * 2 * EXT3_SINGLEDATA_TRANS_BLOCKS for the quote files
+ * ((1+1+1) * 3 * nblocks) + 1 + 1 + 2 * EXT3_SINGLEDATA_TRANS_BLOCKS
+ *
+ * XXX assuming:
+ * (1) fs logic block size == page size
+ * (2) ext3 in writeback mode
+ */
+static inline int ext3_san_write_trans_blocks(int nblocks)
+{
+	int ret;
+	
+	ret = (1 + 1 + 1) * 3 * nblocks + 1 + 1;
+
+#ifdef CONFIG_QUOTA
+	ret += 2 * EXT3_SINGLEDATA_TRANS_BLOCKS;
+#endif
+
+	return ret;
+}
+
+/* Alloc blocks for an inode, while don't create any buffer/page
+ * for data I/O; set the inode size if file is extended.
+ *
+ * @inode:    target inode
+ * @blocks:   array of logic block number
+ * @nblocks:  how many blocks need be alloced
+ * @newsize:  new filesize we should set
+ *
+ * return:    0 success, otherwise failed
+ *            (*blocks) contains physical block number alloced
+ *
+ * XXX this assume the fs block size == page size
+ */
+int ext3_prep_san_write(struct inode *inode, long *blocks,
+			int nblocks, loff_t newsize)
+{
+	handle_t *handle;
+	struct buffer_head bh_tmp;
+	int needed_blocks;
+	int i, ret = 0, ret2;
+
+	needed_blocks = ext3_san_write_trans_blocks(nblocks);
+
+	lock_kernel();
+	handle = ext3_journal_start(inode, needed_blocks);
+	if (IS_ERR(handle)) {
+		unlock_kernel();
+		return PTR_ERR(handle);
+	}
+	unlock_kernel();
+
+	/* alloc blocks one by one */
+	for (i = 0; i < nblocks; i++) {
+		ret = ext3_get_block_handle(handle, inode, blocks[i],
+						&bh_tmp, 1);
+		if (ret)
+			break;
+
+		blocks[i] = bh_tmp.b_blocknr;
+	}
+
+	/* set inode size if needed */
+	if (!ret && (newsize > inode->i_size)) {
+		inode->i_size = newsize;
+		ext3_mark_inode_dirty(handle, inode);
+	}
+
+	lock_kernel();
+	ret2 = ext3_journal_stop(handle, inode);
+	unlock_kernel();
+
+	if (!ret)
+		ret = ret2;
+	return ret;
+}
--- linux/fs/ext3/ext3-exports.c~ext3-san-2.4.20-hp	Tue Apr 29 11:01:51 2003
+++ linux-mmonroe/fs/ext3/ext3-exports.c	Tue Apr 29 11:07:19 2003
@@ -1,9 +1,15 @@
 #include <linux/config.h>
 #include <linux/module.h>
-#include <linux/ext3_fs.h>
+#include <linux/fs.h>
+#include <linux/locks.h>
+#include <linux/slab.h>
 #include <linux/ext3_jbd.h>
+#include <linux/ext3_fs.h>
 #include <linux/ext3_xattr.h>
 
+int ext3_prep_san_write(struct inode *inode, long *blocks,
+	                int nblocks, loff_t newsize);
+
 EXPORT_SYMBOL(ext3_force_commit);
 EXPORT_SYMBOL(ext3_bread);
 EXPORT_SYMBOL(ext3_xattr_register);
@@ -11,3 +17,4 @@ EXPORT_SYMBOL(ext3_xattr_unregister);
 EXPORT_SYMBOL(ext3_xattr_get);
 EXPORT_SYMBOL(ext3_xattr_list);
 EXPORT_SYMBOL(ext3_xattr_set);
+EXPORT_SYMBOL(ext3_prep_san_write);

_
