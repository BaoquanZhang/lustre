 fs/exec.c          |    2 -
 fs/namei.c         |   82 +++++++++++++++++++++++++++++++++++++++++++++++------
 fs/open.c          |   73 ++++++++++++++++++++++++++++++++++++++++-------
 include/linux/fs.h |    9 +++++
 4 files changed, 145 insertions(+), 21 deletions(-)

--- uml-2.5/fs/namei.c~vfs_nointent_2.5.69_rev1	2003-06-01 22:02:20.000000000 -0600
+++ uml-2.5-braam/fs/namei.c	2003-06-01 22:19:39.000000000 -0600
@@ -1260,7 +1260,7 @@ int may_open(struct nameidata *nd, int a
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0);
+			error = do_truncate(dentry, 0, 1);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1495,6 +1495,7 @@ asmlinkage long sys_mknod(const char __u
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
+	intent_init(&nd.it, IT_LOOKUP, 0);
 
 	if (S_ISDIR(mode))
 		return -EPERM;
@@ -1505,6 +1506,15 @@ asmlinkage long sys_mknod(const char __u
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
+
+	if (nd.dentry->d_inode->i_op->mknod_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->mknod_raw(&nd, mode, dev);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out2;
+	}
+
 	dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(dentry);
 
@@ -1527,6 +1537,7 @@ asmlinkage long sys_mknod(const char __u
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
+out2:
 	path_release(&nd);
 out:
 	putname(tmp);
@@ -1568,10 +1579,18 @@ asmlinkage long sys_mkdir(const char __u
 	if (!IS_ERR(tmp)) {
 		struct dentry *dentry;
 		struct nameidata nd;
+                intent_init(&nd.it, IT_LOOKUP, 0);
 
 		error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
+ 		if (nd.dentry->d_inode->i_op->mkdir_raw) {
+ 			struct inode_operations *op = nd.dentry->d_inode->i_op;
+ 			error = op->mkdir_raw(&nd, mode);
+ 			/* the file system wants to use normal vfs path now */
+ 			if (error != -EOPNOTSUPP)
+ 				goto out2;
+ 		}
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
@@ -1581,6 +1600,7 @@ asmlinkage long sys_mkdir(const char __u
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 		putname(tmp);
@@ -1661,6 +1681,7 @@ asmlinkage long sys_rmdir(const char __u
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+        intent_init(&nd.it, IT_LOOKUP, 0);
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1681,8 +1702,18 @@ asmlinkage long sys_rmdir(const char __u
 			error = -EBUSY;
 			goto exit1;
 	}
+
+	if (nd.dentry->d_inode->i_op->rmdir_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		error = op->rmdir_raw(&nd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
+
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, &nd.it);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1737,6 +1768,7 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
+        intent_init(&nd.it, IT_LOOKUP, 0);
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1748,8 +1780,15 @@ asmlinkage long sys_unlink(const char __
 	error = -EISDIR;
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
+	if (nd.dentry->d_inode->i_op->unlink_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->unlink_raw(&nd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit1;
+	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, NULL);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -1815,10 +1854,18 @@ asmlinkage long sys_symlink(const char _
 	if (!IS_ERR(to)) {
 		struct dentry *dentry;
 		struct nameidata nd;
+                intent_init(&nd.it, IT_LOOKUP, 0);
 
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
+		if (nd.dentry->d_inode->i_op->symlink_raw) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->symlink_raw(&nd, from);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
@@ -1826,6 +1873,7 @@ asmlinkage long sys_symlink(const char _
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 		putname(to);
@@ -1889,6 +1937,8 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
+        intent_init(&nd.it, IT_LOOKUP, 0);
+        intent_init(&old_nd.it, IT_LOOKUP, 0);
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -1903,6 +1953,13 @@ asmlinkage long sys_link(const char __us
 	error = -EXDEV;
 	if (old_nd.mnt != nd.mnt)
 		goto out_release;
+        if (nd.dentry->d_inode->i_op->link_raw) {
+                struct inode_operations *op = nd.dentry->d_inode->i_op;
+                error = op->link_raw(&old_nd, &nd);
+                /* the file system wants to use normal vfs path now */
+                if (error != -EOPNOTSUPP)
+                        goto out_release;
+        }
 	new_dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
@@ -1953,7 +2010,7 @@ exit:
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+                   struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error = 0;
 	struct inode *target;
@@ -1998,7 +2055,7 @@ int vfs_rename_dir(struct inode *old_dir
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+                     struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct inode *target;
 	int error;
@@ -2075,6 +2132,8 @@ static inline int do_rename(const char *
 	struct dentry * old_dentry, *new_dentry;
 	struct dentry * trap;
 	struct nameidata oldnd, newnd;
+        intent_init(&oldnd.it, IT_LOOKUP, 0);
+        intent_init(&newnd.it, IT_LOOKUP, 0);
 
 	error = path_lookup(oldname, LOOKUP_PARENT, &oldnd);
 	if (error)
@@ -2097,9 +2156,15 @@ static inline int do_rename(const char *
 	if (newnd.last_type != LAST_NORM)
 		goto exit2;
 
+	if (old_dir->d_inode->i_op->rename_raw) {
+		error = old_dir->d_inode->i_op->rename_raw(&oldnd, &newnd);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto exit2;
+	}
 	trap = lock_rename(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = lookup_hash(&oldnd.last, old_dir, &oldnd.it);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -2119,7 +2184,7 @@ static inline int do_rename(const char *
 	error = -EINVAL;
 	if (old_dentry == trap)
 		goto exit4;
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = lookup_hash(&newnd.last, new_dir, &newnd.it);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
@@ -2128,8 +2193,7 @@ static inline int do_rename(const char *
 	if (new_dentry == trap)
 		goto exit5;
 
-	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+	error = vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry);
 exit5:
 	dput(new_dentry);
 exit4:
--- uml-2.5/fs/open.c~vfs_nointent_2.5.69_rev1	2003-06-01 21:54:37.000000000 -0600
+++ uml-2.5-braam/fs/open.c	2003-06-01 22:06:02.000000000 -0600
@@ -75,9 +75,10 @@ out:
 	return error;
 }
 
-int do_truncate(struct dentry *dentry, loff_t length)
+int do_truncate(struct dentry *dentry, loff_t length, int called_from_open)
 {
 	int err;
+	struct inode_operations *op = dentry->d_inode->i_op;
 	struct iattr newattrs;
 
 	/* Not pretty: "inode->i_size" shouldn't really be signed. But it is. */
@@ -87,7 +88,14 @@ int do_truncate(struct dentry *dentry, l
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
 	down(&dentry->d_inode->i_sem);
-	err = notify_change(dentry, &newattrs);
+	if (called_from_open)
+		newattrs.ia_valid |= ATTR_FROM_OPEN;
+	if (op->setattr_raw) {
+		newattrs.ia_valid |= ATTR_RAW;
+		newattrs.ia_ctime = CURRENT_TIME;
+		err = op->setattr_raw(dentry->d_inode, &newattrs);
+	} else 
+                err = notify_change(dentry, &newattrs);
 	up(&dentry->d_inode->i_sem);
 	return err;
 }
@@ -142,7 +150,7 @@ static inline long do_sys_truncate(const
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length);
+		error = do_truncate(nd.dentry, length, 0);
 	}
 	put_write_access(inode);
 
@@ -194,7 +202,7 @@ static inline long do_sys_ftruncate(unsi
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length);
+		error = do_truncate(dentry, length, 0);
 out_putf:
 	fput(file);
 out:
@@ -265,9 +273,19 @@ asmlinkage long sys_utime(char __user * 
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
-	down(&inode->i_sem);
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	} else {
+                down(&inode->i_sem);
+                error = notify_change(nd.dentry, &newattrs);
+                up(&inode->i_sem);
+        }
 dput_and_out:
 	path_release(&nd);
 out:
@@ -310,9 +328,19 @@ long do_utimes(char __user * filename, s
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
-	down(&inode->i_sem);
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	} else {
+                down(&inode->i_sem);
+                error = notify_change(nd.dentry, &newattrs);
+                up(&inode->i_sem);
+        }
 dput_and_out:
 	path_release(&nd);
 out:
@@ -513,6 +541,18 @@ asmlinkage long sys_chmod(const char __u
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
 	
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_mode = mode;
+		newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	}
+
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
@@ -546,6 +586,18 @@ static int chown_common(struct dentry * 
 	if (IS_RDONLY(inode))
 		goto out;
 	error = -EPERM;
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = dentry->d_inode->i_op;
+
+		newattrs.ia_uid = user;
+		newattrs.ia_gid = group;
+		newattrs.ia_valid = ATTR_UID | ATTR_GID;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			return error;
+	}
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
 	newattrs.ia_valid =  ATTR_CTIME;
@@ -559,6 +611,7 @@ static int chown_common(struct dentry * 
 	}
 	if (!S_ISDIR(inode->i_mode))
 		newattrs.ia_valid |= ATTR_KILL_SUID|ATTR_KILL_SGID;
+
 	down(&inode->i_sem);
 	error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
--- uml-2.5/include/linux/fs.h~vfs_nointent_2.5.69_rev1	2003-06-01 00:13:35.000000000 -0600
+++ uml-2.5-braam/include/linux/fs.h	2003-06-01 22:06:02.000000000 -0600
@@ -737,13 +737,20 @@ struct inode_operations {
 	struct dentry * (*lookup_it) (struct inode *,struct dentry *,
 					struct lookup_intent *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*link_raw) (struct nameidata *,struct nameidata *);
 	int (*unlink) (struct inode *,struct dentry *);
+	int (*unlink_raw) (struct nameidata *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*symlink_raw) (struct nameidata *,const char *);
 	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*mkdir_raw) (struct nameidata *,int);
 	int (*rmdir) (struct inode *,struct dentry *);
+	int (*rmdir_raw) (struct nameidata *);
 	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+	int (*mknod_raw) (struct nameidata *,int,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename_raw) (struct nameidata *, struct nameidata *);
 	int (*readlink) (struct dentry *, char __user *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
 	void (*truncate) (struct inode *);
@@ -1028,7 +1035,7 @@ static inline int break_lease(struct ino
 
 asmlinkage long sys_open(const char *, int, int);
 asmlinkage long sys_close(unsigned int);	/* yes, it's really unsigned */
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, int called_from_open);
 
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
--- uml-2.5/fs/exec.c~vfs_nointent_2.5.69_rev1	2003-05-31 22:26:50.000000000 -0600
+++ uml-2.5-braam/fs/exec.c	2003-06-01 22:06:02.000000000 -0600
@@ -1353,7 +1353,7 @@ int do_coredump(long signr, int exit_cod
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
-	if (do_truncate(file->f_dentry, 0) != 0)
+	if (do_truncate(file->f_dentry, 0, 0) != 0)
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);

_
