Index: linux-2.4.21/kernel/ksyms.c
===================================================================
--- linux-2.4.21.orig/kernel/ksyms.c	2004-10-20 18:48:05.000000000 -0400
+++ linux-2.4.21/kernel/ksyms.c	2004-10-21 12:46:05.000000000 -0400
@@ -86,6 +86,7 @@
 };
 #endif
 
+extern void show_task(task_t *);
 
 EXPORT_SYMBOL(inter_module_register);
 EXPORT_SYMBOL(inter_module_unregister);
@@ -670,6 +671,7 @@
 extern void check_tasklist_locked(void);
 EXPORT_SYMBOL_GPL(check_tasklist_locked);
 EXPORT_SYMBOL(dump_stack);
+EXPORT_SYMBOL(show_task);
 
 EXPORT_SYMBOL_GPL(netdump_func);
 EXPORT_SYMBOL_GPL(netdump_mode);
Index: linux-2.4.21/arch/i386/kernel/traps.c
===================================================================
--- linux-2.4.21.orig/arch/i386/kernel/traps.c	2004-10-20 18:48:05.000000000 -0400
+++ linux-2.4.21/arch/i386/kernel/traps.c	2004-10-21 12:46:50.000000000 -0400
@@ -133,48 +133,142 @@
 
 #endif
 
-void show_trace(unsigned long * stack)
+void scan_stack (unsigned long *stack)
 {
-#if !CONFIG_FRAME_POINTER
 	int i;
-#endif
 	unsigned long addr;
-	/* static to not take up stackspace; if we race here too bad */
-	static char buffer[512];
+	/* static to not take up stackspace */
+	static char buffer[NR_CPUS][512], *bufp;
 
-	if (!stack)
-		stack = (unsigned long*)&stack;
+	bufp = buffer[smp_processor_id()];
 
-	printk("Call Trace:   ");
 	/*
 	 * If we have frame pointers then use them to get
 	 * a 100% exact backtrace, up until the entry frame:
 	 */
-#if CONFIG_FRAME_POINTER
-#define DO(n) \
-	addr = (int)__builtin_return_address(n);	\
-	if (!kernel_text_address(addr))			\
-		goto out;				\
-	lookup_symbol(addr, buffer, 512);		\
-	printk("[<%08lx>] %s\n", addr, buffer);
-
-	DO(0); DO(1); DO(2); DO(3); DO(4); DO(5); DO(7); DO(8); DO(9);
-	DO(10); DO(11); DO(12); DO(13); DO(14); DO(15); DO(17); DO(18); DO(19);
-out:
-#else
 	i = 1;
 	while (((long) stack & (THREAD_SIZE-1)) != 0) {
 		addr = *stack++;
 		if (kernel_text_address(addr)) {
-			lookup_symbol(addr, buffer, 512);
-			printk("[<%08lx>] %s (0x%p)\n", addr,buffer,stack-1);
+			lookup_symbol(addr, bufp, 512);
+			printk("[<%08lx>] %s (0x%p)\n", addr,bufp,stack-1);
 			i++;
 		}
 	}
-#endif
+}
+
+#if CONFIG_FRAME_POINTER
+void show_stack_frame_params (int param_count, unsigned long params[])
+{
+	int i;
+	unsigned long *p, task_addr, stack_base;
+
+	if (param_count <= 0)
+		return;
+
+	task_addr = (unsigned long) current;
+	stack_base = task_addr + THREAD_SIZE - 1;
+
+	printk("             (");
+
+	for (i = 0, p = params;
+	     ((param_count - i) > 1) && (p >= task_addr) && (p <= stack_base);
+	     i++, p++) {
+		printk("0x%x, ", *p);
+
+		if ((i % 4) == 3)
+			printk("\n              ");
+	}
+
+	if ((p >= task_addr) && (p <= stack_base))
+		printk("0x%x)\n", *p);
+}
+
+/* Display a stack trace for the currently executing task.  The 'dummy'
+ * parameter serves a purpose although its value is unused.  We use the
+ * address of 'dummy' as a reference point for finding the saved %ebp register
+ * value on the stack.
+ */
+void frame_pointer_walk (void *dummy)
+{
+	int i;
+	unsigned long addr, task_addr, *frame_ptr, *next_frame_ptr, *eip_ptr,
+		      eip, stack_base;
+	/* static to not take up stackspace */
+	static char buffer[NR_CPUS][512], *bufp;
+
+	bufp = buffer[smp_processor_id()];
+	task_addr = (unsigned long) current;
+	stack_base = task_addr + THREAD_SIZE - 1;
+	frame_ptr = (unsigned long *) (&dummy - 2);
+
+	for (; ; ) {
+		next_frame_ptr = (unsigned long *) (*frame_ptr);
+		addr = (unsigned long) next_frame_ptr;
+
+		/* Stop when we reach a frame pointer that points to a
+		 * location clearly outside our own kernel stack.
+		 */
+		if ((addr < task_addr) || (addr > stack_base))
+			break;
+
+		eip_ptr = frame_ptr + 1;
+		eip = *eip_ptr;
+
+		if (kernel_text_address(eip)) {
+			lookup_symbol(eip, bufp, 512);
+			show_stack_frame_params(4, frame_ptr + 2);
+			printk("[<%08lx>] %s (0x%x)\n", eip, bufp,
+			       eip_ptr);
+		}
+
+		frame_ptr = next_frame_ptr;
+	}
+}
+
+typedef void (*stack_trace_fn_t) (unsigned long *stack);
+
+void show_trace(unsigned long * stack)
+{
+	static const stack_trace_fn_t trace_fn_vector[] =
+		{ scan_stack, frame_pointer_walk };
+	unsigned long addr, task_addr, stack_base;
+	int task_is_current;
+
+	if (!stack)
+		stack = (unsigned long*)&stack;
+
+	printk("Call Trace:\n");
+	addr = (unsigned long) stack;
+	task_addr = (unsigned long) current;
+	stack_base = task_addr + THREAD_SIZE - 1;
+	task_is_current = (addr >= task_addr) && (addr <= stack_base);
+
+	/* We may use frame pointers to do a stack trace only if the current
+	 * task is being traced.  Tracing some other task in this manner
+	 * would require a saved %ebp register value.  Perhaps in the future
+	 * I'll consider providing a means of obtaining this.
+	 */
+	trace_fn_vector[task_is_current](stack);
+
+	printk("\n");
+}
+
+#else /* CONFIG_FRAME_POINTER */
+
+void show_trace(unsigned long * stack)
+{
+	if (!stack)
+		stack = (unsigned long*)&stack;
+
+	printk("Call Trace:\n");
+	scan_stack(stack);
 	printk("\n");
 }
 
+#endif /* CONFIG_FRAME_POINTER */
+
+
 void show_trace_task(struct task_struct *tsk)
 {
 	unsigned long esp = tsk->thread.esp;
@@ -182,6 +276,7 @@
 	/* User space on another CPU? */
 	if ((esp ^ (unsigned long)tsk) & ~(THREAD_SIZE - 1))
 		return;
+	printk("skipping trace...\n");
 	show_trace((unsigned long *)esp);
 }
 
