


 fs/dcache.c            |    3 
 fs/namei.c             |  230 ++++++++++++++++++++++++++++++++++++++-----------
 fs/nfsd/vfs.c          |    2 
 fs/open.c              |   53 ++++++++---
 fs/stat.c              |    9 +
 include/linux/dcache.h |   31 ++++++
 include/linux/fs.h     |   13 ++
 kernel/ksyms.c         |    1 
 8 files changed, 280 insertions(+), 62 deletions(-)

--- linux-2.4.18-p4smp-l6/fs/dcache.c~vfs_intent	Fri Jan 17 12:44:40 2003
+++ linux-2.4.18-p4smp-l6-root/fs/dcache.c	Fri Jan 17 12:44:40 2003
@@ -150,6 +150,8 @@ repeat:
 unhash_it:
 	list_del_init(&dentry->d_hash);
 
+
+
 kill_it: {
 		struct dentry *parent;
 		list_del(&dentry->d_child);
@@ -645,6 +647,7 @@ struct dentry * d_alloc(struct dentry * 
 	dentry->d_fsdata = NULL;
 	dentry->d_extra_attributes = NULL;
 	dentry->d_mounted = 0;
+	dentry->d_it = NULL;
 	INIT_LIST_HEAD(&dentry->d_hash);
 	INIT_LIST_HEAD(&dentry->d_lru);
 	INIT_LIST_HEAD(&dentry->d_subdirs);
--- linux-2.4.18-p4smp-l6/fs/namei.c~vfs_intent	Fri Jan 17 12:44:40 2003
+++ linux-2.4.18-p4smp-l6-root/fs/namei.c	Fri Jan 17 12:46:08 2003
@@ -1,3 +1,6 @@
+
+
+
 /*
  *  linux/fs/namei.c
  *
@@ -94,6 +97,14 @@
  * XEmacs seems to be relying on it...
  */
 
+void intent_release(struct dentry *de, struct lookup_intent *it)
+{
+	if (it && de->d_op && de->d_op->d_intent_release)
+		de->d_op->d_intent_release(de, it);
+
+}
+
+
 /* In order to reduce some races, while at the same time doing additional
  * checking and hopefully speeding things up, we copy filenames to the
  * kernel data space before using them..
@@ -260,10 +271,19 @@ void path_release(struct nameidata *nd)
  * Internal lookup() using the new generic dcache.
  * SMP-safe
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry *cached_lookup(struct dentry *parent, struct qstr *name,
+				    int flags, struct lookup_intent *it)
 {
 	struct dentry * dentry = d_lookup(parent, name);
 
+	if (dentry && dentry->d_op && dentry->d_op->d_revalidate2) {
+		if (!dentry->d_op->d_revalidate2(dentry, flags, it) &&
+		    !d_invalidate(dentry)) {
+			dput(dentry);
+			dentry = NULL;
+		}
+		return dentry;
+	} else
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
@@ -281,7 +301,8 @@ static struct dentry * cached_lookup(str
  * make sure that nobody added the entry to the dcache in the meantime..
  * SMP-safe
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry *real_lookup(struct dentry *parent, struct qstr *name,
+				  int flags, struct lookup_intent *it)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
@@ -300,6 +321,9 @@ static struct dentry * real_lookup(struc
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
 			lock_kernel();
+			if (dir->i_op->lookup2)
+				result = dir->i_op->lookup2(dir, dentry, it);
+			else
 			result = dir->i_op->lookup(dir, dentry);
 			unlock_kernel();
 			if (result)
@@ -321,6 +345,12 @@ static struct dentry * real_lookup(struc
 			dput(result);
 			result = ERR_PTR(-ENOENT);
 		}
+	} else if (result->d_op && result->d_op->d_revalidate2) {
+		if (!result->d_op->d_revalidate2(result, flags, it) &&
+		    !d_invalidate(result)) {
+			dput(result);
+			result = ERR_PTR(-ENOENT);
+		}
 	}
 	return result;
 }
@@ -334,7 +364,8 @@ int max_recursive_link = 5;
  * Without that kind of total limit, nasty chains of consecutive
  * symlinks can cause almost arbitrarily long lookups. 
  */
-static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd)
+static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd, 
+                                 struct lookup_intent *it)
 {
 	int err;
 	if (current->link_count >= max_recursive_link)
@@ -348,10 +379,14 @@ static inline int do_follow_link(struct 
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
-	err = dentry->d_inode->i_op->follow_link(dentry, nd);
+        if (dentry->d_inode->i_op->follow_link2)
+                err = dentry->d_inode->i_op->follow_link2(dentry, nd, it);
+        else 
+                err = dentry->d_inode->i_op->follow_link(dentry, nd);
 	current->link_count--;
 	return err;
 loop:
+        intent_release(dentry, it);
 	path_release(nd);
 	return -ELOOP;
 }
@@ -449,7 +484,8 @@ static inline void follow_dotdot(struct 
  *
  * We expect 'base' to be positive and a directory.
  */
-int link_path_walk(const char * name, struct nameidata *nd)
+int link_path_walk_it(const char *name, struct nameidata *nd,
+		      struct lookup_intent *it)
 {
 	struct dentry *dentry;
 	struct inode *inode;
@@ -526,12 +562,12 @@ int link_path_walk(const char * name, st
 				break;
 		}
 		/* This does the actual lookups.. */
-		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE, NULL);
 		if (!dentry) {
 			err = -EWOULDBLOCKIO;
 			if (atomic)
 				break;
-			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE, NULL);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
@@ -548,8 +584,8 @@ int link_path_walk(const char * name, st
 		if (!inode->i_op)
 			goto out_dput;
 
-		if (inode->i_op->follow_link) {
-			err = do_follow_link(dentry, nd);
+		if (inode->i_op->follow_link || inode->i_op->follow_link2) {
+			err = do_follow_link(dentry, nd, NULL);
 			dput(dentry);
 			if (err)
 				goto return_err;
@@ -565,7 +601,7 @@ int link_path_walk(const char * name, st
 			nd->dentry = dentry;
 		}
 		err = -ENOTDIR; 
-		if (!inode->i_op->lookup)
+		if (!inode->i_op->lookup && !inode->i_op->lookup2)
 			break;
 		continue;
 		/* here ends the main loop */
@@ -592,12 +628,12 @@ last_component:
 			if (err < 0)
 				break;
 		}
-		dentry = cached_lookup(nd->dentry, &this, 0);
+		dentry = cached_lookup(nd->dentry, &this, 0, it);
 		if (!dentry) {
 			err = -EWOULDBLOCKIO;
 			if (atomic)
 				break;
-			dentry = real_lookup(nd->dentry, &this, 0);
+			dentry = real_lookup(nd->dentry, &this, 0, it);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
@@ -606,8 +642,10 @@ last_component:
 			;
 		inode = dentry->d_inode;
 		if ((lookup_flags & LOOKUP_FOLLOW)
-		    && inode && inode->i_op && inode->i_op->follow_link) {
-			err = do_follow_link(dentry, nd);
+		    && inode && inode->i_op && 
+                    (inode->i_op->follow_link || 
+                     inode->i_op->follow_link2)) {
+			err = do_follow_link(dentry, nd, it);
 			dput(dentry);
 			if (err)
 				goto return_err;
@@ -621,7 +659,8 @@ last_component:
 			goto no_inode;
 		if (lookup_flags & LOOKUP_DIRECTORY) {
 			err = -ENOTDIR; 
-			if (!inode->i_op || !inode->i_op->lookup)
+			if (!inode->i_op || (!inode->i_op->lookup &&
+					     !inode->i_op->lookup2))
 				break;
 		}
 		goto return_base;
@@ -658,15 +697,28 @@ out_dput:
 		dput(dentry);
 		break;
 	}
+        if (err)
+                intent_release(nd->dentry, it);
 	path_release(nd);
 return_err:
 	return err;
 }
 
+int link_path_walk(const char * name, struct nameidata *nd)
+{
+	return link_path_walk_it(name, nd, NULL);
+}
+
+int path_walk_it(const char * name, struct nameidata *nd, struct lookup_intent *it)
+{
+	current->total_link_count = 0;
+	return link_path_walk_it(name, nd, it);
+}
+
 int path_walk(const char * name, struct nameidata *nd)
 {
 	current->total_link_count = 0;
-	return link_path_walk(name, nd);
+	return link_path_walk_it(name, nd, NULL);
 }
 
 /* SMP-safe */
@@ -751,6 +803,17 @@ walk_init_root(const char *name, struct 
 }
 
 /* SMP-safe */
+int path_lookup_it(const char *path, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it)
+{
+	int error = 0;
+	if (path_init(path, flags, nd))
+		error = path_walk_it(path, nd, it);
+	return error;
+}
+
+
+/* SMP-safe */
 int path_lookup(const char *path, unsigned flags, struct nameidata *nd)
 {
 	int error = 0;
@@ -779,7 +842,8 @@ int path_init(const char *name, unsigned
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+struct dentry * lookup_hash_it(struct qstr *name, struct dentry * base,
+			       struct lookup_intent *it)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -802,13 +866,16 @@ struct dentry * lookup_hash(struct qstr 
 			goto out;
 	}
 
-	dentry = cached_lookup(base, name, 0);
+	dentry = cached_lookup(base, name, 0, it);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
 		lock_kernel();
+		if (inode->i_op->lookup2)
+			dentry = inode->i_op->lookup2(inode, new, it);
+		else
 		dentry = inode->i_op->lookup(inode, new);
 		unlock_kernel();
 		if (!dentry)
@@ -820,6 +887,12 @@ out:
 	return dentry;
 }
 
+struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+{
+	return lookup_hash_it(name, base, NULL);
+}
+
+
 /* SMP-safe */
 struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
 {
@@ -841,7 +914,7 @@ struct dentry * lookup_one_len(const cha
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return lookup_hash_it(&this, base, NULL);
 access:
 	return ERR_PTR(-EACCES);
 }
@@ -872,6 +945,23 @@ int __user_walk(const char *name, unsign
 	return err;
 }
 
+int __user_walk_it(const char *name, unsigned flags, struct nameidata *nd,
+		   struct lookup_intent *it)
+{
+	char *tmp;
+	int err;
+
+	tmp = getname(name);
+	err = PTR_ERR(tmp);
+	if (!IS_ERR(tmp)) {
+		err = 0;
+		if (path_init(tmp, flags, nd))
+			err = path_walk_it(tmp, nd, it);
+		putname(tmp);
+	}
+	return err;
+}
+
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -1045,14 +1135,17 @@ int may_open(struct nameidata *nd, int a
         return get_lease(inode, flag);
 }
 
+extern struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+			    int flags, struct lookup_intent *it);
+
 struct file *filp_open(const char * pathname, int open_flags, int mode)
 {
 	int acc_mode, error = 0;
-	struct inode *inode;
 	struct dentry *dentry;
 	struct dentry *dir;
 	int flag = open_flags;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_OPEN };
 	int count = 0;
 
 	if ((flag+1) & O_ACCMODE)
@@ -1066,7 +1159,7 @@ struct file *filp_open(const char * path
 	 * The simplest case - just a plain lookup.
 	 */
 	if (!(flag & O_CREAT)) {
-		error = path_lookup(pathname, lookup_flags(flag), &nd);
+		error = path_lookup_it(pathname, lookup_flags(flag), &nd, &it);
 		if (error)
 			return ERR_PTR(error);
 		dentry = nd.dentry;
@@ -1076,6 +1169,8 @@ struct file *filp_open(const char * path
 	/*
 	 * Create - we need to know the parent.
 	 */
+        it.it_mode = mode;
+        it.it_op |= IT_CREAT;
 	error = path_lookup(pathname, LOOKUP_PARENT, &nd);
 	if (error)
 		return ERR_PTR(error);
@@ -1091,7 +1186,7 @@ struct file *filp_open(const char * path
 
 	dir = nd.dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, &it);
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1100,6 +1195,7 @@ do_last:
 		goto exit;
 	}
 
+	it.it_mode = mode;
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		error = vfs_create(dir->d_inode, dentry,
@@ -1134,7 +1230,8 @@ do_last:
 	error = -ENOENT;
 	if (!dentry->d_inode)
 		goto exit_dput;
-	if (dentry->d_inode->i_op && dentry->d_inode->i_op->follow_link)
+	if (dentry->d_inode->i_op && (dentry->d_inode->i_op->follow_link || 
+                                      dentry->d_inode->i_op->follow_link2))
 		goto do_link;
 
 	dput(nd.dentry);
@@ -1149,11 +1246,13 @@ ok:
 	if (!S_ISREG(nd.dentry->d_inode->i_mode))
 		open_flags &= ~O_TRUNC;
 
-        return dentry_open(nd.dentry, nd.mnt, open_flags);
+        return dentry_open_it(nd.dentry, nd.mnt, open_flags, &it);
 
 exit_dput:
+        intent_release(dentry, &it);
 	dput(dentry);
 exit:
+        intent_release(nd.dentry, &it);
 	path_release(&nd);
 	return ERR_PTR(error);
 
@@ -1172,7 +1271,12 @@ do_link:
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
 	UPDATE_ATIME(dentry->d_inode);
-	error = dentry->d_inode->i_op->follow_link(dentry, &nd);
+        if (dentry->d_inode->i_op->follow_link2) 
+                error = dentry->d_inode->i_op->follow_link2(dentry, &nd, &it);
+        else 
+                error = dentry->d_inode->i_op->follow_link(dentry, &nd);
+	if (error)
+		intent_release(dentry, &it);
 	dput(dentry);
 	if (error)
 		return error;
@@ -1194,13 +1298,15 @@ do_link:
 	}
 	dir = nd.dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, &it);
 	putname(nd.last.name);
 	goto do_last;
 }
 
+
 /* SMP-safe */
-static struct dentry *lookup_create(struct nameidata *nd, int is_dir)
+static struct dentry *lookup_create(struct nameidata *nd, int is_dir,
+				    struct lookup_intent *it)
 {
 	struct dentry *dentry;
 
@@ -1208,7 +1314,7 @@ static struct dentry *lookup_create(stru
 	dentry = ERR_PTR(-EEXIST);
 	if (nd->last_type != LAST_NORM)
 		goto fail;
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 	if (IS_ERR(dentry))
 		goto fail;
 	if (!is_dir && nd->last.name[nd->last.len] && !dentry->d_inode)
@@ -1254,6 +1360,7 @@ asmlinkage long sys_mknod(const char * f
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_MKNOD, .it_mode = mode };
 
 	if (S_ISDIR(mode))
 		return -EPERM;
@@ -1264,7 +1371,7 @@ asmlinkage long sys_mknod(const char * f
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
-	dentry = lookup_create(&nd, 0);
+	dentry = lookup_create(&nd, 0, &it);
 	error = PTR_ERR(dentry);
 
 	mode &= ~current->fs->umask;
@@ -1282,6 +1389,7 @@ asmlinkage long sys_mknod(const char * f
 		default:
 			error = -EINVAL;
 		}
+		intent_release(dentry, &it);
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1322,6 +1430,7 @@ asmlinkage long sys_mkdir(const char * p
 {
 	int error = 0;
 	char * tmp;
+	struct lookup_intent it = { .it_op = IT_MKDIR, .it_mode = mode };
 
 	tmp = getname(pathname);
 	error = PTR_ERR(tmp);
@@ -1332,11 +1441,12 @@ asmlinkage long sys_mkdir(const char * p
 		error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 1);
+		dentry = lookup_create(&nd, 1, &it);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
 					  mode & ~current->fs->umask);
+			intent_release(dentry, &it);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1420,6 +1530,7 @@ asmlinkage long sys_rmdir(const char * p
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_RMDIR };
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1441,10 +1552,11 @@ asmlinkage long sys_rmdir(const char * p
 			goto exit1;
 	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, &it);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
+		intent_release(dentry, &it);
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1488,6 +1600,7 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_UNLINK };
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1500,7 +1613,7 @@ asmlinkage long sys_unlink(const char * 
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, &it);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -1508,6 +1621,7 @@ asmlinkage long sys_unlink(const char * 
 			goto slashes;
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
+		intent_release(dentry, &it);
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1554,6 +1668,7 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
+	struct lookup_intent it = { .it_op = IT_SYMLINK };
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1567,10 +1682,12 @@ asmlinkage long sys_symlink(const char *
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 0);
+		it.it_data = from;
+		dentry = lookup_create(&nd, 0, &it);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
+			intent_release(dentry, &it);
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1635,6 +1752,7 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
+	struct lookup_intent it = { .it_op = IT_LINK };
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1642,7 +1760,7 @@ asmlinkage long sys_link(const char * ol
 		struct dentry *new_dentry;
 		struct nameidata nd, old_nd;
 
-		error = __user_walk(oldname, LOOKUP_POSITIVE, &old_nd);
+		error = __user_walk_it(oldname, LOOKUP_POSITIVE, &old_nd, &it);
 		if (error)
 			goto exit;
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
@@ -1651,10 +1769,12 @@ asmlinkage long sys_link(const char * ol
 		error = -EXDEV;
 		if (old_nd.mnt != nd.mnt)
 			goto out_release;
-		new_dentry = lookup_create(&nd, 0);
+		it.it_op = IT_LINK2;
+		new_dentry = lookup_create(&nd, 0, &it);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
+			intent_release(new_dentry, &it);
 			dput(new_dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1695,7 +1815,8 @@ exit:
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		   struct inode *new_dir, struct dentry *new_dentry,
+		   struct lookup_intent *it)
 {
 	int error;
 	struct inode *target;
@@ -1753,6 +1874,7 @@ int vfs_rename_dir(struct inode *old_dir
 		error = -EBUSY;
 	else 
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry, it);
 	if (target) {
 		if (!error)
 			target->i_flags |= S_DEAD;
@@ -1774,7 +1896,8 @@ out_unlock:
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		     struct inode *new_dir, struct dentry *new_dentry,
+		     struct lookup_intent *it)
 {
 	int error;
 
@@ -1805,6 +1928,7 @@ int vfs_rename_other(struct inode *old_d
 		error = -EBUSY;
 	else
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry, it);
 	double_up(&old_dir->i_zombie, &new_dir->i_zombie);
 	if (error)
 		return error;
@@ -1816,13 +1940,14 @@ int vfs_rename_other(struct inode *old_d
 }
 
 int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry,
+	       struct lookup_intent *it)
 {
 	int error;
 	if (S_ISDIR(old_dentry->d_inode->i_mode))
-		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry,it);
 	else
-		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry,it);
 	if (!error) {
 		if (old_dir == new_dir)
 			inode_dir_notify(old_dir, DN_RENAME);
@@ -1839,6 +1964,7 @@ static inline int do_rename(const char *
 	int error = 0;
 	struct dentry * old_dir, * new_dir;
 	struct dentry * old_dentry, *new_dentry;
+	struct lookup_intent it = { .it_op = IT_RENAME };
 	struct nameidata oldnd, newnd;
 
 	error = path_lookup(oldname, LOOKUP_PARENT, &oldnd);
@@ -1864,7 +1990,7 @@ static inline int do_rename(const char *
 
 	double_lock(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = lookup_hash_it(&oldnd.last, old_dir, &it);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -1880,18 +2006,21 @@ static inline int do_rename(const char *
 		if (newnd.last.name[newnd.last.len])
 			goto exit4;
 	}
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	it.it_op = IT_RENAME2;
+	new_dentry = lookup_hash_it(&newnd.last, new_dir, &it);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
 	lock_kernel();
 	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+				   new_dir->d_inode, new_dentry, &it);
 	unlock_kernel();
 
+	intent_release(new_dentry, &it);
 	dput(new_dentry);
 exit4:
+	intent_release(old_dentry, &it);
 	dput(old_dentry);
 exit3:
 	double_up(&new_dir->d_inode->i_sem, &old_dir->d_inode->i_sem);
@@ -1940,7 +2069,8 @@ out:
 }
 
 static inline int
-__vfs_follow_link(struct nameidata *nd, const char *link)
+__vfs_follow_link(struct nameidata *nd, const char *link, 
+                     struct lookup_intent *it)
 {
 	int res = 0;
 	char *name;
@@ -1953,7 +2083,7 @@ __vfs_follow_link(struct nameidata *nd, 
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
-	res = link_path_walk(link, nd);
+	res = link_path_walk_it(link, nd, it);
 out:
 	if (current->link_count || res || nd->last_type!=LAST_NORM)
 		return res;
@@ -1975,7 +2105,13 @@ fail:
 
 int vfs_follow_link(struct nameidata *nd, const char *link)
 {
-	return __vfs_follow_link(nd, link);
+	return __vfs_follow_link(nd, link, NULL);
+}
+
+int vfs_follow_link_it(struct nameidata *nd, const char *link, 
+                       struct lookup_intent *it)
+{
+	return __vfs_follow_link(nd, link, it);
 }
 
 /* get the link contents into pagecache */
@@ -2017,7 +2153,7 @@ int page_follow_link(struct dentry *dent
 {
 	struct page *page = NULL;
 	char *s = page_getlink(dentry, &page);
-	int res = __vfs_follow_link(nd, s);
+	int res = __vfs_follow_link(nd, s, NULL);
 	if (page) {
 		kunmap(page);
 		page_cache_release(page);
--- linux-2.4.18-p4smp-l6/fs/nfsd/vfs.c~vfs_intent	Fri Jan 17 12:44:40 2003
+++ linux-2.4.18-p4smp-l6-root/fs/nfsd/vfs.c	Fri Jan 17 12:44:40 2003
@@ -1298,7 +1298,7 @@ nfsd_rename(struct svc_rqst *rqstp, stru
 			err = nfserr_perm;
 	} else
 #endif
-	err = vfs_rename(fdir, odentry, tdir, ndentry);
+	err = vfs_rename(fdir, odentry, tdir, ndentry, NULL);
 	unlock_kernel();
 	if (!err && EX_ISSYNC(tfhp->fh_export)) {
 		nfsd_sync_dir(tdentry);
--- linux-2.4.18-p4smp-l6/fs/open.c~vfs_intent	Fri Jan 17 12:44:40 2003
+++ linux-2.4.18-p4smp-l6-root/fs/open.c	Fri Jan 17 12:44:40 2003
@@ -19,6 +19,9 @@
 #include <asm/uaccess.h>
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
+extern int path_walk_it(const char *name, struct nameidata *nd,
+			struct lookup_intent *it);
+extern void intent_release(struct dentry *de, struct lookup_intent *it);
 
 int vfs_statfs(struct super_block *sb, struct statfs *buf)
 {
@@ -118,12 +121,13 @@ static inline long do_sys_truncate(const
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
+	struct lookup_intent it = { .it_op = IT_SETATTR };
 
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path_walk(path, &nd);
+	error = user_path_walk_it(path, &nd, &it);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
@@ -168,6 +172,7 @@ static inline long do_sys_truncate(const
 	put_write_access(inode);
 
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -259,8 +264,9 @@ asmlinkage long sys_utime(char * filenam
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
+	struct lookup_intent it = { .it_op = IT_SETATTR };
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
@@ -286,6 +292,7 @@ asmlinkage long sys_utime(char * filenam
 	}
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -303,8 +310,9 @@ asmlinkage long sys_utimes(char * filena
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
+	struct lookup_intent it = { .it_op = IT_SETATTR };
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 
 	if (error)
 		goto out;
@@ -331,6 +339,7 @@ asmlinkage long sys_utimes(char * filena
 	}
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -347,6 +356,7 @@ asmlinkage long sys_access(const char * 
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -364,13 +374,14 @@ asmlinkage long sys_access(const char * 
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = user_path_walk(filename, &nd);
+	res = user_path_walk_it(filename, &nd, &it);
 	if (!res) {
 		res = permission(nd.dentry->d_inode, mode);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 
@@ -385,8 +396,11 @@ asmlinkage long sys_chdir(const char * f
 {
 	int error;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = __user_walk(filename,LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,&nd);
+	error = __user_walk_it(filename,
+			       LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,
+			       &nd, &it);
 	if (error)
 		goto out;
 
@@ -397,6 +411,7 @@ asmlinkage long sys_chdir(const char * f
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -436,9 +451,10 @@ asmlinkage long sys_chroot(const char * 
 {
 	int error;
 	struct nameidata nd;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = __user_walk(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
-		      LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
+	error = __user_walk_it(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
+			       LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd, &it);
 	if (error)
 		goto out;
 
@@ -454,6 +470,7 @@ asmlinkage long sys_chroot(const char * 
 	set_fs_altroot();
 	error = 0;
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -498,8 +515,9 @@ asmlinkage long sys_chmod(const char * f
 	struct inode * inode;
 	int error;
 	struct iattr newattrs;
+	struct lookup_intent it = { .it_op = IT_SETATTR };
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
@@ -519,6 +537,7 @@ asmlinkage long sys_chmod(const char * f
 	error = notify_change(nd.dentry, &newattrs);
 
 dput_and_out:
+	intent_release(nd.dentry, &it);
 	path_release(&nd);
 out:
 	return error;
@@ -588,10 +607,12 @@ asmlinkage long sys_chown(const char * f
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_SETATTR };
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (!error) {
 		error = chown_common(nd.dentry, user, group);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -601,10 +622,12 @@ asmlinkage long sys_lchown(const char * 
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_SETATTR };
 
-	error = user_path_walk_link(filename, &nd);
+	error = user_path_walk_link_it(filename, &nd, &it);
 	if (!error) {
 		error = chown_common(nd.dentry, user, group);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -628,7 +651,8 @@ extern ssize_t do_readahead(struct file 
 /* for files over a certains size it doesn't pay to do readahead on open */
 #define READAHEAD_CUTOFF 48000
 
-struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt,
+			    int flags, struct lookup_intent *it)
 {
 	struct file * f;
 	struct inode *inode;
@@ -693,6 +717,7 @@ struct file *dentry_open(struct dentry *
 		do_readahead(f, 0, (48 * 1024) >> PAGE_SHIFT);
 	
 
+	intent_release(dentry, it);
 	return f;
 
 cleanup_all:
@@ -707,11 +732,17 @@ cleanup_all:
 cleanup_file:
 	put_filp(f);
 cleanup_dentry:
+	intent_release(dentry, it);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
 }
 
+struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+{
+	return dentry_open_it(dentry, mnt, flags, NULL);
+}
+
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
--- linux-2.4.18-p4smp-l6/fs/stat.c~vfs_intent	Fri Jan 17 12:44:40 2003
+++ linux-2.4.18-p4smp-l6-root/fs/stat.c	Fri Jan 17 12:44:40 2003
@@ -13,6 +13,7 @@
 
 #include <asm/uaccess.h>
 
+extern void intent_release(struct dentry *de, struct lookup_intent *it);
 /*
  * Revalidate the inode. This is required for proper NFS attribute caching.
  */
@@ -104,10 +105,12 @@ int vfs_stat(char *name, struct kstat *s
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = user_path_walk(name, &nd);
+	error = user_path_walk_it(name, &nd, &it);
 	if (!error) {
 		error = do_getattr(nd.mnt, nd.dentry, stat);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
@@ -117,10 +120,12 @@ int vfs_lstat(char *name, struct kstat *
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it = { .it_op = IT_GETATTR };
 
-	error = user_path_walk_link(name, &nd);
+	error = user_path_walk_link_it(name, &nd, &it);
 	if (!error) {
 		error = do_getattr(nd.mnt, nd.dentry, stat);
+		intent_release(nd.dentry, &it);
 		path_release(&nd);
 	}
 	return error;
--- linux-2.4.18-p4smp-l6/include/linux/dcache.h~vfs_intent	Fri Jan 17 12:44:40 2003
+++ linux-2.4.18-p4smp-l6-root/include/linux/dcache.h	Fri Jan 17 12:44:40 2003
@@ -6,6 +6,34 @@
 #include <asm/atomic.h>
 #include <linux/mount.h>
 
+#define IT_OPEN  (1)
+#define IT_CREAT  (1<<1)
+#define IT_MKDIR  (1<<2)
+#define IT_LINK  (1<<3)
+#define IT_LINK2  (1<<4)
+#define IT_SYMLINK  (1<<5)
+#define IT_UNLINK  (1<<6)
+#define IT_RMDIR  (1<<7)
+#define IT_RENAME  (1<<8)
+#define IT_RENAME2  (1<<9)
+#define IT_READDIR  (1<<10)
+#define IT_GETATTR  (1<<11)
+#define IT_SETATTR  (1<<12)
+#define IT_READLINK  (1<<13)
+#define IT_MKNOD  (1<<14)
+#define IT_LOOKUP  (1<<15)
+
+struct lookup_intent {
+	int it_op;
+	int it_mode;
+	int it_disposition;
+	int it_status;
+	struct iattr *it_iattr;
+	__u64 it_lock_handle[2];
+	int it_lock_mode;
+	void *it_data;
+};
+
 /*
  * linux/include/linux/dcache.h
  *
@@ -78,6 +106,7 @@ struct dentry {
 	unsigned long d_time;		/* used by d_revalidate */
 	struct dentry_operations  *d_op;
 	struct super_block * d_sb;	/* The root of the dentry tree */
+	struct lookup_intent *d_it;
 	unsigned long d_vfs_flags;
 	void * d_fsdata;		/* fs-specific data */
 	void * d_extra_attributes;	/* TUX-specific data */
@@ -91,6 +120,8 @@ struct dentry_operations {
 	int (*d_delete)(struct dentry *);
 	void (*d_release)(struct dentry *);
 	void (*d_iput)(struct dentry *, struct inode *);
+	int (*d_revalidate2)(struct dentry *, int, struct lookup_intent *);
+	void (*d_intent_release)(struct dentry *, struct lookup_intent *);
 };
 
 /* the dentry parameter passed to d_hash and d_compare is the parent
--- linux-2.4.18-p4smp-l6/include/linux/fs.h~vfs_intent	Fri Jan 17 12:44:40 2003
+++ linux-2.4.18-p4smp-l6-root/include/linux/fs.h	Fri Jan 17 12:44:40 2003
@@ -576,6 +576,7 @@ struct file {
 
 	/* needed for tty driver, and maybe others */
 	void			*private_data;
+	struct lookup_intent    *f_intent;
 
 	/* preallocated helper kiobuf to speedup O_DIRECT */
 	struct kiobuf		*f_iobuf;
@@ -836,7 +837,9 @@ extern int vfs_symlink(struct inode *, s
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		struct inode *new_dir, struct dentry *new_dentry,
+		struct lookup_intent *it);
 
 /*
  * File types
@@ -897,6 +900,7 @@ struct file_operations {
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
+	struct dentry * (*lookup2) (struct inode *,struct dentry *, struct lookup_intent *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
@@ -907,6 +911,8 @@ struct inode_operations {
 			struct inode *, struct dentry *);
 	int (*readlink) (struct dentry *, char *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
+	int (*follow_link2) (struct dentry *, struct nameidata *, 
+                            struct lookup_intent *it);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int);
 	int (*revalidate) (struct dentry *);
@@ -1383,6 +1389,7 @@ typedef int (*read_actor_t)(read_descrip
 extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
 
 extern int FASTCALL(__user_walk(const char *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_it(const char *, unsigned, struct nameidata *, struct lookup_intent *it));
 extern int FASTCALL(path_init(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
@@ -1394,6 +1401,8 @@ extern struct dentry * lookup_one_len(co
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
 #define user_path_walk(name,nd)	 __user_walk(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd)
 #define user_path_walk_link(name,nd) __user_walk(name, LOOKUP_POSITIVE, nd)
+#define user_path_walk_it(name,nd,it)  __user_walk_it(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd, it)
+#define user_path_walk_link_it(name,nd,it) __user_walk_it(name, LOOKUP_POSITIVE, nd, it)
 
 extern void inode_init_once(struct inode *);
 extern void iput(struct inode *);
@@ -1494,6 +1503,8 @@ extern struct file_operations generic_ro
 
 extern int vfs_readlink(struct dentry *, char *, int, const char *);
 extern int vfs_follow_link(struct nameidata *, const char *);
+extern int vfs_follow_link_it(struct nameidata *, const char *, 
+                              struct lookup_intent *it);
 extern int page_readlink(struct dentry *, char *, int);
 extern int page_follow_link(struct dentry *, struct nameidata *);
 extern struct inode_operations page_symlink_inode_operations;
--- linux-2.4.18-p4smp-l6/kernel/ksyms.c~vfs_intent	Fri Jan 17 12:44:40 2003
+++ linux-2.4.18-p4smp-l6-root/kernel/ksyms.c	Fri Jan 17 12:44:40 2003
@@ -294,6 +294,7 @@ EXPORT_SYMBOL(read_cache_page);
 EXPORT_SYMBOL(set_page_dirty);
 EXPORT_SYMBOL(vfs_readlink);
 EXPORT_SYMBOL(vfs_follow_link);
+EXPORT_SYMBOL(vfs_follow_link_it);
 EXPORT_SYMBOL(page_readlink);
 EXPORT_SYMBOL(page_follow_link);
 EXPORT_SYMBOL(page_symlink_inode_operations);

_
