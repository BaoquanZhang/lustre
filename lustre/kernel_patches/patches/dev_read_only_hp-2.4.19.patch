 drivers/block/blkpg.c  |   38 ++++++++++++++++++++++++++++++++++++++
 drivers/block/loop.c   |    3 +++
 drivers/ide/ide-disk.c |    4 ++++
 3 files changed, 45 insertions(+)

--- linux-2.4.19-hppl/drivers/block/blkpg.c~dev_read_only_hp_chaos	2003-04-11 16:36:21.000000000 +0800
+++ linux-2.4.19-hppl-root/drivers/block/blkpg.c	2003-04-11 16:47:55.000000000 +0800
@@ -309,6 +309,44 @@ int blk_ioctl(kdev_t dev, unsigned int c
 }
 
 EXPORT_SYMBOL(blk_ioctl);
+ 
+   
+ 
+ #define NUM_DEV_NO_WRITE 16
+ static int dev_no_write[NUM_DEV_NO_WRITE];
+ 
+ /*
+  * Debug code for turning block devices "read-only" (will discard writes
+  * silently).  This is for filesystem crash/recovery testing.
+  */
+ void dev_set_rdonly(kdev_t dev, int no_write)
+ {
+ 	if (dev) {
+ 		printk(KERN_WARNING "Turning device %s read-only\n",
+ 		       bdevname(dev));
+ 		dev_no_write[no_write] = 0xdead0000 + dev;
+ 	}
+ }
+ 
+ int dev_check_rdonly(kdev_t dev) {
+ 	int i;
+ 
+ 	for (i = 0; i < NUM_DEV_NO_WRITE; i++) {
+ 		if ((dev_no_write[i] & 0xffff0000) == 0xdead0000 &&
+ 		    dev == (dev_no_write[i] & 0xffff))
+ 			return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ void dev_clear_rdonly(int no_write) {
+ 	dev_no_write[no_write] = 0;
+ }
+ 
+ EXPORT_SYMBOL(dev_set_rdonly);
+ EXPORT_SYMBOL(dev_check_rdonly);
+ EXPORT_SYMBOL(dev_clear_rdonly);
+ 
 
 /**
  * get_last_sector()
--- linux-2.4.19-hppl/drivers/block/loop.c~dev_read_only_hp_chaos	2002-08-03 08:39:43.000000000 +0800
+++ linux-2.4.19-hppl-root/drivers/block/loop.c	2003-04-11 16:46:47.000000000 +0800
@@ -474,6 +474,9 @@ static int loop_make_request(request_que
 	spin_unlock_irq(&lo->lo_lock);
 
 	if (rw == WRITE) {
+		if (dev_check_rdonly(rbh->b_rdev))
+			goto err;
+
 		if (lo->lo_flags & LO_FLAGS_READ_ONLY)
 			goto err;
 	} else if (rw == READA) {
--- linux-2.4.19-hppl/drivers/ide/ide-disk.c~dev_read_only_hp_chaos	2002-08-03 08:39:44.000000000 +0800
+++ linux-2.4.19-hppl-root/drivers/ide/ide-disk.c	2003-04-11 16:46:47.000000000 +0800
@@ -551,6 +551,10 @@ static ide_startstop_t lba_48_rw_disk (i
  */
 static ide_startstop_t do_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long block)
 {
+	if (rq->cmd == WRITE && dev_check_rdonly(rq->rq_dev)) {
+		ide_end_request(1, HWGROUP(drive));
+		return ide_stopped;
+	}
 	if (IDE_CONTROL_REG)
 		OUT_BYTE(drive->ctl,IDE_CONTROL_REG);
 

_
