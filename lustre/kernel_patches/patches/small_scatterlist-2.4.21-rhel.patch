diff -X dontdiff -urp kern_oldest/crypto/cipher.c kern_fix/crypto/cipher.c
--- kern_oldest/crypto/cipher.c	2006-05-01 11:55:53.000000000 -0700
+++ kern_fix/crypto/cipher.c	2006-05-01 14:14:13.000000000 -0700
@@ -88,12 +88,21 @@ static void scatterwalk_start(struct sca
 
 	walk->sg = sg;
 
+#if SMALL_SCATTERLIST
+	walk->page = sg->u.page.page;
+	walk->len_this_segment = sg->length;
+
+	rest_of_page = PAGE_CACHE_SIZE - (sg->u.page.offset & (PAGE_CACHE_SIZE - 1));
+	walk->len_this_page = min(sg->length, rest_of_page);
+	walk->offset = sg->u.page.offset;
+#else
 	walk->page = sg->page;
 	walk->len_this_segment = sg->length;
 
 	rest_of_page = PAGE_CACHE_SIZE - (sg->offset & (PAGE_CACHE_SIZE - 1));
 	walk->len_this_page = min(sg->length, rest_of_page);
 	walk->offset = sg->offset;
+#endif
 }
 
 static void scatterwalk_map(struct scatter_walk *walk, int out)
diff -X dontdiff -urp kern_oldest/crypto/digest.c kern_fix/crypto/digest.c
--- kern_oldest/crypto/digest.c	2006-05-01 11:55:53.000000000 -0700
+++ kern_fix/crypto/digest.c	2006-05-01 14:14:13.000000000 -0700
@@ -29,7 +29,11 @@ static void update(struct crypto_tfm *tf
 	unsigned int i;
 	
 	for (i = 0; i < nsg; i++) {
+#if SMALL_SCATTERLIST
+		char *p = crypto_kmap(sg[i].u.page.page, 0) + sg[i].u.page.offset;
+#else
 		char *p = crypto_kmap(sg[i].page, 0) + sg[i].offset;
+#endif
 		tfm->__crt_alg->cra_digest.dia_update(crypto_tfm_ctx(tfm),
 		                                      p, sg[i].length);
 		crypto_kunmap(p, 0);
@@ -50,7 +54,11 @@ static void digest(struct crypto_tfm *tf
 	tfm->crt_digest.dit_init(tfm);
 		
 	for (i = 0; i < nsg; i++) {
+#if SMALL_SCATTERLIST
+		char *p = crypto_kmap(sg[i].u.page.page, 0) + sg[i].u.page.offset;
+#else
 		char *p = crypto_kmap(sg[i].page, 0) + sg[i].offset;
+#endif
 		tfm->__crt_alg->cra_digest.dia_update(crypto_tfm_ctx(tfm),
 		                                      p, sg[i].length);
 		crypto_kunmap(p, 0);
diff -X dontdiff -urp kern_oldest/crypto/hmac.c kern_fix/crypto/hmac.c
--- kern_oldest/crypto/hmac.c	2006-05-01 11:55:53.000000000 -0700
+++ kern_fix/crypto/hmac.c	2006-05-01 14:14:13.000000000 -0700
@@ -25,8 +25,14 @@ static void hash_key(struct crypto_tfm *
 {
 	struct scatterlist tmp;
 	
+#if SMALL_SCATTERLIST
+	tmp.ispaged = 1;
+	tmp.u.page.page = virt_to_page(key);
+	tmp.u.page.offset = ((long)key & ~PAGE_MASK);
+#else
 	tmp.page = virt_to_page(key);
 	tmp.offset = ((long)key & ~PAGE_MASK);
+#endif
 	tmp.length = keylen;
 	crypto_digest_digest(tfm, &tmp, 1, key);
 		
@@ -70,8 +76,14 @@ void crypto_hmac_init(struct crypto_tfm 
 	for (i = 0; i < crypto_tfm_alg_blocksize(tfm); i++)
 		ipad[i] ^= 0x36;
 
+#if SMALL_SCATTERLIST
+	tmp.ispaged = 1;
+	tmp.u.page.page = virt_to_page(ipad);
+	tmp.u.page.offset = ((long)ipad & ~PAGE_MASK);
+#else
 	tmp.page = virt_to_page(ipad);
 	tmp.offset = ((long)ipad & ~PAGE_MASK);
+#endif
 	tmp.length = crypto_tfm_alg_blocksize(tfm);
 	
 	crypto_digest_init(tfm);
@@ -104,15 +116,27 @@ void crypto_hmac_final(struct crypto_tfm
 	for (i = 0; i < crypto_tfm_alg_blocksize(tfm); i++)
 		opad[i] ^= 0x5c;
 
+#if SMALL_SCATTERLIST
+	tmp.ispaged = 1;
+	tmp.u.page.page = virt_to_page(opad);
+	tmp.u.page.offset = ((long)opad & ~PAGE_MASK);
+#else
 	tmp.page = virt_to_page(opad);
 	tmp.offset = ((long)opad & ~PAGE_MASK);
+#endif
 	tmp.length = crypto_tfm_alg_blocksize(tfm);
 
 	crypto_digest_init(tfm);
 	crypto_digest_update(tfm, &tmp, 1);
 	
+#if SMALL_SCATTERLIST
+	tmp.ispaged = 1;
+	tmp.u.page.page = virt_to_page(out);
+	tmp.u.page.offset = ((long)out & ~PAGE_MASK);
+#else
 	tmp.page = virt_to_page(out);
 	tmp.offset = ((long)out & ~PAGE_MASK);
+#endif
 	tmp.length = crypto_tfm_alg_digestsize(tfm);
 	
 	crypto_digest_update(tfm, &tmp, 1);
diff -X dontdiff -urp kern_oldest/crypto/tcrypt.c kern_fix/crypto/tcrypt.c
--- kern_oldest/crypto/tcrypt.c	2006-05-01 11:55:53.000000000 -0700
+++ kern_fix/crypto/tcrypt.c	2006-05-01 14:14:13.000000000 -0700
@@ -24,6 +24,15 @@
 #include <linux/highmem.h>
 #include "tcrypt.h"
 
+#if SMALL_SCATTERLIST
+#define SG_PAGE(sg)    ((sg).u.page.page)
+#define SG_OFFSET(sg)  ((sg).u.page.offset)
+#define SG_ADDRESS(sg) ((sg).u.address)
+#else
+#define SG_PAGE(sg)    ((sg).page)
+#define SG_OFFSET(sg)  ((sg).offset)
+#define SG_ADDRESS(sg) ((sg).address)
+#endif /* !SMALL_SCATTERLIST */
 /*
  * Need to kmalloc() memory for testing kmap().
  */
@@ -95,8 +104,8 @@ test_md5(void)
 		memset(result, 0, sizeof (result));
 
 		p = md5_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(md5_tv[i].plaintext);
 
 		crypto_digest_init(tfm);
@@ -118,13 +127,13 @@ test_md5(void)
 	memcpy(&xbuf[IDX2], "nopqrstuvwxyz", 13);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 13;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 13;
 
 	memset(result, 0, sizeof (result));
@@ -172,8 +181,8 @@ test_hmac_md5(void)
 		memset(result, 0, sizeof (result));
 
 		p = hmac_md5_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(hmac_md5_tv[i].plaintext);
 
 		klen = strlen(hmac_md5_tv[i].key);
@@ -194,13 +203,13 @@ test_hmac_md5(void)
 	memcpy(&xbuf[IDX2], "for nothing?", 12);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 16;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 12;
 
 	memset(result, 0, sizeof (result));
@@ -249,8 +258,8 @@ test_hmac_sha1(void)
 		memset(result, 0, sizeof (result));
 
 		p = hmac_sha1_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(hmac_sha1_tv[i].plaintext);
 
 		klen = strlen(hmac_sha1_tv[i].key);
@@ -273,13 +282,13 @@ test_hmac_sha1(void)
 	memcpy(&xbuf[IDX2], "for nothing?", 12);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 16;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 12;
 
 	memset(result, 0, sizeof (result));
@@ -328,8 +337,8 @@ test_hmac_sha256(void)
 		memset(result, 0, sizeof (result));
 
 		p = hmac_sha256_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(hmac_sha256_tv[i].plaintext);
 
 		klen = strlen(hmac_sha256_tv[i].key);
@@ -382,8 +391,8 @@ test_md4(void)
 		memset(result, 0, sizeof (result));
 
 		p = md4_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(md4_tv[i].plaintext);
 
 		crypto_digest_digest(tfm, sg, 1, result);
@@ -432,8 +441,8 @@ test_sha1(void)
 		memset(result, 0, sizeof (result));
 
 		p = sha1_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(sha1_tv[i].plaintext);
 
 		crypto_digest_init(tfm);
@@ -455,13 +464,13 @@ test_sha1(void)
 	memcpy(&xbuf[IDX2], "hijkijkljklmklmnlmnomnopnopq", 28);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 28;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 28;
 
 	memset(result, 0, sizeof (result));
@@ -507,8 +516,8 @@ test_sha256(void)
 		memset(result, 0, sizeof (result));
 
 		p = sha256_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(sha256_tv[i].plaintext);
 
 		crypto_digest_init(tfm);
@@ -530,13 +539,13 @@ test_sha256(void)
 	memcpy(&xbuf[IDX2], "hijkijkljklmklmnlmnomnopnopq", 28);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 28;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 28;
 
 	memset(result, 0, sizeof (result));
@@ -583,8 +592,8 @@ test_sha384(void)
 		memset(result, 0, sizeof (result));
 
 		p = sha384_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(sha384_tv[i].plaintext);
 
 		crypto_digest_init(tfm);
@@ -635,8 +644,8 @@ test_sha512(void)
 		memset(result, 0, sizeof (result));
 
 		p = sha512_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = strlen(sha512_tv[i].plaintext);
 
 		crypto_digest_init(tfm);
@@ -700,8 +709,8 @@ test_des(void)
 		len = des_tv[i].len;
 
 		p = des_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = len;
 		ret = crypto_cipher_encrypt(tfm, sg, sg, len);
 		if (ret) {
@@ -709,7 +718,7 @@ test_des(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, len);
 
 		printk("%s\n",
@@ -737,13 +746,13 @@ test_des(void)
 	memcpy(&xbuf[IDX2], des_tv[i].plaintext + 8, 8);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 8;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 8;
 
 	ret = crypto_cipher_encrypt(tfm, sg, sg, 16);
@@ -753,12 +762,12 @@ test_des(void)
 	}
 
 	printk("page 1\n");
-	q = kmap(sg[0].page) + sg[0].offset;
+	q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 	hexdump(q, 8);
 	printk("%s\n", memcmp(q, des_tv[i].result, 8) ? "fail" : "pass");
 
 	printk("page 2\n");
-	q = kmap(sg[1].page) + sg[1].offset;
+	q = kmap(SG_PAGE(sg[1])) + SG_OFFSET(sg[1]);
 	hexdump(q, 8);
 	printk("%s\n", memcmp(q, des_tv[i].result + 8, 8) ? "fail" : "pass");
 
@@ -800,18 +809,18 @@ test_des(void)
 	memcpy(&xbuf[IDX5], des_tv[i].plaintext + 24, 8);
 
 	p = &xbuf[IDX3];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 14;
 
 	p = &xbuf[IDX4];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 10;
 
 	p = &xbuf[IDX5];
-	sg[2].page = virt_to_page(p);
-	sg[2].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[2]) = virt_to_page(p);
+	SG_OFFSET(sg[2]) = ((long) p & ~PAGE_MASK);
 	sg[2].length = 8;
 
 	ret = crypto_cipher_encrypt(tfm, sg, sg, 32);
@@ -822,17 +831,17 @@ test_des(void)
 	}
 
 	printk("page 1\n");
-	q = kmap(sg[0].page) + sg[0].offset;
+	q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 	hexdump(q, 14);
 	printk("%s\n", memcmp(q, des_tv[i].result, 14) ? "fail" : "pass");
 
 	printk("page 2\n");
-	q = kmap(sg[1].page) + sg[1].offset;
+	q = kmap(SG_PAGE(sg[1])) + SG_OFFSET(sg[1]);
 	hexdump(q, 10);
 	printk("%s\n", memcmp(q, des_tv[i].result + 14, 10) ? "fail" : "pass");
 
 	printk("page 3\n");
-	q = kmap(sg[2].page) + sg[2].offset;
+	q = kmap(SG_PAGE(sg[2])) + SG_OFFSET(sg[2]);
 	hexdump(q, 8);
 	printk("%s\n", memcmp(q, des_tv[i].result + 24, 8) ? "fail" : "pass");
 
@@ -871,23 +880,23 @@ test_des(void)
 	memcpy(&xbuf[IDX6], des_tv[i].plaintext + 6, 18);
 
 	p = &xbuf[IDX3];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 2;
 
 	p = &xbuf[IDX4];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 1;
 
 	p = &xbuf[IDX5];
-	sg[2].page = virt_to_page(p);
-	sg[2].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[2]) = virt_to_page(p);
+	SG_OFFSET(sg[2]) = ((long) p & ~PAGE_MASK);
 	sg[2].length = 3;
 
 	p = &xbuf[IDX6];
-	sg[3].page = virt_to_page(p);
-	sg[3].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[3]) = virt_to_page(p);
+	SG_OFFSET(sg[3]) = ((long) p & ~PAGE_MASK);
 	sg[3].length = 18;
 
 	ret = crypto_cipher_encrypt(tfm, sg, sg, 24);
@@ -898,22 +907,22 @@ test_des(void)
 	}
 
 	printk("page 1\n");
-	q = kmap(sg[0].page) + sg[0].offset;
+	q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 	hexdump(q, 2);
 	printk("%s\n", memcmp(q, des_tv[i].result, 2) ? "fail" : "pass");
 
 	printk("page 2\n");
-	q = kmap(sg[1].page) + sg[1].offset;
+	q = kmap(SG_PAGE(sg[1])) + SG_OFFSET(sg[1]);
 	hexdump(q, 1);
 	printk("%s\n", memcmp(q, des_tv[i].result + 2, 1) ? "fail" : "pass");
 
 	printk("page 3\n");
-	q = kmap(sg[2].page) + sg[2].offset;
+	q = kmap(SG_PAGE(sg[2])) + SG_OFFSET(sg[2]);
 	hexdump(q, 3);
 	printk("%s\n", memcmp(q, des_tv[i].result + 3, 3) ? "fail" : "pass");
 
 	printk("page 4\n");
-	q = kmap(sg[3].page) + sg[3].offset;
+	q = kmap(SG_PAGE(sg[3])) + SG_OFFSET(sg[3]);
 	hexdump(q, 18);
 	printk("%s\n", memcmp(q, des_tv[i].result + 6, 18) ? "fail" : "pass");
 
@@ -955,28 +964,28 @@ test_des(void)
 	memcpy(&xbuf[IDX7], des_tv[i].plaintext + 8, 8);
 
 	p = &xbuf[IDX3];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 2;
 
 	p = &xbuf[IDX4];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 2;
 
 	p = &xbuf[IDX5];
-	sg[2].page = virt_to_page(p);
-	sg[2].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[2]) = virt_to_page(p);
+	SG_OFFSET(sg[2]) = ((long) p & ~PAGE_MASK);
 	sg[2].length = 2;
 
 	p = &xbuf[IDX6];
-	sg[3].page = virt_to_page(p);
-	sg[3].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[3]) = virt_to_page(p);
+	SG_OFFSET(sg[3]) = ((long) p & ~PAGE_MASK);
 	sg[3].length = 2;
 
 	p = &xbuf[IDX7];
-	sg[4].page = virt_to_page(p);
-	sg[4].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[4]) = virt_to_page(p);
+	SG_OFFSET(sg[4]) = ((long) p & ~PAGE_MASK);
 	sg[4].length = 8;
 
 	ret = crypto_cipher_encrypt(tfm, sg, sg, 16);
@@ -987,27 +996,27 @@ test_des(void)
 	}
 
 	printk("page 1\n");
-	q = kmap(sg[0].page) + sg[0].offset;
+	q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 	hexdump(q, 2);
 	printk("%s\n", memcmp(q, des_tv[i].result, 2) ? "fail" : "pass");
 
 	printk("page 2\n");
-	q = kmap(sg[1].page) + sg[1].offset;
+	q = kmap(SG_PAGE(sg[1])) + SG_OFFSET(sg[1]);
 	hexdump(q, 2);
 	printk("%s\n", memcmp(q, des_tv[i].result + 2, 2) ? "fail" : "pass");
 
 	printk("page 3\n");
-	q = kmap(sg[2].page) + sg[2].offset;
+	q = kmap(SG_PAGE(sg[2])) + SG_OFFSET(sg[2]);
 	hexdump(q, 2);
 	printk("%s\n", memcmp(q, des_tv[i].result + 4, 2) ? "fail" : "pass");
 
 	printk("page 4\n");
-	q = kmap(sg[3].page) + sg[3].offset;
+	q = kmap(SG_PAGE(sg[3])) + SG_OFFSET(sg[3]);
 	hexdump(q, 2);
 	printk("%s\n", memcmp(q, des_tv[i].result + 6, 2) ? "fail" : "pass");
 
 	printk("page 5\n");
-	q = kmap(sg[4].page) + sg[4].offset;
+	q = kmap(SG_PAGE(sg[4])) + SG_OFFSET(sg[4]);
 	hexdump(q, 8);
 	printk("%s\n", memcmp(q, des_tv[i].result + 8, 8) ? "fail" : "pass");
 
@@ -1039,43 +1048,43 @@ test_des(void)
 	xbuf[IDX8] = des_tv[i].plaintext[7];
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 1;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 1;
 
 	p = &xbuf[IDX3];
-	sg[2].page = virt_to_page(p);
-	sg[2].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[2]) = virt_to_page(p);
+	SG_OFFSET(sg[2]) = ((long) p & ~PAGE_MASK);
 	sg[2].length = 1;
 
 	p = &xbuf[IDX4];
-	sg[3].page = virt_to_page(p);
-	sg[3].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[3]) = virt_to_page(p);
+	SG_OFFSET(sg[3]) = ((long) p & ~PAGE_MASK);
 	sg[3].length = 1;
 
 	p = &xbuf[IDX5];
-	sg[4].page = virt_to_page(p);
-	sg[4].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[4]) = virt_to_page(p);
+	SG_OFFSET(sg[4]) = ((long) p & ~PAGE_MASK);
 	sg[4].length = 1;
 
 	p = &xbuf[IDX6];
-	sg[5].page = virt_to_page(p);
-	sg[5].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[5]) = virt_to_page(p);
+	SG_OFFSET(sg[5]) = ((long) p & ~PAGE_MASK);
 	sg[5].length = 1;
 
 	p = &xbuf[IDX7];
-	sg[6].page = virt_to_page(p);
-	sg[6].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[6]) = virt_to_page(p);
+	SG_OFFSET(sg[6]) = ((long) p & ~PAGE_MASK);
 	sg[6].length = 1;
 
 	p = &xbuf[IDX8];
-	sg[7].page = virt_to_page(p);
-	sg[7].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[7]) = virt_to_page(p);
+	SG_OFFSET(sg[7]) = ((long) p & ~PAGE_MASK);
 	sg[7].length = 1;
 
 	ret = crypto_cipher_encrypt(tfm, sg, sg, 8);
@@ -1085,7 +1094,7 @@ test_des(void)
 	}
 
 	for (i = 0; i < 8; i++)
-		res[i] = *(char *) (kmap(sg[i].page) + sg[i].offset);
+		res[i] = *(char *) (kmap(SG_PAGE(sg[i])) + SG_OFFSET(sg[i]));
 
 	hexdump(res, 8);
 	printk("%s\n", memcmp(res, des_tv[7].result, 8) ? "fail" : "pass");
@@ -1116,8 +1125,8 @@ test_des(void)
 		len = des_tv[i].len;
 
 		p = des_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = len;
 
 		ret = crypto_cipher_decrypt(tfm, sg, sg, sg[0].length);
@@ -1127,7 +1136,7 @@ test_des(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, len);
 
 		printk("%s\n",
@@ -1154,13 +1163,13 @@ test_des(void)
 	memcpy(&xbuf[IDX2], des_tv[i].plaintext + 8, 8);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 8;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 8;
 
 	ret = crypto_cipher_decrypt(tfm, sg, sg, 16);
@@ -1170,12 +1179,12 @@ test_des(void)
 	}
 
 	printk("page 1\n");
-	q = kmap(sg[0].page) + sg[0].offset;
+	q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 	hexdump(q, 8);
 	printk("%s\n", memcmp(q, des_tv[i].result, 8) ? "fail" : "pass");
 
 	printk("page 2\n");
-	q = kmap(sg[1].page) + sg[1].offset;
+	q = kmap(SG_PAGE(sg[1])) + SG_OFFSET(sg[1]);
 	hexdump(q, 8);
 	printk("%s\n", memcmp(q, des_tv[i].result + 8, 8) ? "fail" : "pass");
 
@@ -1206,18 +1215,18 @@ test_des(void)
 	memcpy(&xbuf[IDX3], des_tv[i].plaintext + 15, 1);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 3;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 12;
 
 	p = &xbuf[IDX3];
-	sg[2].page = virt_to_page(p);
-	sg[2].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[2]) = virt_to_page(p);
+	SG_OFFSET(sg[2]) = ((long) p & ~PAGE_MASK);
 	sg[2].length = 1;
 
 	ret = crypto_cipher_decrypt(tfm, sg, sg, 16);
@@ -1228,17 +1237,17 @@ test_des(void)
 	}
 
 	printk("page 1\n");
-	q = kmap(sg[0].page) + sg[0].offset;
+	q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 	hexdump(q, 3);
 	printk("%s\n", memcmp(q, des_tv[i].result, 3) ? "fail" : "pass");
 
 	printk("page 2\n");
-	q = kmap(sg[1].page) + sg[1].offset;
+	q = kmap(SG_PAGE(sg[1])) + SG_OFFSET(sg[1]);
 	hexdump(q, 12);
 	printk("%s\n", memcmp(q, des_tv[i].result + 3, 12) ? "fail" : "pass");
 
 	printk("page 3\n");
-	q = kmap(sg[2].page) + sg[2].offset;
+	q = kmap(SG_PAGE(sg[2])) + SG_OFFSET(sg[2]);
 	hexdump(q, 1);
 	printk("%s\n", memcmp(q, des_tv[i].result + 15, 1) ? "fail" : "pass");
 
@@ -1283,8 +1292,8 @@ test_des(void)
 		len = des_tv[i].len;
 		p = des_tv[i].plaintext;
 
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = len;
 
 		crypto_cipher_set_iv(tfm, des_tv[i].iv,
@@ -1297,7 +1306,7 @@ test_des(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, len);
 
 		printk("%s\n",
@@ -1338,13 +1347,13 @@ test_des(void)
 	memcpy(&xbuf[IDX2], des_tv[i].plaintext + 13, 11);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 13;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 11;
 
 	crypto_cipher_set_iv(tfm, des_tv[i].iv, crypto_tfm_alg_ivsize(tfm));
@@ -1356,12 +1365,12 @@ test_des(void)
 	}
 
 	printk("page 1\n");
-	q = kmap(sg[0].page) + sg[0].offset;
+	q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 	hexdump(q, 13);
 	printk("%s\n", memcmp(q, des_tv[i].result, 13) ? "fail" : "pass");
 
 	printk("page 2\n");
-	q = kmap(sg[1].page) + sg[1].offset;
+	q = kmap(SG_PAGE(sg[1])) + SG_OFFSET(sg[1]);
 	hexdump(q, 11);
 	printk("%s\n", memcmp(q, des_tv[i].result + 13, 11) ? "fail" : "pass");
 
@@ -1391,8 +1400,8 @@ test_des(void)
 		len = des_tv[i].len;
 		p = des_tv[i].plaintext;
 
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = len;
 
 		crypto_cipher_set_iv(tfm, des_tv[i].iv,
@@ -1407,7 +1416,7 @@ test_des(void)
 
 		hexdump(tfm->crt_cipher.cit_iv, 8);
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, len);
 
 		printk("%s\n",
@@ -1439,13 +1448,13 @@ test_des(void)
 	memcpy(&xbuf[IDX2], des_tv[i].plaintext + 4, 4);
 
 	p = &xbuf[IDX1];
-	sg[0].page = virt_to_page(p);
-	sg[0].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[0]) = virt_to_page(p);
+	SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 	sg[0].length = 4;
 
 	p = &xbuf[IDX2];
-	sg[1].page = virt_to_page(p);
-	sg[1].offset = ((long) p & ~PAGE_MASK);
+	SG_PAGE(sg[1]) = virt_to_page(p);
+	SG_OFFSET(sg[1]) = ((long) p & ~PAGE_MASK);
 	sg[1].length = 4;
 
 	crypto_cipher_set_iv(tfm, des_tv[i].iv, crypto_tfm_alg_ivsize(tfm));
@@ -1457,12 +1466,12 @@ test_des(void)
 	}
 
 	printk("page 1\n");
-	q = kmap(sg[0].page) + sg[0].offset;
+	q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 	hexdump(q, 4);
 	printk("%s\n", memcmp(q, des_tv[i].result, 4) ? "fail" : "pass");
 
 	printk("page 2\n");
-	q = kmap(sg[1].page) + sg[1].offset;
+	q = kmap(SG_PAGE(sg[1])) + SG_OFFSET(sg[1]);
 	hexdump(q, 4);
 	printk("%s\n", memcmp(q, des_tv[i].result + 4, 4) ? "fail" : "pass");
 
@@ -1515,8 +1524,8 @@ test_des3_ede(void)
 		len = des_tv[i].len;
 
 		p = des_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = len;
 		ret = crypto_cipher_encrypt(tfm, sg, sg, len);
 		if (ret) {
@@ -1524,7 +1533,7 @@ test_des3_ede(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, len);
 
 		printk("%s\n",
@@ -1558,8 +1567,8 @@ test_des3_ede(void)
 		len = des_tv[i].len;
 
 		p = des_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = len;
 		ret = crypto_cipher_decrypt(tfm, sg, sg, len);
 		if (ret) {
@@ -1567,7 +1576,7 @@ test_des3_ede(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, len);
 
 		printk("%s\n",
@@ -1621,8 +1630,8 @@ test_blowfish(void)
 		}
 
 		p = bf_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = bf_tv[i].plen;
 		ret = crypto_cipher_encrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -1630,7 +1639,7 @@ test_blowfish(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, bf_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, bf_tv[i].result, bf_tv[i].rlen) ?
@@ -1663,8 +1672,8 @@ test_blowfish(void)
 		}
 
 		p = bf_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = bf_tv[i].plen;
 		ret = crypto_cipher_decrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -1672,7 +1681,7 @@ test_blowfish(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, bf_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, bf_tv[i].result, bf_tv[i].rlen) ?
@@ -1712,8 +1721,8 @@ test_blowfish(void)
 
 		p = bf_tv[i].plaintext;
 
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length =  bf_tv[i].plen;
 
 		crypto_cipher_set_iv(tfm, bf_tv[i].iv,
@@ -1726,7 +1735,7 @@ test_blowfish(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, bf_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, bf_tv[i].result, bf_tv[i].rlen)
@@ -1757,8 +1766,8 @@ test_blowfish(void)
 
 		p = bf_tv[i].plaintext;
 
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length =  bf_tv[i].plen;
 
 		crypto_cipher_set_iv(tfm, bf_tv[i].iv,
@@ -1771,7 +1780,7 @@ test_blowfish(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, bf_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, bf_tv[i].result, bf_tv[i].rlen)
@@ -1826,8 +1835,8 @@ test_twofish(void)
 		}
 
 		p = tf_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = tf_tv[i].plen;
 		ret = crypto_cipher_encrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -1835,7 +1844,7 @@ test_twofish(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, tf_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, tf_tv[i].result, tf_tv[i].rlen) ?
@@ -1868,8 +1877,8 @@ test_twofish(void)
 		}
 
 		p = tf_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = tf_tv[i].plen;
 		ret = crypto_cipher_decrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -1877,7 +1886,7 @@ test_twofish(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, tf_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, tf_tv[i].result, tf_tv[i].rlen) ?
@@ -1917,8 +1926,8 @@ test_twofish(void)
 
 		p = tf_tv[i].plaintext;
 
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length =  tf_tv[i].plen;
 
 		crypto_cipher_set_iv(tfm, tf_tv[i].iv,
@@ -1931,7 +1940,7 @@ test_twofish(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, tf_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, tf_tv[i].result, tf_tv[i].rlen)
@@ -1963,8 +1972,8 @@ test_twofish(void)
 
 		p = tf_tv[i].plaintext;
 
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length =  tf_tv[i].plen;
 
 		crypto_cipher_set_iv(tfm, tf_tv[i].iv,
@@ -1977,7 +1986,7 @@ test_twofish(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, tf_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, tf_tv[i].result, tf_tv[i].rlen)
@@ -2027,8 +2036,8 @@ test_serpent(void)
 		}
 
 		p = serp_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = sizeof(serp_tv[i].plaintext);
 		ret = crypto_cipher_encrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -2036,7 +2045,7 @@ test_serpent(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, sizeof(serp_tv[i].result));
 
 		printk("%s\n", memcmp(q, serp_tv[i].result,
@@ -2067,8 +2076,8 @@ test_serpent(void)
 		}
 
 		p = serp_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = sizeof(serp_tv[i].plaintext);
 		ret = crypto_cipher_decrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -2076,7 +2085,7 @@ test_serpent(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, sizeof(serp_tv[i].result));
 
 		printk("%s\n", memcmp(q, serp_tv[i].result,
@@ -2126,8 +2135,8 @@ test_cast6(void)
 		}
 
 		p = cast_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = sizeof(cast_tv[i].plaintext);
 		ret = crypto_cipher_encrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -2135,7 +2144,7 @@ test_cast6(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, sizeof(cast_tv[i].result));
 
 		printk("%s\n", memcmp(q, cast_tv[i].result,
@@ -2166,8 +2175,8 @@ test_cast6(void)
 		}
 
 		p = cast_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = sizeof(cast_tv[i].plaintext);
 		ret = crypto_cipher_decrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -2175,7 +2184,7 @@ test_cast6(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, sizeof(cast_tv[i].result));
 
 		printk("%s\n", memcmp(q, cast_tv[i].result,
@@ -2229,8 +2238,8 @@ test_aes(void)
 		}
 
 		p = aes_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = aes_tv[i].plen;
 		ret = crypto_cipher_encrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -2238,7 +2247,7 @@ test_aes(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, aes_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, aes_tv[i].result, aes_tv[i].rlen) ?
@@ -2271,8 +2280,8 @@ test_aes(void)
 		}
 
 		p = aes_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = aes_tv[i].plen;
 		ret = crypto_cipher_decrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -2280,7 +2289,7 @@ test_aes(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, aes_tv[i].rlen);
 
 		printk("%s\n", memcmp(q, aes_tv[i].result, aes_tv[i].rlen) ?
@@ -2330,8 +2339,8 @@ test_cast5(void)
 		}
 
 		p = c5_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = sizeof(c5_tv[i].plaintext);
 		ret = crypto_cipher_encrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -2339,7 +2348,7 @@ test_cast5(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, sizeof(c5_tv[i].ciphertext));
 
 		printk("%s\n", memcmp(q, c5_tv[i].ciphertext,
@@ -2368,8 +2377,8 @@ test_cast5(void)
 		}
 
 		p = c5_tv[i].plaintext;
-		sg[0].page = virt_to_page(p);
-		sg[0].offset = ((long) p & ~PAGE_MASK);
+		SG_PAGE(sg[0]) = virt_to_page(p);
+		SG_OFFSET(sg[0]) = ((long) p & ~PAGE_MASK);
 		sg[0].length = sizeof(c5_tv[i].plaintext);
 		ret = crypto_cipher_decrypt(tfm, sg, sg, sg[0].length);
 		if (ret) {
@@ -2377,7 +2386,7 @@ test_cast5(void)
 			goto out;
 		}
 
-		q = kmap(sg[0].page) + sg[0].offset;
+		q = kmap(SG_PAGE(sg[0])) + SG_OFFSET(sg[0]);
 		hexdump(q, sizeof(c5_tv[i].ciphertext));
 
 		printk("%s\n", memcmp(q, c5_tv[i].ciphertext,
diff -X dontdiff -urp kern_oldest/drivers/addon/iscsi_sfnet/iscsi.c kern_fix/drivers/addon/iscsi_sfnet/iscsi.c
--- kern_oldest/drivers/addon/iscsi_sfnet/iscsi.c	2006-05-01 11:55:44.000000000 -0700
+++ kern_fix/drivers/addon/iscsi_sfnet/iscsi.c	2006-05-01 14:14:13.000000000 -0700
@@ -118,6 +118,16 @@
 #include "iscsi-probe.h"
 #include "iscsi-crc.h"
 
+#if SMALL_SCATTERLIST
+#define ISCSI_SG_ADDRESS(sg) (sg->u.address)
+#define ISCSI_SG_PAGE(sg)    (sg->u.page.page)
+#define ISCSI_SG_OFFSET(sg)  (sg->u.page.offset)
+#else
+#define ISCSI_SG_ADDRESS(sg) (sg->address)
+#define ISCSI_SG_PAGE(sg)    (sg->page)
+#define ISCSI_SG_OFFSET(sg)  (sg->offset)
+#endif
+
 /*
  *  IMPORTANT NOTE: to prevent deadlock, when holding multiple locks,
  *  the following locking order must be followed at all times:
@@ -2932,15 +2942,17 @@ print_cmnd(Scsi_Cmnd * sc)
 #if (HAS_SCATTERLIST_PAGE && HAS_SCATTERLIST_ADDRESS)
 	    printk("iSCSI:   sglist %p index %02d = addr %p, page %p, "
 		   "offset %u, len %u\n",
-		   sglist, i, sglist->address, sglist->page, sglist->offset,
-		   sglist->length);
+		   sglist, i, ISCSI_SG_ADDRESS(sglist), 
+		   ISCSI_SG_PAGE(sglist),
+		   ISCSI_SG_OFFSET(sglist), sglist->length);
 #elif HAS_SCATTERLIST_PAGE
 	    printk("iSCSI:   sglist %p index %02d = page %p, offset %u, "
 		   "len %u\n",
-		   sglist, i, sglist->page, sglist->offset, sglist->length);
+		   sglist, i, ISCSI_SG_PAGE(sglist), ISCSI_SG_OFFSET(sglist),
+		   sglist->length);
 #else
 	    printk("iSCSI:   sglist %p index %02d = addr %p, len %u\n",
-		   sglist, i, sglist->address, sglist->length);
+		   sglist, i, ISCSI_SG_ADDRESS(sglist), sglist->length);
 #endif
 	    sglist++;
 	}
@@ -5305,7 +5317,7 @@ iscsi_xmit_task(iscsi_task_t * task)
 		    bytes_from_segment = sg->length - segment_offset;
 		    if (bytes_from_segment > bytes_to_fill) {
 			/* only need part of this segment */
-			iov[iovn].iov_base = sg->address + segment_offset;
+  		        iov[iovn].iov_base = ISCSI_SG_ADDRESS(sg) + segment_offset;
 			iov[iovn].iov_len = bytes_to_fill;
 			xfrlen += bytes_to_fill;
 			DEBUG_FLOW("iSCSI: session %p xmit_data xfrlen %d, "
@@ -5862,21 +5874,21 @@ sg_virtual_address(struct scatterlist *s
 {
 #if (HAS_SCATTERLIST_PAGE && HAS_SCATTERLIST_ADDRESS)
     /* page may or may not be mapped */
-    if (sg->address) {
-	return sg->address;
-    } else if (sg->page) {
-	return page_address(sg->page) + sg->offset;
+    if (ISCSI_SG_ADDRESS(sg)) {
+	return ISCSI_SG_ADDRESS(sg);
+    } else if (ISCSI_SG_PAGE(sg)) {
+	return page_address(ISCSI_SG_PAGE(sg)) + ISCSI_SG_OFFSET(sg);
     }
     return NULL;
 
 #elif HAS_SCATTERLIST_PAGE
     /* should have already mapped the page */
-    if (sg->page) {
-	return page_address(sg->page) + sg->offset;
+    if (ISCSI_SG_PAGE(sg)) {
+	return page_address(ISCSI_SG_PAGE(sg)) + ISCSI_SG_OFFSET(sg);
     }
     return NULL;
 #else
-    return sg->address;
+    return ISCSI_SG_ADDRESS(sg);
 #endif
 
 }
@@ -5899,12 +5911,12 @@ kmap_sg(struct scatterlist *sg)
 {
 #if (HAS_SCATTERLIST_PAGE && HAS_SCATTERLIST_ADDRESS)
     /* page may or may not be mapped if HIGHMEM is in use */
-    if (sg->address) {
-	DEBUG_FLOW("iSCSI: kmap sg %p to address %p\n", sg, sg->address);
-	return sg->address;
-    } else if (sg->page) {
-	void *addr = kmap(sg->page);
-	DEBUG_FLOW("iSCSI: kmap sg %p page %p to addr %p\n", sg, sg->page,
+    if (ISCSI_SG_ADDRESS(sg)) {
+	DEBUG_FLOW("iSCSI: kmap sg %p to address %p\n", sg, ISCSI_SG_ADDRESS(sg));
+	return ISCSI_SG_ADDRESS(sg);
+    } else if (ISCSI_SG_PAGE(sg)) {
+	void *addr = kmap(ISCSI_SG_PAGE(sg));
+	DEBUG_FLOW("iSCSI: kmap sg %p page %p to addr %p\n", sg, ISCSI_SG_PAGE(sg),
 		   addr);
 	return addr;
     }
@@ -5912,15 +5924,15 @@ kmap_sg(struct scatterlist *sg)
 
 #elif HAS_SCATTERLIST_PAGE
     /* there is no address, must kmap the page */
-    if (sg->page) {
-	return kmap(sg->page);
+    if (ISCSI_SG_PAGE(sg)) {
+	return kmap(ISCSI_SG_PAGE(sg));
     }
     return NULL;
 
 #else
     /* just use the address */
-    DEBUG_FLOW("iSCSI: kmap sg %p to address %p\n", sg, sg->address);
-    return sg->address;
+    DEBUG_FLOW("iSCSI: kmap sg %p to address %p\n", sg, ISCSI_SG_ADDRESS(sg));
+    return ISCSI_SG_ADDRESS(sg);
 #endif
 }
 
@@ -5932,11 +5944,11 @@ static inline void
 kunmap_sg(struct scatterlist *sg)
 {
 #if (HAS_SCATTERLIST_PAGE && HAS_SCATTERLIST_ADDRESS)
-    if (!sg->address && sg->page)
-	kunmap(sg->page);
+    if (!ISCSI_SG_ADDRESS(sg) && ISCSI_SG_PAGE(sg))
+	kunmap(ISCSI_SG_PAGE(sg));
 #elif HAS_SCATTERLIST_PAGE
-    if (sg->page)
-	kunmap(sg->page);
+    if (ISCSI_SG_PAGE(sg))
+	kunmap(ISCSI_SG_PAGE(sg));
 #endif
     return;
 }
diff -X dontdiff -urp kern_oldest/drivers/block/cciss.c kern_fix/drivers/block/cciss.c
--- kern_oldest/drivers/block/cciss.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/block/cciss.c	2006-05-01 14:14:13.000000000 -0700
@@ -2636,9 +2636,14 @@ next:
 		} else {
 			if (seg == MAXSGENTRIES)
 				BUG();
+#if SMALL_SCATTERLIST
+			tmp_sg[seg].u.page.page = bh->b_page;
+			tmp_sg[seg].u.page.offset = bh_offset(bh);
+#else
 			tmp_sg[seg].page = bh->b_page;
-			tmp_sg[seg].length = bh->b_size;
 			tmp_sg[seg].offset = bh_offset(bh);
+#endif
+			tmp_sg[seg].length = bh->b_size;
 			lastdataend = bh_phys(bh) + bh->b_size;
 			seg++;
 		}
@@ -2652,8 +2657,16 @@ next:
 		ddir = PCI_DMA_TODEVICE;
 	for (i=0; i<seg; i++) {
 		c->SG[i].Len = tmp_sg[i].length;
-		temp64.val = pci_map_page(h->pdev, tmp_sg[i].page,
-			    tmp_sg[i].offset, tmp_sg[i].length, ddir);
+#if SMALL_SCATTERLIST
+		temp64.val = pci_map_page(h->pdev,
+					  tmp_sg[i].u.page.page, 
+					  tmp_sg[i].u.page.offset,
+					  tmp_sg[i].length, ddir);
+#else
+		temp64.val = pci_map_page(h->pdev,
+					  tmp_sg[i].page, tmp_sg[i].offset,
+					  tmp_sg[i].length, ddir);
+#endif
 		c->SG[i].Addr.lower = temp64.val32.lower;
                 c->SG[i].Addr.upper = temp64.val32.upper;
                 c->SG[i].Ext = 0;  /* we are not chaining */
diff -X dontdiff -urp kern_oldest/drivers/block/cpqarray.c kern_fix/drivers/block/cpqarray.c
--- kern_oldest/drivers/block/cpqarray.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/block/cpqarray.c	2006-05-01 14:14:13.000000000 -0700
@@ -1003,9 +1003,14 @@ DBGPX(
 		} else {
 			if (seg == SG_MAX)
 				BUG();
+#if SMALL_SCATTERLIST
+			tmp_sg[seg].u.page.page = bh->b_page;
+			tmp_sg[seg].u.page.offset = bh_offset(bh);
+#else
 			tmp_sg[seg].page = bh->b_page;
-			tmp_sg[seg].length = bh->b_size;
 			tmp_sg[seg].offset = bh_offset(bh);
+#endif
+			tmp_sg[seg].length = bh->b_size;
 			lastdataend = bh_phys(bh) + bh->b_size;
 			seg++;
 		}
@@ -1014,11 +1019,21 @@ DBGPX(
 	/* Now do all the DMA Mappings */
 	for( i=0; i < seg; i++) {
 		c->req.sg[i].size = tmp_sg[i].length;
+#if SMALL_SCATTERLIST
+		c->req.sg[i].addr = (__u32) pci_map_page(
+                		h->pci_dev, 
+				tmp_sg[i].u.page.page, tmp_sg[i].u.page.offset,
+				tmp_sg[i].length,
+                                (creq->cmd == READ) ? 
+					PCI_DMA_FROMDEVICE : PCI_DMA_TODEVICE);
+#else
 		c->req.sg[i].addr = (__u32) pci_map_page(
-                		h->pci_dev, tmp_sg[i].page, tmp_sg[i].offset,
+                		h->pci_dev, 
+				tmp_sg[i].page, tmp_sg[i].offset,
 				tmp_sg[i].length,
                                 (creq->cmd == READ) ? 
 					PCI_DMA_FROMDEVICE : PCI_DMA_TODEVICE);
+#endif
 	}
 DBGPX(	printk("Submitting %d sectors in %d segments\n", sect, seg); );
 	c->req.hdr.sg_cnt = seg;
diff -X dontdiff -urp kern_oldest/drivers/block/sx8.c kern_fix/drivers/block/sx8.c
--- kern_oldest/drivers/block/sx8.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/block/sx8.c	2006-05-01 14:14:13.000000000 -0700
@@ -1103,9 +1103,15 @@ static int blk_rq_map_sg(request_queue_t
 		} else {
 			if (unlikely(n_elem == CARM_MAX_REQ_SG))
 				BUG();
+#if SMALL_SCATTERLIST
+			sg[n_elem].u.page.page = bh->b_page;
+			sg[n_elem].length = bh->b_size;
+			sg[n_elem].u.page.offset = bh_offset(bh);
+#else
 			sg[n_elem].page = bh->b_page;
 			sg[n_elem].length = bh->b_size;
 			sg[n_elem].offset = bh_offset(bh);
+#endif /* !SMALL_SCATTERLIST */
 			last_phys = bh_phys(bh) + bh->b_size;
 			n_elem++;
 		}
diff -X dontdiff -urp kern_oldest/drivers/ide/ide-dma.c kern_fix/drivers/ide/ide-dma.c
--- kern_oldest/drivers/ide/ide-dma.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/ide/ide-dma.c	2006-05-01 14:14:13.000000000 -0700
@@ -280,14 +280,25 @@ static int ide_build_sglist (ide_hwif_t 
 		memset(&sg[nents], 0, sizeof(*sg));
 
 		if (bh->b_page) {
+#if SMALL_SCATTERLIST
+			sg[nents].ispaged = 1;
+			sg[nents].u.page.page = bh->b_page;
+			sg[nents].u.page.offset = bh_offset(bh);
+#else
 			sg[nents].page = bh->b_page;
 			sg[nents].offset = bh_offset(bh);
+#endif
 			lastdataend = bh_phys(bh) + bh->b_size;
 		} else {
 			if ((unsigned long) bh->b_data < PAGE_SIZE)
 				BUG();
 
+#if SMALL_SCATTERLIST
+			sg[nents].ispaged = 0;
+			sg[nents].u.address = bh->b_data;
+#else
 			sg[nents].address = bh->b_data;
+#endif
 			lastdataend = (unsigned long) bh->b_data + bh->b_size;
 		}
 
@@ -328,14 +339,24 @@ static int ide_raw_build_sglist (ide_hwi
 #if 1
 	if (sector_count > 128) {
 		memset(&sg[nents], 0, sizeof(*sg));
+#if SMALL_SCATTERLIST
+		sg[nents].ispaged = 0;
+		sg[nents].u.address = virt_addr;
+#else
 		sg[nents].address = virt_addr;
+#endif
 		sg[nents].length = 128  * SECTOR_SIZE;
 		nents++;
 		virt_addr = virt_addr + (128 * SECTOR_SIZE);
 		sector_count -= 128;
 	}
 	memset(&sg[nents], 0, sizeof(*sg));
+#if SMALL_SCATTERLIST
+	sg[nents].ispaged = 0;
+	sg[nents].u.address = virt_addr;
+#else
 	sg[nents].address = virt_addr;
+#endif
 	sg[nents].length =  sector_count  * SECTOR_SIZE;
 	nents++;
 #else
diff -X dontdiff -urp kern_oldest/drivers/ieee1394/dma.c kern_fix/drivers/ieee1394/dma.c
--- kern_oldest/drivers/ieee1394/dma.c	2006-05-01 11:55:43.000000000 -0700
+++ kern_fix/drivers/ieee1394/dma.c	2006-05-01 14:14:13.000000000 -0700
@@ -97,8 +97,12 @@ int dma_region_alloc(struct dma_region *
 	/* fill scatter/gather list with pages */
 	for(i = 0; i < dma->n_pages; i++) {
 		unsigned long va = (unsigned long) dma->kvirt + i * PAGE_SIZE;
-			
+
+#if SMALL_SCATTERLIST
+		dma->sglist[i].u.page.page = vmalloc_to_page((void *)va);
+#else
 		dma->sglist[i].page = vmalloc_to_page((void *)va);
+#endif
 		dma->sglist[i].length = PAGE_SIZE;
 	}
 
diff -X dontdiff -urp kern_oldest/drivers/ieee1394/sbp2.c kern_fix/drivers/ieee1394/sbp2.c
--- kern_oldest/drivers/ieee1394/sbp2.c	2006-05-01 11:55:43.000000000 -0700
+++ kern_fix/drivers/ieee1394/sbp2.c	2006-05-01 14:14:13.000000000 -0700
@@ -2036,11 +2036,19 @@ static int sbp2_create_command_orb(struc
 			command->dma_dir = dma_dir;
 			command->dma_size = sgpnt[0].length;
 			command->dma_type = CMD_DMA_PAGE;
+#if SMALL_SCATTERLIST
+			command->cmd_dma = pci_map_page(hi->host->pdev,
+							sgpnt[0].u.page.page,
+							sgpnt[0].u.page.offset,
+							command->dma_size,
+							command->dma_dir);
+#else
 			command->cmd_dma = pci_map_page(hi->host->pdev,
 							sgpnt[0].page,
 							sgpnt[0].offset,
 							command->dma_size,
 							command->dma_dir);
+#endif
 			SBP2_DMA_ALLOC("single page scatter element");
 
 			command_orb->data_descriptor_hi = ORB_SET_NODE_ID(hi->host->node_id);
diff -X dontdiff -urp kern_oldest/drivers/message/i2o/i2o_scsi.c kern_fix/drivers/message/i2o/i2o_scsi.c
--- kern_oldest/drivers/message/i2o/i2o_scsi.c	2006-05-01 11:55:43.000000000 -0700
+++ kern_fix/drivers/message/i2o/i2o_scsi.c	2006-05-01 14:14:13.000000000 -0700
@@ -693,7 +693,11 @@ static int i2o_scsi_queuecommand(Scsi_Cm
 			{
 				*mptr++=direction|0x10000000|sg->length;
 				len+=sg->length;
+#if SMALL_SCATTERLIST
+				*mptr++=virt_to_bus(sg->u.address);
+#else
 				*mptr++=virt_to_bus(sg->address);
+#endif
 				sg++;
 			}
 			mptr[-2]=direction|0xD0000000|(sg-1)->length;
@@ -704,7 +708,11 @@ static int i2o_scsi_queuecommand(Scsi_Cm
 			{
 				i2o_raw_writel(direction|0x10000000|sg->length, mptr++);
 				len+=sg->length;
+#if SMALL_SCATTERLIST
+				i2o_raw_writel(virt_to_bus(sg->u.address), mptr++);
+#else
 				i2o_raw_writel(virt_to_bus(sg->address), mptr++);
+#endif
 				sg++;
 			}
 
diff -X dontdiff -urp kern_oldest/drivers/net/fc/iph5526.c kern_fix/drivers/net/fc/iph5526.c
--- kern_oldest/drivers/net/fc/iph5526.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/net/fc/iph5526.c	2006-05-01 14:14:13.000000000 -0700
@@ -4249,7 +4249,11 @@ int no_of_sg = 0;
 			if (Cmnd->use_sg) {
 			int count = 0, j;
 				for(i = 0; i < no_of_sg; i++) {
+#if SMALL_SCATTERLIST
+				char *addr_ptr = sl2->u.address;
+#else
 				char *addr_ptr = sl2->address;
+#endif
 					count = sl2->length / SEST_BUFFER_SIZE;
 					if (sl2->length % SEST_BUFFER_SIZE)
 						count++;
@@ -4349,7 +4353,11 @@ int no_of_sg = 0;
 				int count = 0, j;
 					count = sl1->length / SEST_BUFFER_SIZE;
 					for (j = 0; j < count; j++) {
+#if SMALL_SCATTERLIST
+						build_EDB(fi, (char *)sl1->u.address, 0, SEST_BUFFER_SIZE);
+#else
 						build_EDB(fi, (char *)sl1->address, 0, SEST_BUFFER_SIZE);
+#endif
 						memcpy(fi->q.ptr_edb[fi->q.edb_buffer_indx], &(fi->g.edb), sizeof(EDB));
 						/* Mark this EDB as being in use */
 						fi->q.free_edb_list[fi->q.edb_buffer_indx] = EDB_BUSY;
@@ -4358,13 +4366,21 @@ int no_of_sg = 0;
 						 * safe.
 				 	 	 */
 						update_EDB_indx(fi);
+#if SMALL_SCATTERLIST
+						sl1->u.address += SEST_BUFFER_SIZE;
+#else
 						sl1->address += SEST_BUFFER_SIZE;
+#endif
 					}
 					/* Just in case itz not a multiple of 
 					 * SEST_BUFFER_SIZE bytes.
 					 */
 					if (sl1->length % SEST_BUFFER_SIZE) {
+#if SMALL_SCATTERLIST
+						build_EDB(fi, (char *)sl1->u.address, 0, sl1->length % SEST_BUFFER_SIZE);
+#else
 						build_EDB(fi, (char *)sl1->address, 0, sl1->length % SEST_BUFFER_SIZE);
+#endif
 						memcpy(fi->q.ptr_edb[fi->q.edb_buffer_indx], &(fi->g.edb), sizeof(EDB));
 						fi->q.free_edb_list[fi->q.edb_buffer_indx] = EDB_BUSY;
 						update_EDB_indx(fi);
diff -X dontdiff -urp kern_oldest/drivers/net/wireless/airo.c kern_fix/drivers/net/wireless/airo.c
--- kern_oldest/drivers/net/wireless/airo.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/net/wireless/airo.c	2006-05-01 14:14:13.000000000 -0700
@@ -1584,11 +1584,20 @@ void emmh32_setseed(emmh32_context *cont
 		aes_counter[12] = (u8)(counter >> 24);
 		counter++;
 		memcpy (plain, aes_counter, 16);
+#if SMALL_SCATTERLIST
+		sg[0].u.page.page = virt_to_page(plain);
+		sg[0].u.page.offset = ((long) plain & ~PAGE_MASK);
+#else
 		sg[0].page = virt_to_page(plain);
 		sg[0].offset = ((long) plain & ~PAGE_MASK);
+#endif
 		sg[0].length = 16;
 		crypto_cipher_encrypt(tfm, sg, sg, 16);
+#if SMALL_SCATTERLIST
+		cipher = kmap(sg[0].u.page.page) + sg[0].u.page.offset;
+#else
 		cipher = kmap(sg[0].page) + sg[0].offset;
+#endif
 		for (j=0; (j<16) && (i< (sizeof(context->coeff)/sizeof(context->coeff[0]))); ) {
 			context->coeff[i++] = ntohl(*(u32 *)&cipher[j]);
 			j += 4;
diff -X dontdiff -urp kern_oldest/drivers/scsi/53c7,8xx.c kern_fix/drivers/scsi/53c7,8xx.c
--- kern_oldest/drivers/scsi/53c7,8xx.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/53c7,8xx.c	2006-05-01 14:14:13.000000000 -0700
@@ -3787,7 +3787,11 @@ create_cmd (Scsi_Cmnd *cmd) {
     for (i = 0; cmd->use_sg ? (i < cmd->use_sg) : !i; cmd_datain += 4, 
 	cmd_dataout += 4, ++i) {
 	u32 buf = cmd->use_sg ? 
+#if SMALL_SCATTERLIST
+	    virt_to_bus(((struct scatterlist *)cmd->buffer)[i].u.address) :
+#else
 	    virt_to_bus(((struct scatterlist *)cmd->buffer)[i].address) :
+#endif
 	    virt_to_bus(cmd->request_buffer);
 	u32 count = cmd->use_sg ?
 	    ((struct scatterlist *)cmd->buffer)[i].length :
@@ -5752,8 +5756,13 @@ insn_to_offset (Scsi_Cmnd *cmd, u32 *ins
 	    if ((buffers = cmd->use_sg)) {
     	    	for (offset = 0, 
 		     	segment = (struct scatterlist *) cmd->buffer;
+#if SMALL_SCATTERLIST
+    	    	     buffers && !((found = ((ptr >= segment->u.address) && 
+    	    	    	    (ptr < (segment->u.address + segment->length)))));
+#else
     	    	     buffers && !((found = ((ptr >= segment->address) && 
     	    	    	    (ptr < (segment->address + segment->length)))));
+#endif
     	    	     --buffers, offset += segment->length, ++segment)
 #if 0
 		    printk("scsi%d: comparing 0x%p to 0x%p\n", 
@@ -5761,7 +5770,11 @@ insn_to_offset (Scsi_Cmnd *cmd, u32 *ins
 #else
 		    ;
 #endif
+#if SMALL_SCATTERLIST
+    	    	    offset += ptr - segment->u.address;
+#else
     	    	    offset += ptr - segment->address;
+#endif
     	    } else {
 		found = 1;
     	    	offset = ptr - (char *) (cmd->request_buffer);
diff -X dontdiff -urp kern_oldest/drivers/scsi/advansys.c kern_fix/drivers/scsi/advansys.c
--- kern_oldest/drivers/scsi/advansys.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/advansys.c	2006-05-01 14:14:13.000000000 -0700
@@ -6803,7 +6803,11 @@ asc_build_req(asc_board_t *boardp, Scsi_
         slp = (struct scatterlist *) scp->request_buffer;
         for (sgcnt = 0; sgcnt < scp->use_sg; sgcnt++, slp++) {
             asc_sg_head.sg_list[sgcnt].addr =
+#if SMALL_SCATTERLIST
+                cpu_to_le32(virt_to_bus(slp->u.address));
+#else
                 cpu_to_le32(virt_to_bus(slp->address));
+#endif
             asc_sg_head.sg_list[sgcnt].bytes = cpu_to_le32(slp->length);
             ASC_STATS_ADD(scp->host, sg_xfer, ASC_CEILING(slp->length, 512));
         }
@@ -7061,7 +7065,11 @@ adv_get_sglist(asc_board_t *boardp, adv_
         for (i = 0; i < NO_OF_SG_PER_BLOCK; i++)
         {
             sg_block->sg_list[i].sg_addr =
+#if SMALL_SCATTERLIST
+                cpu_to_le32(virt_to_bus(slp->u.address));
+#else
                 cpu_to_le32(virt_to_bus(slp->address));
+#endif
             sg_block->sg_list[i].sg_count = cpu_to_le32(slp->length);
             ASC_STATS_ADD(scp->host, sg_xfer, ASC_CEILING(slp->length, 512));
 
diff -X dontdiff -urp kern_oldest/drivers/scsi/aha152x.c kern_fix/drivers/scsi/aha152x.c
--- kern_oldest/drivers/scsi/aha152x.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/aha152x.c	2006-05-01 14:14:13.000000000 -0700
@@ -603,7 +603,11 @@ struct aha152x_scdata {
 #define SCSEM(SCpnt)		SCDATA(SCpnt)->sem
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if SMALL_SCATTERLIST
+#define SG_ADDRESS(buffer)	((buffer)->u.address)
+#else
 #define SG_ADDRESS(buffer)	((buffer)->address)
+#endif
 #else
 #define SG_ADDRESS(buffer)	((char *) (page_address((buffer)->page)+(buffer)->offset))
 #endif
diff -X dontdiff -urp kern_oldest/drivers/scsi/aha1542.c kern_fix/drivers/scsi/aha1542.c
--- kern_oldest/drivers/scsi/aha1542.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/aha1542.c	2006-05-01 14:14:13.000000000 -0700
@@ -69,8 +69,13 @@ static void BAD_SG_DMA(Scsi_Cmnd * SCpnt
 {
 	printk(KERN_CRIT "sgpnt[%d:%d] addr %p/0x%lx length %d\n",
 	       badseg, nseg,
+#if SMALL_SCATTERLIST
+	       sgpnt[badseg].u.address,
+	       SCSI_PA(sgpnt[badseg].u.address),
+#else
 	       sgpnt[badseg].address,
 	       SCSI_PA(sgpnt[badseg].address),
+#endif
 	       sgpnt[badseg].length);
 
 	/*
@@ -710,11 +715,21 @@ static int aha1542_queuecommand(Scsi_Cmn
 			panic("aha1542.c: unable to allocate DMA memory\n");
 		for (i = 0; i < SCpnt->use_sg; i++) {
 			if (sgpnt[i].length == 0 || SCpnt->use_sg > 16 ||
-			    (((int) sgpnt[i].address) & 1) || (sgpnt[i].length & 1)) {
+#if SMALL_SCATTERLIST
+			    (((int) sgpnt[i].u.address) & 1) 
+#else
+			    (((int) sgpnt[i].address) & 1)
+#endif
+			    || (sgpnt[i].length & 1)) {
 				unsigned char *ptr;
 				printk(KERN_CRIT "Bad segment list supplied to aha1542.c (%d, %d)\n", SCpnt->use_sg, i);
 				for (i = 0; i < SCpnt->use_sg; i++) {
-					printk(KERN_CRIT "%d: %p %d\n", i, sgpnt[i].address,
+					printk(KERN_CRIT "%d: %p %d\n", i, 
+#if SMALL_SCATTERLIST
+					       sgpnt[i].u.address,
+#else
+					       sgpnt[i].address,
+#endif
 					       sgpnt[i].length);
 				};
 				printk(KERN_CRIT "cptr %x: ", (unsigned int) cptr);
@@ -723,8 +738,13 @@ static int aha1542_queuecommand(Scsi_Cmn
 					printk("%02x ", ptr[i]);
 				panic("Foooooooood fight!");
 			};
+#if SMALL_SCATTERLIST
+			any2scsi(cptr[i].dataptr, SCSI_PA(sgpnt[i].u.address));
+			if (SCSI_PA(sgpnt[i].u.address + sgpnt[i].length - 1) > ISA_DMA_THRESHOLD)
+#else
 			any2scsi(cptr[i].dataptr, SCSI_PA(sgpnt[i].address));
 			if (SCSI_PA(sgpnt[i].address + sgpnt[i].length - 1) > ISA_DMA_THRESHOLD)
+#endif
 				BAD_SG_DMA(SCpnt, sgpnt, SCpnt->use_sg, i);
 			any2scsi(cptr[i].datalen, sgpnt[i].length);
 		};
diff -X dontdiff -urp kern_oldest/drivers/scsi/aha1740.c kern_fix/drivers/scsi/aha1740.c
--- kern_oldest/drivers/scsi/aha1740.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/aha1740.c	2006-05-01 14:14:13.000000000 -0700
@@ -397,7 +397,11 @@ int aha1740_queuecommand(Scsi_Cmnd * SCp
 	for(i=0; i<SCpnt->use_sg; i++)
 	{
 	    cptr[i].datalen = sgpnt[i].length;
+#if SMALL_SCATTERLIST
+	    cptr[i].dataptr = virt_to_bus(sgpnt[i].u.address);
+#else
 	    cptr[i].dataptr = virt_to_bus(sgpnt[i].address);
+#endif
 	}
 	host->ecb[ecbno].datalen = SCpnt->use_sg * sizeof(struct aha1740_chain);
 	host->ecb[ecbno].dataptr = virt_to_bus(cptr);
diff -X dontdiff -urp kern_oldest/drivers/scsi/aic7xxx_old.c kern_fix/drivers/scsi/aic7xxx_old.c
--- kern_oldest/drivers/scsi/aic7xxx_old.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/aic7xxx_old.c	2006-05-01 14:14:13.000000000 -0700
@@ -2845,7 +2845,11 @@ aic7xxx_done(struct aic7xxx_host *p, str
           struct scatterlist *sg;
 
           sg = (struct scatterlist *)cmd->request_buffer;
+#if SMALL_SCATTERLIST
+          buffer = (char *)sg[0].u.address;
+#else
           buffer = (char *)sg[0].address;
+#endif
         }
         else
         {
diff -X dontdiff -urp kern_oldest/drivers/scsi/AM53C974.c kern_fix/drivers/scsi/AM53C974.c
--- kern_oldest/drivers/scsi/AM53C974.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/AM53C974.c	2006-05-01 14:14:13.000000000 -0700
@@ -842,7 +842,11 @@ static __inline__ void initialize_SCp(Sc
 	if (cmd->use_sg) {
 		cmd->SCp.buffer = (struct scatterlist *) cmd->buffer;
 		cmd->SCp.buffers_residual = cmd->use_sg - 1;
+#if SMALL_SCATTERLIST
+		cmd->SCp.ptr = (char *) cmd->SCp.buffer->u.address;
+#else
 		cmd->SCp.ptr = (char *) cmd->SCp.buffer->address;
+#endif
 		cmd->SCp.this_residual = cmd->SCp.buffer->length;
 	} else {
 		cmd->SCp.buffer = NULL;
@@ -1555,7 +1559,11 @@ static void AM53C974_information_transfe
 		if ((!cmd->SCp.this_residual) && cmd->SCp.buffers_residual) {
 			cmd->SCp.buffer++;
 			cmd->SCp.buffers_residual--;
+#if SMALL_SCATTERLIST
+			cmd->SCp.ptr = (unsigned char *) cmd->SCp.buffer->u.address;
+#else
 			cmd->SCp.ptr = (unsigned char *) cmd->SCp.buffer->address;
+#endif
 			cmd->SCp.this_residual = cmd->SCp.buffer->length;
 		}
 		if (cmd->SCp.this_residual) {
diff -X dontdiff -urp kern_oldest/drivers/scsi/atp870u.c kern_fix/drivers/scsi/atp870u.c
--- kern_oldest/drivers/scsi/atp870u.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/atp870u.c	2006-05-01 14:14:13.000000000 -0700
@@ -804,7 +804,11 @@ oktosend:
 		sgpnt = (struct scatterlist *) workrequ->request_buffer;
 		i = 0;
 		for (j = 0; j < workrequ->use_sg; j++) {
+#if SMALL_SCATTERLIST
+			bttl = virt_to_bus(sgpnt[j].u.address);
+#else
 			bttl = virt_to_bus(sgpnt[j].address);
+#endif
 			l = sgpnt[j].length;
 			while (l > 0x10000) {
 				(unsigned short int) (((unsigned short int *) (prd))[i + 3]) = 0x0000;
diff -X dontdiff -urp kern_oldest/drivers/scsi/BusLogic.c kern_fix/drivers/scsi/BusLogic.c
--- kern_oldest/drivers/scsi/BusLogic.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/BusLogic.c	2006-05-01 14:14:13.000000000 -0700
@@ -3402,7 +3402,12 @@ int BusLogic_QueueCommand(SCSI_Command_T
 	  CCB->ScatterGatherList[Segment].SegmentByteCount =
 	    ScatterList[Segment].length;
 	  CCB->ScatterGatherList[Segment].SegmentDataPointer =
+#if SMALL_SCATTERLIST
+	    Virtual_to_Bus(ScatterList[Segment].u.address);
+#else
 	    Virtual_to_Bus(ScatterList[Segment].address);
+#endif
+
 	}
     }
   switch (CDB[0])
diff -X dontdiff -urp kern_oldest/drivers/scsi/dpt_i2o.c kern_fix/drivers/scsi/dpt_i2o.c
--- kern_oldest/drivers/scsi/dpt_i2o.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/dpt_i2o.c	2006-05-01 14:14:13.000000000 -0700
@@ -2166,7 +2166,13 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pH
 		for(i = 0 ; i < cmd->use_sg; i++) {
 			*mptr++ = direction|0x10000000|sg->length;
 			len+=sg->length;
+#if SMALL_SCATTERLIST
+			if (sg->ispaged)
+			   BUG();
+			*mptr++ = virt_to_bus(sg->u.address);
+#else
 			*mptr++ = virt_to_bus(sg->address);
+#endif
 			sg++;
 		}
 		/* Make this an end of list */
diff -X dontdiff -urp kern_oldest/drivers/scsi/eata_dma.c kern_fix/drivers/scsi/eata_dma.c
--- kern_oldest/drivers/scsi/eata_dma.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/eata_dma.c	2006-05-01 14:14:13.000000000 -0700
@@ -571,7 +571,11 @@ int eata_queue(Scsi_Cmnd * cmd, void (* 
 	ccb->cp_datalen = htonl(cmd->use_sg * sizeof(struct eata_sg_list));
 	sl=(struct scatterlist *)cmd->request_buffer;
 	for(i = 0; i < cmd->use_sg; i++, sl++){
+#if SMALL_SCATTERLIST
+	    ccb->sg_list[i].data = htonl(virt_to_bus(sl->u.address));
+#else
 	    ccb->sg_list[i].data = htonl(virt_to_bus(sl->address));
+#endif
 	    ccb->sg_list[i].len = htonl((u32) sl->length);
 	}
     } else {
diff -X dontdiff -urp kern_oldest/drivers/scsi/eata_pio.c kern_fix/drivers/scsi/eata_pio.c
--- kern_oldest/drivers/scsi/eata_pio.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/eata_pio.c	2006-05-01 14:14:13.000000000 -0700
@@ -99,7 +99,11 @@ void IncStat(Scsi_Pointer *SCp, uint Inc
 	else
 	{
 	    SCp->buffer++;
+#if SMALL_SCATTERLIST
+	    SCp->ptr=SCp->buffer->u.address;
+#else
 	    SCp->ptr=SCp->buffer->address;
+#endif
 	    SCp->this_residual=SCp->buffer->length;
 	}
     }
@@ -371,7 +375,11 @@ int eata_pio_queue(Scsi_Cmnd * cmd, void
     } else {
 	cmd->SCp.buffer = cmd->request_buffer;
 	cmd->SCp.buffers_residual = cmd->use_sg;
+#if SMALL_SCATTERLIST
+	cmd->SCp.ptr = cmd->SCp.buffer->u.address;
+#else
 	cmd->SCp.ptr = cmd->SCp.buffer->address;
+#endif
 	cmd->SCp.this_residual = cmd->SCp.buffer->length;
     }
     cmd->SCp.Status = (cmd->SCp.this_residual != 0);  /* TRUE as long as bytes 
diff -X dontdiff -urp kern_oldest/drivers/scsi/fdomain.c kern_fix/drivers/scsi/fdomain.c
--- kern_oldest/drivers/scsi/fdomain.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/fdomain.c	2006-05-01 14:14:13.000000000 -0700
@@ -1564,7 +1564,11 @@ void do_fdomain_16x0_intr( int irq, void
 	    if (current_SC->SCp.buffers_residual) {
 	       --current_SC->SCp.buffers_residual;
 	       ++current_SC->SCp.buffer;
+#if SMALL_SCATTERLIST
+	       current_SC->SCp.ptr = current_SC->SCp.buffer->u.address;
+#else
 	       current_SC->SCp.ptr = current_SC->SCp.buffer->address;
+#endif
 	       current_SC->SCp.this_residual = current_SC->SCp.buffer->length;
 	    } else
 		  break;
@@ -1597,7 +1601,11 @@ void do_fdomain_16x0_intr( int irq, void
 	     && current_SC->SCp.buffers_residual) {
 	    --current_SC->SCp.buffers_residual;
 	    ++current_SC->SCp.buffer;
+#if SMALL_SCATTERLIST
+	    current_SC->SCp.ptr = current_SC->SCp.buffer->u.address;
+#else
 	    current_SC->SCp.ptr = current_SC->SCp.buffer->address;
+#endif
 	    current_SC->SCp.this_residual = current_SC->SCp.buffer->length;
 	 }
       }
@@ -1683,7 +1691,11 @@ int fdomain_16x0_queue( Scsi_Cmnd * SCpn
    if (current_SC->use_sg) {
       current_SC->SCp.buffer =
 	    (struct scatterlist *)current_SC->request_buffer;
+#if SMALL_SCATTERLIST
+      current_SC->SCp.ptr              = current_SC->SCp.buffer->u.address;
+#else
       current_SC->SCp.ptr              = current_SC->SCp.buffer->address;
+#endif
       current_SC->SCp.this_residual    = current_SC->SCp.buffer->length;
       current_SC->SCp.buffers_residual = current_SC->use_sg - 1;
    } else {
diff -X dontdiff -urp kern_oldest/drivers/scsi/gdth.c kern_fix/drivers/scsi/gdth.c
--- kern_oldest/drivers/scsi/gdth.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/gdth.c	2006-05-01 14:14:13.000000000 -0700
@@ -2662,7 +2662,11 @@ static void gdth_copy_internal_data(Scsi
             if (cpsum+cpnow > cpcount) 
                 cpnow = cpcount - cpsum;
             cpsum += cpnow;
+#if SMALL_SCATTERLIST
+            memcpy((char*)sl->u.address,buffer,cpnow);
+#else
             memcpy((char*)sl->address,buffer,cpnow);
+#endif
             if (cpsum == cpcount)
                 break;
             buffer += cpnow;
@@ -2837,7 +2841,11 @@ static int gdth_fill_cache_cmd(int hanum
             cmdp->u.cache.DestAddr= 0xffffffff;
             sl = (struct scatterlist *)scp->request_buffer;
             for (i=0; i<scp->use_sg; ++i,++sl) {
+#if SMALL_SCATTERLIST
+                cmdp->u.cache.sg_lst[i].sg_ptr = virt_to_bus(sl->u.address);
+#else
                 cmdp->u.cache.sg_lst[i].sg_ptr = virt_to_bus(sl->address);
+#endif
                 cmdp->u.cache.sg_lst[i].sg_len = (ulong32)sl->length;
             }
             cmdp->u.cache.sg_canz = (ulong32)i;
@@ -2954,7 +2962,11 @@ static int gdth_fill_raw_cmd(int hanum,S
             cmdp->u.raw.sdata  = 0xffffffff;
             sl = (struct scatterlist *)scp->request_buffer;
             for (i=0; i<scp->use_sg; ++i,++sl) {
+#if SMALL_SCATTERLIST
+                cmdp->u.raw.sg_lst[i].sg_ptr = virt_to_bus(sl->u.address);
+#else
                 cmdp->u.raw.sg_lst[i].sg_ptr = virt_to_bus(sl->address);
+#endif
                 cmdp->u.raw.sg_lst[i].sg_len = (ulong32)sl->length;
             }
             cmdp->u.raw.sg_ranz = (ulong32)i;
diff -X dontdiff -urp kern_oldest/drivers/scsi/ide-scsi.c kern_fix/drivers/scsi/ide-scsi.c
--- kern_oldest/drivers/scsi/ide-scsi.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/ide-scsi.c	2006-05-01 14:14:13.000000000 -0700
@@ -154,7 +154,11 @@ static void idescsi_input_buffers (ide_d
 			return;
 		}
 		count = IDE_MIN(pc->sg->length - pc->b_count, bcount);
+#if SMALL_SCATTERLIST
+		HWIF(drive)->atapi_input_bytes(drive, pc->sg->u.address + pc->b_count, count);
+#else
 		HWIF(drive)->atapi_input_bytes(drive, pc->sg->address + pc->b_count, count);
+#endif
 		bcount -= count;
 		pc->b_count += count;
 		if (pc->b_count == pc->sg->length) {
@@ -176,7 +180,11 @@ static void idescsi_output_buffers (ide_
 			return;
 		}
 		count = IDE_MIN(pc->sg->length - pc->b_count, bcount);
+#if SMALL_SCATTERLIST
+		HWIF(drive)->atapi_output_bytes(drive, pc->sg->u.address + pc->b_count, count);
+#else
 		HWIF(drive)->atapi_output_bytes(drive, pc->sg->address + pc->b_count, count);
+#endif
 		bcount -= count;
 		pc->b_count += count;
 		if (pc->b_count == pc->sg->length) {
@@ -1026,6 +1034,19 @@ static inline struct buffer_head *idescs
 			pc->request_transfer >> 10);
 #endif /* IDESCSI_DEBUG_LOG */
 		while (segments--) {
+#if SMALL_SCATTERLIST
+#if 1
+			bh->b_data = sg->u.address;
+#else
+			if (sg->u.address) {
+				bh->b_page = virt_to_page(sg->u.address);
+				bh->b_data = (char *) ((unsigned long) sg->u.address & ~PAGE_MASK);
+			} else if (sg->u.page.page) {
+				bh->b_page = sg->u.page.page;
+				bh->b_data = (char *) sg->u.page.offset;
+			}
+#endif
+#else /* !SMALL_SCATTERLIST */
 #if 1
 			bh->b_data = sg->address;
 #else
@@ -1037,6 +1058,7 @@ static inline struct buffer_head *idescs
 				bh->b_data = (char *) sg->offset;
 			}
 #endif
+#endif /* !SMALL_SCATTERLIST */
 			bh->b_size = sg->length;
 			bh = bh->b_reqnext;
 			sg++;
diff -X dontdiff -urp kern_oldest/drivers/scsi/imm.c kern_fix/drivers/scsi/imm.c
--- kern_oldest/drivers/scsi/imm.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/imm.c	2006-05-01 14:14:13.000000000 -0700
@@ -834,7 +834,11 @@ static int imm_completion(Scsi_Cmnd * cm
 	    if (cmd->SCp.buffers_residual--) {
 		cmd->SCp.buffer++;
 		cmd->SCp.this_residual = cmd->SCp.buffer->length;
+#if SMALL_SCATTERLIST
+		cmd->SCp.ptr = cmd->SCp.buffer->u.address;
+#else
 		cmd->SCp.ptr = cmd->SCp.buffer->address;
+#endif
 
 		/*
 		 * Make sure that we transfer even number of bytes
@@ -1008,7 +1012,11 @@ static int imm_engine(imm_struct * tmp, 
 	    /* if many buffers are available, start filling the first */
 	    cmd->SCp.buffer = (struct scatterlist *) cmd->request_buffer;
 	    cmd->SCp.this_residual = cmd->SCp.buffer->length;
+#if SMALL_SCATTERLIST
+	    cmd->SCp.ptr = cmd->SCp.buffer->u.address;
+#else
 	    cmd->SCp.ptr = cmd->SCp.buffer->address;
+#endif
 	} else {
 	    /* else fill the only available buffer */
 	    cmd->SCp.buffer = NULL;
diff -X dontdiff -urp kern_oldest/drivers/scsi/in2000.c kern_fix/drivers/scsi/in2000.c
--- kern_oldest/drivers/scsi/in2000.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/in2000.c	2006-05-01 14:14:13.000000000 -0700
@@ -355,7 +355,11 @@ DB(DB_QUEUE_COMMAND,printk("Q-%d-%02x-%l
    if (cmd->use_sg) {
       cmd->SCp.buffer = (struct scatterlist *)cmd->buffer;
       cmd->SCp.buffers_residual = cmd->use_sg - 1;
+#if SMALL_SCATTERLIST
+      cmd->SCp.ptr = (char *)cmd->SCp.buffer->u.address;
+#else
       cmd->SCp.ptr = (char *)cmd->SCp.buffer->address;
+#endif
       cmd->SCp.this_residual = cmd->SCp.buffer->length;
       }
    else {
@@ -762,7 +766,11 @@ int i;
       ++cmd->SCp.buffer;
       --cmd->SCp.buffers_residual;
       cmd->SCp.this_residual = cmd->SCp.buffer->length;
+#if SMALL_SCATTERLIST
+      cmd->SCp.ptr = cmd->SCp.buffer->u.address;
+#else
       cmd->SCp.ptr = cmd->SCp.buffer->address;
+#endif
       }
 
 /* Set up hardware registers */
diff -X dontdiff -urp kern_oldest/drivers/scsi/ini9100u.c kern_fix/drivers/scsi/ini9100u.c
--- kern_oldest/drivers/scsi/ini9100u.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/ini9100u.c	2006-05-01 14:14:13.000000000 -0700
@@ -489,7 +489,11 @@ static void i91uBuildSCB(HCS * pHCB, SCB
 	if (SCpnt->use_sg) {
 		pSrbSG = (struct scatterlist *) SCpnt->request_buffer;
 		if (SCpnt->use_sg == 1) {	/* If only one entry in the list *//*      treat it as regular I/O */
+#if SMALL_SCATTERLIST
+			pSCB->SCB_BufPtr = (U32) VIRT_TO_BUS(pSrbSG->u.address);
+#else
 			pSCB->SCB_BufPtr = (U32) VIRT_TO_BUS(pSrbSG->address);
+#endif
 			TotalLen = pSrbSG->length;
 			pSCB->SCB_SGLen = 0;
 		} else {	/* Assign SG physical address   */
@@ -498,7 +502,11 @@ static void i91uBuildSCB(HCS * pHCB, SCB
 			for (i = 0, TotalLen = 0, pSG = &pSCB->SCB_SGList[0];	/* 1.01g */
 			     i < SCpnt->use_sg;
 			     i++, pSG++, pSrbSG++) {
+#if SMALL_SCATTERLIST
+				pSG->SG_Ptr = (U32) VIRT_TO_BUS(pSrbSG->u.address);
+#else
 				pSG->SG_Ptr = (U32) VIRT_TO_BUS(pSrbSG->address);
+#endif
 				TotalLen += pSG->SG_Len = pSrbSG->length;
 			}
 			pSCB->SCB_SGLen = i;
diff -X dontdiff -urp kern_oldest/drivers/scsi/inia100.c kern_fix/drivers/scsi/inia100.c
--- kern_oldest/drivers/scsi/inia100.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/inia100.c	2006-05-01 14:14:13.000000000 -0700
@@ -494,7 +494,11 @@ static void inia100BuildSCB(ORC_HCS * pH
 			pSCB->SCB_SGLen = (U32) (SCpnt->use_sg * 8);
 			pSrbSG = (struct scatterlist *) SCpnt->request_buffer;
 			for (i = 0; i < SCpnt->use_sg; i++, pSG++, pSrbSG++) {
+#if SMALL_SCATTERLIST
+				pSG->SG_Ptr = (U32) (VIRT_TO_BUS(pSrbSG->u.address));
+#else
 				pSG->SG_Ptr = (U32) (VIRT_TO_BUS(pSrbSG->address));
+#endif
 				pSG->SG_Len = (U32) pSrbSG->length;
 				TotalLen += (U32) pSrbSG->length;
 			}
diff -X dontdiff -urp kern_oldest/drivers/scsi/ips.c kern_fix/drivers/scsi/ips.c
--- kern_oldest/drivers/scsi/ips.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/ips.c	2006-05-01 14:14:13.000000000 -0700
@@ -217,7 +217,11 @@ MODULE_PARM(ips, "s");
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,0)
 #include <linux/blk.h>
 #include "sd.h"
+#ifdef SMALL_SCATTERLIST
+#define IPS_SG_ADDRESS(sg)       ((sg)->u.address)
+#else
 #define IPS_SG_ADDRESS(sg)       ((sg)->address)
+#endif /* !SMALL_SCATTERLIST */
 #define IPS_LOCK_SAVE(lock,flags) spin_lock_irqsave(&io_request_lock,flags)
 #define IPS_UNLOCK_RESTORE(lock,flags) spin_unlock_irqrestore(&io_request_lock,flags)
 #ifndef __devexit_p
diff -X dontdiff -urp kern_oldest/drivers/scsi/libata-core.c kern_fix/drivers/scsi/libata-core.c
--- kern_oldest/drivers/scsi/libata-core.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/libata-core.c	2006-05-01 14:14:13.000000000 -0700
@@ -3010,8 +3010,13 @@ static void ata_pio_sector(struct ata_qu
 	if (qc->cursect == (qc->nsect - 1))
 		ap->hsm_task_state = HSM_ST_LAST;
 
+#if SMALL_SCATTERLIST
+	page = sg[qc->cursg].u.page.page;
+	offset = sg[qc->cursg].u.page.offset + qc->cursg_ofs * ATA_SECT_SIZE;
+#else
 	page = sg[qc->cursg].page;
 	offset = sg[qc->cursg].offset + qc->cursg_ofs * ATA_SECT_SIZE;
+#endif /* SMALL_SCATTERLIST */
 
 	/* get the current page and offset */
 	page = nth_page(page, (offset >> PAGE_SHIFT));
@@ -3086,8 +3091,13 @@ next_sg:
 
 	sg = &qc->__sg[qc->cursg];
 
+#if SMALL_SCATTERLIST
+	page = sg->u.page.page;
+	offset = sg->u.page.offset + qc->cursg_ofs;
+#else
 	page = sg->page;
 	offset = sg->offset + qc->cursg_ofs;
+#endif
 
 	/* get the current page and offset */
 	page = nth_page(page, (offset >> PAGE_SHIFT));
diff -X dontdiff -urp kern_oldest/drivers/scsi/libata-scsi.c kern_fix/drivers/scsi/libata-scsi.c
--- kern_oldest/drivers/scsi/libata-scsi.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/libata-scsi.c	2006-05-01 14:14:13.000000000 -0700
@@ -1314,7 +1314,11 @@ static unsigned int ata_scsi_rbuf_get(st
 		struct scatterlist *sg;
 
 		sg = (struct scatterlist *) cmd->request_buffer;
+#if SMALL_SCATTERLIST
+		buf = kmap_atomic(sg->u.page.page, KM_USER0) + sg->u.page.offset;
+#else
 		buf = kmap_atomic(sg->page, KM_USER0) + sg->offset;
+#endif /* !SMALL_SCATTERLIST */
 		buflen = sg->length;
 	} else {
 		buf = cmd->request_buffer;
@@ -1342,7 +1346,11 @@ static inline void ata_scsi_rbuf_put(str
 		struct scatterlist *sg;
 
 		sg = (struct scatterlist *) cmd->request_buffer;
+#if SMALL_SCATTERLIST
+		kunmap_atomic(buf - sg->u.page.offset, KM_USER0);
+#else
 		kunmap_atomic(buf - sg->offset, KM_USER0);
+#endif /* !SMALL_SCATTERLIST */
 	}
 }
 
diff -X dontdiff -urp kern_oldest/drivers/scsi/megaraid2.c kern_fix/drivers/scsi/megaraid2.c
--- kern_oldest/drivers/scsi/megaraid2.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/megaraid2.c	2006-05-01 14:14:13.000000000 -0700
@@ -2068,7 +2068,11 @@ mega_cmd_done(adapter_t *adapter, u8 com
 			if( cmd->use_sg ) {
 				sgl = (struct scatterlist *)
 					cmd->request_buffer;
+#if SMALL_SCATTERLIST
+				c = *(u8 *)sgl[0].u.address;
+#else
 				c = *(u8 *)sgl[0].address;
+#endif
 			}
 			else {
 				c = *(u8 *)cmd->request_buffer;
diff -X dontdiff -urp kern_oldest/drivers/scsi/megaraid.c kern_fix/drivers/scsi/megaraid.c
--- kern_oldest/drivers/scsi/megaraid.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/megaraid.c	2006-05-01 14:14:13.000000000 -0700
@@ -1201,8 +1201,13 @@ static void mega_cmd_done (mega_host_con
 	case READ_CAPACITY:
 		if ( SCpnt->use_sg ) {
 			sgList = (struct scatterlist *)SCpnt->request_buffer;
+#if SMALL_SCATTERLIST
+			memcpy(sgList[0].u.address, pScb->bounce_buffer,
+			       SCpnt->request_bufflen);
+#else
 			memcpy(sgList[0].address, pScb->bounce_buffer,
-							SCpnt->request_bufflen);
+			       SCpnt->request_bufflen);
+#endif
 		} else {
 				memcpy (SCpnt->request_buffer, pScb->bounce_buffer,
 								SCpnt->request_bufflen);
@@ -1226,7 +1231,11 @@ static void mega_cmd_done (mega_host_con
 	if (SCpnt->cmnd[0] == INQUIRY && !islogical) {
 		if ( SCpnt->use_sg ) {
 			sgList = (struct scatterlist *)SCpnt->request_buffer;
+#if SMALL_SCATTERLIST
+			memcpy(&c, sgList[0].u.address, 0x1);
+#else
 			memcpy(&c, sgList[0].address, 0x1);
+#endif
 		} else {
 			memcpy(&c, SCpnt->request_buffer, 0x1);
 		}
diff -X dontdiff -urp kern_oldest/drivers/scsi/NCR5380.c kern_fix/drivers/scsi/NCR5380.c
--- kern_oldest/drivers/scsi/NCR5380.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/NCR5380.c	2006-05-01 14:14:13.000000000 -0700
@@ -337,7 +337,11 @@ static __inline__ void initialize_SCp(Sc
 	if (cmd->use_sg) {
 		cmd->SCp.buffer = (struct scatterlist *) cmd->buffer;
 		cmd->SCp.buffers_residual = cmd->use_sg - 1;
+#if SMALL_SCATTERLIST
+		cmd->SCp.ptr = (char *) cmd->SCp.buffer->u.address;
+#else
 		cmd->SCp.ptr = (char *) cmd->SCp.buffer->address;
+#endif
 		cmd->SCp.this_residual = cmd->SCp.buffer->length;
 	} else {
 		cmd->SCp.buffer = NULL;
@@ -2308,7 +2312,11 @@ static void NCR5380_information_transfer
 					++cmd->SCp.buffer;
 					--cmd->SCp.buffers_residual;
 					cmd->SCp.this_residual = cmd->SCp.buffer->length;
+#if SMALL_SCATTERLIST
+					cmd->SCp.ptr = cmd->SCp.buffer->u.address;
+#else
 					cmd->SCp.ptr = cmd->SCp.buffer->address;
+#endif
 					dprintk(NDEBUG_INFORMATION, ("scsi%d : %d bytes and %d buffers left\n", instance->host_no, cmd->SCp.this_residual, cmd->SCp.buffers_residual));
 				}
 				/*
diff -X dontdiff -urp kern_oldest/drivers/scsi/NCR53c406a.c kern_fix/drivers/scsi/NCR53c406a.c
--- kern_oldest/drivers/scsi/NCR53c406a.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/NCR53c406a.c	2006-05-01 14:14:13.000000000 -0700
@@ -895,7 +895,11 @@ NCR53c406a_intr(int unused, void *dev_id
                 sgcount = current_SC->use_sg;
                 sglist = current_SC->request_buffer;
                 while( sgcount-- ) {
+#if SMALL_SCATTERLIST
+                    NCR53c406a_pio_write(sglist->u.address, sglist->length);
+#else
                     NCR53c406a_pio_write(sglist->address, sglist->length);
+#endif
                     sglist++;
                 }
             }
@@ -924,7 +928,11 @@ NCR53c406a_intr(int unused, void *dev_id
                 sgcount = current_SC->use_sg;
                 sglist = current_SC->request_buffer;
                 while( sgcount-- ) {
+#if SMALL_SCATTERLIST
+                    NCR53c406a_pio_read(sglist->u.address, sglist->length);
+#else
                     NCR53c406a_pio_read(sglist->address, sglist->length);
+#endif
                     sglist++;
                 }
             }
diff -X dontdiff -urp kern_oldest/drivers/scsi/osst.c kern_fix/drivers/scsi/osst.c
--- kern_oldest/drivers/scsi/osst.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/osst.c	2006-05-01 14:14:13.000000000 -0700
@@ -477,7 +477,11 @@ static int osst_verify_frame(OS_Scsi_Tap
 	if (STp->raw) {
 		if (STp->buffer->syscall_result) {
 			for (i=0; i < STp->buffer->sg_segs; i++)
+#if SMALL_SCATTERLIST
+				memset(STp->buffer->sg[i].u.address, 0, STp->buffer->sg[i].length);
+#else
 				memset(STp->buffer->sg[i].address, 0, STp->buffer->sg[i].length);
+#endif
 			strcpy(STp->buffer->b_data, "READ ERROR ON FRAME");
                 } else
 			STp->buffer->buffer_bytes = OS_FRAME_SIZE;
@@ -4460,10 +4464,19 @@ static int os_scsi_tape_open(struct inod
 		for (i = 0, b_size = 0; 
 		     i < STp->buffer->sg_segs && (b_size + STp->buffer->sg[i].length) <= OS_DATA_SIZE; 
 		     b_size += STp->buffer->sg[i++].length);
+#if SMALL_SCATTERLIST
+		STp->buffer->aux = (os_aux_t *) (STp->buffer->sg[i].u.address + OS_DATA_SIZE - b_size);
+#else
 		STp->buffer->aux = (os_aux_t *) (STp->buffer->sg[i].address + OS_DATA_SIZE - b_size);
+#endif
 #if DEBUG
 		printk(OSST_DEB_MSG "osst%d:D: b_data points to %p in segment 0 at %p\n", dev,
-			STp->buffer->b_data, STp->buffer->sg[0].address);
+			STp->buffer->b_data, 
+#if SMALL_SCATTERLIST
+		       STp->buffer->sg[0].u.address);
+#else
+  		       STp->buffer->sg[0].address);
+#endif
 		printk(OSST_DEB_MSG "osst%d:D: AUX points to %p in segment %d at %p\n", dev,
 			 STp->buffer->aux, i, STp->buffer->sg[i].address);
 #endif
@@ -5007,6 +5020,12 @@ out:
 
 /* Memory handling routines */
 
+#if SMALL_SCATTERLIST
+#define SG_ADDRESS(sg) ((sg).u.address)
+#else
+#define SG_ADDRESS(sg) ((sg).address)
+#endif
+
 /* Try to allocate a new tape buffer */
 static OSST_buffer * new_tape_buffer( int from_initialization, int need_dma )
 {
@@ -5035,15 +5054,19 @@ static OSST_buffer * new_tape_buffer( in
 		     b_size *= 2,                 order++ );
 
 		for ( ; b_size >= PAGE_SIZE; order--, b_size /= 2) {
-			tb->sg[0].address =
+			SG_ADDRESS(tb->sg[0]) =
 			    (unsigned char *)__get_free_pages(priority, order);
-			if (tb->sg[0].address != NULL) {
+			if (SG_ADDRESS(tb->sg[0]) != NULL) {
+#if SMALL_SCATTERLIST
+			    tb->sg[0].ispaged = 0;
+#else
 			    tb->sg[0].page = NULL;
+#endif
 			    tb->sg[0].length = b_size;
 			    break;
 			}
 		}
-		if (tb->sg[segs].address == NULL) {
+		if (SG_ADDRESS(tb->sg[segs]) == NULL) {
 			kfree(tb);
 			tb = NULL;
 		}
@@ -5055,9 +5078,9 @@ static OSST_buffer * new_tape_buffer( in
 
 			for (segs=1, got=tb->sg[0].length;
 			     got < osst_buffer_size && segs < OSST_FIRST_SG; ) {
-			    tb->sg[segs].address =
+			    SG_ADDRESS(tb->sg[segs]) =
 				(unsigned char *)__get_free_pages(priority, order);
-			    if (tb->sg[segs].address == NULL) {
+			    if (SG_ADDRESS(tb->sg[segs]) == NULL) {
 				if (osst_buffer_size - got <=
 				    (OSST_FIRST_SG - segs) * b_size / 2) {
 				    b_size /= 2; /* Large enough for the rest of the buffers */
@@ -5074,7 +5097,11 @@ static OSST_buffer * new_tape_buffer( in
 				tb = NULL;
 				break;
 			    }
+#if SMALL_SCATTERLIST
+			    tb->sg[segs].ispaged = 0;
+#else
                             tb->sg[segs].page = NULL;
+#endif
 			    tb->sg[segs].length = b_size;
 			    got += b_size;
 			    segs++;
@@ -5087,7 +5114,7 @@ static OSST_buffer * new_tape_buffer( in
 		return NULL;
 	}
 	tb->sg_segs = tb->orig_sg_segs = segs;
-	tb->b_data = tb->sg[0].address;
+	tb->b_data = SG_ADDRESS(tb->sg[0]);
 
 #if DEBUG
 	if (debugging) {
@@ -5132,9 +5159,9 @@ static int enlarge_buffer(OSST_buffer *S
 
 	for (segs=STbuffer->sg_segs, got=STbuffer->buffer_size;
 	     segs < max_segs && got < new_size; ) {
-		STbuffer->sg[segs].address =
+		SG_ADDRESS(STbuffer->sg[segs]) =
 			  (unsigned char *)__get_free_pages(priority, order);
-		if (STbuffer->sg[segs].address == NULL) {
+		if (SG_ADDRESS(STbuffer->sg[segs]) == NULL) {
 			if (new_size - got <= (max_segs - segs) * b_size / 2) {
 				b_size /= 2;  /* Large enough for the rest of the buffers */
 				order--;
@@ -5148,7 +5175,11 @@ static int enlarge_buffer(OSST_buffer *S
 			normalize_buffer(STbuffer);
 			return FALSE;
 		}
+#if SMALL_SCATTERLIST
+		STbuffer->sg[segs].ispaged = 0;
+#else
 		STbuffer->sg[segs].page = NULL;
+#endif
 		STbuffer->sg[segs].length = b_size;
 		STbuffer->sg_segs += 1;
 		got += b_size;
@@ -5181,8 +5212,8 @@ static void normalize_buffer(OSST_buffer
 		for (b_size = PAGE_SIZE, order = 0;
 		     b_size < STbuffer->sg[i].length;
 		     b_size *= 2, order++);
-
-		free_pages((unsigned long)STbuffer->sg[i].address, order);
+ 
+		free_pages((unsigned long)SG_ADDRESS(STbuffer->sg[i]), order);
 		STbuffer->buffer_size -= STbuffer->sg[i].length;
 	}
 #if DEBUG
@@ -5210,7 +5241,7 @@ static int append_to_buffer(const char *
 	for ( ; i < st_bp->sg_segs && do_count > 0; i++) {
 		cnt = st_bp->sg[i].length - offset < do_count ?
 		      st_bp->sg[i].length - offset : do_count;
-		res = copy_from_user(st_bp->sg[i].address + offset, ubp, cnt);
+		res = copy_from_user(SG_ADDRESS(st_bp->sg[i]) + offset, ubp, cnt);
 		if (res)
 			return (-EFAULT);
 		do_count -= cnt;
@@ -5243,7 +5274,7 @@ static int from_buffer(OSST_buffer *st_b
 	for ( ; i < st_bp->sg_segs && do_count > 0; i++) {
 		cnt = st_bp->sg[i].length - offset < do_count ?
 		      st_bp->sg[i].length - offset : do_count;
-		res = copy_to_user(ubp, st_bp->sg[i].address + offset, cnt);
+		res = copy_to_user(ubp, SG_ADDRESS(st_bp->sg[i]) + offset, cnt);
 		if (res)
 			return (-EFAULT);
 		do_count -= cnt;
@@ -5276,7 +5307,7 @@ static int osst_zero_buffer_tail(OSST_bu
 	     i < st_bp->sg_segs && do_count > 0; i++) {
 		cnt = st_bp->sg[i].length - offset < do_count ?
 		      st_bp->sg[i].length - offset : do_count ;
-		memset(st_bp->sg[i].address + offset, 0, cnt);
+		memset(SG_ADDRESS(st_bp->sg[i]) + offset, 0, cnt);
 		do_count -= cnt;
 		offset = 0;
 	}
@@ -5296,7 +5327,7 @@ static int osst_copy_to_buffer(OSST_buff
 	for (i = 0; i < st_bp->sg_segs && do_count > 0; i++) {
 		cnt = st_bp->sg[i].length < do_count ?
 		      st_bp->sg[i].length : do_count ;
-		memcpy(st_bp->sg[i].address, ptr, cnt);
+		memcpy(SG_ADDRESS(st_bp->sg[i]), ptr, cnt);
 		do_count -= cnt;
 		ptr      += cnt;
 	}
@@ -5317,7 +5348,7 @@ static int osst_copy_from_buffer(OSST_bu
 	for (i = 0; i < st_bp->sg_segs && do_count > 0; i++) {
 		cnt = st_bp->sg[i].length < do_count ?
 		      st_bp->sg[i].length : do_count ;
-		memcpy(ptr, st_bp->sg[i].address, cnt);
+		memcpy(ptr, SG_ADDRESS(st_bp->sg[i]), cnt);
 		do_count -= cnt;
 		ptr      += cnt;
 	}
diff -X dontdiff -urp kern_oldest/drivers/scsi/pci2000.c kern_fix/drivers/scsi/pci2000.c
--- kern_oldest/drivers/scsi/pci2000.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/pci2000.c	2006-05-01 14:14:13.000000000 -0700
@@ -513,7 +513,11 @@ int Pci2000_QueueCommand (Scsi_Cmnd *SCp
 			
 			if ( SCpnt->use_sg )
 				{
+#if SMALL_SCATTERLIST
+				SCpnt->SCp.have_data_in = pci_map_single (padapter->pdev, ((struct scatterlist *)SCpnt->request_buffer)->u.address, 
+#else
 				SCpnt->SCp.have_data_in = pci_map_single (padapter->pdev, ((struct scatterlist *)SCpnt->request_buffer)->address, 
+#endif
 										  SCpnt->request_bufflen, scsi_to_pci_dma_dir (SCpnt->sc_data_direction));
 				}
 			else
@@ -536,7 +540,11 @@ int Pci2000_QueueCommand (Scsi_Cmnd *SCp
 		case SCSIOP_READ_CAPACITY:			  	// read capacity CDB
 			if ( SCpnt->use_sg )
 				{
+#if SMALL_SCATTERLIST
+				SCpnt->SCp.have_data_in = pci_map_single (padapter->pdev, ((struct scatterlist *)(SCpnt->request_buffer))->u.address,
+#else
 				SCpnt->SCp.have_data_in = pci_map_single (padapter->pdev, ((struct scatterlist *)(SCpnt->request_buffer))->address,
+#endif
 										  8, PCI_DMA_FROMDEVICE);
 				}
 			else
diff -X dontdiff -urp kern_oldest/drivers/scsi/pci2220i.c kern_fix/drivers/scsi/pci2220i.c
--- kern_oldest/drivers/scsi/pci2220i.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/pci2220i.c	2006-05-01 14:14:13.000000000 -0700
@@ -463,7 +463,11 @@ static void WalkScatGath (PADAPTER2220I 
 			{
 			if ( padapter->nextSg < padapter->SCpnt->use_sg )
 				{
+#if SMALL_SCATTERLIST
+				padapter->currentSgBuffer = ((struct scatterlist *)padapter->SCpnt->request_buffer)[padapter->nextSg].u.address;
+#else
 				padapter->currentSgBuffer = ((struct scatterlist *)padapter->SCpnt->request_buffer)[padapter->nextSg].address;
+#endif
 				padapter->currentSgCount = ((struct scatterlist *)padapter->SCpnt->request_buffer)[padapter->nextSg].length;
 				padapter->nextSg++;
 				}
@@ -2057,7 +2061,11 @@ int Pci2220i_QueueCommand (Scsi_Cmnd *SC
 
 	if ( SCpnt->use_sg )
 		{
+#if SMALL_SCATTERLIST
+		padapter->currentSgBuffer = ((struct scatterlist *)SCpnt->request_buffer)[0].u.address;
+#else
 		padapter->currentSgBuffer = ((struct scatterlist *)SCpnt->request_buffer)[0].address;
+#endif
 		padapter->currentSgCount = ((struct scatterlist *)SCpnt->request_buffer)[0].length;
 		}
 	else
diff -X dontdiff -urp kern_oldest/drivers/scsi/pcmcia/nsp_cs.c kern_fix/drivers/scsi/pcmcia/nsp_cs.c
--- kern_oldest/drivers/scsi/pcmcia/nsp_cs.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/pcmcia/nsp_cs.c	2006-05-01 14:14:13.000000000 -0700
@@ -201,7 +201,11 @@ static int nsp_queuecommand(Scsi_Cmnd *S
 	   SCp.phase		: current state of the command */
 	if (SCpnt->use_sg) {
 		SCpnt->SCp.buffer	    = (struct scatterlist *) SCpnt->request_buffer;
+#if SMALL_SCATTERLIST
+		SCpnt->SCp.ptr		    = SCpnt->SCp.buffer->u.address;
+#else
 		SCpnt->SCp.ptr		    = SCpnt->SCp.buffer->address;
+#endif
 		SCpnt->SCp.this_residual    = SCpnt->SCp.buffer->length;
 		SCpnt->SCp.buffers_residual = SCpnt->use_sg - 1;
 	} else {
@@ -713,7 +717,11 @@ static void nsp_pio_read(Scsi_Cmnd *SCpn
 			//DEBUG(0, " scatterlist next timeout=%d\n", time_out);
 			SCpnt->SCp.buffers_residual--;
 			SCpnt->SCp.buffer++;
+#if SMALL_SCATTERLIST
+			SCpnt->SCp.ptr		 = SCpnt->SCp.buffer->u.address;
+#else
 			SCpnt->SCp.ptr		 = SCpnt->SCp.buffer->address;
+#endif
 			SCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;
 		}
 
@@ -786,7 +794,11 @@ static void nsp_pio_write(Scsi_Cmnd *SCp
 			//DEBUG(0, " scatterlist next\n");
 			SCpnt->SCp.buffers_residual--;
 			SCpnt->SCp.buffer++;
+#if SMALL_SCATTERLIST
+			SCpnt->SCp.ptr		 = SCpnt->SCp.buffer->u.address;
+#else
 			SCpnt->SCp.ptr		 = SCpnt->SCp.buffer->address;
+#endif
 			SCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;
 		}
 
diff -X dontdiff -urp kern_oldest/drivers/scsi/ppa.c kern_fix/drivers/scsi/ppa.c
--- kern_oldest/drivers/scsi/ppa.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/ppa.c	2006-05-01 14:14:13.000000000 -0700
@@ -740,7 +740,11 @@ static int ppa_completion(Scsi_Cmnd * cm
 	    if (cmd->SCp.buffers_residual--) {
 		cmd->SCp.buffer++;
 		cmd->SCp.this_residual = cmd->SCp.buffer->length;
+#if SMALL_SCATTERLIST
+		cmd->SCp.ptr = cmd->SCp.buffer->u.address;
+#else
 		cmd->SCp.ptr = cmd->SCp.buffer->address;
+#endif
 	    }
 	}
 	/* Now check to see if the drive is ready to comunicate */
@@ -925,7 +929,11 @@ static int ppa_engine(ppa_struct * tmp, 
 	    /* if many buffers are available, start filling the first */
 	    cmd->SCp.buffer = (struct scatterlist *) cmd->request_buffer;
 	    cmd->SCp.this_residual = cmd->SCp.buffer->length;
+#if SMALL_SCATTERLIST
+	    cmd->SCp.ptr = cmd->SCp.buffer->u.address;
+#else
 	    cmd->SCp.ptr = cmd->SCp.buffer->address;
+#endif
 	} else {
 	    /* else fill the only available buffer */
 	    cmd->SCp.buffer = NULL;
diff -X dontdiff -urp kern_oldest/drivers/scsi/qla1280.c kern_fix/drivers/scsi/qla1280.c
--- kern_oldest/drivers/scsi/qla1280.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/qla1280.c	2006-05-01 14:14:13.000000000 -0700
@@ -3985,8 +3985,13 @@ qla1280_64bit_start_scsi(scsi_qla_host_t
                     {
                         DEBUG(sprintf(debug_buff,"SG Segment ap=0x%p, len=0x%x\n\r",sg->address,sg->length));
                         DEBUG(qla1280_print(debug_buff));
+#if SMALL_SCATTERLIST
+                        *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_LOW(sg->u.address));
+                        *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_HIGH(sg->u.address));
+#else
                         *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_LOW(sg->address));
                         *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_HIGH(sg->address));
+#endif
                         *dword_ptr++ = sg->length;
                         sg++;
                     }
@@ -4038,8 +4043,13 @@ qla1280_64bit_start_scsi(scsi_qla_host_t
                         /* Load continuation entry data segments. */
                         for (cnt = 0; cnt < 5 && seg_cnt; cnt++, seg_cnt--)
                         {
+#if SMALL_SCATTERLIST
+                            *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_LOW(sg->u.address));
+                            *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_HIGH(sg->u.address));
+#else
                             *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_LOW(sg->address));
                             *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_HIGH(sg->address));
+#endif
                             *dword_ptr++ = sg->length;
                             sg++;
                         }
@@ -4325,7 +4335,11 @@ qla1280_32bit_start_scsi(scsi_qla_host_t
                     /* Load command entry data segments. */
                     for (cnt = 0; cnt < 4 && seg_cnt; cnt++, seg_cnt--)
                     {
+#if SMALL_SCATTERLIST
+                        *dword_ptr++ = (uint32_t) cpu_to_le32(VIRT_TO_BUS(sg->u.address));
+#else
                         *dword_ptr++ = (uint32_t) cpu_to_le32(VIRT_TO_BUS(sg->address));
+#endif
                         *dword_ptr++ = sg->length;
                         DEBUG(sprintf(debug_buff,"SG Segment ap=0x%p, len=0x%x\n\r",sg->address,sg->length));
                         DEBUG(qla1280_print(debug_buff));
@@ -4368,7 +4382,11 @@ qla1280_32bit_start_scsi(scsi_qla_host_t
                         /* Load continuation entry data segments. */
                         for (cnt = 0; cnt < 7 && seg_cnt; cnt++, seg_cnt--)
                         {
+#if SMALL_SCATTERLIST
+                            *dword_ptr++ = (u_int) cpu_to_le32(VIRT_TO_BUS(sg->u.address));
+#else
                             *dword_ptr++ = (u_int) cpu_to_le32(VIRT_TO_BUS(sg->address));
+#endif
                             *dword_ptr++ = sg->length;
                             sg++;
                         }
diff -X dontdiff -urp kern_oldest/drivers/scsi/qlogicfas.c kern_fix/drivers/scsi/qlogicfas.c
--- kern_oldest/drivers/scsi/qlogicfas.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/qlogicfas.c	2006-05-01 14:14:13.000000000 -0700
@@ -393,7 +393,11 @@ rtrc(2)
 					REG0;
 					return ((qabort == 1 ? DID_ABORT : DID_RESET) << 16);
 				}
+#if SMALL_SCATTERLIST
+				if (ql_pdma(phase, sglist->u.address, sglist->length))
+#else
 				if (ql_pdma(phase, sglist->address, sglist->length))
+#endif
 					break;
 				sglist++;
 			}
diff -X dontdiff -urp kern_oldest/drivers/scsi/scsi_debug.c kern_fix/drivers/scsi/scsi_debug.c
--- kern_oldest/drivers/scsi/scsi_debug.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/scsi_debug.c	2006-05-01 14:14:13.000000000 -0700
@@ -186,7 +186,13 @@ int scsi_debug_queuecommand(Scsi_Cmnd * 
 		struct scatterlist *sgpnt = (struct scatterlist *)
 						SCpnt->request_buffer;
 
+#if SMALL_SCATTERLIST		
+		if (sgpnt[0].ispaged)
+		   BUG();
+		buff = sgpnt[0].u.address;
+#else
 		buff = sgpnt[0].address;
+#endif
 		bufflen = sgpnt[0].length;
 		/* READ and WRITE process scatterlist themselves */
 	}
@@ -672,7 +678,13 @@ static int resp_read(Scsi_Cmnd * SCpnt, 
 	if (SCpnt->use_sg) {
 		sgcount = 0;
 		sgpnt = (struct scatterlist *) buff;
+#if SMALL_SCATTERLIST
+		if (sgpnt[sgcount].ispaged)
+		   BUG();
+		buff = sgpnt[sgcount].u.address;
+#else
 		buff = sgpnt[sgcount].address;
+#endif
 		bufflen = sgpnt[sgcount].length;
 	}
 	do {
@@ -682,7 +694,13 @@ static int resp_read(Scsi_Cmnd * SCpnt, 
 			block += bufflen >> POW2_SECT_SIZE;
 			sgcount++;
 			if (nbytes) {
+#if SMALL_SCATTERLIST
+				if (sgpnt[sgcount].ispaged)
+					BUG();
+				buff = sgpnt[sgcount].u.address;
+#else
 				buff = sgpnt[sgcount].address;
+#endif
 				bufflen = sgpnt[sgcount].length;
 			}
 		} else if (nbytes > 0)
@@ -713,7 +731,13 @@ static int resp_write(Scsi_Cmnd * SCpnt,
 	if (SCpnt->use_sg) {
 		sgcount = 0;
 		sgpnt = (struct scatterlist *) buff;
+#if SMALL_SCATTERLIST
+		if (sgpnt[sgcount].ispaged)
+			BUG();
+		buff = sgpnt[sgcount].u.address;
+#else
 		buff = sgpnt[sgcount].address;
+#endif
 		bufflen = sgpnt[sgcount].length;
 	}
 	do {
@@ -724,7 +748,13 @@ static int resp_write(Scsi_Cmnd * SCpnt,
 			block += bufflen >> POW2_SECT_SIZE;
 			sgcount++;
 			if (nbytes) {
+#if SMALL_SCATTERLIST
+				if (sgpnt[sgcount].ispaged)
+					BUG();
+				buff = sgpnt[sgcount].u.address;
+#else
 				buff = sgpnt[sgcount].address;
+#endif
 				bufflen = sgpnt[sgcount].length;
 			}
 		} else if (nbytes > 0)
diff -X dontdiff -urp kern_oldest/drivers/scsi/scsiiom.c kern_fix/drivers/scsi/scsiiom.c
--- kern_oldest/drivers/scsi/scsiiom.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/scsiiom.c	2006-05-01 14:14:13.000000000 -0700
@@ -379,7 +379,11 @@ dc390_DataOut_0( PACB pACB, PSRB pSRB, P
 		pSRB->pSegmentList++;
 		psgl = pSRB->pSegmentList;
 
+#if SMALL_SCATTERLIST
+		pSRB->SGBusAddr = virt_to_bus( psgl->u.address );
+#else
 		pSRB->SGBusAddr = virt_to_bus( psgl->address );
+#endif
 		pSRB->SGToBeXferLen = (ULONG) psgl->length;
 	    }
 	    else
@@ -443,7 +447,11 @@ dc390_DataIn_0( PACB pACB, PSRB pSRB, PU
 		pSRB->pSegmentList++;
 		psgl = pSRB->pSegmentList;
 
+#if SMALL_SCATTERLIST
+		pSRB->SGBusAddr = virt_to_bus( psgl->u.address );
+#else
 		pSRB->SGBusAddr = virt_to_bus( psgl->address );
+#endif
 		pSRB->SGToBeXferLen = (ULONG) psgl->length;
 	    }
 	    else
@@ -742,7 +750,11 @@ dc390_restore_ptr (PACB pACB, PSRB pSRB)
 	      pSRB->pSegmentList++;
 	      psgl = pSRB->pSegmentList;
 	      
+#if SMALL_SCATTERLIST
+	      pSRB->SGBusAddr = virt_to_bus( psgl->u.address );
+#else
 	      pSRB->SGBusAddr = virt_to_bus( psgl->address );
+#endif
 	      pSRB->SGToBeXferLen = (ULONG) psgl->length;
 	    }
 	  else
@@ -756,10 +768,17 @@ dc390_restore_ptr (PACB pACB, PSRB pSRB)
     {
 	pSRB->SGcount = 1;
 	pSRB->pSegmentList = (PSGL) &pSRB->Segmentx;
+#if SMALL_SCATTERLIST
+	pSRB->Segmentx.u.address = (PUCHAR) pSRB->pcmd->request_buffer + pSRB->Saved_Ptr;
+	pSRB->Segmentx.length = pSRB->pcmd->request_bufflen - pSRB->Saved_Ptr;
+	printk (KERN_INFO "DC390: Pointer restored. Total %li, Bus %p\n",
+		pSRB->Saved_Ptr, pSRB->Segmentx.u.address);
+#else
 	pSRB->Segmentx.address = (PUCHAR) pSRB->pcmd->request_buffer + pSRB->Saved_Ptr;
 	pSRB->Segmentx.length = pSRB->pcmd->request_bufflen - pSRB->Saved_Ptr;
 	printk (KERN_INFO "DC390: Pointer restored. Total %li, Bus %p\n",
 		pSRB->Saved_Ptr, pSRB->Segmentx.address);
+#endif
     }
      else
        {
@@ -893,7 +912,11 @@ dc390_DataIO_Comm( PACB pACB, PSRB pSRB,
 	if( !pSRB->SGToBeXferLen )
 	{
 	    psgl = pSRB->pSegmentList;
+#if SMALL_SCATTERLIST
+	    pSRB->SGBusAddr = virt_to_bus( psgl->u.address );
+#else
 	    pSRB->SGBusAddr = virt_to_bus( psgl->address );
+#endif
 	    pSRB->SGToBeXferLen = (ULONG) psgl->length;
 	    DEBUG1(printk (KERN_DEBUG " DC390: Next SG segment.");)
 	}
@@ -1368,7 +1391,11 @@ dc390_SRBdone( PACB pACB, PDCB pDCB, PSR
     status = pSRB->TargetStatus;
     ptr = (PSCSI_INQDATA) (pcmd->request_buffer);
     if( pcmd->use_sg )
+#if SMALL_SCATTERLIST
+	ptr = (PSCSI_INQDATA) (((PSGL) ptr)->u.address);
+#else
 	ptr = (PSCSI_INQDATA) (((PSGL) ptr)->address);
+#endif
 	
     DEBUG0(printk (" SRBdone (%02x,%08x), SRB %p, pid %li\n", status, pcmd->result,\
 		pSRB, pcmd->pid);)
@@ -1443,7 +1470,11 @@ dc390_SRBdone( PACB pACB, PDCB pDCB, PSR
 	    else if( pcmd->request_buffer )
 	    {
 		pSRB->pSegmentList = (PSGL) &pSRB->Segmentx;
+#if SMALL_SCATTERLIST
+		pSRB->Segmentx.u.address = (PUCHAR) pcmd->request_buffer;
+#else
 		pSRB->Segmentx.address = (PUCHAR) pcmd->request_buffer;
+#endif
 		pSRB->Segmentx.length = pcmd->request_bufflen;
 	    }
 	    if( dc390_StartSCSI( pACB, pDCB, pSRB ) ) {
@@ -1518,7 +1549,11 @@ dc390_SRBdone( PACB pACB, PDCB pDCB, PSR
 		else if( pcmd->request_buffer )
 		{
 		    pSRB->pSegmentList = (PSGL) &pSRB->Segmentx;
+#if SMALL_SCATTERLIST
+		    pSRB->Segmentx.u.address = (PUCHAR) pcmd->request_buffer;
+#else
 		    pSRB->Segmentx.address = (PUCHAR) pcmd->request_buffer;
+#endif
 		    pSRB->Segmentx.length = pcmd->request_bufflen;
 		}
 		if( dc390_StartSCSI( pACB, pDCB, pSRB ) ) {
@@ -1759,7 +1794,11 @@ dc390_RequestSense( PACB pACB, PDCB pDCB
 
     pcmd = pSRB->pcmd;
 
+#if SMALL_SCATTERLIST
+    pSRB->Segmentx.u.address = (PUCHAR) &(pcmd->sense_buffer);
+#else
     pSRB->Segmentx.address = (PUCHAR) &(pcmd->sense_buffer);
+#endif
     pSRB->Segmentx.length = sizeof(pcmd->sense_buffer);
     pSRB->pSegmentList = &pSRB->Segmentx;
     pSRB->SGcount = 1;
diff -X dontdiff -urp kern_oldest/drivers/scsi/scsi_lib.c kern_fix/drivers/scsi/scsi_lib.c
--- kern_oldest/drivers/scsi/scsi_lib.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/scsi_lib.c	2006-05-01 14:14:13.000000000 -0700
@@ -553,7 +553,13 @@ static void scsi_release_buffers(Scsi_Cm
 		if (bbpnt) {
 			for (i = 0; i < SCpnt->use_sg; i++) {
 				if (bbpnt[i])
+#if SMALL_SCATTERLIST
+					if (sgpnt[i].ispaged)
+						BUG();
+					scsi_free(sgpnt[i].u.address, sgpnt[i].length);
+#else
 					scsi_free(sgpnt[i].address, sgpnt[i].length);
+#endif
 			}
 		}
 		scsi_free(SCpnt->request_buffer, SCpnt->sglist_len);
@@ -629,12 +635,23 @@ void scsi_io_completion(Scsi_Cmnd * SCpn
 		if (bbpnt) {
 			for (i = 0; i < SCpnt->use_sg; i++) {
 				if (bbpnt[i]) {
+#if SMALL_SCATTERLIST
+					if (sgpnt[i].ispaged)
+						BUG();
+					if (req->cmd == READ) {
+						memcpy(bbpnt[i],
+						       sgpnt[i].u.address,
+						       sgpnt[i].length);
+					}
+					scsi_free(sgpnt[i].u.address, sgpnt[i].length);
+#else
 					if (req->cmd == READ) {
 						memcpy(bbpnt[i],
 						       sgpnt[i].address,
 						       sgpnt[i].length);
 					}
 					scsi_free(sgpnt[i].address, sgpnt[i].length);
+#endif
 				}
 			}
 		}
diff -X dontdiff -urp kern_oldest/drivers/scsi/scsi_merge.c kern_fix/drivers/scsi/scsi_merge.c
--- kern_oldest/drivers/scsi/scsi_merge.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/scsi_merge.c	2006-05-01 14:14:13.000000000 -0700
@@ -144,11 +144,21 @@ static void dma_exhausted(Scsi_Cmnd * SC
 	 */
 	for(jj=0; jj < SCpnt->use_sg; jj++)
 	{
+#if SMALL_SCATTERLIST
+		if (sgpnt[jj].ispaged)
+			BUG();
+		printk("[%d]\tlen:%d\taddr:%p\tbounce:%p\n",
+		       jj,
+		       sgpnt[jj].length,
+		       sgpnt[jj].u.address,
+		       (bbpnt ? bbpnt[jj] : NULL));
+#else
 		printk("[%d]\tlen:%d\taddr:%p\tbounce:%p\n",
 		       jj,
 		       sgpnt[jj].length,
 		       sgpnt[jj].address,
 		       (bbpnt ? bbpnt[jj] : NULL));
+#endif
 		if (bbpnt && bbpnt[jj])
 			consumed += sgpnt[jj].length;
 	}
@@ -612,6 +622,9 @@ __inline static int __scsi_merge_request
 		max_segments = scsi_max_sg;
 
 #ifdef DMA_CHUNK_SIZE
+# if SMALL_SCATTERLIST
+#  error "This defeats the purpose of SMALL_SCATTERLIST"
+# endif
 	if (max_segments > 64)
 		max_segments = 64;
 
@@ -929,15 +942,26 @@ __inline static int __init_io(Scsi_Cmnd 
 		}
 
 		if (SCpnt->host->highmem_io) {
+#if SMALL_SCATTERLIST
+			sgpnt[count].ispaged = 1;
+			sgpnt[count].u.page.page = bh->b_page;
+			sgpnt[count].u.page.offset = bh_offset(bh);
+#else
 			sgpnt[count].page = bh->b_page;
 			sgpnt[count].offset = bh_offset(bh);
 			sgpnt[count].address = NULL;
+#endif
 		} else {
 			if (PageHighMem(bh->b_page))
 				BUG();
 
+#if SMALL_SCATTERLIST
+			sgpnt[count].ispaged = 0;
+			sgpnt[count].u.address = bh->b_data;
+#else
 			sgpnt[count].page = NULL;
 			sgpnt[count].address = bh->b_data;
+#endif
 		}
 		
 		sgpnt[count].length = bh->b_size;
@@ -972,6 +996,50 @@ __inline static int __init_io(Scsi_Cmnd 
 		 * only done for dma_host, in which case .page is not
 		 * set since it's guarenteed to be a low memory page
 		 */
+#if SMALL_SCATTERLIST
+		if (sgpnt[i].ispaged)
+			BUG();
+		if (virt_to_phys(sgpnt[i].u.address) + sgpnt[i].length - 1 >
+		    ISA_DMA_THRESHOLD) {
+			if( scsi_dma_free_sectors - sectors <= 10  ) {
+				/*
+				 * If this would nearly drain the DMA
+				 * pool empty, then let's stop here.
+				 * Don't make this request any larger.
+				 * This is kind of a safety valve that
+				 * we use - we could get screwed later
+				 * on if we run out completely.  
+				 */
+				SCpnt->request_bufflen -= sgpnt[i].length;
+				SCpnt->use_sg = i;
+				if (i == 0) {
+					goto big_trouble;
+				}
+				break;
+			}
+
+			bbpnt[i] = sgpnt[i].u.address;
+			sgpnt[i].u.address =
+			    (char *) scsi_malloc(sgpnt[i].length);
+			/*
+			 * If we cannot allocate memory for this DMA bounce
+			 * buffer, then queue just what we have done so far.
+			 */
+			if (sgpnt[i].u.address == NULL) {
+				printk("Warning - running low on DMA memory\n");
+				SCpnt->request_bufflen -= sgpnt[i].length;
+				SCpnt->use_sg = i;
+				if (i == 0) {
+					goto big_trouble;
+				}
+				break;
+			}
+			if (req->cmd == WRITE) {
+				memcpy(sgpnt[i].u.address, bbpnt[i],
+				       sgpnt[i].length);
+			}
+		}
+#else
 		if (virt_to_phys(sgpnt[i].address) + sgpnt[i].length - 1 >
 		    ISA_DMA_THRESHOLD) {
 			if( scsi_dma_free_sectors - sectors <= 10  ) {
@@ -1012,6 +1080,7 @@ __inline static int __init_io(Scsi_Cmnd 
 				       sgpnt[i].length);
 			}
 		}
+#endif
 	}
 	return 1;
 
diff -X dontdiff -urp kern_oldest/drivers/scsi/seagate.c kern_fix/drivers/scsi/seagate.c
--- kern_oldest/drivers/scsi/seagate.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/seagate.c	2006-05-01 14:14:13.000000000 -0700
@@ -1070,7 +1070,11 @@ static int internal_command (unsigned ch
 
 			buffer = (struct scatterlist *) SCint->buffer;
 			len = buffer->length;
+#if SMALL_SCATTERLIST
+			data = (unsigned char *) buffer->u.address;
+#else
 			data = (unsigned char *) buffer->address;
+#endif
 		} else {
 			DPRINTK (DEBUG_SG,
 				 "scsi%d : scatter gather not requested.\n",
@@ -1337,7 +1341,11 @@ static int internal_command (unsigned ch
 					++buffer;
 					len = buffer->length;
 					data =
-					    (unsigned char *) buffer->address;
+#if SMALL_SCATTERLIST
+					    (unsigned char *)buffer->u.address;
+#else
+					    (unsigned char *)buffer->address;
+#endif
 					DPRINTK (DEBUG_SG,
 						 "scsi%d : next scatter-gather buffer len = %d address = %08x\n",
 						 hostno, len, data);
@@ -1521,7 +1529,11 @@ static int internal_command (unsigned ch
 					++buffer;
 					len = buffer->length;
 					data =
+#if SMALL_SCATTERLIST
+					    (unsigned char *)buffer->u.address;
+#else
 					    (unsigned char *) buffer->address;
+#endif
 					DPRINTK (DEBUG_SG,
 						 "scsi%d : next scatter-gather buffer len = %d address = %08x\n",
 						 hostno, len, data);
diff -X dontdiff -urp kern_oldest/drivers/scsi/sg.c kern_fix/drivers/scsi/sg.c
--- kern_oldest/drivers/scsi/sg.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/sg.c	2006-05-01 14:14:13.000000000 -0700
@@ -1077,7 +1077,11 @@ static void sg_rb_correct4mmap(Sg_scatte
 
         for (k = 0; k < rsv_schp->k_use_sg; ++k, ++sclp) {
 	    for (m = PAGE_SIZE; m < sclp->length; m += PAGE_SIZE) {
+#if SMALL_SCATTERLIST
+		page_ptr = (unsigned char *)sclp->u.address + m;
+#else
 		page_ptr = (unsigned char *)sclp->address + m;
+#endif
 		page = virt_to_page(page_ptr);
 		if (startFinish)
 		    get_page(page);	/* increment page count */
@@ -1130,7 +1134,11 @@ static struct page * sg_vma_nopage(struc
             len = vma->vm_end - sa;
             len = (len < sclp->length) ? len : sclp->length;
 	    if (offset < len) {
+#if SMALL_SCATTERLIST
+		page_ptr = (unsigned char *)sclp->u.address + offset;
+#else
 		page_ptr = (unsigned char *)sclp->address + offset;
+#endif
 		page = virt_to_page(page_ptr);
 		get_page(page);	/* increment page count */
 		break;
@@ -1175,8 +1183,13 @@ static int sg_mmap(struct file * filp, s
 
 	for (k = 0; (k < rsv_schp->k_use_sg) && (sa < vma->vm_end); 
 	     ++k, ++sclp) {
+#if SMALL_SCATTERLIST
+	    if ((unsigned long)sclp->u.address & (PAGE_SIZE - 1))
+	    	return -EFAULT;     /* non page aligned memory ?? */
+#else
 	    if ((unsigned long)sclp->address & (PAGE_SIZE - 1))
 	    	return -EFAULT;     /* non page aligned memory ?? */
+#endif
 	    len = vma->vm_end - sa;
 	    len = (len < sclp->length) ? len : sclp->length;
 	    sa += len;
@@ -1725,16 +1738,27 @@ static int sg_build_dir(Sg_request * srp
 	offset = (0 == k) ? kp->offset : 0;
 	num = (rem_sz > (PAGE_SIZE - offset)) ? (PAGE_SIZE - offset) :
 						rem_sz;
+#if SMALL_SCATTERLIST
+	sclp->u.address = page_address(kp->maplist[k]) + offset;
+	sclp->ispaged = 0;
+#else
 	sclp->address = page_address(kp->maplist[k]) + offset;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,13)
 	sclp->page = NULL;
 #endif
+#endif
 	sclp->length = num;
 	mem_src_arr[k] = SG_USER_MEM;
 	rem_sz -= num;
+#if SMALL_SCATTERLIST
+	SCSI_LOG_TIMEOUT(5,
+	    printk("sg_build_dir: k=%d, a=0x%p, len=%d, ms=%d\n",
+	    k, sclp->u.address, num, mem_src_arr[k]));
+#else
 	SCSI_LOG_TIMEOUT(5,
 	    printk("sg_build_dir: k=%d, a=0x%p, len=%d, ms=%d\n",
 	    k, sclp->address, num, mem_src_arr[k]));
+#endif
     }
     schp->k_use_sg = k;
     SCSI_LOG_TIMEOUT(5,
@@ -1814,16 +1838,27 @@ static int sg_build_indi(Sg_scatter_hold
                 if (! p)
                     break;
             }
+#if SMALL_SCATTERLIST
+            sclp->u.address = p;
+	    sclp->ispaged = 0;
+#else
             sclp->address = p;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,13)
 	    sclp->page = NULL;
 #endif
+#endif
             sclp->length = ret_sz;
 	    mem_src_arr[k] = mem_src;
 
+#if SMALL_SCATTERLIST
+	    SCSI_LOG_TIMEOUT(5,
+		printk("sg_build_build: k=%d, a=0x%p, len=%d, ms=%d\n",
+                k, sclp->u.address, ret_sz, mem_src));
+#else
 	    SCSI_LOG_TIMEOUT(5,
 		printk("sg_build_build: k=%d, a=0x%p, len=%d, ms=%d\n",
                 k, sclp->address, ret_sz, mem_src));
+#endif
         } /* end of for loop */
 	schp->k_use_sg = k;
 	SCSI_LOG_TIMEOUT(5,
@@ -1888,13 +1923,21 @@ static int sg_write_xfer(Sg_request * sr
 	struct scatterlist * sclp = (struct scatterlist *)schp->buffer;
 	char * mem_src_arr = sg_get_sgat_msa(schp);
 	ksglen = (int)sclp->length;
+#if SMALL_SCATTERLIST
+	p = sclp->u.address;
+#else
 	p = sclp->address;
+#endif
 
 	for (j = 0, k = 0; j < onum; ++j) {
 	    res = sg_u_iovec(hp, iovec_count, j, 1, &usglen, &up);
 	    if (res) return res;
 
+#if SMALL_SCATTERLIST
+	    for ( ; p; ++sclp, ksglen = (int)sclp->length, p = sclp->u.address) {
+#else
 	    for ( ; p; ++sclp, ksglen = (int)sclp->length, p = sclp->address) {
+#endif
 		ok = (SG_USER_MEM != mem_src_arr[k]);
 		if (usglen <= 0)
 		    break;
@@ -1971,6 +2014,18 @@ static void sg_remove_scat(Sg_scatter_ho
         struct scatterlist * sclp = (struct scatterlist *)schp->buffer;
 	char * mem_src_arr = sg_get_sgat_msa(schp);
 
+#if SMALL_SCATTERLIST
+	for (k = 0; (k < schp->k_use_sg) && sclp->u.address; ++k, ++sclp) {
+	    mem_src = mem_src_arr[k];
+	    SCSI_LOG_TIMEOUT(5,
+		printk("sg_remove_scat: k=%d, a=0x%p, len=%d, ms=%d\n",
+                       k, sclp->u.address, sclp->length, mem_src));
+            sg_free(sclp->u.address, sclp->length, mem_src);
+            sclp->u.address = NULL;
+	    sclp->ispaged = 0;
+            sclp->length = 0;
+        }
+#else
 	for (k = 0; (k < schp->k_use_sg) && sclp->address; ++k, ++sclp) {
 	    mem_src = mem_src_arr[k];
 	    SCSI_LOG_TIMEOUT(5,
@@ -1983,6 +2038,7 @@ static void sg_remove_scat(Sg_scatter_ho
 #endif
             sclp->length = 0;
         }
+#endif
 	sg_free(schp->buffer, schp->sglist_len, schp->buffer_mem_src);
     }
     else if (schp->buffer)
@@ -2043,13 +2099,21 @@ static int sg_read_xfer(Sg_request * srp
 	struct scatterlist * sclp = (struct scatterlist *)schp->buffer;
 	char * mem_src_arr = sg_get_sgat_msa(schp);
 	ksglen = (int)sclp->length;
+#if SMALL_SCATTERLIST
+	p = sclp->u.address;
+#else
 	p = sclp->address;
+#endif
 
 	for (j = 0, k = 0; j < onum; ++j) {
 	    res = sg_u_iovec(hp, iovec_count, j, 0, &usglen, &up);
 	    if (res) return res;
 
+#if SMALL_SCATTERLIST
+	    for ( ; p; ++sclp, ksglen = (int)sclp->length, p = sclp->u.address) {
+#else
 	    for ( ; p; ++sclp, ksglen = (int)sclp->length, p = sclp->address) {
+#endif
 		ok = (SG_USER_MEM != mem_src_arr[k]);
 		if (usglen <= 0)
 		    break;
@@ -2093,14 +2157,26 @@ static void sg_read_oxfer(Sg_request * s
         int k, num;
         struct scatterlist * sclp = (struct scatterlist *)schp->buffer;
 
+#if SMALL_SCATTERLIST
+	for (k = 0; (k < schp->k_use_sg) && sclp->u.address; ++k, ++sclp) {
+#else
 	for (k = 0; (k < schp->k_use_sg) && sclp->address; ++k, ++sclp) {
+#endif
             num = (int)sclp->length;
             if (num > num_read_xfer) {
+#if SMALL_SCATTERLIST
+                __copy_to_user(outp, sclp->u.address, num_read_xfer);
+#else
                 __copy_to_user(outp, sclp->address, num_read_xfer);
+#endif
                 break;
             }
             else {
+#if SMALL_SCATTERLIST
+                __copy_to_user(outp, sclp->u.address, num);
+#else
                 __copy_to_user(outp, sclp->address, num);
+#endif
                 num_read_xfer -= num;
                 if (num_read_xfer <= 0)
                     break;
@@ -2146,7 +2222,11 @@ static void sg_link_reserve(Sg_fd * sfp,
             if (rem <= num) {
 		if (0 == k) {
 		    req_schp->k_use_sg = 0;
+#if SMALL_SCATTERLIST
+		    req_schp->buffer = sclp->u.address;
+#else
 		    req_schp->buffer = sclp->address;
+#endif
 		}
 		else {
     		    sfp->save_scat_len = num;
diff -X dontdiff -urp kern_oldest/drivers/scsi/sim710.c kern_fix/drivers/scsi/sim710.c
--- kern_oldest/drivers/scsi/sim710.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/sim710.c	2006-05-01 14:14:13.000000000 -0700
@@ -1164,7 +1164,11 @@ run_command (struct sim710_hostdata *hos
 
     for (i = 0; cmd->use_sg ? (i < cmd->use_sg) : !i; i++) {
 	u32 vbuf = cmd->use_sg ?
+#if SMALL_SCATTERLIST
+		(u32)(((struct scatterlist *)cmd->buffer)[i].u.address) :
+#else
 		(u32)(((struct scatterlist *)cmd->buffer)[i].address) :
+#endif
 		(u32)(cmd->request_buffer);
 	u32 bbuf = virt_to_bus((void *)vbuf);
 	u32 cnt = cmd->use_sg ?
diff -X dontdiff -urp kern_oldest/drivers/scsi/sr.c kern_fix/drivers/scsi/sr.c
--- kern_oldest/drivers/scsi/sr.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/sr.c	2006-05-01 14:14:13.000000000 -0700
@@ -343,7 +343,12 @@ static int sr_scatter_pad(Scsi_Cmnd *SCp
 
 	i = 0;
 	if (fsize) {
+#if SMALL_SCATTERLIST
+		sg[0].ispaged = 0;
+		sg[0].u.address = bbpnt[0] = front;
+#else
 		sg[0].address = bbpnt[0] = front;
+#endif
 		sg[0].length = fsize;
 		i++;
 	}
@@ -354,7 +359,12 @@ static int sr_scatter_pad(Scsi_Cmnd *SCp
 		scsi_free(old_sg, (((SCpnt->use_sg * sizeof(struct scatterlist)) +
 				    (SCpnt->use_sg * sizeof(void *))) + 511) & ~511);
 	} else {
+#if SMALL_SCATTERLIST
+		sg[i].ispaged = 0;
+		sg[i].u.address = SCpnt->request_buffer;
+#else
 		sg[i].address = SCpnt->request_buffer;
+#endif
 		sg[i].length = SCpnt->request_bufflen;
 	}
 
@@ -364,7 +374,12 @@ static int sr_scatter_pad(Scsi_Cmnd *SCp
 	SCpnt->use_sg += i;
 
 	if (bsize) {
+#if SMALL_SCATTERLIST
+		sg[SCpnt->use_sg].ispaged = 0;
+		sg[SCpnt->use_sg].u.address = back;
+#else
 		sg[SCpnt->use_sg].address = back;
+#endif
 		bbpnt[SCpnt->use_sg] = back;
 		sg[SCpnt->use_sg].length = bsize;
 		SCpnt->use_sg++;
diff -X dontdiff -urp kern_oldest/drivers/scsi/st.c kern_fix/drivers/scsi/st.c
--- kern_oldest/drivers/scsi/st.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/st.c	2006-05-01 14:14:13.000000000 -0700
@@ -3410,6 +3410,12 @@ static int st_ioctl(struct inode *inode,
 }
 
 
+#if SMALL_SCATTERLIST
+#define SG_ADDRESS(sg) ((sg).u.address)
+#else
+#define SG_ADDRESS(sg) ((sg).address)
+#endif
+
 /* Try to allocate a new tape buffer. Calling function must not hold
    dev_arr_lock. */
 static ST_buffer *
@@ -3447,18 +3453,23 @@ static ST_buffer *
 		     order++, b_size *= 2)
 			;
 		for ( ; b_size >= PAGE_SIZE; order--, b_size /= 2) {
-			tb->sg[0].address =
+			SG_ADDRESS(tb->sg[0]) =
 			    (unsigned char *) __get_free_pages(priority, order);
-			if (tb->sg[0].address != NULL) {
+			if (SG_ADDRESS(tb->sg[0]) != NULL) {
 				tb->sg_lengths[0] = b_size;
 				break;
 			}
 		}
+#if SMALL_SCATTERLIST
+		tb->sg[0].ispaged = 0;
+#else
 		tb->sg[0].page = NULL;
-		if (tb->sg[segs].address == NULL) {
+#endif
+		if (SG_ADDRESS(tb->sg[segs]) == NULL) {
 			kfree(tb);
 			tb = NULL;
-		} else {	/* Got something, continue */
+		}
+		else {	/* Got something, continue */
 
 			for (b_size = PAGE_SIZE, order=0;
 			     st_buffer_size >
@@ -3467,10 +3478,10 @@ static ST_buffer *
 				;
 			for (segs = 1, got = tb->sg_lengths[0];
 			     got < st_buffer_size && segs < ST_FIRST_SG;) {
-				tb->sg[segs].address =
+				SG_ADDRESS(tb->sg[segs]) =
 					(unsigned char *) __get_free_pages(priority,
 									   order);
-				if (tb->sg[segs].address == NULL) {
+				if (SG_ADDRESS(tb->sg[segs]) == NULL) {
 					if (st_buffer_size - got <=
 					    (ST_FIRST_SG - segs) * b_size / 2) {
 						b_size /= 2; /* Large enough for the
@@ -3486,7 +3497,11 @@ static ST_buffer *
 					tb = NULL;
 					break;
 				}
+#if SMALL_SCATTERLIST
+				tb->sg[segs].ispaged = 0;
+#else
 				tb->sg[segs].page = NULL;
+#endif
 				tb->sg_lengths[segs] = b_size;
 				got += b_size;
 				segs++;
@@ -3500,7 +3515,7 @@ static ST_buffer *
 		return NULL;
 	}
 	tb->sg_segs = tb->orig_sg_segs = segs;
-	tb->b_data = tb->sg[0].address;
+	tb->b_data = SG_ADDRESS(tb->sg[0]);
 
         DEBC(printk(ST_DEB_MSG
                     "st: Allocated tape buffer %d (%d bytes, %d segments, dma: %d, a: %p).\n",
@@ -3546,9 +3561,9 @@ static int enlarge_buffer(ST_buffer * ST
 
 	for (segs = STbuffer->sg_segs, got = STbuffer->buffer_size;
 	     segs < max_segs && got < new_size;) {
-		STbuffer->sg[segs].address =
+		SG_ADDRESS(STbuffer->sg[segs]) =
 			(unsigned char *) __get_free_pages(priority, order);
-		if (STbuffer->sg[segs].address == NULL) {
+		if (SG_ADDRESS(STbuffer->sg[segs]) == NULL) {
 			if (new_size - got <= (max_segs - segs) * b_size / 2) {
 				b_size /= 2; /* Large enough for the rest of the buffers */
 				order--;
@@ -3560,7 +3575,11 @@ static int enlarge_buffer(ST_buffer * ST
 			normalize_buffer(STbuffer);
 			return FALSE;
 		}
+#if SMALL_SCATTERLIST
+		STbuffer->sg[segs].ispaged = 0;
+#else
 		STbuffer->sg[segs].page = NULL;
+#endif
 		STbuffer->sg_lengths[segs] = b_size;
 		STbuffer->sg_segs += 1;
 		got += b_size;
@@ -3584,13 +3603,13 @@ static void normalize_buffer(ST_buffer *
 		for (b_size=PAGE_SIZE, order=0; b_size < STbuffer->sg_lengths[i];
 		     order++, b_size *= 2)
 			; /* empty */
-		free_pages((unsigned long)(STbuffer->sg[i].address), order);
+		free_pages((unsigned long)(SG_ADDRESS(STbuffer->sg[i])), order);
 		STbuffer->buffer_size -= STbuffer->sg_lengths[i];
 	}
         DEB(
 	if (debugging && STbuffer->orig_sg_segs < STbuffer->sg_segs)
 		printk(ST_DEB_MSG "st: Buffer at %p normalized to %d bytes (segs %d).\n",
-		       STbuffer->sg[0].address, STbuffer->buffer_size,
+		       SG_ADDRESS(STbuffer->sg[0]), STbuffer->buffer_size,
 		       STbuffer->sg_segs);
         ) /* end DEB */
 	STbuffer->sg_segs = STbuffer->orig_sg_segs;
@@ -3613,7 +3632,7 @@ static int append_to_buffer(const char *
 	for (; i < st_bp->sg_segs && do_count > 0; i++) {
 		cnt = st_bp->sg_lengths[i] - offset < do_count ?
 		    st_bp->sg_lengths[i] - offset : do_count;
-		res = copy_from_user(st_bp->sg[i].address + offset, ubp, cnt);
+		res = copy_from_user(SG_ADDRESS(st_bp->sg[i]) + offset, ubp, cnt);
 		if (res)
 			return (-EFAULT);
 		do_count -= cnt;
@@ -3646,7 +3665,7 @@ static int from_buffer(ST_buffer * st_bp
 	for (; i < st_bp->sg_segs && do_count > 0; i++) {
 		cnt = st_bp->sg_lengths[i] - offset < do_count ?
 		    st_bp->sg_lengths[i] - offset : do_count;
-		res = copy_to_user(ubp, st_bp->sg[i].address + offset, cnt);
+		res = copy_to_user(ubp, SG_ADDRESS(st_bp->sg[i]) + offset, cnt);
 		if (res)
 			return (-EFAULT);
 		do_count -= cnt;
@@ -3689,8 +3708,8 @@ static void move_buffer_data(ST_buffer *
 	for (dst_seg=dst_offset=0; total > 0; ) {
 		count = min(st_bp->sg_lengths[dst_seg] - dst_offset,
 			    st_bp->sg_lengths[src_seg] - src_offset);
-		memmove(st_bp->sg[dst_seg].address + dst_offset,
-			st_bp->sg[src_seg].address + src_offset, count);
+		memmove(SG_ADDRESS(st_bp->sg[dst_seg]) + dst_offset,
+			SG_ADDRESS(st_bp->sg[src_seg]) + src_offset, count);
 		printk("st: move (%d,%d) -> (%d,%d) count %d\n",
 		       src_seg, src_offset, dst_seg, dst_offset, count);
 		src_offset += count;
diff -X dontdiff -urp kern_oldest/drivers/scsi/sym53c416.c kern_fix/drivers/scsi/sym53c416.c
--- kern_oldest/drivers/scsi/sym53c416.c	2006-05-01 11:55:41.000000000 -0700
+++ kern_fix/drivers/scsi/sym53c416.c	2006-05-01 14:14:13.000000000 -0700
@@ -448,7 +448,11 @@ static void sym53c416_intr_handle(int ir
 					sglist = current_command->request_buffer;
 					while(sgcount--)
 					{
+#if SMALL_SCATTERLIST
+						tot_trans += sym53c416_write(base, sglist->u.address, sglist->length);
+#else
 						tot_trans += sym53c416_write(base, sglist->address, sglist->length);
+#endif
 						sglist++;
 					}
 				}
@@ -474,7 +478,11 @@ static void sym53c416_intr_handle(int ir
 					sglist = current_command->request_buffer;
 					while(sgcount--)
 					{
+#if SMALL_SCATTERLIST
+						tot_trans += sym53c416_read(base, sglist->u.address, sglist->length);
+#else
 						tot_trans += sym53c416_read(base, sglist->address, sglist->length);
+#endif
 						sglist++;
 					}
 				}
diff -X dontdiff -urp kern_oldest/drivers/scsi/tmscsim.c kern_fix/drivers/scsi/tmscsim.c
--- kern_oldest/drivers/scsi/tmscsim.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/tmscsim.c	2006-05-01 14:14:13.000000000 -0700
@@ -1146,7 +1146,11 @@ static void dc390_BuildSRB (Scsi_Cmnd* p
     {
 	pSRB->SGcount = 1;
 	pSRB->pSegmentList = (PSGL) &pSRB->Segmentx;
+#if SMALL_SCATTERLIST
+	pSRB->Segmentx.u.address = (PUCHAR) pcmd->request_buffer;
+#else
 	pSRB->Segmentx.address = (PUCHAR) pcmd->request_buffer;
+#endif
 	pSRB->Segmentx.length = pcmd->request_bufflen;
     }
     else
diff -X dontdiff -urp kern_oldest/drivers/scsi/ultrastor.c kern_fix/drivers/scsi/ultrastor.c
--- kern_oldest/drivers/scsi/ultrastor.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/ultrastor.c	2006-05-01 14:14:13.000000000 -0700
@@ -666,7 +666,11 @@ static inline void build_sg_list(registe
 	sl = (struct scatterlist *) SCpnt->request_buffer;
 	max = SCpnt->use_sg;
 	for (i = 0; i < max; i++) {
+#if SMALL_SCATTERLIST
+		mscp->sglist[i].address = virt_to_bus(sl[i].u.address);
+#else
 		mscp->sglist[i].address = virt_to_bus(sl[i].address);
+#endif
 		mscp->sglist[i].num_bytes = sl[i].length;
 		transfer_length += sl[i].length;
 	}
diff -X dontdiff -urp kern_oldest/drivers/scsi/wd7000.c kern_fix/drivers/scsi/wd7000.c
--- kern_oldest/drivers/scsi/wd7000.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/drivers/scsi/wd7000.c	2006-05-01 14:14:13.000000000 -0700
@@ -1189,7 +1189,11 @@ int wd7000_queuecommand (Scsi_Cmnd *SCpn
 	any2scsi (scb->maxlen, SCpnt->use_sg * sizeof (Sgb));
 
 	for (i = 0; i < SCpnt->use_sg; i++) {
+#if SMALL_SCATTERLIST
+	    any2scsi (sgb[i].ptr, (int) sg[i].u.address);
+#else
 	    any2scsi (sgb[i].ptr, (int) sg[i].address);
+#endif
 	    any2scsi (sgb[i].len, sg[i].length);
 	}
     }
diff -X dontdiff -urp kern_oldest/drivers/usb/hpusbscsi.c kern_fix/drivers/usb/hpusbscsi.c
--- kern_oldest/drivers/usb/hpusbscsi.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/hpusbscsi.c	2006-05-01 14:14:13.000000000 -0700
@@ -576,6 +576,17 @@ static void scatter_gather_callback(stru
 		hpusbscsi->state = HP_STATE_WORKING;
 	PDEBUG(2, "state= %s", states[hpusbscsi->state]);
 
+#if SMALL_SCATTERLIST
+        FILL_BULK_URB(
+                u,
+                hpusbscsi->dev,
+                hpusbscsi->current_data_pipe,
+                sg[hpusbscsi->fragment].u.address,
+                sg[hpusbscsi->fragment++].length,
+                callback,
+                hpusbscsi
+        );
+#else
         FILL_BULK_URB(
                 u,
                 hpusbscsi->dev,
@@ -585,6 +596,7 @@ static void scatter_gather_callback(stru
                 callback,
                 hpusbscsi
         );
+#endif
 
         res = usb_submit_urb(u);
         if (res)
diff -X dontdiff -urp kern_oldest/drivers/usb/microtek.c kern_fix/drivers/usb/microtek.c
--- kern_oldest/drivers/usb/microtek.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/microtek.c	2006-05-01 14:14:13.000000000 -0700
@@ -623,7 +623,11 @@ static void mts_do_sg (struct urb* trans
 	context->fragment++;
 	mts_int_submit_urb(transfer,
 			context->data_pipe,
+#if SMALL_SCATTERLIST
+			sg[context->fragment].u.address,
+#else
 			sg[context->fragment].address,
+#endif
 			sg[context->fragment].length,
 			context->fragment + 1 == context->srb->use_sg ? mts_data_done : mts_do_sg);
 	return;
@@ -667,7 +671,11 @@ mts_build_transfer_context( Scsi_Cmnd *s
 	} else {
 		MTS_DEBUG("Using scatter/gather\n");
 		sg = srb->buffer;
+#if SMALL_SCATTERLIST
+		desc->context.data = sg[0].u.address;
+#else
 		desc->context.data = sg[0].address;
+#endif
 		desc->context.data_length = sg[0].length;
 	}
 
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/datafab.c kern_fix/drivers/usb/storage/datafab.c
--- kern_oldest/drivers/usb/storage/datafab.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/datafab.c	2006-05-01 14:14:13.000000000 -0700
@@ -265,18 +265,30 @@ static int datafab_read_data(struct us_d
 			while (sg_idx < use_sg && transferred < len) {
 				if (len - transferred >= sg[sg_idx].length - current_sg_offset) {
 					US_DEBUGP("datafab_read_data:  adding %d bytes to %d byte sg buffer\n", sg[sg_idx].length - current_sg_offset, sg[sg_idx].length);
+#if SMALL_SCATTERLIST
+					memcpy(sg[sg_idx].u.address + current_sg_offset,
+					       buffer + transferred,
+					       sg[sg_idx].length - current_sg_offset);
+#else
 					memcpy(sg[sg_idx].address + current_sg_offset,
 					       buffer + transferred,
 					       sg[sg_idx].length - current_sg_offset);
+#endif
 					transferred += sg[sg_idx].length - current_sg_offset;
 					current_sg_offset = 0;
 					// on to the next sg buffer
 					++sg_idx;
 				} else {
 					US_DEBUGP("datafab_read_data:  adding %d bytes to %d byte sg buffer\n", len - transferred, sg[sg_idx].length);
+#if SMALL_SCATTERLIST
+					memcpy(sg[sg_idx].u.address + current_sg_offset,
+					       buffer + transferred,
+					       len - transferred);
+#else
 					memcpy(sg[sg_idx].address + current_sg_offset,
 					       buffer + transferred,
 					       len - transferred);
+#endif
 					current_sg_offset += len - transferred;
 					// this sg buffer is only partially full and we're out of data to copy in
 					break;
@@ -355,18 +367,30 @@ static int datafab_write_data(struct us_
 			while (transferred < len) {
 				if (len - transferred >= sg[sg_idx].length - current_sg_offset) {
 					US_DEBUGP("datafab_write_data:  getting %d bytes from %d byte sg buffer\n", sg[sg_idx].length - current_sg_offset, sg[sg_idx].length);
+#if SMALL_SCATTERLIST
+					memcpy(ptr + transferred,
+					       sg[sg_idx].u.address + current_sg_offset,
+					       sg[sg_idx].length - current_sg_offset);
+#else
 					memcpy(ptr + transferred,
 					       sg[sg_idx].address + current_sg_offset,
 					       sg[sg_idx].length - current_sg_offset);
+#endif
 					transferred += sg[sg_idx].length - current_sg_offset;
 					current_sg_offset = 0;
 					// on to the next sg buffer
 					++sg_idx;
 				} else {
 					US_DEBUGP("datafab_write_data:  getting %d bytes from %d byte sg buffer\n", len - transferred, sg[sg_idx].length);
+#if SMALL_SCATTERLIST
+					memcpy(ptr + transferred,
+					       sg[sg_idx].u.address + current_sg_offset,
+					       len - transferred);
+#else
 					memcpy(ptr + transferred,
 					       sg[sg_idx].address + current_sg_offset,
 					       len - transferred);
+#endif
 					current_sg_offset += len - transferred;
 					// we only copied part of this sg buffer
 					break;
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/freecom.c kern_fix/drivers/usb/storage/freecom.c
--- kern_oldest/drivers/usb/storage/freecom.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/freecom.c	2006-05-01 14:14:13.000000000 -0700
@@ -144,11 +144,20 @@ static void us_transfer_freecom(Scsi_Cmn
 			if (transfer_amount - total_transferred >= 
 					sg[i].length) {
 				result = usb_stor_transfer_partial(us,
-						sg[i].address, sg[i].length);
+#if SMALL_SCATTERLIST
+						sg[i].u.address,
+#else
+						sg[i].address,
+#endif
+						sg[i].length);
 				total_transferred += sg[i].length;
 			} else {
 				result = usb_stor_transfer_partial(us,
+#if SMALL_SCATTERLIST
+						sg[i].u.address,
+#else
 						sg[i].address,
+#endif
 						transfer_amount - total_transferred);
 				total_transferred += transfer_amount - total_transferred;
 			}
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/isd200.c kern_fix/drivers/usb/storage/isd200.c
--- kern_oldest/drivers/usb/storage/isd200.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/isd200.c	2006-05-01 14:14:13.000000000 -0700
@@ -494,13 +494,21 @@ static void isd200_transfer( struct us_d
                             sg[i].length) {
                                 result = isd200_transfer_partial(us, 
                                                                  srb->sc_data_direction,
+#if SMALL_SCATTERLIST
+                                                                 sg[i].u.address, 
+#else
                                                                  sg[i].address, 
+#endif
                                                                  sg[i].length);
                                 total_transferred += sg[i].length;
                         } else
                                 result = isd200_transfer_partial(us, 
                                                                  srb->sc_data_direction,                            
+#if SMALL_SCATTERLIST
+                                                                 sg[i].u.address,
+#else
                                                                  sg[i].address,
+#endif
                                                                  transfer_amount - total_transferred);
 
                         /* if we get an error, end the loop here */
@@ -1396,10 +1404,18 @@ void isd200_data_copy(Scsi_Cmnd *srb, ch
 				/* transfer the lesser of the next buffer or the
 				 * remaining data */
 				if (len - total >= sg[i].length) {
+#if SMALL_SCATTERLIST
+					memcpy(sg[i].u.address, src + total, sg[i].length);
+#else
 					memcpy(sg[i].address, src + total, sg[i].length);
+#endif
 					total += sg[i].length;
 				} else {
+#if SMALL_SCATTERLIST
+					memcpy(sg[i].u.address, src + total, len - total);
+#else
 					memcpy(sg[i].address, src + total, len - total);
+#endif
 					total = len;
 				}
 			} 
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/jumpshot.c kern_fix/drivers/usb/storage/jumpshot.c
--- kern_oldest/drivers/usb/storage/jumpshot.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/jumpshot.c	2006-05-01 14:14:13.000000000 -0700
@@ -341,18 +341,30 @@ static int jumpshot_read_data(struct us_
                         while (sg_idx < use_sg && transferred < len) {
                                 if (len - transferred >= sg[sg_idx].length - current_sg_offset) {
                                         US_DEBUGP("jumpshot_read_data:  adding %d bytes to %d byte sg buffer\n", sg[sg_idx].length - current_sg_offset, sg[sg_idx].length);
+#if SMALL_SCATTERLIST
+                                        memcpy(sg[sg_idx].u.address + current_sg_offset,
+                                               buffer + transferred,
+                                               sg[sg_idx].length - current_sg_offset);
+#else
                                         memcpy(sg[sg_idx].address + current_sg_offset,
                                                buffer + transferred,
                                                sg[sg_idx].length - current_sg_offset);
+#endif
                                         transferred += sg[sg_idx].length - current_sg_offset;
                                         current_sg_offset = 0;
                                         // on to the next sg buffer
                                         ++sg_idx;
                                 } else {
                                         US_DEBUGP("jumpshot_read_data:  adding %d bytes to %d byte sg buffer\n", len - transferred, sg[sg_idx].length);
+#if SMALL_SCATTERLIST
+                                        memcpy(sg[sg_idx].u.address + current_sg_offset,
+                                               buffer + transferred,
+                                               len - transferred);
+#else
                                         memcpy(sg[sg_idx].address + current_sg_offset,
                                                buffer + transferred,
                                                len - transferred);
+#endif
                                         current_sg_offset += len - transferred;
                                         // this sg buffer is only partially full and we're out of data to copy in
                                         break;
@@ -422,18 +434,31 @@ static int jumpshot_write_data(struct us
                         while (transferred < len) {
                                 if (len - transferred >= sg[sg_idx].length - current_sg_offset) {
                                         US_DEBUGP("jumpshot_write_data:  getting %d bytes from %d byte sg buffer\n", sg[sg_idx].length - current_sg_offset, sg[sg_idx].length);
+#if SMALL_SCATTERLIST
+                                        memcpy(ptr + transferred,
+                                               sg[sg_idx].u.address + current_sg_offset,
+                                               sg[sg_idx].length - current_sg_offset);
+#else
                                         memcpy(ptr + transferred,
                                                sg[sg_idx].address + current_sg_offset,
                                                sg[sg_idx].length - current_sg_offset);
+
+#endif
                                         transferred += sg[sg_idx].length - current_sg_offset;
                                         current_sg_offset = 0;
                                         // on to the next sg buffer
                                         ++sg_idx;
                                 } else {
                                         US_DEBUGP("jumpshot_write_data:  getting %d bytes from %d byte sg buffer\n", len - transferred, sg[sg_idx].length);
+#if SMALL_SCATTERLIST
+                                        memcpy(ptr + transferred,
+                                               sg[sg_idx].u.address + current_sg_offset,
+                                               len - transferred);
+#else
                                         memcpy(ptr + transferred,
                                                sg[sg_idx].address + current_sg_offset,
                                                len - transferred);
+#endif
                                         current_sg_offset += len - transferred;
                                         // we only copied part of this sg buffer
                                         break;
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/protocol.c kern_fix/drivers/usb/storage/protocol.c
--- kern_oldest/drivers/usb/storage/protocol.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/protocol.c	2006-05-01 14:14:13.000000000 -0700
@@ -72,7 +72,11 @@ void fix_inquiry_data(Scsi_Cmnd *srb)
 		struct scatterlist *sg;
 
 		sg = (struct scatterlist *) srb->request_buffer;
+#if SMALL_SCATTERLIST
+		data_ptr = (unsigned char *) sg[0].u.address;
+#else
 		data_ptr = (unsigned char *) sg[0].address;
+#endif
 	} else
 		data_ptr = (unsigned char *)srb->request_buffer;
 
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/scsiglue.c kern_fix/drivers/usb/storage/scsiglue.c
--- kern_oldest/drivers/usb/storage/scsiglue.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/scsiglue.c	2006-05-01 14:14:13.000000000 -0700
@@ -606,7 +606,11 @@ int usb_stor_scsiSense10to6( Scsi_Cmnd* 
 	    }
 
 	  /* copy one byte */
+#if SMALL_SCATTERLIST
+	  sg[db].u.address[di] = sg[sb].u.address[si];
+#else
 	  sg[db].address[di] = sg[sb].address[si];
+#endif
 
 	  /* get next destination */
 	  if ( sg[db].length-1 == di )
@@ -644,7 +648,11 @@ int usb_stor_scsiSense10to6( Scsi_Cmnd* 
 	      break;
 	    }
 
+#if SMALL_SCATTERLIST
+	  sg[db].u.address[di] = 0;
+#else
 	  sg[db].address[di] = 0;
+#endif
 
 	  /* get next destination */
 	  if ( sg[db].length-1 == di )
@@ -794,7 +802,11 @@ int usb_stor_scsiSense6to10( Scsi_Cmnd* 
 	    }
 
 	  /* copy one byte */
+#if SMALL_SCATTERLIST
+	  sg[db].u.address[di] = sg[sb].u.address[si];
+#else
 	  sg[db].address[di] = sg[sb].address[si];
+#endif
 
 	  /* get next destination */
 	  if ( di == 0 )
@@ -831,7 +843,11 @@ int usb_stor_scsiSense6to10( Scsi_Cmnd* 
 	      break;
 	    }
 
+#if SMALL_SCATTERLIST
+	  sg[db].u.address[di] = tempBuffer[element-USB_STOR_SCSI_SENSE_HDRSZ];
+#else
 	  sg[db].address[di] = tempBuffer[element-USB_STOR_SCSI_SENSE_HDRSZ];
+#endif
 
 	  /* get next destination */
 	  if ( di == 0 )
@@ -881,6 +897,15 @@ void usb_stor_scsiSenseParseBuffer( Scsi
 		  if ( element < USB_STOR_SCSI_SENSE_HDRSZ )
 		    {
 		      /* fill in the pointers for both header types */
+#if SMALL_SCATTERLIST
+		      the6->array[element] = &(sg[i].u.address[j]);
+		      the10->array[element] = &(sg[i].u.address[j]);
+		    }
+		  else if ( element < USB_STOR_SCSI_SENSE_10_HDRSZ )
+		    {
+		      /* only the longer headers still cares now */
+		      the10->array[element] = &(sg[i].u.address[j]);
+#else
 		      the6->array[element] = &(sg[i].address[j]);
 		      the10->array[element] = &(sg[i].address[j]);
 		    }
@@ -888,6 +913,7 @@ void usb_stor_scsiSenseParseBuffer( Scsi
 		    {
 		      /* only the longer headers still cares now */
 		      the10->array[element] = &(sg[i].address[j]);
+#endif
 		    }
 		  /* increase element counter */
 		  element++;
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/sddr09.c kern_fix/drivers/usb/storage/sddr09.c
--- kern_oldest/drivers/usb/storage/sddr09.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/sddr09.c	2006-05-01 14:14:13.000000000 -0700
@@ -387,7 +387,11 @@ sddr09_bulk_transport(struct us_data *us
 			unsigned char *buf;
 			unsigned int length;
 
+#if SMALL_SCATTERLIST
+			buf = sg[i].u.address;
+#else
 			buf = sg[i].address;
+#endif
 			length = len-transferred;
 			if (length > sg[i].length)
 				length = sg[i].length;
@@ -903,7 +907,11 @@ sddr09_read_data(struct us_data *us,
 		int transferred = 0;
 
 		for (i=0; i<use_sg && transferred<len; i++) {
+#if SMALL_SCATTERLIST
+			unsigned char *buf = sg[i].u.address;
+#else
 			unsigned char *buf = sg[i].address;
+#endif
 			unsigned int length;
 
 			length = len-transferred;
@@ -1085,10 +1093,17 @@ sddr09_write_data(struct us_data *us,
 			return USB_STOR_TRANSPORT_ERROR;
 
 		for (i=0; i<use_sg && transferred<len; i++) {
+#if SMALL_SCATTERLIST
+			memcpy(buffer+transferred,
+			       sg[i].u.address,
+			       len-transferred > sg[i].length ?
+			        sg[i].length : len-transferred);
+#else
 			memcpy(buffer+transferred,
 			       sg[i].address,
 			       len-transferred > sg[i].length ?
 			        sg[i].length : len-transferred);
+#endif
 			transferred += sg[i].length;
 		}
 		ptr = buffer;
@@ -1307,17 +1322,35 @@ sddr09_read_map(struct us_data *us) {
 
 	for (i=0; i<alloc_blocks; i++) {
 		if (i<alloc_blocks-1) {
+#if SMALL_SCATTERLIST
+			sg[i].u.address = kmalloc( (1<<17), GFP_NOIO );
+			sg[i].ispaged = 0;
+			sg[i].length = (1<<17);
+		} else {
+			sg[i].u.address = kmalloc(alloc_len, GFP_NOIO);
+			sg[i].ispaged = 0;
+#else
 			sg[i].address = kmalloc( (1<<17), GFP_NOIO );
 			sg[i].page = NULL;
 			sg[i].length = (1<<17);
 		} else {
 			sg[i].address = kmalloc(alloc_len, GFP_NOIO);
 			sg[i].page = NULL;
+#endif
 			sg[i].length = alloc_len;
 		}
 		alloc_len -= sg[i].length;
 	}
 	for (i=0; i<alloc_blocks; i++)
+#if SMALL_SCATTERLIST
+		if (sg[i].u.address == NULL) {
+			for (i=0; i<alloc_blocks; i++)
+				if (sg[i].u.address != NULL)
+					kfree(sg[i].u.address);
+			kfree(sg);
+			return 0;
+		}
+#else
 		if (sg[i].address == NULL) {
 			for (i=0; i<alloc_blocks; i++)
 				if (sg[i].address != NULL)
@@ -1325,14 +1358,18 @@ sddr09_read_map(struct us_data *us) {
 			kfree(sg);
 			return 0;
 		}
-
+#endif
 	numblocks = info->capacity >> (info->blockshift + info->pageshift);
 
 	result = sddr09_read_control(us, 0, numblocks,
 				     (unsigned char *)sg, alloc_blocks);
 	if (result != USB_STOR_TRANSPORT_GOOD) {
 		for (i=0; i<alloc_blocks; i++)
+#if SMALL_SCATTERLIST
+			kfree(sg[i].u.address);
+#else
 			kfree(sg[i].address);
+#endif
 		kfree(sg);
 		return -1;
 	}
@@ -1348,7 +1385,12 @@ sddr09_read_map(struct us_data *us) {
 		info->lba_to_pba = NULL;
 		info->pba_to_lba = NULL;
 		for (i=0; i<alloc_blocks; i++)
+#if SMALL_SCATTERLIST
+			kfree(sg[i].u.address);
+#else
 			kfree(sg[i].address);
+#endif
+
 		kfree(sg);
 		return 0;
 	}
@@ -1356,7 +1398,11 @@ sddr09_read_map(struct us_data *us) {
 	for (i = 0; i < numblocks; i++)
 		info->lba_to_pba[i] = info->pba_to_lba[i] = UNDEF;
 
+#if SMALL_SCATTERLIST
+	ptr = sg[0].u.address;
+#else
 	ptr = sg[0].address;
+#endif
 
 	/*
 	 * Define lba-pba translation table
@@ -1374,7 +1420,11 @@ sddr09_read_map(struct us_data *us) {
 	printk("sddr09: no translation today\n");
 #else
 	for (i=0; i<numblocks; i++) {
+#if SMALL_SCATTERLIST
+		ptr = sg[i>>11].u.address + ((i&0x7ff)<<6);
+#else
 		ptr = sg[i>>11].address + ((i&0x7ff)<<6);
+#endif
 
 		if (i == 0 || i == 1) {
 			info->pba_to_lba[i] = UNUSABLE;
@@ -1477,7 +1527,11 @@ sddr09_read_map(struct us_data *us) {
 	US_DEBUGP("Found %d LBA's\n", lbact);
 
 	for (i=0; i<alloc_blocks; i++)
+#if SMALL_SCATTERLIST
+		kfree(sg[i].u.address);
+#else
 		kfree(sg[i].address);
+#endif
 	kfree(sg);
 	return 0;
 }
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/sddr55.c kern_fix/drivers/usb/storage/sddr55.c
--- kern_oldest/drivers/usb/storage/sddr55.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/sddr55.c	2006-05-01 14:14:13.000000000 -0700
@@ -402,9 +402,15 @@ static int sddr55_read_data(struct us_da
 	if (use_sg) {
 		transferred = 0;
 		for (i=0; i<use_sg && transferred<len; i++) {
+#if SMALL_SCATTERLIST
+			memcpy(sg[i].u.address, buffer+transferred,
+				len-transferred > sg[i].length ?
+					sg[i].length : len-transferred);
+#else
 			memcpy(sg[i].address, buffer+transferred,
 				len-transferred > sg[i].length ?
 					sg[i].length : len-transferred);
+#endif
 			transferred += sg[i].length;
 		}
 		kfree(buffer);
@@ -462,9 +468,15 @@ static int sddr55_write_data(struct us_d
 
 		transferred = 0;
 		for (i=0; i<use_sg && transferred<len; i++) {
+#if SMALL_SCATTERLIST
+			memcpy(buffer+transferred, sg[i].u.address,
+				len-transferred > sg[i].length ?
+					sg[i].length : len-transferred);
+#else
 			memcpy(buffer+transferred, sg[i].address,
 				len-transferred > sg[i].length ?
 					sg[i].length : len-transferred);
+#endif
 			transferred += sg[i].length;
 		}
 
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/shuttle_usbat.c kern_fix/drivers/usb/storage/shuttle_usbat.c
--- kern_oldest/drivers/usb/storage/shuttle_usbat.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/shuttle_usbat.c	2006-05-01 14:14:13.000000000 -0700
@@ -217,7 +217,11 @@ static int usbat_bulk_transport(struct u
 		sg = (struct scatterlist *)data;
 		for (i=0; i<use_sg && transferred<len; i++) {
 			result = usbat_raw_bulk(us, direction,
+#if SMALL_SCATTERLIST
+				sg[i].u.address, 
+#else
 				sg[i].address, 
+#endif
 				len-transferred > sg[i].length ?
 					sg[i].length : len-transferred);
 			if (result!=US_BULK_TRANSFER_GOOD)
@@ -742,17 +746,29 @@ int usbat_handle_read10(struct us_data *
 			while (amount<len) {
 				if (len - amount >= 
 					  sg[sg_segment].length-sg_offset) {
+#if SMALL_SCATTERLIST
+				  memcpy(sg[sg_segment].u.address + sg_offset,
+					buffer + amount,
+					sg[sg_segment].length - sg_offset);
+#else
 				  memcpy(sg[sg_segment].address + sg_offset,
 					buffer + amount,
 					sg[sg_segment].length - sg_offset);
+#endif
 				  amount += 
 					  sg[sg_segment].length-sg_offset;
 				  sg_segment++;
 				  sg_offset=0;
 				} else {
+#if SMALL_SCATTERLIST
+				  memcpy(sg[sg_segment].u.address + sg_offset,
+					buffer + amount,
+					len - amount);
+#else
 				  memcpy(sg[sg_segment].address + sg_offset,
 					buffer + amount,
 					len - amount);
+#endif
 				  sg_offset += (len - amount);
 				  amount = len;
 				}
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/transport.c kern_fix/drivers/usb/storage/transport.c
--- kern_oldest/drivers/usb/storage/transport.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/transport.c	2006-05-01 14:14:13.000000000 -0700
@@ -592,11 +592,20 @@ void usb_stor_transfer(Scsi_Cmnd *srb, s
 			if (transfer_amount - total_transferred >= 
 					sg[i].length) {
 				result = usb_stor_transfer_partial(us,
-						sg[i].address, sg[i].length);
+#if SMALL_SCATTERLIST
+						sg[i].u.address,
+#else
+						sg[i].address,
+#endif
+						sg[i].length);
 				total_transferred += sg[i].length;
 			} else
 				result = usb_stor_transfer_partial(us,
+#if SMALL_SCATTERLIST
+						sg[i].u.address,
+#else
 						sg[i].address,
+#endif
 						transfer_amount - total_transferred);
 
 			/* if we get an error, end the loop here */
diff -X dontdiff -urp kern_oldest/drivers/usb/storage/usb.c kern_fix/drivers/usb/storage/usb.c
--- kern_oldest/drivers/usb/storage/usb.c	2006-05-01 11:55:42.000000000 -0700
+++ kern_fix/drivers/usb/storage/usb.c	2006-05-01 14:14:13.000000000 -0700
@@ -291,13 +291,21 @@ void fill_inquiry_response(struct us_dat
 	if (us->srb->use_sg) {
 		sg = (struct scatterlist *)us->srb->request_buffer;
 		for (i=0; i<us->srb->use_sg; i++)
+#if SMALL_SCATTERLIST
+			memset(sg[i].u.address, 0, sg[i].length);
+#else
 			memset(sg[i].address, 0, sg[i].length);
+#endif
 		for (i=0, transferred=0; 
 				i<us->srb->use_sg && transferred < len;
 				i++) {
 			amt = sg[i].length > len-transferred ? 
 					len-transferred : sg[i].length;
+#if SMALL_SCATTERLIST
+			memcpy(sg[i].u.address, data+transferred, amt);
+#else
 			memcpy(sg[i].address, data+transferred, amt);
+#endif
 			transferred -= amt;
 		}
 	} else {
diff -X dontdiff -urp kern_oldest/net/ipv6/addrconf.c kern_fix/net/ipv6/addrconf.c
--- kern_oldest/net/ipv6/addrconf.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/net/ipv6/addrconf.c	2006-05-01 14:14:24.000000000 -0700
@@ -1047,11 +1047,18 @@ static int __ipv6_regen_rndid(struct ine
 	u8 digest[16];
 	struct scatterlist sg[2];
 
-	sg[0].page = virt_to_page(idev->entropy);
+#if SMALL_SCATTERLIST
+ 	sg[0].u.page.page = virt_to_page(idev->entropy);
+	sg[0].u.page.offset = ((long) idev->entropy & ~PAGE_MASK);
+	sg[1].u.page.page = virt_to_page(eui64);
+	sg[1].u.page.offset = ((long) eui64 & ~PAGE_MASK);
+#else
+ 	sg[0].page = virt_to_page(idev->entropy);
 	sg[0].offset = ((long) idev->entropy & ~PAGE_MASK);
-	sg[0].length = 8;
 	sg[1].page = virt_to_page(eui64);
 	sg[1].offset = ((long) eui64 & ~PAGE_MASK);
+#endif
+	sg[0].length = 8;
 	sg[1].length = 8;
 
 	dev = idev->dev;
diff -X dontdiff -urp kern_oldest/net/xfrm/xfrm_algo.c kern_fix/net/xfrm/xfrm_algo.c
--- kern_oldest/net/xfrm/xfrm_algo.c	2006-05-01 11:55:40.000000000 -0700
+++ kern_fix/net/xfrm/xfrm_algo.c	2006-05-01 14:14:24.000000000 -0700
@@ -487,9 +487,14 @@ void skb_icv_walk(const struct sk_buff *
 	if (copy > 0) {
 		if (copy > len)
 			copy = len;
-		
+#if SMALL_SCATTERLIST		
+		sg.ispaged = 1;
+		sg.u.page.page = virt_to_page(skb->data + offset);
+		sg.u.page.offset = (unsigned long)(skb->data + offset) % PAGE_SIZE;
+#else
 		sg.page = virt_to_page(skb->data + offset);
 		sg.offset = (unsigned long)(skb->data + offset) % PAGE_SIZE;
+#endif
 		sg.length = copy;
 		
 		icv_update(tfm, &sg, 1);
@@ -511,8 +516,14 @@ void skb_icv_walk(const struct sk_buff *
 			if (copy > len)
 				copy = len;
 			
+#if SMALL_SCATTERLIST
+			sg.ispaged = 1;
+			sg.u.page.page = frag->page;
+			sg.u.page.offset = frag->page_offset + offset-start;
+#else
 			sg.page = frag->page;
 			sg.offset = frag->page_offset + offset-start;
+#endif
 			sg.length = copy;
 			
 			icv_update(tfm, &sg, 1);
@@ -562,8 +573,15 @@ skb_to_sgvec(struct sk_buff *skb, struct
 	if (copy > 0) {
 		if (copy > len)
 			copy = len;
+#if SMALL_SCATTERLIST
+#
+		sg[elt].u.page.page = virt_to_page(skb->data + offset);
+		sg[elt].u.page.offset = (unsigned long)(skb->data + offset) % PAGE_SIZE;
+#else
+#
 		sg[elt].page = virt_to_page(skb->data + offset);
 		sg[elt].offset = (unsigned long)(skb->data + offset) % PAGE_SIZE;
+#endif
 		sg[elt].length = copy;
 		elt++;
 		if ((len -= copy) == 0)
@@ -582,8 +600,13 @@ skb_to_sgvec(struct sk_buff *skb, struct
 
 			if (copy > len)
 				copy = len;
+#if SMALL_SCATTERLIST
+			sg[elt].u.page.page = frag->page;
+			sg[elt].u.page.offset = frag->page_offset+offset-start;
+#else
 			sg[elt].page = frag->page;
 			sg[elt].offset = frag->page_offset+offset-start;
+#endif
 			sg[elt].length = copy;
 			elt++;
 			if (!(len -= copy))
diff -urp a/drivers/scsi/libata-core.c b/drivers/scsi/libata-core.c
--- a/drivers/scsi/libata-core.c	2006-05-15 00:42:16.000000000 -0700
+++ b/drivers/scsi/libata-core.c	2006-05-15 00:40:14.000000000 -0700
@@ -54,6 +54,7 @@
 #include <asm/io.h>
 #include <asm/semaphore.h>
 #include <asm/byteorder.h>
+#include <asm/scatterlist.h>
 
 #include "libata.h"
 
@@ -2424,9 +2425,15 @@ static void ata_sg_clean(struct ata_queu
 		sg[qc->orig_n_elem - 1].length += qc->pad_len;
 		if (pad_buf) {
 			struct scatterlist *psg = &qc->pad_sgent;
+#if SMALL_SCATTERLIST
+			void *addr = kmap_atomic(psg->u.page.page, KM_IRQ0);
+			memcpy(addr + psg->u.page.offset, pad_buf, qc->pad_len);
+			kunmap_atomic(psg->u.page.page, KM_IRQ0);
+#else
 			void *addr = kmap_atomic(psg->page, KM_IRQ0);
 			memcpy(addr + psg->offset, pad_buf, qc->pad_len);
 			kunmap_atomic(psg->page, KM_IRQ0);
+#endif
 		}
 	} else {
 		if (sg_dma_len(&sg[0]) > 0)
@@ -2693,14 +2700,26 @@ static int ata_sg_setup(struct ata_queue
 		 * psg->page/offset are used to copy to-be-written
 		 * data in this function or read data in ata_sg_clean.
 		 */
+#if SMALL_SCATTERLIST
+		offset = lsg->u.page.offset + lsg->length - qc->pad_len;
+		psg->u.page.page = nth_page(lsg->u.page.page, offset >> PAGE_SHIFT);
+		psg->u.page.offset = offset_in_page(offset);
+#else
 		offset = lsg->offset + lsg->length - qc->pad_len;
 		psg->page = nth_page(lsg->page, offset >> PAGE_SHIFT);
 		psg->offset = offset_in_page(offset);
+#endif
 
 		if (qc->tf.flags & ATA_TFLAG_WRITE) {
+#if SMALL_SCATTERLIST
+			void *addr = kmap_atomic(psg->u.page.page, KM_IRQ0);
+			memcpy(pad_buf, addr + psg->u.page.offset, qc->pad_len);
+			kunmap_atomic(psg->u.page.page, KM_IRQ0);
+#else
 			void *addr = kmap_atomic(psg->page, KM_IRQ0);
 			memcpy(pad_buf, addr + psg->offset, qc->pad_len);
 			kunmap_atomic(psg->page, KM_IRQ0);
+#endif
 		}
 
 		sg_dma_address(psg) = ap->pad_dma + (qc->tag * ATA_DMA_PAD_SZ);
diff -urp a/include/linux/libata-compat.h b/include/linux/libata-compat.h
--- a/include/linux/libata-compat.h	2006-05-15 00:41:42.000000000 -0700
+++ b/include/linux/libata-compat.h	2006-05-15 00:39:53.000000000 -0700
@@ -198,8 +198,13 @@ pci_iomap(struct pci_dev *dev, int bar, 
 static inline void sg_set_buf(struct scatterlist *sg, void *buf,
 			      unsigned int buflen)
 {
+#if SMALL_SCATTERLIST
+	sg->u.page.page = virt_to_page(buf);
+	sg->u.page.offset = offset_in_page(buf);
+#else
 	sg->page = virt_to_page(buf);
 	sg->offset = offset_in_page(buf);
+#endif
 	sg->length = buflen;
 }
 
