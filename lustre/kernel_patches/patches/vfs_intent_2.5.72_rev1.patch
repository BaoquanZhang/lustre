 fs/exec.c              |   15 ++-
 fs/namei.c             |  189 ++++++++++++++++++++++++++++++++++++++++++-------
 fs/namespace.c         |    2 
 fs/open.c              |   64 ++++++++++------
 fs/stat.c              |   28 +++++--
 fs/sysfs/inode.c       |    2 
 include/linux/dcache.h |   36 +++++++++
 include/linux/fs.h     |   10 ++
 include/linux/namei.h  |   19 +++-
 kernel/ksyms.c         |    7 +
 net/sunrpc/rpc_pipe.c  |    6 -
 net/unix/af_unix.c     |    2 
 12 files changed, 309 insertions(+), 71 deletions(-)

--- linux-2.5.72/fs/sysfs/inode.c~vfs_intent_2.5.72_rev1	2003-06-16 22:20:21.000000000 -0600
+++ linux-2.5.72-braam/fs/sysfs/inode.c	2003-06-25 08:13:39.000000000 -0600
@@ -81,7 +81,7 @@ struct dentry * sysfs_get_dentry(struct 
 	qstr.name = name;
 	qstr.len = strlen(name);
 	qstr.hash = full_name_hash(name,qstr.len);
-	return lookup_hash(&qstr,parent);
+	return lookup_hash(&qstr,parent, NULL);
 }
 
 void sysfs_hash_and_remove(struct dentry * dir, const char * name)
--- linux-2.5.72/fs/exec.c~vfs_intent_2.5.72_rev1	2003-06-16 22:19:59.000000000 -0600
+++ linux-2.5.72-braam/fs/exec.c	2003-06-25 22:03:23.000000000 -0600
@@ -116,6 +116,9 @@ asmlinkage long sys_uselib(const char __
 	struct file * file;
 	struct nameidata nd;
 	int error;
+        intent_init(&nd.it, IT_OPEN, O_RDONLY);
+  
+ 	error = user_path_walk_it(library, &nd);
 
 	error = user_path_walk(library, &nd);
 	if (error)
@@ -129,7 +132,7 @@ asmlinkage long sys_uselib(const char __
 	if (error)
 		goto exit;
 
-	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+	file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &nd.it);
 	error = PTR_ERR(file);
 	if (IS_ERR(file))
 		goto out;
@@ -453,8 +456,12 @@ static inline void free_arg_pages(struct
 struct file *open_exec(const char *name)
 {
 	struct nameidata nd;
-	int err = path_lookup(name, LOOKUP_FOLLOW, &nd);
-	struct file *file = ERR_PTR(err);
+ 	int err;
+ 	struct file *file;
+         
+        intent_init(&nd.it, IT_OPEN, O_RDONLY);
+        err = path_lookup(name, LOOKUP_FOLLOW, &nd);
+        file = ERR_PTR(err);
 
 	if (!err) {
 		struct inode *inode = nd.dentry->d_inode;
@@ -466,7 +473,7 @@ struct file *open_exec(const char *name)
 				err = -EACCES;
 			file = ERR_PTR(err);
 			if (!err) {
-				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+				file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &nd.it);
 				if (!IS_ERR(file)) {
 					err = deny_write_access(file);
 					if (err) {
--- linux-2.5.72/fs/namei.c~vfs_intent_2.5.72_rev1	2003-06-16 22:19:57.000000000 -0600
+++ linux-2.5.72-braam/fs/namei.c	2003-06-29 11:42:52.000000000 -0600
@@ -263,8 +263,19 @@ int deny_write_access(struct file * file
 	return 0;
 }
 
+void intent_release(struct lookup_intent *it)
+{
+        if (!it) 
+                return;
+        if (it->it_magic != INTENT_MAGIC)
+                return;
+        if (it->it_op_release)
+                it->it_op_release(it);
+}
+
 void path_release(struct nameidata *nd)
 {
+        intent_release(&nd->it);
 	dput(nd->dentry);
 	mntput(nd->mnt);
 }
@@ -273,7 +284,7 @@ void path_release(struct nameidata *nd)
  * Internal lookup() using the new generic dcache.
  * SMP-safe
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags, struct nameidata *nd)
 {
 	struct dentry * dentry = __d_lookup(parent, name);
 
@@ -283,6 +294,14 @@ static struct dentry * cached_lookup(str
 	if (!dentry)
 		dentry = d_lookup(parent, name);
 
+	if (dentry && dentry->d_op && dentry->d_op->d_revalidate_nd) {
+		if (!dentry->d_op->d_revalidate_nd(dentry, flags, nd) &&
+		    !d_invalidate(dentry)) {
+			dput(dentry);
+			dentry = NULL;
+		}
+		return dentry;
+	} else
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
@@ -336,7 +355,7 @@ ok:
  * make sure that nobody added the entry to the dcache in the meantime..
  * SMP-safe
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags, struct nameidata *nd)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
@@ -361,7 +380,10 @@ static struct dentry * real_lookup(struc
 		struct dentry * dentry = d_alloc(parent, name);
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
-			result = dir->i_op->lookup(dir, dentry);
+			if (dir->i_op->lookup_it)
+				result = dir->i_op->lookup_it(dir, dentry, nd);
+			else
+                                result = dir->i_op->lookup(dir, dentry);
 			if (result)
 				dput(dentry);
 			else
@@ -381,6 +403,12 @@ static struct dentry * real_lookup(struc
 			dput(result);
 			result = ERR_PTR(-ENOENT);
 		}
+	} else if (result->d_op && result->d_op->d_revalidate_nd) {
+		if (!result->d_op->d_revalidate_nd(result, flags, nd) &&
+		    !d_invalidate(result)) {
+			dput(result);
+			result = ERR_PTR(-ENOENT);
+		}
 	}
 	return result;
 }
@@ -455,15 +483,25 @@ static int follow_mount(struct vfsmount 
 	return res;
 }
 
-static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry)
+static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry,
+                              struct lookup_intent *it)
 {
 	struct vfsmount *mounted;
 
 	spin_lock(&dcache_lock);
 	mounted = lookup_mnt(*mnt, *dentry);
 	if (mounted) {
+		int opc = 0, mode = 0;
 		*mnt = mntget(mounted);
 		spin_unlock(&dcache_lock);
+		if (it) {
+			opc = it->it_op;
+			mode = it->it_mode;
+		}
+		if (it) {
+			it->it_op = opc;
+			it->it_mode = mode;
+		}
 		dput(*dentry);
 		mntput(mounted->mnt_parent);
 		*dentry = dget(mounted->mnt_root);
@@ -475,7 +513,7 @@ static inline int __follow_down(struct v
 
 int follow_down(struct vfsmount **mnt, struct dentry **dentry)
 {
-	return __follow_down(mnt,dentry);
+	return __follow_down(mnt,dentry,NULL);
 }
  
 static inline void follow_dotdot(struct vfsmount **mnt, struct dentry **dentry)
@@ -531,7 +569,8 @@ static int do_lookup(struct nameidata *n
 
 	if (!dentry)
 		goto need_lookup;
-	if (dentry->d_op && dentry->d_op->d_revalidate)
+	if (dentry->d_op && (dentry->d_op->d_revalidate || 
+                             dentry->d_op->d_revalidate_nd) )
 		goto need_revalidate;
 done:
 	path->mnt = mnt;
@@ -539,13 +578,17 @@ done:
 	return 0;
 
 need_lookup:
-	dentry = real_lookup(nd->dentry, name, LOOKUP_CONTINUE);
+	dentry = real_lookup(nd->dentry, name, LOOKUP_CONTINUE, nd);
 	if (IS_ERR(dentry))
 		goto fail;
 	goto done;
 
 need_revalidate:
-	if (dentry->d_op->d_revalidate(dentry, flags))
+	if (dentry->d_op->d_revalidate && 
+            dentry->d_op->d_revalidate(dentry, flags))
+		goto done;
+	if (dentry->d_op->d_revalidate_nd && 
+            dentry->d_op->d_revalidate_nd(dentry, flags, nd))
 		goto done;
 	if (d_invalidate(dentry))
 		goto done;
@@ -556,6 +599,32 @@ fail:
 	return PTR_ERR(dentry);
 }
 
+
+static int revalidate_special(struct nameidata *nd)
+{
+        struct dentry *dentry = nd->dentry;
+        int err, counter = 0;
+
+        if (!dentry->d_op || !dentry->d_op->d_revalidate_nd)
+                return 0;
+ revalidate_again:
+        if (!dentry->d_op->d_revalidate_nd(dentry, 0, nd)) {
+                struct dentry *new;
+                if ((err = permission(dentry->d_parent->d_inode, MAY_EXEC)))
+                        return err;
+                new = real_lookup(dentry->d_parent, &dentry->d_name, 0, nd);
+                d_invalidate(dentry);
+                dput(dentry);
+                dentry = new;
+                counter++;
+                if (counter < 10)
+                        goto revalidate_again;
+                printk("excessive revalidate_it loops\n");
+                return -ESTALE;
+        }
+        return 0;
+}
+
 /*
  * Name resolution.
  *
@@ -655,7 +724,9 @@ int link_path_walk(const char * name, st
 
 		if (inode->i_op->follow_link) {
 			mntget(next.mnt);
+                        nd->flags |= LOOKUP_LINK_NOTLAST;
 			err = do_follow_link(next.dentry, nd);
+                        nd->flags &= ~LOOKUP_LINK_NOTLAST;
 			dput(next.dentry);
 			mntput(next.mnt);
 			if (err)
@@ -673,7 +744,7 @@ int link_path_walk(const char * name, st
 			nd->dentry = next.dentry;
 		}
 		err = -ENOTDIR; 
-		if (!inode->i_op->lookup)
+		if (!inode->i_op->lookup && !inode->i_op->lookup_it)
 			break;
 		continue;
 		/* here ends the main loop */
@@ -693,6 +764,11 @@ last_component:
 				inode = nd->dentry->d_inode;
 				/* fallthrough */
 			case 1:
+                                nd->flags |= LOOKUP_LAST;
+                                err = revalidate_special(nd);
+                                nd->flags &= ~LOOKUP_LAST;
+                                if (err)
+                                        break;
 				goto return_base;
 		}
 		if (nd->dentry->d_op && nd->dentry->d_op->d_hash) {
@@ -700,7 +776,9 @@ last_component:
 			if (err < 0)
 				break;
 		}
+                nd->flags |= LOOKUP_LAST;
 		err = do_lookup(nd, &this, &next, 0);
+                nd->flags &= ~LOOKUP_LAST;
 		if (err)
 			break;
 		follow_mount(&next.mnt, &next.dentry);
@@ -724,7 +802,8 @@ last_component:
 			break;
 		if (lookup_flags & LOOKUP_DIRECTORY) {
 			err = -ENOTDIR; 
-			if (!inode->i_op || !inode->i_op->lookup)
+			if (!inode->i_op || 
+                            (!inode->i_op->lookup && !inode->i_op->lookup_it))
 				break;
 		}
 		goto return_base;
@@ -743,7 +822,7 @@ out_dput:
 		dput(next.dentry);
 		break;
 	}
-	path_release(nd);
+        path_release(nd);
 return_err:
 	return err;
 }
@@ -866,7 +945,8 @@ int path_lookup(const char *name, unsign
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+struct dentry * lookup_hash(struct qstr *name, struct dentry * base, 
+                            struct nameidata *nd)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -889,13 +969,16 @@ struct dentry * lookup_hash(struct qstr 
 			goto out;
 	}
 
-	dentry = cached_lookup(base, name, 0);
+	dentry = cached_lookup(base, name, 0, nd);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
-		dentry = inode->i_op->lookup(inode, new);
+		if (inode->i_op->lookup_it)
+			dentry = inode->i_op->lookup_it(inode, new, nd);
+		else
+			dentry = inode->i_op->lookup(inode, new);
 		if (!dentry)
 			dentry = new;
 		else
@@ -906,7 +989,7 @@ out:
 }
 
 /* SMP-safe */
-struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+struct dentry * lookup_one_len_it(const char * name, struct dentry * base, int len, struct nameidata *nd)
 {
 	unsigned long hash;
 	struct qstr this;
@@ -926,11 +1009,16 @@ struct dentry * lookup_one_len(const cha
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return lookup_hash(&this, base, nd);
 access:
 	return ERR_PTR(-EACCES);
 }
 
+struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+{
+        return lookup_one_len_it(name, base, len, NULL);
+}
+
 /*
  *	namei()
  *
@@ -942,10 +1030,11 @@ access:
  * that namei follows links, while lnamei does not.
  * SMP-safe
  */
-int __user_walk(const char __user *name, unsigned flags, struct nameidata *nd)
+int __user_walk_it(const char __user *name, unsigned flags, struct nameidata *nd)
 {
 	char *tmp = getname(name);
 	int err = PTR_ERR(tmp);
+ 
 
 	if (!IS_ERR(tmp)) {
 		err = path_lookup(tmp, flags, nd);
@@ -954,6 +1043,12 @@ int __user_walk(const char __user *name,
 	return err;
 }
 
+int __user_walk(const char __user *name, unsigned flags, struct nameidata *nd)
+{
+        intent_init(&nd->it, IT_LOOKUP, 0);
+        return __user_walk_it(name, flags, nd);
+}
+
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -1093,6 +1188,32 @@ void unlock_rename(struct dentry *p1, st
 	}
 }
 
+int vfs_create_it(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+{
+	int error = may_create(dir, dentry);
+
+	if (error)
+		return error;
+
+	if (!dir->i_op || (!dir->i_op->create && !dir->i_op->create_nd))
+		return -EACCES;	/* shouldn't it be ENOSYS? */
+	mode &= S_IALLUGO;
+	mode |= S_IFREG;
+	error = security_inode_create(dir, dentry, mode);
+	if (error)
+		return error;
+	DQUOT_INIT(dir);
+        if (dir->i_op->create_nd)
+                error = dir->i_op->create_nd(dir, dentry, mode, nd);
+        else 
+                error = dir->i_op->create(dir, dentry, mode);
+	if (!error) {
+		inode_dir_notify(dir, DN_CREATE);
+		security_inode_post_create(dir, dentry, mode);
+	}
+	return error;
+}
+
 int vfs_create(struct inode *dir, struct dentry *dentry, int mode)
 {
 	int error = may_create(dir, dentry);
@@ -1232,6 +1353,9 @@ int open_namei(const char * pathname, in
 	/*
 	 * Create - we need to know the parent.
 	 */
+	nd->it.it_mode = mode;
+	nd->it.it_op |= IT_CREAT;
+		
 	error = path_lookup(pathname, LOOKUP_PARENT, nd);
 	if (error)
 		return error;
@@ -1247,7 +1371,9 @@ int open_namei(const char * pathname, in
 
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+        nd->flags |= LOOKUP_LAST;
+	dentry = lookup_hash(&nd->last, nd->dentry, nd);
+        nd->flags &= ~LOOKUP_LAST;
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1255,12 +1381,13 @@ do_last:
 		up(&dir->d_inode->i_sem);
 		goto exit;
 	}
-
+        
+	nd->it.it_mode = mode;
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
-		error = vfs_create(dir->d_inode, dentry, mode);
+		error = vfs_create_it(dir->d_inode, dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
 		nd->dentry = dentry;
@@ -1285,7 +1412,7 @@ do_last:
 		error = -ELOOP;
 		if (flag & O_NOFOLLOW)
 			goto exit_dput;
-		while (__follow_down(&nd->mnt,&dentry) && d_mountpoint(dentry));
+		while (__follow_down(&nd->mnt,&dentry,&nd->it) && d_mountpoint(dentry));
 	}
 	error = -ENOENT;
 	if (!dentry->d_inode)
@@ -1350,7 +1477,9 @@ do_link:
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+        nd->flags |= LOOKUP_LAST;
+	dentry = lookup_hash(&nd->last, nd->dentry, nd);
+        nd->flags &= ~LOOKUP_LAST;
 	putname(nd->last.name);
 	goto do_last;
 }
@@ -1364,7 +1493,7 @@ static struct dentry *lookup_create(stru
 	dentry = ERR_PTR(-EEXIST);
 	if (nd->last_type != LAST_NORM)
 		goto fail;
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash(&nd->last, nd->dentry, nd);
 	if (IS_ERR(dentry))
 		goto fail;
 	if (!is_dir && nd->last.name[nd->last.len] && !dentry->d_inode)
@@ -1596,7 +1725,7 @@ asmlinkage long sys_rmdir(const char __u
 			goto exit1;
 	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, &nd);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1665,7 +1794,7 @@ asmlinkage long sys_unlink(const char __
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, &nd);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -2015,7 +2144,7 @@ static inline int do_rename(const char *
 
 	trap = lock_rename(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = lookup_hash(&oldnd.last, old_dir, &oldnd);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -2035,7 +2164,7 @@ static inline int do_rename(const char *
 	error = -EINVAL;
 	if (old_dentry == trap)
 		goto exit4;
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = lookup_hash(&newnd.last, new_dir, &newnd);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
@@ -2100,7 +2229,10 @@ static inline int
 __vfs_follow_link(struct nameidata *nd, const char *link)
 {
 	int res = 0;
+        struct lookup_intent it = nd->it;
+        int mode = it.it_mode;
 	char *name;
+
 	if (IS_ERR(link))
 		goto fail;
 
@@ -2110,6 +2242,9 @@ __vfs_follow_link(struct nameidata *nd, 
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
+
+        intent_init(&nd->it, it.it_op, it.it_flags);
+        nd->it.it_mode = mode;
 	res = link_path_walk(link, nd);
 out:
 	if (current->link_count || res || nd->last_type!=LAST_NORM)
--- linux-2.5.72/fs/namespace.c~vfs_intent_2.5.72_rev1	2003-06-16 22:20:06.000000000 -0600
+++ linux-2.5.72-braam/fs/namespace.c	2003-06-29 01:51:10.000000000 -0600
@@ -728,6 +728,7 @@ long do_mount(char * dev_name, char * di
 	int retval = 0;
 	int mnt_flags = 0;
 
+        intent_init(&nd.it, IT_LOOKUP, 0);
 	/* Discard magic */
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
 		flags &= ~MS_MGC_MSK;
@@ -937,6 +938,7 @@ void set_fs_pwd(struct fs_struct *fs, st
 		mntput(old_pwdmnt);
 	}
 }
+EXPORT_SYMBOL(set_fs_pwd);
 
 static void chroot_fs_refs(struct nameidata *old_nd, struct nameidata *new_nd)
 {
--- linux-2.5.72/fs/open.c~vfs_intent_2.5.72_rev1	2003-06-16 22:19:40.000000000 -0600
+++ linux-2.5.72-braam/fs/open.c	2003-06-25 21:59:58.000000000 -0600
@@ -97,7 +97,7 @@ static inline long do_sys_truncate(const
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
-
+	intent_init(&nd.it, IT_GETATTR, 0);
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
@@ -340,6 +340,7 @@ asmlinkage long sys_access(const char __
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	intent_init(&nd.it, IT_GETATTR, 0);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -371,6 +372,7 @@ asmlinkage long sys_access(const char __
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+		                
 		path_release(&nd);
 	}
 
@@ -385,6 +387,7 @@ asmlinkage long sys_chdir(const char __u
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.it, IT_GETATTR, 0);
 
 	error = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
 	if (error)
@@ -436,6 +439,7 @@ asmlinkage long sys_chroot(const char __
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.it, IT_GETATTR, 0);
 
 	error = __user_walk(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
 	if (error)
@@ -508,7 +512,7 @@ asmlinkage long sys_chmod(const char __u
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
-
+	
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
@@ -616,25 +620,8 @@ asmlinkage long sys_fchown(unsigned int 
  * for the internal routines (ie open_namei()/follow_link() etc). 00 is
  * used by symlinks.
  */
-struct file *filp_open(const char * filename, int flags, int mode)
-{
-	int namei_flags, error;
-	struct nameidata nd;
-
-	namei_flags = flags;
-	if ((namei_flags+1) & O_ACCMODE)
-		namei_flags++;
-	if (namei_flags & O_TRUNC)
-		namei_flags |= 2;
-
-	error = open_namei(filename, namei_flags, mode, &nd);
-	if (!error)
-		return dentry_open(nd.dentry, nd.mnt, flags);
-
-	return ERR_PTR(error);
-}
-
-struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt, int flags, 
+                            struct lookup_intent *it)
 {
 	struct file * f;
 	struct inode *inode;
@@ -646,6 +633,7 @@ struct file *dentry_open(struct dentry *
 		goto cleanup_dentry;
 	f->f_flags = flags;
 	f->f_mode = (flags+1) & O_ACCMODE;
+        f->f_it = it;
 	inode = dentry->d_inode;
 	if (f->f_mode & FMODE_WRITE) {
 		error = get_write_access(inode);
@@ -664,6 +652,7 @@ struct file *dentry_open(struct dentry *
 		error = f->f_op->open(inode,f);
 		if (error)
 			goto cleanup_all;
+                intent_release(it);
 	}
 	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);
 
@@ -675,7 +664,7 @@ struct file *dentry_open(struct dentry *
 				f = ERR_PTR(-EINVAL);
 		}
 	}
-
+        
 	return f;
 
 cleanup_all:
@@ -688,11 +677,42 @@ cleanup_all:
 cleanup_file:
 	put_filp(f);
 cleanup_dentry:
+        intent_release(it);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
 }
 
+struct file *filp_open(const char * filename, int flags, int mode)
+{
+	int namei_flags, error;
+	struct file * temp_filp;
+        struct nameidata nd;
+	intent_init(&nd.it, IT_OPEN, flags);
+
+	namei_flags = flags;
+	if ((namei_flags+1) & O_ACCMODE)
+		namei_flags++;
+	if (namei_flags & O_TRUNC)
+		namei_flags |= 2;
+
+	error = open_namei(filename, namei_flags, mode, &nd);
+	if (!error) {
+		temp_filp = dentry_open_it(nd.dentry, nd.mnt, flags, &nd.it);
+		return temp_filp;
+	}	
+	return ERR_PTR(error);
+}
+
+
+struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+{
+        struct lookup_intent it;
+	intent_init(&it, IT_LOOKUP, 0);
+
+        return dentry_open_it(dentry, mnt, flags, &it);
+}
+
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
--- linux-2.5.72/fs/stat.c~vfs_intent_2.5.72_rev1	2003-06-16 22:19:42.000000000 -0600
+++ linux-2.5.72-braam/fs/stat.c	2003-06-25 21:52:45.000000000 -0600
@@ -33,7 +33,7 @@ void generic_fillattr(struct inode *inod
 	stat->blksize = inode->i_blksize;
 }
 
-int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+int vfs_getattr_it(struct vfsmount *mnt, struct dentry *dentry, struct lookup_intent *it, struct kstat *stat)
 {
 	struct inode *inode = dentry->d_inode;
 	int retval;
@@ -44,6 +44,8 @@ int vfs_getattr(struct vfsmount *mnt, st
 
 	if (inode->i_op->getattr)
 		return inode->i_op->getattr(mnt, dentry, stat);
+	if (inode->i_op->getattr_it)
+		return inode->i_op->getattr_it(mnt, dentry, it, stat);
 
 	generic_fillattr(inode, stat);
 	if (!stat->blksize) {
@@ -56,15 +58,21 @@ int vfs_getattr(struct vfsmount *mnt, st
 	return 0;
 }
 
+int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+        return vfs_getattr_it(mnt, dentry, NULL, stat);
+}
+
 int vfs_stat(char __user *name, struct kstat *stat)
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.it, IT_GETATTR, 0);
 
-	error = user_path_walk(name, &nd);
+	error = user_path_walk_it(name, &nd);
 	if (!error) {
-		error = vfs_getattr(nd.mnt, nd.dentry, stat);
-		path_release(&nd);
+		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.it, stat);
+                path_release(&nd);
 	}
 	return error;
 }
@@ -73,11 +81,12 @@ int vfs_lstat(char __user *name, struct 
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.it, IT_GETATTR, 0);
 
-	error = user_path_walk_link(name, &nd);
+	error = user_path_walk_link_it(name, &nd);
 	if (!error) {
-		error = vfs_getattr(nd.mnt, nd.dentry, stat);
-		path_release(&nd);
+		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.it, stat);
+                path_release(&nd);
 	}
 	return error;
 }
@@ -86,9 +95,12 @@ int vfs_fstat(unsigned int fd, struct ks
 {
 	struct file *f = fget(fd);
 	int error = -EBADF;
+        struct nameidata nd;
+	intent_init(&nd.it, IT_GETATTR, 0);
 
 	if (f) {
-		error = vfs_getattr(f->f_vfsmnt, f->f_dentry, stat);
+		error = vfs_getattr_it(f->f_vfsmnt, f->f_dentry, &nd.it, stat);
+                intent_release(&nd.it);
 		fput(f);
 	}
 	return error;
--- linux-2.5.72/include/linux/dcache.h~vfs_intent_2.5.72_rev1	2003-06-16 22:20:27.000000000 -0600
+++ linux-2.5.72-braam/include/linux/dcache.h	2003-06-28 14:42:16.000000000 -0600
@@ -4,6 +4,7 @@
 #ifdef __KERNEL__
 
 #include <asm/atomic.h>
+#include <linux/string.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/cache.h>
@@ -12,6 +13,38 @@
 
 struct vfsmount;
 
+#define IT_OPEN     (1)
+#define IT_CREAT    (1<<1)
+#define IT_READDIR  (1<<2)
+#define IT_GETATTR  (1<<3)
+#define IT_LOOKUP   (1<<4)
+#define IT_UNLINK   (1<<5)
+#define IT_GETXATTR (1<<6)
+
+struct nameidata;
+#define INTENT_MAGIC 0x19620323
+struct lookup_intent {
+        int it_op;
+        int it_mode;
+        void (*it_op_release)(struct lookup_intent *);
+        int it_magic;
+        int it_flags;
+        int it_disposition;
+        int it_status;
+        struct iattr *it_iattr;
+        __u64 it_lock_handle[2];
+        int it_lock_mode;
+        void *it_data;
+};
+
+static inline void intent_init(struct lookup_intent *it, int op, int flags)
+{
+        memset(it, 0, sizeof(*it));
+        it->it_magic = INTENT_MAGIC;
+        it->it_op = op;
+        it->it_flags = flags;
+}
+
 /*
  * linux/include/linux/dcache.h
  *
@@ -34,6 +67,8 @@ struct qstr {
 	char name_str[0];
 };
 
+#include <linux/namei.h>
+
 struct dentry_stat_t {
 	int nr_dentry;
 	int nr_unused;
@@ -112,6 +147,7 @@ struct dentry_operations {
 	int (*d_delete)(struct dentry *);
 	void (*d_release)(struct dentry *);
 	void (*d_iput)(struct dentry *, struct inode *);
+ 	int (*d_revalidate_nd)(struct dentry *, int, struct nameidata *);
 };
 
 /* the dentry parameter passed to d_hash and d_compare is the parent
--- linux-2.5.72/include/linux/fs.h~vfs_intent_2.5.72_rev1	2003-06-16 22:19:46.000000000 -0600
+++ linux-2.5.72-braam/include/linux/fs.h	2003-06-29 00:48:28.000000000 -0600
@@ -237,6 +237,8 @@ typedef int (get_blocks_t)(struct inode 
 #define ATTR_ATTR_FLAG	1024
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
+#define ATTR_RAW       	8192    /* file system, not vfs will massage attrs */
+#define ATTR_FROM_OPEN 	16384    /* called from open path, ie O_TRUNC */
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -445,6 +447,7 @@ struct file {
 	/* Used by fs/eventpoll.c to link all the hooks to this file */
 	struct list_head	f_ep_links;
 	spinlock_t		f_ep_lock;
+        struct lookup_intent    *f_it;
 };
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
@@ -731,7 +734,10 @@ struct file_operations {
 
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
+	int (*create_nd) (struct inode *,struct dentry *,int, struct nameidata *);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
+ 	struct dentry * (*lookup_it) (struct inode *,struct dentry *,
+                                      struct nameidata *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
@@ -745,7 +751,9 @@ struct inode_operations {
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int);
 	int (*setattr) (struct dentry *, struct iattr *);
+ 	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+ 	int (*getattr_it) (struct vfsmount *, struct dentry *, struct lookup_intent *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
@@ -958,6 +966,7 @@ extern int register_filesystem(struct fi
 extern int unregister_filesystem(struct file_system_type *);
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount(struct vfsmount *);
+struct vfsmount *do_kern_mount(const char *type, int flags, const char *name, void *data);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 
 extern int vfs_statfs(struct super_block *, struct statfs *);
@@ -1025,6 +1034,7 @@ extern int do_truncate(struct dentry *, 
 
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern struct file * dentry_open_it(struct dentry *, struct vfsmount *, int, struct lookup_intent *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 
--- linux-2.5.72/include/linux/namei.h~vfs_intent_2.5.72_rev1	2003-06-16 22:19:47.000000000 -0600
+++ linux-2.5.72-braam/include/linux/namei.h	2003-06-28 17:47:25.000000000 -0600
@@ -11,6 +11,7 @@ struct nameidata {
 	struct qstr	last;
 	unsigned int	flags;
 	int		last_type;
+        struct lookup_intent it;
 };
 
 /*
@@ -27,24 +28,32 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LA
  *  - locked when lookup done with dcache_lock held
  */
 #define LOOKUP_FOLLOW		 1
-#define LOOKUP_DIRECTORY	 2
-#define LOOKUP_CONTINUE		 4
-#define LOOKUP_PARENT		16
-#define LOOKUP_NOALT		32
+#define LOOKUP_DIRECTORY	 (1<<1)
+#define LOOKUP_CONTINUE		 (1<<2)
+#define LOOKUP_PARENT		 (1<<3)
+#define LOOKUP_NOALT		 (1<<4)
+#define LOOKUP_LAST		 (1<<5)
+#define LOOKUP_LINK_NOTLAST	 (1<<6)
 
 
 extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_it(const char __user *name, unsigned flags, struct nameidata *nd));
 #define user_path_walk(name,nd) \
 	__user_walk(name, LOOKUP_FOLLOW, nd)
 #define user_path_walk_link(name,nd) \
 	__user_walk(name, 0, nd)
+#define user_path_walk_it(name,nd) \
+	__user_walk_it(name, LOOKUP_FOLLOW, nd)
+#define user_path_walk_link_it(name,nd) \
+	__user_walk_it(name, 0, nd)
+extern void intent_release(struct lookup_intent *);
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
 extern void path_release(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
+extern struct dentry * lookup_hash(struct qstr *, struct dentry *, struct nameidata *);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);
--- linux-2.5.72/kernel/ksyms.c~vfs_intent_2.5.72_rev1	2003-06-16 22:19:39.000000000 -0600
+++ linux-2.5.72-braam/kernel/ksyms.c	2003-06-25 08:13:39.000000000 -0600
@@ -375,6 +375,7 @@ EXPORT_SYMBOL(unregister_filesystem);
 EXPORT_SYMBOL(kern_mount);
 EXPORT_SYMBOL(__mntput);
 EXPORT_SYMBOL(may_umount);
+EXPORT_SYMBOL(reparent_to_init);
 
 /* executable format registration */
 EXPORT_SYMBOL(register_binfmt);
@@ -404,6 +405,12 @@ EXPORT_SYMBOL(del_timer);
 EXPORT_SYMBOL(request_irq);
 EXPORT_SYMBOL(free_irq);
 
+/* lustre */
+EXPORT_SYMBOL(do_kern_mount);
+EXPORT_SYMBOL(exit_files);
+//EXPORT_SYMBOL(kmem_cache_validate);
+
+
 /* waitqueue handling */
 EXPORT_SYMBOL(add_wait_queue);
 EXPORT_SYMBOL(add_wait_queue_exclusive);
--- linux-2.5.72/net/unix/af_unix.c~vfs_intent_2.5.72_rev1	2003-06-16 22:20:06.000000000 -0600
+++ linux-2.5.72-braam/net/unix/af_unix.c	2003-06-25 08:13:39.000000000 -0600
@@ -704,7 +704,7 @@ static int unix_bind(struct socket *sock
 		/*
 		 * Do the final lookup.
 		 */
-		dentry = lookup_hash(&nd.last, nd.dentry);
+		dentry = lookup_hash(&nd.last, nd.dentry, NULL);
 		err = PTR_ERR(dentry);
 		if (IS_ERR(dentry))
 			goto out_mknod_unlock;
--- linux-2.5.72/net/sunrpc/rpc_pipe.c~vfs_intent_2.5.72_rev1	2003-06-16 22:19:47.000000000 -0600
+++ linux-2.5.72-braam/net/sunrpc/rpc_pipe.c	2003-06-25 08:13:39.000000000 -0600
@@ -598,7 +598,7 @@ rpc_lookup_negative(char *path, struct n
 		return ERR_PTR(error);
 	dir = nd->dentry->d_inode;
 	down(&dir->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash(&nd->last, nd->dentry, NULL);
 	if (IS_ERR(dentry))
 		goto out_err;
 	if (dentry->d_inode) {
@@ -660,7 +660,7 @@ rpc_rmdir(char *path)
 		return error;
 	dir = nd.dentry->d_inode;
 	down(&dir->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, NULL);
 	if (IS_ERR(dentry)) {
 		error = PTR_ERR(dentry);
 		goto out_release;
@@ -721,7 +721,7 @@ rpc_unlink(char *path)
 		return error;
 	dir = nd.dentry->d_inode;
 	down(&dir->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash(&nd.last, nd.dentry, NULL);
 	if (IS_ERR(dentry)) {
 		error = PTR_ERR(dentry);
 		goto out_release;

_
