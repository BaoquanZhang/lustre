diff -ur linux-2.4.20-rh.orig/drivers/block/ll_rw_blk.c linux-2.4.20-rh/drivers/block/ll_rw_blk.c
--- linux-2.4.20-rh.orig/drivers/block/ll_rw_blk.c	2004-05-27 11:25:09.000000000 -0700
+++ linux-2.4.20-rh/drivers/block/ll_rw_blk.c	2005-04-08 09:02:14.734804881 -0700
@@ -645,6 +645,86 @@ void set_device_ro(kdev_t dev,int flag)
 	else ro_bits[major][minor >> 5] &= ~(1 << (minor & 31));
 }
 
+
+/*
+ * Debug code for turning block devices read-only *silently* (will 
+ * discard writes silently).  This is only for filesystem crash/recovery
+ * testing.
+ */
+struct deventry {
+        kdev_t dev;
+        struct deventry *next;
+};
+
+static struct deventry *devlist = NULL;
+static spinlock_t devlock = SPIN_LOCK_UNLOCKED; 
+
+int dev_check_rdonly(kdev_t dev) {
+        struct deventry *cur;
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (dev == cur->dev) {
+                        spin_unlock(&devlock);
+                        return 1;
+                }
+                cur = cur->next;
+        }
+        spin_unlock(&devlock);
+        return 0;
+}
+
+void dev_set_rdonly(kdev_t dev)
+{
+        struct deventry *newdev, *cur;
+        newdev = kmalloc(sizeof(struct deventry), GFP_KERNEL);
+        if (!newdev) return;
+
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (dev == cur->dev) {
+                        spin_unlock(&devlock);
+                        kfree(newdev);
+                        return;
+                }
+                cur = cur->next;
+        }
+        newdev->dev = dev;
+        newdev->next = devlist;
+        devlist = newdev;
+        spin_unlock(&devlock);
+        printk(KERN_WARNING "Turning device %s read-only\n",
+               bdevname(dev));
+}
+
+void dev_clear_rdonly(kdev_t dev) {
+        struct deventry *cur, *last = NULL;
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (dev == cur->dev) {
+                        if (last) 
+                                last->next = cur->next;
+                        else
+                                devlist = cur->next;
+                        spin_unlock(&devlock);
+                        kfree(cur);
+                        printk(KERN_WARNING "Removing read-only on %s\n",
+                               bdevname(dev));
+                        return;
+                }
+                last = cur;
+                cur = cur->next;
+        }
+        spin_unlock(&devlock);
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
+
+
 inline void drive_stat_acct (kdev_t dev, int rw,
 				unsigned long nr_sectors, int new_io)
 {
@@ -1183,6 +1263,10 @@ void generic_make_request (int rw, struc
 			buffer_IO_error(bh);
 			break;
 		}
+                if ((rw & WRITE)&&(dev_check_rdonly(bh->b_rdev))) {
+                        bh->b_end_io(bh, 0);
+                        break;
+                }
 	} while (q->make_request_fn(q, rw, bh));
 }
 
diff -ur linux-2.4.20-rh.orig/fs/block_dev.c linux-2.4.20-rh/fs/block_dev.c
--- linux-2.4.20-rh.orig/fs/block_dev.c	2002-08-02 17:39:45.000000000 -0700
+++ linux-2.4.20-rh/fs/block_dev.c	2005-04-08 09:02:15.005789333 -0700
@@ -645,6 +645,7 @@ int blkdev_put(struct block_device *bdev
 		bdev->bd_op = NULL;
 	unlock_kernel();
 	up(&bdev->bd_sem);
+       dev_clear_rdonly(to_kdev_t(bdev->bd_dev));
 	bdput(bdev);
 	return ret;
 }
diff -ur linux-2.4.20-rh.orig/include/linux/fs.h linux-2.4.20-rh/include/linux/fs.h
--- linux-2.4.20-rh.orig/include/linux/fs.h	2004-05-27 11:25:09.000000000 -0700
+++ linux-2.4.20-rh/include/linux/fs.h	2005-04-08 09:02:14.915794496 -0700
@@ -1425,6 +1425,10 @@ extern struct buffer_head * getblk(kdev_
 extern void ll_rw_block(int, int, struct buffer_head * bh[]);
 extern void submit_bh(int, struct buffer_head *);
 extern int is_read_only(kdev_t);
+#define HAVE_CLEAR_RDONLY_ON_PUT
+void dev_set_rdonly(kdev_t dev);
+int dev_check_rdonly(kdev_t dev);
+void dev_clear_rdonly(kdev_t dev);
 extern void __brelse(struct buffer_head *);
 static inline void brelse(struct buffer_head *buf)
 {

