 drivers/block/blkpg.c  |   35 +++++++++++++++++++++++++++++++++++
 drivers/block/loop.c   |    3 +++
 drivers/ide/ide-disk.c |    5 +++++
 3 files changed, 43 insertions(+)

--- kernel-2.4.20-6chaos_18_7/drivers/block/blkpg.c~dev_read_only_2.4.20-rh	2003-05-15 21:12:48.000000000 -0600
+++ kernel-2.4.20-6chaos_18_7-braam/drivers/block/blkpg.c	2003-07-12 15:10:31.000000000 -0600
@@ -297,3 +297,38 @@ int blk_ioctl(kdev_t dev, unsigned int c
 }
 
 EXPORT_SYMBOL(blk_ioctl);
+
+#define NUM_DEV_NO_WRITE 16
+static int dev_no_write[NUM_DEV_NO_WRITE];
+
+/*
+ * Debug code for turning block devices "read-only" (will discard writes
+ * silently).  This is for filesystem crash/recovery testing.
+ */
+void dev_set_rdonly(kdev_t dev, int no_write)
+{
+	if (dev) {
+		printk(KERN_WARNING "Turning device %s read-only\n",
+		       bdevname(dev));
+		dev_no_write[no_write] = 0xdead0000 + dev;
+	}
+}
+
+int dev_check_rdonly(kdev_t dev) {
+	int i;
+
+	for (i = 0; i < NUM_DEV_NO_WRITE; i++) {
+		if ((dev_no_write[i] & 0xffff0000) == 0xdead0000 &&
+		    dev == (dev_no_write[i] & 0xffff))
+			return 1;
+	}
+	return 0;
+}
+
+void dev_clear_rdonly(int no_write) {
+	dev_no_write[no_write] = 0;
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
--- kernel-2.4.20-6chaos_18_7/drivers/block/loop.c~dev_read_only_2.4.20-rh	2003-05-15 21:12:50.000000000 -0600
+++ kernel-2.4.20-6chaos_18_7-braam/drivers/block/loop.c	2003-07-12 15:10:31.000000000 -0600
@@ -491,6 +491,9 @@ static int loop_make_request(request_que
 	spin_unlock_irq(&lo->lo_lock);
 
 	if (rw == WRITE) {
+		if (dev_check_rdonly(rbh->b_rdev))
+			goto err;
+
 		if (lo->lo_flags & LO_FLAGS_READ_ONLY)
 			goto err;
 	} else if (rw == READA) {
--- kernel-2.4.20-6chaos_18_7/drivers/ide/ide-disk.c~dev_read_only_2.4.20-rh	2003-05-15 21:13:09.000000000 -0600
+++ kernel-2.4.20-6chaos_18_7-braam/drivers/ide/ide-disk.c	2003-07-12 15:12:03.000000000 -0600
@@ -371,6 +371,11 @@ ide_startstop_t __ide_do_rw_disk (ide_dr
 	if (driver_blocked)
 		panic("Request while ide driver is blocked?");
 
+  	if (rq->cmd == WRITE && dev_check_rdonly(rq->rq_dev)) {
+  		ide_end_request(1, HWGROUP(drive));
+  		return ide_stopped;
+  	}
+
 	if (IDE_CONTROL_REG)
 		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
 

_
