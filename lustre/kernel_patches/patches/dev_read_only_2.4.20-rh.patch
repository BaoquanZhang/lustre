--- linux-2.4.20-rh.orig/drivers/block/ll_rw_blk.c	2005-01-19 10:59:48.000000000 -0800
+++ linux-2.4.20-rh/drivers/block/ll_rw_blk.c	2005-01-19 12:13:39.325347995 -0800
@@ -645,6 +645,86 @@ void set_device_ro(kdev_t dev,int flag)
 	else ro_bits[major][minor >> 5] &= ~(1 << (minor & 31));
 }
 
+
+/*
+ * Debug code for turning block devices read-only *silently* (will 
+ * discard writes silently).  This is only for filesystem crash/recovery
+ * testing.
+ */
+struct deventry {
+        kdev_t dev;
+        struct deventry *next;
+};
+
+static struct deventry *devlist = NULL;
+static spinlock_t devlock = SPIN_LOCK_UNLOCKED; 
+
+int dev_check_rdonly(kdev_t dev) {
+        struct deventry *cur;
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (dev == cur->dev) {
+                        spin_unlock(&devlock);
+                        return 1;
+                }
+                cur = cur->next;
+        }
+        spin_unlock(&devlock);
+        return 0;
+}
+
+void dev_set_rdonly(kdev_t dev)
+{
+        struct deventry *newdev, *cur;
+        newdev = kmalloc(sizeof(struct deventry), GFP_KERNEL);
+        if (!newdev) return;
+
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (dev == cur->dev) {
+                        spin_unlock(&devlock);
+                        kfree(newdev);
+                        return;
+                }
+                cur = cur->next;
+        }
+        newdev->dev = dev;
+        newdev->next = devlist;
+        devlist = newdev;
+        spin_unlock(&devlock);
+        printk(KERN_WARNING "Turning device %s read-only\n",
+               bdevname(dev));
+}
+
+void dev_clear_rdonly(kdev_t dev) {
+        struct deventry *cur, *last = NULL;
+        spin_lock(&devlock);
+        cur = devlist;
+        while(cur) {
+                if (dev == cur->dev) {
+                        if (last) 
+                                last->next = cur->next;
+                        else
+                                devlist = cur->next;
+                        spin_unlock(&devlock);
+                        kfree(cur);
+                        printk(KERN_WARNING "Removing read-only on %s\n",
+                               bdevname(dev));
+                        return;
+                }
+                last = cur;
+                cur = cur->next;
+        }
+        spin_unlock(&devlock);
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
+
+
 inline void drive_stat_acct (kdev_t dev, int rw,
 				unsigned long nr_sectors, int new_io)
 {
@@ -1183,6 +1263,10 @@ void generic_make_request (int rw, struc
 			buffer_IO_error(bh);
 			break;
 		}
+                if ((rw & WRITE)&&(dev_check_rdonly(bh->b_rdev))) {
+                        bh->b_end_io(bh, 0);
+                        break;
+                }
 	} while (q->make_request_fn(q, rw, bh));
 }
 
