Index: linux-2.6.0-test5/drivers/dump/dump_netdev.c
===================================================================
--- linux-2.6.0-test5.orig/drivers/dump/dump_netdev.c	2003-09-27 21:53:32.000000000 +0800
+++ linux-2.6.0-test5/drivers/dump/dump_netdev.c	2003-09-30 22:26:22.709337152 +0800
@@ -14,6 +14,7 @@
  *
  * Copyright (C) 2001  Ingo Molnar <mingo@redhat.com>
  * Copyright (C) 2002 International Business Machines Corp. 
+ * Rewrited with netpoll by wangdi <wangdi@clusterfs.com>
  *
  *  This code is released under version 2 of the GNU GPL.
  */
@@ -26,29 +27,19 @@
 #include <linux/module.h>
 #include <linux/dump.h>
 #include <linux/dump_netdev.h>
+#include <linux/netpoll.h>
 
 #include <asm/unaligned.h>
 
 static int startup_handshake;
 static int page_counter;
-static struct net_device *dump_ndev;
 static struct in_device *dump_in_dev;
-static u16 source_port, target_port;
-static u32 source_ip, target_ip;
-static unsigned char daddr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff} ;
-static spinlock_t dump_skb_lock = SPIN_LOCK_UNLOCKED;
-static int dump_nr_skbs;
-static struct sk_buff *dump_skb;
 static unsigned long flags_global;
 static int netdump_in_progress;
 static char device_name[IFNAMSIZ];
+int new_req = 0;
+static req_t req;
 
-/*
- * security depends on the trusted path between the netconsole
- * server and netconsole client, since none of the packets are
- * encrypted. The random magic number protects the protocol
- * against spoofing.
- */
 static u64 dump_magic;
 
 #define MAX_UDP_CHUNK 1460
@@ -64,300 +55,26 @@
 #define MAX_SKB_SIZE \
 		(MAX_UDP_CHUNK + sizeof(struct udphdr) + \
 				sizeof(struct iphdr) + sizeof(struct ethhdr))
+static char send_buffer[MAX_UDP_CHUNK];
 
-static void
-dump_refill_skbs(void)
-{
-	struct sk_buff *skb;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dump_skb_lock, flags);
-	while (dump_nr_skbs < DUMP_MAX_SKBS) {
-		skb = alloc_skb(MAX_SKB_SIZE, GFP_ATOMIC);
-		if (!skb)
-			break;
-		if (dump_skb)
-			skb->next = dump_skb;
-		else
-			skb->next = NULL;
-		dump_skb = skb;
-		dump_nr_skbs++;
-	}
-	spin_unlock_irqrestore(&dump_skb_lock, flags);
-}
-
-static struct
-sk_buff * dump_get_skb(void)
-{
-	struct sk_buff *skb;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dump_skb_lock, flags);
-	skb = dump_skb;
-	if (skb) {
-		dump_skb = skb->next;
-		skb->next = NULL;
-		dump_nr_skbs--;
-	}
-	spin_unlock_irqrestore(&dump_skb_lock, flags);
-        
-	return skb;
-}
-
-/*
- * Zap completed output skbs.
- */
-static void
-zap_completion_queue(void)
-{
-	int count;
-	unsigned long flags;
-	int cpu = smp_processor_id();
-	struct softnet_data *softnet_data;
-       	
-
-	softnet_data = &__get_cpu_var(softnet_data);
-	count=0;
-	if (softnet_data[cpu].completion_queue) {
-		struct sk_buff *clist;
-	
-		local_irq_save(flags);
-		clist = softnet_data[cpu].completion_queue;
-		softnet_data[cpu].completion_queue = NULL;
-		local_irq_restore(flags);
-
-		while (clist != NULL) {
-			struct sk_buff *skb = clist;
-			clist = clist->next;
-			__kfree_skb(skb);
-			count++;
-			if (count > 10000)
-				printk("Error in sk list\n");
-		}
-	}
-}
-
-static void
-dump_send_skb(struct net_device *dev, const char *msg, unsigned int msg_len,
-		reply_t *reply)
-{
-	int once = 1;
-	int total_len, eth_len, ip_len, udp_len, count = 0;
-	struct sk_buff *skb;
-	struct udphdr *udph;
-	struct iphdr *iph;
-	struct ethhdr *eth; 
-
-	udp_len = msg_len + HEADER_LEN + sizeof(*udph);
-	ip_len = eth_len = udp_len + sizeof(*iph);
-	total_len = eth_len + ETH_HLEN;
-
-repeat_loop:
-	zap_completion_queue();
-	if (dump_nr_skbs < DUMP_MAX_SKBS)
-		dump_refill_skbs();
-
-	skb = alloc_skb(total_len, GFP_ATOMIC);
-	if (!skb) {
-		skb = dump_get_skb();
-		if (!skb) {
-			count++;
-			if (once && (count == 1000000)) {
-				printk("possibly FATAL: out of netconsole "
-					"skbs!!! will keep retrying.\n");
-				once = 0;
-			}
-			dev->poll_controller(dev);
-			goto repeat_loop;
-		}
-	}
-
-	atomic_set(&skb->users, 1);
-	skb_reserve(skb, total_len - msg_len - HEADER_LEN);
-	skb->data[0] = NETCONSOLE_VERSION;
-
-	put_unaligned(htonl(reply->nr), (u32 *) (skb->data + 1));
-	put_unaligned(htonl(reply->code), (u32 *) (skb->data + 5));
-	put_unaligned(htonl(reply->info), (u32 *) (skb->data + 9));
-
-	memcpy(skb->data + HEADER_LEN, msg, msg_len);
-	skb->len += msg_len + HEADER_LEN;
-
-	udph = (struct udphdr *) skb_push(skb, sizeof(*udph));
-	udph->source = source_port;
-	udph->dest = target_port;
-	udph->len = htons(udp_len);
-	udph->check = 0;
-
-	iph = (struct iphdr *)skb_push(skb, sizeof(*iph));
-
-	iph->version  = 4;
-	iph->ihl      = 5;
-	iph->tos      = 0;
-	iph->tot_len  = htons(ip_len);
-	iph->id       = 0;
-	iph->frag_off = 0;
-	iph->ttl      = 64;
-	iph->protocol = IPPROTO_UDP;
-	iph->check    = 0;
-	iph->saddr    = source_ip;
-	iph->daddr    = target_ip;
-	iph->check    = ip_fast_csum((unsigned char *)iph, iph->ihl);
-
-	eth = (struct ethhdr *) skb_push(skb, ETH_HLEN);
-
-	eth->h_proto = htons(ETH_P_IP);
-	memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
-	memcpy(eth->h_dest, daddr, dev->addr_len);
+extern void handle_sysrq(int key, struct pt_regs *pt_regs, struct tty_struct *tty);
+static void dump_rx_hook(struct netpoll *np, int port, char *msg, int len);
 
-	count=0;
-repeat_poll:
-	spin_lock(&dev->xmit_lock);
-	dev->xmit_lock_owner = smp_processor_id();
-
-	count++;
-
-
-	if (netif_queue_stopped(dev)) {
-		dev->xmit_lock_owner = -1;
-		spin_unlock(&dev->xmit_lock);
-
-		dev->poll_controller(dev);
-		zap_completion_queue();
-
-
-		goto repeat_poll;
-	}
-
-	dev->hard_start_xmit(skb, dev);
-
-	dev->xmit_lock_owner = -1;
-	spin_unlock(&dev->xmit_lock);
-}
-
-static unsigned short
-udp_check(struct udphdr *uh, int len, unsigned long saddr, unsigned long daddr,
-	       	unsigned long base)
-{
-	return csum_tcpudp_magic(saddr, daddr, len, IPPROTO_UDP, base);
-}
-
-static int
-udp_checksum_init(struct sk_buff *skb, struct udphdr *uh,
-			     unsigned short ulen, u32 saddr, u32 daddr)
-{
-	if (uh->check == 0) {
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-	} else if (skb->ip_summed == CHECKSUM_HW) {
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-		if (!udp_check(uh, ulen, saddr, daddr, skb->csum))
-			return 0;
-		skb->ip_summed = CHECKSUM_NONE;
-	}
-	if (skb->ip_summed != CHECKSUM_UNNECESSARY)
-		skb->csum = csum_tcpudp_nofold(saddr, daddr, ulen,
-				IPPROTO_UDP, 0);
-	/* Probably, we should checksum udp header (it should be in cache
-	 * in any case) and data in tiny packets (< rx copybreak).
-	 */
-	return 0;
-}
-
-static __inline__ int
-__udp_checksum_complete(struct sk_buff *skb)
-{
-	return (unsigned short)csum_fold(skb_checksum(skb, 0, skb->len,
-				skb->csum));
-}
-
-static __inline__
-int udp_checksum_complete(struct sk_buff *skb)
-{
-	return skb->ip_summed != CHECKSUM_UNNECESSARY &&
-		__udp_checksum_complete(skb);
-}
-
-int new_req = 0;
-static req_t req;
+static struct netpoll np = {
+	.name = "netdumpoe",
+	.dev_name = "eth0",
+	.rx_hook = dump_rx_hook,
+	.local_port = 0,
+	.remote_port = 0,
+	.remote_mac = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
+};
 
-static int
-dump_rx_hook(struct sk_buff *skb)
+static void dump_rx_hook(struct netpoll *np, int port, char *msg, int len)
 {
-	int proto;
-	struct iphdr *iph;
-	struct udphdr *uh;
-	__u32 len, saddr, daddr, ulen;
 	req_t *__req;
+	
+	__req = (req_t *)msg;
 
-	/* 
-	 * First check if were are dumping or doing startup handshake, if
-	 * not quickly return.
-	 */
-	if (!netdump_in_progress)
-		return NET_RX_SUCCESS;
-
-	if (skb->dev->type != ARPHRD_ETHER)
-		goto out;
-
-	proto = ntohs(skb->mac.ethernet->h_proto);
-	if (proto != ETH_P_IP)
-		goto out;
-
-	if (skb->pkt_type == PACKET_OTHERHOST)
-		goto out;
-
-	if (skb_shared(skb))
-		goto out;
-
-	 /* IP header correctness testing: */
-	iph = (struct iphdr *)skb->data;
-	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
-		goto out;
-
-	if (iph->ihl < 5 || iph->version != 4)
-		goto out;
-
-	if (!pskb_may_pull(skb, iph->ihl*4))
-		goto out;
-
-	if (ip_fast_csum((u8 *)iph, iph->ihl) != 0)
-		goto out;
-
-	len = ntohs(iph->tot_len);
-	if (skb->len < len || len < iph->ihl*4)
-		goto out;
-
-	saddr = iph->saddr;
-	daddr = iph->daddr;
-	if (iph->protocol != IPPROTO_UDP)
-		goto out;
-
-	if (source_ip != daddr)
-		goto out;
-
-	if (target_ip != saddr)
-		goto out;
-
-	len -= iph->ihl*4;
-	uh = (struct udphdr *)(((char *)iph) + iph->ihl*4);
-	ulen = ntohs(uh->len);
-
-	if (ulen != len || ulen < (sizeof(*uh) + sizeof(*__req)))
-		goto out;
-
-	if (udp_checksum_init(skb, uh, ulen, saddr, daddr) < 0)
-		goto out;
-
-	if (udp_checksum_complete(skb))
-		goto out;
-
-	if (source_port != uh->dest)
-		goto out;
-
-	if (target_port != uh->source)
-		goto out;
-
-	__req = (req_t *)(uh + 1);
 	if ((ntohl(__req->command) != COMM_GET_MAGIC) &&
 	    (ntohl(__req->command) != COMM_HELLO) &&
 	    (ntohl(__req->command) != COMM_START_WRITE_NETDUMP_ACK) &&
@@ -372,11 +89,27 @@
 	req.nr = ntohl(__req->nr);
 	new_req = 1;
 out:
-	return NET_RX_DROP;
+	return;
 }
 
 static void
-dump_send_mem(struct net_device *dev, req_t *req, const char* buff, size_t len)
+dump_send_skb(const char *msg, unsigned int msg_len, reply_t *reply)
+{
+	/*copy the msg to send buffer*/
+	send_buffer[0] = NETCONSOLE_VERSION;
+
+	put_unaligned(htonl(reply->nr), (u32 *) (send_buffer + 1));
+	put_unaligned(htonl(reply->code), (u32 *) (send_buffer + 5));
+	put_unaligned(htonl(reply->info), (u32 *) (send_buffer + 9));
+	memcpy(send_buffer + 1 + sizeof(reply_t), msg, msg_len);
+
+	if (!np.dev)
+		return;
+	netpoll_send_udp(&np, send_buffer, (msg_len + 1 + sizeof(reply_t)));
+}
+
+static void
+dump_send_mem( req_t *req, const char* buff, size_t len)
 {
 	int i;
 
@@ -392,7 +125,7 @@
 		unsigned int offset = i*1024;
 		reply.code = REPLY_MEM;
 		reply.info = offset;
-                dump_send_skb(dev, buff + offset, 1024, &reply);
+                dump_send_skb(buff + offset, 1024, &reply);
 	}
 }
 static void dump_do_sysrq(int key)
@@ -400,9 +133,16 @@
         struct pt_regs regs;
         
 	get_current_regs(&regs);
-	handle_sysrq(key, &regs, NULL, NULL);
+	handle_sysrq(key, &regs, NULL);
 }
 
+static void netdump_netpoll_poll(struct netpoll *np)
+{
+	/*FIXME netpoll_set_trap(0) may have impacts to other parts */
+	netpoll_set_trap(1);
+	netpoll_poll(np);
+	netpoll_set_trap(0);
+}
 /*
  * This function waits for the client to acknowledge the receipt
  * of the netdump startup reply, with the possibility of packets
@@ -433,24 +173,27 @@
 	
 	/* send 300 handshake packets before declaring failure */
 	for (i = 0; i < 300; i++) {
-		dump_send_skb(dump_ndev, tmp, strlen(tmp), &reply);
-
+		dump_send_skb(tmp, strlen(tmp), &reply);
+#if 0
 		/* wait 1 sec */
+			udelay(100);
+			netpoll_poll(&np);
+			if (new_req)
+				break;
+		}
+#endif
 		for (j = 0; j < 10000; j++) {
 			udelay(100);
-			dump_ndev->poll_controller(dump_ndev);
-			zap_completion_queue();
+			netdump_netpoll_poll(&np);
 			if (new_req)
 				break;
 		}
-
 		/* 
 		 * if there is no new request, try sending the handshaking
 		 * packet again
 		 */
 		if (!new_req)
 			continue;
-
 		/* 
 		 * check if the new request is of the expected type,
 		 * if so, return, else try sending the handshaking
@@ -504,10 +247,12 @@
 	repeatCounter = 0;
 	total_loop = 0;
 	while (1) {
-                if (!new_req) {
-			dump_ndev->poll_controller(dump_ndev);
-			zap_completion_queue();
+                while (!new_req) {
+			netdump_netpoll_poll(&np);
+			if (new_req)
+				break;
 		}
+#if 0
 		if (!new_req) {
 			repeatCounter++;
 
@@ -532,13 +277,15 @@
 		repeatCounter = 0;
 		counter = 0;
 		total_loop = 0;
+#endif
+		
 		new_req = 0;
 		switch (req.command) {
 		case COMM_NONE:
 			break;
 
 		case COMM_SEND_MEM:
-			dump_send_mem(dump_ndev, &req, buff, len);
+			dump_send_mem(&req, buff, len);
 			break;
 
 		case COMM_EXIT:
@@ -549,10 +296,11 @@
 		case COMM_HELLO:
 			sprintf(tmp, "Hello, this is netdump version "
 					"0.%02d\n", NETCONSOLE_VERSION);
+			
 			reply.code = REPLY_HELLO;
 			reply.nr = req.nr;
                         reply.info = net_dev->curr_offset;
-			dump_send_skb(dump_ndev, tmp, strlen(tmp), &reply);
+			dump_send_skb(tmp, strlen(tmp), &reply);
 			break;
 
 		case COMM_GET_PAGE_SIZE:
@@ -560,7 +308,7 @@
 			reply.code = REPLY_PAGE_SIZE;
 			reply.nr = req.nr;
 			reply.info = PAGE_SIZE;
-			dump_send_skb(dump_ndev, tmp, strlen(tmp), &reply);
+			dump_send_skb(tmp, strlen(tmp), &reply);
 			break;
 
 		case COMM_GET_NR_PAGES:
@@ -569,15 +317,14 @@
 			reply.info = num_physpages;
                         reply.info = page_counter;
 			sprintf(tmp, "Number of pages: %ld\n", num_physpages);
-			dump_send_skb(dump_ndev, tmp, strlen(tmp), &reply);
+			dump_send_skb(tmp, strlen(tmp), &reply);
 			break;
 
 		case COMM_GET_MAGIC:
 			reply.code = REPLY_MAGIC;
 			reply.nr = req.nr;
 			reply.info = NETCONSOLE_VERSION;
-			dump_send_skb(dump_ndev, (char *)&dump_magic,
-					sizeof(dump_magic), &reply);
+			dump_send_skb((char *)&dump_magic, sizeof(dump_magic), &reply);
 			break;
                 case COMM_SYSRQ:
 			dump_do_sysrq(req.from);
@@ -585,7 +332,7 @@
 			reply.nr = req.nr;
 			reply.info = req.from;
 			sprintf(tmp, "SYSRQ command %d \n", req.from);
-			dump_send_skb(dump_ndev, tmp, strlen(tmp), &reply);
+			dump_send_skb(tmp, strlen(tmp), &reply);
 			break;
 		default:
 			reply.code = REPLY_ERROR;
@@ -593,7 +340,7 @@
 			reply.info = req.command;
 			sprintf(tmp, "Got unknown command code %d!\n",
 					req.command);
-			dump_send_skb(dump_ndev, tmp, strlen(tmp), &reply);
+			dump_send_skb(tmp, strlen(tmp), &reply);
 			break;
 		}
 	}
@@ -605,45 +352,45 @@
 static int
 dump_validate_config(void)
 {
-	source_ip = dump_in_dev->ifa_list->ifa_local;
-	if (!source_ip) {
+#if 0
+	np.local_ip = dump_in_dev->ifa_list->ifa_local;
+	if (!np.local_ip) {
 		printk("network device %s has no local address, "
 				"aborting.\n", device_name);
 		return -1;
 	}
-
-#define IP(x) ((unsigned char *)&source_ip)[x]
+#endif
+#define IP(x) ((unsigned char *)&np.local_ip)[x]
 	printk("Source %d.%d.%d.%d", IP(0), IP(1), IP(2), IP(3));
 #undef IP
 
-	if (!source_port) {
+	if (!np.local_port) {
 		printk("source_port parameter not specified, aborting.\n");
 		return -1;
 	}
-	printk(":%i\n", source_port);
-	source_port = htons(source_port);
+	printk(":%i\n", np.local_port);
 
-	if (!target_ip) {
+	if (!np.remote_ip) {
 		printk("target_ip parameter not specified, aborting.\n");
 		return -1;
 	}
 
-#define IP(x) ((unsigned char *)&target_ip)[x]
+#define IP(x) ((unsigned char *)&np.remote_ip)[x]
 	printk("Target %d.%d.%d.%d", IP(0), IP(1), IP(2), IP(3));
 #undef IP
 
-	if (!target_port) {
+	if (!np.remote_port) {
 		printk("target_port parameter not specified, aborting.\n");
 		return -1;
 	}
-	printk(":%i\n", target_port);
-	target_port = htons(target_port);
+	printk(":%i\n", np.remote_port);
 
 	printk("Target Ethernet Address %02x:%02x:%02x:%02x:%02x:%02x",
-		daddr[0], daddr[1], daddr[2], daddr[3], daddr[4], daddr[5]);
+		np.remote_mac[0], np.remote_mac[1], np.remote_mac[2], 
+		np.remote_mac[3], np.remote_mac[4], np.remote_mac[5]);
 
-	if ((daddr[0] & daddr[1] & daddr[2] & daddr[3] & daddr[4] & 
-				daddr[5]) == 255)
+	if ((np.remote_mac[0] & np.remote_mac[1] & np.remote_mac[2] & 
+		np.remote_mac[3] & np.remote_mac[4] & np.remote_mac[5]) == 255)
 		printk("(Broadcast)");
 	printk("\n");
 	return 0;
@@ -659,31 +406,24 @@
 dump_net_open(struct dump_dev *net_dev, unsigned long arg)
 {
 	int retval = 0;
-
+#if 0
 	/* get the interface name */
 	if (copy_from_user(device_name, (void *)arg, IFNAMSIZ))
 		return -EFAULT;
 
-	if (!(dump_ndev = dev_get_by_name(device_name))) {
+	if (!(np.dev = dev_get_by_name(device_name))) {
 		printk("network device %s does not exist, aborting.\n",
 				device_name);
 		return -ENODEV;
 	}
-
-	if (!dump_ndev->poll_controller) {
-		printk("network device %s does not implement polling yet, "
-				"aborting.\n", device_name);
-		retval = -1; /* return proper error */
-		goto err1;
-	}
-
-	if (!(dump_in_dev = in_dev_get(dump_ndev))) {
+#endif
+	if (!(dump_in_dev = in_dev_get(np.dev))) {
 		printk("network device %s is not an IP protocol device, "
 				"aborting.\n", device_name);
 		retval = -EINVAL;
 		goto err1;
 	}
-
+	
 	if ((retval = dump_validate_config()) < 0)
 		goto err2;
 
@@ -694,7 +434,7 @@
 err2:
 	in_dev_put(dump_in_dev);
 err1:
-	dev_put(dump_ndev);	
+	dev_put(np.dev);	
 	return retval;
 }
 
@@ -707,8 +447,8 @@
 {
 	if (dump_in_dev)
 		in_dev_put(dump_in_dev);
-	if (dump_ndev)
-		dev_put(dump_ndev);
+	if (np.dev)
+		dev_put(np.dev);
 	return 0;
 }
 
@@ -720,7 +460,6 @@
 dump_net_silence(struct dump_dev *net_dev)
 {
 	local_irq_save(flags_global);
-	dump_ndev->rx_hook = dump_rx_hook;
         startup_handshake = 1;
 	net_dev->curr_offset = 0;
 	printk("Dumping to network device %s on CPU %d ...\n", device_name,
@@ -740,7 +479,7 @@
 	reply_t reply;
 	char tmp[200];
 
-        if (!dump_ndev)
+        if (!np.dev)
 		return (0);
 
 	sprintf(tmp, "NETDUMP end.\n");
@@ -748,11 +487,10 @@
 		reply.code = REPLY_END_NETDUMP;
 		reply.nr = 0;
 		reply.info = 0;
-		dump_send_skb(dump_ndev, tmp, strlen(tmp), &reply);
+		dump_send_skb(tmp, strlen(tmp), &reply);
 	}
 	printk("NETDUMP END!\n");
 	local_irq_restore(flags_global);
-	dump_ndev->rx_hook = NULL;
 	startup_handshake = 0;
 	return 0;
 }
@@ -809,18 +547,19 @@
 static int
 dump_net_ioctl(struct dump_dev *net_dev, unsigned int cmd, unsigned long arg)
 {
+	#if 0
 	switch (cmd) {
 	case DIOSTARGETIP:
-		target_ip = arg;
+		np.remote_ip = arg;
 		break;
 	case DIOSTARGETPORT:
-		target_port = (u16)arg;
+		np.remote_port = (u16)arg;
 		break;
 	case DIOSSOURCEPORT:
-		source_port = (u16)arg;
+		np.local_port = (u16)arg;
 		break;
 	case DIOSETHADDR:
-		return copy_from_user(daddr, (void *)arg, 6);
+		return copy_from_user(np.remote_mac, (void *)arg, 6);
 		break;
 	case DIOGTARGETIP:
 	case DIOGTARGETPORT:
@@ -830,6 +569,7 @@
 	default:
 		return -EINVAL;
 	}
+	#endif
 	return 0;
 }
 
@@ -851,17 +591,28 @@
 	.curr_offset = 0
 };
 
+static int option_setup(char *opt)
+{
+	return netpoll_parse_options(&np, opt);
+}
+
+__setup("netdumpoe=", option_setup);
+
+
 static int __init
 dump_netdev_init(void)
 {
         default_dump_netdev.curr_offset = 0;
 
+	if(!np.remote_ip || netpoll_setup(&np))
+		return 1;
+
 	if (dump_register_device(&default_dump_netdev) < 0) {
 		printk("network dump device driver registration failed\n");
 		return -1;
 	}
 	printk("network device driver for LKCD registered\n");
- 
+
 	get_random_bytes(&dump_magic, sizeof(dump_magic));
 	return 0;
 }
@@ -870,6 +621,7 @@
 dump_netdev_cleanup(void)
 {
 	dump_unregister_device(&default_dump_netdev);
+	netpoll_cleanup(&np);
 }
 
 MODULE_AUTHOR("LKCD Development Team <lkcd-devel@lists.sourceforge.net>");
