--- lustre/extN/inode.orig.c	2002-12-29 18:48:56.000000000 +0800
+++ lustre/extN/inode.c	2002-12-29 19:17:24.000000000 +0800
@@ -2728,3 +2728,85 @@
  * here, in extN_aops_journal_start() to ensure that the forthcoming "see if we
  * need to extend" test in extN_prepare_write() succeeds.  
  */
+
+/* for each block: 1 ind + 1 dind + 1 tind
+ * for each block: 3 bitmap blocks
+ * for each block: 3 group descriptor blocks
+ * i inode block
+ * 1 superblock
+ * 2 * EXTN_SINGLEDATA_TRANS_BLOCKS for the quote files
+ * ((1+1+1) * 3 * nblocks) + 1 + 1 + 2 * EXTN_SINGLEDATA_TRANS_BLOCKS
+ *
+ * XXX assuming:
+ * (1) fs logic block size == page size
+ * (2) extN in writeback mode
+ */
+static inline int extN_san_write_trans_blocks(int nblocks)
+{
+	int ret;
+	
+	ret = (1 + 1 + 1) * 3 * nblocks + 1 + 1;
+
+#ifdef CONFIG_QUOTA
+	ret += 2 * EXTN_SINGLEDATA_TRANS_BLOCKS;
+#endif
+
+	return ret;
+}
+
+/* Alloc blocks for an inode, while don't create any buffer/page
+ * for data I/O; set the inode size if file is extended.
+ *
+ * @inode:    target inode
+ * @blocks:   array of logic block number
+ * @nblocks:  how many blocks need be alloced
+ * @newsize:  new filesize we should set
+ *
+ * return:    0 success, otherwise failed
+ *            (*blocks) contains physical block number alloced
+ *
+ * XXX this assume the fs block size == page size
+ */
+int extN_prep_san_write(struct inode *inode, long *blocks,
+			int nblocks, loff_t newsize)
+{
+	handle_t *handle;
+	struct buffer_head bh_tmp;
+	int needed_blocks;
+	int i, ret = 0, ret2;
+
+	needed_blocks = extN_san_write_trans_blocks(nblocks);
+
+	lock_kernel();
+	handle = extN_journal_start(inode, needed_blocks);
+	if (IS_ERR(handle)) {
+		unlock_kernel();
+		return PTR_ERR(handle);
+	}
+	unlock_kernel();
+
+	/* alloc blocks one by one */
+	for (i = 0; i < nblocks; i++) {
+		ret = extN_get_block_handle(handle, inode, blocks[i],
+						&bh_tmp, 1);
+		if (ret)
+			break;
+
+		blocks[i] = bh_tmp.b_blocknr;
+	}
+
+	/* set inode size if needed */
+	if (!ret && (newsize > inode->i_size)) {
+		inode->i_size = newsize;
+		extN_mark_inode_dirty(handle, inode);
+	}
+
+	lock_kernel();
+	ret2 = extN_journal_stop(handle, inode);
+	unlock_kernel();
+
+	if (!ret)
+		ret = ret2;
+	return ret;
+}
+EXPORT_SYMBOL(extN_prep_san_write);
