#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>
#include <errno.h>

const char usage_fmt[] = "Usage: %s <mountpoint>\n";
#define INAME_LEN (PATH_MAX + 1)
const char *progname;

#define CHECK_IT(exp, pstr) \
if (!(exp)) { \
    fprintf(stderr, "%s: at %s:%d: ", progname, __FILE__, __LINE__); \
    perror((pstr)); \
    exit(1); \
}

#define CHECK_SNPRINTF(rc, len) \
    CHECK_IT((rc) > 0 && (rc) <= (len), "snprintf() failed")

static char *get_iname(char *fname, const char *mtpt)
{
        char *iname;
        int fd, rc;
        struct stat buf;

        iname = malloc(INAME_LEN);
        CHECK_IT(iname, "malloc() failed");

        fd = open(fname, O_CREAT, 0644);
        CHECK_IT(fd >= 0 || errno == EISDIR, "open(fname) failed");

        if (fd >= 0)
                close(fd);

        rc = stat(fname, &buf);
        CHECK_IT(rc == 0, "stat(fname) failed");

        rc = snprintf(iname, INAME_LEN,
                      "%s/__iopen__/%lu", mtpt, buf.st_ino);
        CHECK_SNPRINTF(rc, INAME_LEN);

        return iname;
}

int main(int argc, char *argv[])
{
        char *fname, *mtpt, *pname;
        int rc, fd;
        char *fname_iname, *dir;
        char *dir_iname = NULL, *foo = NULL, *bar = NULL;

        int i,j;
        int thread=0;

        pname = strdup(argv[0]);
        progname = basename(argv[0]);
                                                                                                                             
        if (argc != 2) {
                fprintf(stderr, usage_fmt, progname);
                return 1;
        }
 
        for(i=1;i<=10;i++) {
                rc=fork();
                if (rc < 0) {
                        fprintf(stderr, "error: %s: #%ld - %s\n", argv[0], i,
                                strerror(rc = errno));
                        break;
                } else if (rc == 0) {
                        thread = i;
                        break;
                } else {
                        printf("%s: thread #%ld (PID %d) started\n",
                               argv[0], i, rc);
                }
                rc = 0;
        }

        if (thread!=0){
                j=1000;

                mtpt  = argv[1];
                fname = malloc(INAME_LEN);
                CHECK_IT(fname, "malloc() failed");

                rc = snprintf(fname, INAME_LEN,
                              "%s/%d", mtpt, getpid());
                CHECK_SNPRINTF(rc, INAME_LEN);

                rc = mkdir(fname, 0644);
                CHECK_IT(rc == 0, "mkdir(fname) failed");

                fname_iname = get_iname(fname, mtpt);

                dir = malloc(INAME_LEN);
                CHECK_IT(dir, "malloc() failed");

                rc = snprintf(dir, INAME_LEN,
                              "%s/dir", fname_iname);
                CHECK_SNPRINTF(rc, INAME_LEN);

                foo = malloc(INAME_LEN);
                CHECK_IT(foo, "malloc() failed");

                bar = malloc(INAME_LEN);
                CHECK_IT(bar, "malloc() failed");

                do {
                        rc = mkdir(dir, 0644);
                        CHECK_IT(rc == 0, "mkdir() failed");

                        dir_iname = get_iname(dir, mtpt);
		
                        rc = snprintf(foo, INAME_LEN,
                                      "%s/bar", dir_iname);
                        CHECK_SNPRINTF(rc, INAME_LEN);
		
                        rc = snprintf(bar, INAME_LEN,
                                      "%s/bar", dir_iname);
                        CHECK_SNPRINTF(rc, INAME_LEN);

                        fd = open(foo, O_CREAT, 0644);
                        CHECK_IT(fd >= 0, "open(foo) failed");
                        close(fd);

                        rc = rename(foo, bar);
                        CHECK_IT(rc == 0, "rename(foo, bar) failed");

                        rc = unlink(bar);
                        CHECK_IT(rc == 0, "unlink(bar) failed");
                        rc = rmdir(dir);
                        CHECK_IT(rc == 0, "rmdir(dir) failed");

                        free(dir_iname);
                        j--;
                } while (j>=1);
        }
        return 0;
}
