--- kernel-rh-2.4.18-pristine/drivers/quadrics/elan3comms/epcomms.c	Thu Jun 13 12:26:50 2002
+++ kernel-rh-2.4.18/drivers/quadrics/elan3comms/epcomms.c	Thu Jun 20 11:24:56 2002
@@ -2249,7 +2249,7 @@
 	if (EP_EVENT_FIRING (edev, txdElan + offsetof (EP_TXD_ELAN, DataEvent), txd->DataCookie, txdMain->DataEvent) &&	/* PCI read */
 	    EP_EVENT_FIRING (edev, txdElan + offsetof (EP_TXD_ELAN, EnveEvent), txd->EnveCookie, txdMain->EnveEvent))		/* PCI read */
 	{
-	    if (delay == 1)
+	    if (0 /* delay == 1 */)
 		printf ("LargeTxDataEvent: events set but block copy not completed\n");
 	    if (delay > EP_EVENT_FIRING_TLIMIT)
 		panic ("LargeTxDataEvent: events set but block copy not completed\n");
@@ -2438,7 +2438,7 @@
 	
 	if (EP_EVENT_FIRING (edev, rxdElan + offsetof (EP_RXD_ELAN, DataEvent), rxd->DataCookie, rxdMain->DataEvent))	/* PCI read */
 	{
-	    if (delay == 1)
+	    if (0 /* delay == 1 */)
 		printf ("LargeRxDataEvent: events set but block copy not completed\n");
 	    if (delay > EP_EVENT_FIRING_TLIMIT)
 		panic ("LargeRxDataEvent: events set but block copy not completed\n");
--- kernel-rh-2.4.18-pristine/scripts/mkspec	Thu Jun 13 12:27:18 2002
+++ kernel-rh-2.4.18/scripts/mkspec	Thu Jun 20 11:24:56 2002
@@ -41,6 +41,7 @@
 echo 'mkdir -p $RPM_BUILD_ROOT/boot $RPM_BUILD_ROOT/lib $RPM_BUILD_ROOT/lib/modules'
 echo 'INSTALL_MOD_PATH=$RPM_BUILD_ROOT make modules_install'
 echo 'cp arch/i386/boot/bzImage $RPM_BUILD_ROOT'"/boot/vmlinuz-$VERSION.$PATCHLEVEL.$SUBLEVEL$EXTRAVERSION"
+echo 'cp vmlinux $RPM_BUILD_ROOT'"/boot/vmlinux-$VERSION.$PATCHLEVEL.$SUBLEVEL$EXTRAVERSION"
 echo 'cp System.map $RPM_BUILD_ROOT'"/boot/System.map-$VERSION.$PATCHLEVEL.$SUBLEVEL$EXTRAVERSION"
 echo ""
 echo "%clean"
--- kernel-rh-2.4.18-pristine/arch/ia64/mm/init.c	Thu Jun 13 12:26:28 2002
+++ kernel-rh-2.4.18/arch/ia64/mm/init.c	Thu Jun 20 14:49:08 2002
@@ -37,6 +37,12 @@
 
 static unsigned long totalram_pages;
 
+struct page *check_get_page(unsigned long kaddr)
+{
+#warning FIXME: Lustre team, is this solid?
+        return virt_to_page(kaddr);
+}
+
 int
 do_check_pgt_cache (int low, int high)
 {
--- kernel-rh-2.4.18-pristine/arch/i386/mm/init.c	Thu Jun 13 12:26:28 2002
+++ kernel-rh-2.4.18/arch/i386/mm/init.c	Thu Jun 20 11:24:56 2002
@@ -43,6 +43,14 @@
 static unsigned long totalram_pages;
 static unsigned long totalhigh_pages;
 
+
+struct page *check_get_page(unsigned long kaddr)
+{
+#warning FIXME: Lustre team, is this solid enough?
+        return virt_to_page(kaddr);
+}
+
+
 int do_check_pgt_cache(int low, int high)
 {
 	int freed = 0;
--- kernel-rh-2.4.18-pristine/mm/slab.c	Thu Jun 13 12:27:15 2002
+++ kernel-rh-2.4.18/mm/slab.c	Thu Jun 20 11:24:56 2002
@@ -1216,6 +1216,60 @@
  * Called with the cache-lock held.
  */
 
+extern struct page *check_get_page(unsigned long kaddr);
+struct page *page_mem_map(struct page *page);
+static int kmem_check_cache_obj (kmem_cache_t * cachep,
+                                 slab_t *slabp, void * objp)
+{
+	int i;
+	unsigned int objnr;
+#if DEBUG
+	if (cachep->flags & SLAB_RED_ZONE) {
+		objp -= BYTES_PER_WORD;
+		if ( *(unsigned long *)objp != RED_MAGIC2)
+			/* Either write before start, or a double free. */
+                        return 0;
+		if (*(unsigned long *)(objp+cachep->objsize -
+				BYTES_PER_WORD) != RED_MAGIC2)
+			/* Either write past end, or a double free. */
+                        return 0;
+	}
+#endif
+
+        objnr = (objp-slabp->s_mem)/cachep->objsize;
+	if (objnr >= cachep->num)
+                return 0;
+	if (objp != slabp->s_mem + objnr*cachep->objsize)
+                return 0;
+
+	/* Check slab's freelist to see if this obj is there. */
+	for (i = slabp->free; i != BUFCTL_END; i = slab_bufctl(slabp)[i]) {
+		if (i == objnr)
+                        return 0;
+	}
+	return 1;
+}
+
+
+int kmem_cache_validate(kmem_cache_t *cachep, void *objp)
+{
+        struct page *page = check_get_page((unsigned long)objp); 
+
+        if (!VALID_PAGE(page)) {
+                return 0;
+        }
+
+        if (!PageSlab(page)) {
+                return 0;
+        }
+
+        /* XXX check for freed slab objects ? */ 
+        if (!kmem_check_cache_obj(cachep, GET_PAGE_SLAB(page), objp)) 
+                return 0;
+
+        return (cachep == GET_PAGE_CACHE(page));
+}
+
 #if DEBUG
 static int kmem_extra_free_checks (kmem_cache_t * cachep,
 			slab_t *slabp, void * objp)
--- kernel-rh-2.4.18-pristine/drivers/block/blkpg.c	Thu Jun 13 12:26:40 2002
+++ kernel-rh-2.4.18/drivers/block/blkpg.c	Thu Jun 20 11:24:56 2002
@@ -295,3 +295,38 @@
 }
 
 EXPORT_SYMBOL(blk_ioctl);
+
+#define NUM_DEV_NO_WRITE 16
+static int dev_no_write[NUM_DEV_NO_WRITE];
+
+/*
+ * Debug code for turning block devices "read-only" (will discard writes
+ * silently).  This is for filesystem crash/recovery testing.
+ */
+void dev_set_rdonly(kdev_t dev, int no_write)
+{
+	if (dev) {
+		printk(KERN_WARNING "Turning device %s read-only\n", 
+		       bdevname(dev));
+		dev_no_write[no_write] = 0xdead0000 + dev;
+	}
+}
+
+int dev_check_rdonly(kdev_t dev) {
+	int i;
+
+	for (i = 0; i < NUM_DEV_NO_WRITE; i++) {
+		if ((dev_no_write[i] & 0xffff0000) == 0xdead0000 &&
+		    dev == (dev_no_write[i] & 0xffff))
+			return 1;
+	}
+	return 0;
+}
+
+void dev_clear_rdonly(int no_write) {
+	dev_no_write[no_write] = 0;
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
--- kernel-rh-2.4.18-pristine/drivers/block/loop.c	Thu Jun 13 12:26:40 2002
+++ kernel-rh-2.4.18/drivers/block/loop.c	Thu Jun 20 11:24:56 2002
@@ -503,6 +503,11 @@
 	spin_unlock_irq(&lo->lo_lock);
 
 	if (rw == WRITE) {
+#ifdef CONFIG_DEV_RDONLY
+		if (dev_check_rdonly(rbh->b_rdev))
+			goto err;
+#endif
+
 		if (lo->lo_flags & LO_FLAGS_READ_ONLY)
 			goto err;
 	} else if (rw == READA) {
--- kernel-rh-2.4.18-pristine/drivers/ide/ide-disk.c	Thu Jun 13 12:26:43 2002
+++ kernel-rh-2.4.18/drivers/ide/ide-disk.c	Thu Jun 20 11:24:56 2002
@@ -557,6 +557,12 @@
  */
 static ide_startstop_t do_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long block)
 {
+#ifdef CONFIG_DEV_RDONLY
+	if (rq->cmd == WRITE && dev_check_rdonly(rq->rq_dev)) {
+		ide_end_request(1, HWGROUP(drive));
+		return ide_stopped;
+	}
+#endif
 	if (IDE_CONTROL_REG)
 		OUT_BYTE(drive->ctl,IDE_CONTROL_REG);
 
--- kernel-rh-2.4.18-pristine/fs/ext3/Makefile	Thu Jun 13 12:27:00 2002
+++ kernel-rh-2.4.18/fs/ext3/Makefile	Thu Jun 20 11:24:56 2002
@@ -9,6 +9,8 @@
 
 O_TARGET := ext3.o
 
+export-objs :=	super.o
+
 obj-y    := balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o \
 		ioctl.o namei.o super.o symlink.o
 obj-m    := $(O_TARGET)
--- kernel-rh-2.4.18-pristine/fs/ext3/super.c	Thu Jun 13 12:27:01 2002
+++ kernel-rh-2.4.18/fs/ext3/super.c	Thu Jun 20 11:24:56 2002
@@ -1746,7 +1746,7 @@
 	unregister_filesystem(&ext3_fs_type);
 }
 
-EXPORT_NO_SYMBOLS;
+EXPORT_SYMBOL(ext3_bread);
 
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");
 MODULE_DESCRIPTION("Second Extended Filesystem with journaling extensions");
--- kernel-rh-2.4.18-pristine/fs/jbd/commit.c	Thu Jun 13 12:27:05 2002
+++ kernel-rh-2.4.18/fs/jbd/commit.c	Thu Jun 20 11:24:56 2002
@@ -482,7 +482,7 @@
            transaction's t_log_list queue, and metadata buffers are on
            the t_iobuf_list queue.
 
-	   Wait for the transactions in reverse order.  That way we are
+	   Wait for the buffers in reverse order.  That way we are
 	   less likely to be woken up until all IOs have completed, and
 	   so we incur less scheduling load.
 	*/
@@ -575,8 +575,10 @@
 
 	jbd_debug(3, "JBD: commit phase 6\n");
 
-	if (is_journal_aborted(journal))
+	if (is_journal_aborted(journal)) {
+		unlock_journal(journal);
 		goto skip_commit;
+	}
 
 	/* Done it all: now write the commit record.  We should have
 	 * cleaned up our previous buffers by now, so if we are in abort
@@ -586,9 +588,10 @@
 	descriptor = journal_get_descriptor_buffer(journal);
 	if (!descriptor) {
 		__journal_abort_hard(journal);
+		unlock_journal(journal);
 		goto skip_commit;
 	}
-	
+
 	/* AKPM: buglet - add `i' to tmp! */
 	for (i = 0; i < jh2bh(descriptor)->b_size; i += 512) {
 		journal_header_t *tmp =
@@ -609,7 +612,6 @@
 		put_bh(bh);		/* One for getblk() */
 		journal_unlock_journal_head(descriptor);
 	}
-	lock_journal(journal);
 
 	/* End of a transaction!  Finally, we can do checkpoint
            processing: any buffers committed as a result of this
@@ -618,6 +620,25 @@
 
 skip_commit:
 
+	/* Call any callbacks that had been registered for handles in this
+	 * transaction.  It is up to the callback to free any allocated
+	 * memory.
+	 */
+	if (!list_empty(&commit_transaction->t_jcb)) {
+		struct list_head *p, *n;
+		int error = is_journal_aborted(journal);
+
+		list_for_each_safe(p, n, &commit_transaction->t_jcb) {
+			struct journal_callback *jcb;
+
+			jcb = list_entry(p, struct journal_callback, jcb_list);
+			list_del(p);
+			jcb->jcb_func(jcb, error);
+		}
+	}
+
+	lock_journal(journal);
+
 	jbd_debug(3, "JBD: commit phase 7\n");
 
 	J_ASSERT(commit_transaction->t_sync_datalist == NULL);
--- kernel-rh-2.4.18-pristine/fs/jbd/journal.c	Thu Jun 13 12:27:05 2002
+++ kernel-rh-2.4.18/fs/jbd/journal.c	Thu Jun 20 11:24:56 2002
@@ -58,6 +58,7 @@
 #endif
 EXPORT_SYMBOL(journal_flush);
 EXPORT_SYMBOL(journal_revoke);
+EXPORT_SYMBOL(journal_callback_set);
 
 EXPORT_SYMBOL(journal_init_dev);
 EXPORT_SYMBOL(journal_init_inode);
--- kernel-rh-2.4.18-pristine/fs/jbd/transaction.c	Thu Jun 13 12:27:05 2002
+++ kernel-rh-2.4.18/fs/jbd/transaction.c	Thu Jun 20 11:24:56 2002
@@ -57,6 +57,7 @@
 	transaction->t_state = T_RUNNING;
 	transaction->t_tid = journal->j_transaction_sequence++;
 	transaction->t_expires = jiffies + journal->j_commit_interval;
+	INIT_LIST_HEAD(&transaction->t_jcb);
 
 	/* Set up the commit timer for the new transaction. */
 	J_ASSERT (!journal->j_commit_timer_active);
@@ -201,6 +202,20 @@
 	return 0;
 }
 
+/* Allocate a new handle.  This should probably be in a slab... */
+static handle_t *get_handle(int nblocks)
+{
+	handle_t *handle = jbd_kmalloc(sizeof (handle_t), GFP_NOFS);
+	if (!handle)
+		return NULL;
+	memset(handle, 0, sizeof (handle_t));
+	handle->h_buffer_credits = nblocks;
+	handle->h_ref = 1;
+	INIT_LIST_HEAD(&handle->h_jcb);
+
+	return handle;
+}
+
 /*
  * Obtain a new handle.  
  *
@@ -227,14 +242,11 @@
 		handle->h_ref++;
 		return handle;
 	}
-	
-	handle = jbd_kmalloc(sizeof (handle_t), GFP_NOFS);
+
+	handle = get_handle(nblocks);
 	if (!handle)
 		return ERR_PTR(-ENOMEM);
-	memset (handle, 0, sizeof (handle_t));
 
-	handle->h_buffer_credits = nblocks;
-	handle->h_ref = 1;
 	current->journal_info = handle;
 
 	err = start_this_handle(journal, handle);
@@ -333,14 +345,11 @@
 	
 	if (is_journal_aborted(journal))
 		return ERR_PTR(-EIO);
-	
-	handle = jbd_kmalloc(sizeof (handle_t), GFP_NOFS);
+
+	handle = get_handle(nblocks);
 	if (!handle)
 		return ERR_PTR(-ENOMEM);
-	memset (handle, 0, sizeof (handle_t));
 
-	handle->h_buffer_credits = nblocks;
-	handle->h_ref = 1;
 	current->journal_info = handle;
 
 	err = try_start_this_handle(journal, handle);
@@ -1319,6 +1328,29 @@
 #endif
 
 /*
+ * Register a callback function for this handle.  The function will be
+ * called when the transaction that this handle is part of has been
+ * committed to disk with the original callback data struct and the
+ * error status of the journal as parameters.  There is no guarantee of
+ * ordering between handles within a single transaction, nor between
+ * callbacks registered on the same handle.
+ *
+ * The caller is responsible for allocating the journal_callback struct.
+ * This is to allow the caller to add as much extra data to the callback
+ * as needed, but reduce the overhead of multiple allocations.  The caller
+ * allocated struct must start with a struct journal_callback at offset 0,
+ * and has the caller-specific data afterwards.
+ */
+void journal_callback_set(handle_t *handle, void (*func)(void *, int),
+			  void *cb_data)
+{
+	struct journal_callback *jcb = cb_data;
+
+	list_add(&jcb->jcb_list, &handle->h_jcb);
+	jcb->jcb_func = func;
+}
+
+/*
  * All done for a particular handle.
  *
  * There is not much action needed here.  We just return any remaining
@@ -1383,7 +1415,10 @@
 			wake_up(&journal->j_wait_transaction_locked);
 	}
 
-	/* 
+	/* Move callbacks from the handle to the transaction. */
+	list_splice(&handle->h_jcb, &transaction->t_jcb);
+
+	/*
 	 * If the handle is marked SYNC, we need to set another commit
 	 * going!  We also want to force a commit if the current
 	 * transaction is occupying too much of the log, or if the
--- kernel-rh-2.4.18-pristine/include/linux/blkdev.h	Thu Jun 13 12:27:14 2002
+++ kernel-rh-2.4.18/include/linux/blkdev.h	Thu Jun 20 11:24:56 2002
@@ -276,4 +276,9 @@
 	}
 	return retval;
 }
+
+#define CONFIG_DEV_RDONLY
+void dev_set_rdonly(kdev_t, int);
+int dev_check_rdonly(kdev_t);
+void dev_clear_rdonly(int);
 #endif
--- kernel-rh-2.4.18-pristine/include/linux/slab.h	Thu Jun 13 12:27:15 2002
+++ kernel-rh-2.4.18/include/linux/slab.h	Thu Jun 20 11:24:56 2002
@@ -58,6 +58,7 @@
 extern int kmem_cache_shrink_nr(kmem_cache_t *);
 extern void *kmem_cache_alloc(kmem_cache_t *, int);
 extern void kmem_cache_free(kmem_cache_t *, void *);
+extern int kmem_cache_validate(kmem_cache_t *cachep, void *objp);
 
 extern void *kmalloc(size_t, int);
 extern void kfree(const void *);
--- kernel-rh-2.4.18-pristine/include/linux/jbd.h	Thu Jun 13 12:27:14 2002
+++ kernel-rh-2.4.18/include/linux/jbd.h	Thu Jun 20 11:24:56 2002
@@ -257,6 +257,13 @@
 	return bh->b_private;
 }
 
+#define HAVE_JOURNAL_CALLBACK_STATUS
+struct journal_callback {
+	struct list_head jcb_list;
+	void (*jcb_func)(void *cb_data, int error);
+	/* user data goes here */
+};
+
 struct jbd_revoke_table_s;
 
 /* The handle_t type represents a single atomic update being performed
@@ -287,6 +294,12 @@
 	   operations */
 	int			h_err;
 
+	/* List of application registered callbacks for this handle.
+	 * The function(s) will be called after the transaction that
+	 * this handle is part of has been committed to disk.
+	 */
+	struct list_head	h_jcb;
+
 	/* Flags */
 	unsigned int	h_sync:		1;	/* sync-on-close */
 	unsigned int	h_jdata:	1;	/* force data journaling */
@@ -406,6 +419,10 @@
 
 	/* How many handles used this transaction? */
 	int t_handle_count;
+
+	/* List of registered callback functions for this transaction.
+	 * Called when the transaction is committed. */
+	struct list_head	t_jcb;
 };
 
 
@@ -654,6 +671,8 @@
 extern int	 journal_try_to_free_buffers(journal_t *, struct page *, int);
 extern int	 journal_stop(handle_t *);
 extern int	 journal_flush (journal_t *);
+extern void	 journal_callback_set(handle_t *handle, void (*fn)(void *, int),
+				      void *cb_data);
 
 extern void	 journal_lock_updates (journal_t *);
 extern void	 journal_unlock_updates (journal_t *);
--- kernel-rh-2.4.18-pristine/kernel/ksyms.c	Thu Jun 13 12:27:15 2002
+++ kernel-rh-2.4.18/kernel/ksyms.c	Thu Jun 20 11:24:56 2002
@@ -305,6 +305,12 @@
 EXPORT_SYMBOL(lock_may_write);
 EXPORT_SYMBOL(dcache_readdir);
 
+/* lustre */
+EXPORT_SYMBOL(pagecache_lock);
+EXPORT_SYMBOL(kmem_cache_validate);
+EXPORT_SYMBOL(do_kern_mount);
+
+
 /* for stackable file systems (lofs, wrapfs, cryptfs, etc.) */
 EXPORT_SYMBOL(default_llseek);
 EXPORT_SYMBOL(dentry_open);
--- kernel-rh-2.4.18-pristine/include/linux/dcache.h	Thu Jun 13 12:27:14 2002
+++ kernel-rh-2.4.18/include/linux/dcache.h	Thu Jun 20 11:24:56 2002
@@ -6,6 +6,32 @@
 #include <asm/atomic.h>
 #include <linux/mount.h>
 
+#define IT_OPEN  (1)
+#define IT_CREAT  (1<<1)
+#define IT_MKDIR  (1<<2)
+#define IT_LINK  (1<<3)
+#define IT_SYMLINK  (1<<4)
+#define IT_UNLINK  (1<<5)
+#define IT_RMDIR  (1<<6)
+#define IT_RENAME  (1<<7)
+#define IT_RENAME2  (1<<8)
+#define IT_READDIR  (1<<9)
+#define IT_GETATTR  (1<<10)
+#define IT_SETATTR  (1<<11)
+#define IT_READLINK  (1<<12)
+#define IT_MKNOD  (1<<13)
+
+struct lookup_intent { 
+	int it_op;
+	int it_mode;
+	int it_disposition;
+	int it_status; 
+	struct iattr *it_iattr;
+        __u64 it_lock_handle[2];
+        int it_lock_mode;
+	void *it_data;
+};
+
 /*
  * linux/include/linux/dcache.h
  *
@@ -78,6 +104,7 @@
 	unsigned long d_time;		/* used by d_revalidate */
 	struct dentry_operations  *d_op;
 	struct super_block * d_sb;	/* The root of the dentry tree */
+ 	struct lookup_intent *d_it;
 	unsigned long d_vfs_flags;
 	void * d_fsdata;		/* fs-specific data */
 	void * d_extra_attributes;	/* TUX-specific data */
@@ -91,6 +118,8 @@
 	int (*d_delete)(struct dentry *);
 	void (*d_release)(struct dentry *);
 	void (*d_iput)(struct dentry *, struct inode *);
+	int (*d_revalidate2)(struct dentry *, int, struct lookup_intent *);
+ 	void (*d_intent_release)(struct dentry *);
 };
 
 /* the dentry parameter passed to d_hash and d_compare is the parent
--- kernel-rh-2.4.18-pristine/include/linux/fs.h	Thu Jun 13 12:27:14 2002
+++ kernel-rh-2.4.18/include/linux/fs.h	Thu Jun 20 11:24:56 2002
@@ -570,6 +570,7 @@
 
 	/* needed for tty driver, and maybe others */
 	void			*private_data;
+	 struct lookup_intent    *f_intent;
 
 	/* preallocated helper kiobuf to speedup O_DIRECT */
 	struct kiobuf		*f_iobuf;
@@ -827,7 +828,9 @@
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		struct inode *new_dir, struct dentry *new_dentry, 
+		struct lookup_intent *it);
 
 /*
  * File types
@@ -888,6 +891,7 @@
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
+	 struct dentry * (*lookup2) (struct inode *,struct dentry *, struct lookup_intent *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
@@ -1034,6 +1038,7 @@
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount(struct vfsmount *);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
+struct vfsmount *do_kern_mount(const char *type, int flags, char *name, void *data);
 extern void umount_tree(struct vfsmount *);
 
 #define kern_umount mntput
@@ -1360,6 +1365,7 @@
 extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
 
 extern int FASTCALL(__user_walk(const char *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_it(const char *, unsigned, struct nameidata *, struct lookup_intent *it));
 extern int FASTCALL(path_init(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
@@ -1370,6 +1376,8 @@
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
 #define user_path_walk(name,nd)	 __user_walk(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd)
 #define user_path_walk_link(name,nd) __user_walk(name, LOOKUP_POSITIVE, nd)
+#define user_path_walk_it(name,nd,it)  __user_walk_it(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd, it)
+#define user_path_walk_link_it(name,nd,it) __user_walk_it(name, LOOKUP_POSITIVE, nd, it)
 
 extern void iput(struct inode *);
 extern void force_delete(struct inode *);
--- kernel-rh-2.4.18-pristine/fs/nfsd/vfs.c	Thu Jun 13 12:27:05 2002
+++ kernel-rh-2.4.18/fs/nfsd/vfs.c	Thu Jun 20 11:24:56 2002
@@ -1285,7 +1285,7 @@
 			err = nfserr_perm;
 	} else
 #endif
-	err = vfs_rename(fdir, odentry, tdir, ndentry);
+	err = vfs_rename(fdir, odentry, tdir, ndentry, NULL);
 	if (!err && EX_ISSYNC(tfhp->fh_export)) {
 		nfsd_sync_dir(tdentry);
 		nfsd_sync_dir(fdentry);
--- kernel-rh-2.4.18-pristine/fs/namei.c	Thu Jun 13 12:27:05 2002
+++ kernel-rh-2.4.18/fs/namei.c	Thu Jun 20 14:27:27 2002
@@ -94,6 +94,14 @@
  * XEmacs seems to be relying on it...
  */
 
+void intent_release(struct dentry *de) 
+{
+	if (de->d_op && de->d_op->d_intent_release)
+		de->d_op->d_intent_release(de);
+	de->d_it = NULL;
+}
+
+
 /* In order to reduce some races, while at the same time doing additional
  * checking and hopefully speeding things up, we copy filenames to the
  * kernel data space before using them..
@@ -260,10 +268,18 @@
  * Internal lookup() using the new generic dcache.
  * SMP-safe
  */
-static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry * cached_lookup(struct dentry * parent, struct qstr * name, int flags, struct lookup_intent *it)
 {
 	struct dentry * dentry = d_lookup(parent, name);
 
+	if (dentry && dentry->d_op && dentry->d_op->d_revalidate2) {
+		if (!dentry->d_op->d_revalidate2(dentry, flags, it) && !d_invalidate(dentry)) {
+			dput(dentry);
+			dentry = NULL;
+		}
+		return dentry; 
+	}
+
 	if (dentry && dentry->d_op && dentry->d_op->d_revalidate) {
 		if (!dentry->d_op->d_revalidate(dentry, flags) && !d_invalidate(dentry)) {
 			dput(dentry);
@@ -281,7 +297,7 @@
  * make sure that nobody added the entry to the dcache in the meantime..
  * SMP-safe
  */
-static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags, struct lookup_intent *it)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
@@ -300,6 +316,9 @@
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
 			lock_kernel();
+			if (dir->i_op->lookup2) 
+				result = dir->i_op->lookup2(dir, dentry, it);
+			else 
 			result = dir->i_op->lookup(dir, dentry);
 			unlock_kernel();
 			if (result)
@@ -322,6 +341,12 @@
 			result = ERR_PTR(-ENOENT);
 		}
 	}
+	if (result->d_op && result->d_op->d_revalidate2) {
+		if (!result->d_op->d_revalidate2(result, flags, it) && !d_invalidate(result)) {
+			dput(result);
+			result = ERR_PTR(-ENOENT);
+		}
+	}
 	return result;
 }
 
@@ -447,7 +472,7 @@
  *
  * We expect 'base' to be positive and a directory.
  */
-int link_path_walk(const char * name, struct nameidata *nd)
+int link_path_walk_it(const char * name, struct nameidata *nd, struct lookup_intent *it)
 {
 	struct dentry *dentry;
 	struct inode *inode;
@@ -524,12 +549,12 @@
 				break;
 		}
 		/* This does the actual lookups.. */
-		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+		dentry = cached_lookup(nd->dentry, &this, LOOKUP_CONTINUE, it);
 		if (!dentry) {
 			err = -EWOULDBLOCKIO;
 			if (atomic)
 				break;
-			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE);
+			dentry = real_lookup(nd->dentry, &this, LOOKUP_CONTINUE, it);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
@@ -563,7 +588,7 @@
 			nd->dentry = dentry;
 		}
 		err = -ENOTDIR; 
-		if (!inode->i_op->lookup)
+		if (!inode->i_op->lookup && !inode->i_op->lookup2)
 			break;
 		continue;
 		/* here ends the main loop */
@@ -590,12 +615,12 @@
 			if (err < 0)
 				break;
 		}
-		dentry = cached_lookup(nd->dentry, &this, 0);
+		dentry = cached_lookup(nd->dentry, &this, 0, it);
 		if (!dentry) {
 			err = -EWOULDBLOCKIO;
 			if (atomic)
 				break;
-			dentry = real_lookup(nd->dentry, &this, 0);
+			dentry = real_lookup(nd->dentry, &this, 0, it);
 			err = PTR_ERR(dentry);
 			if (IS_ERR(dentry))
 				break;
@@ -619,7 +644,8 @@
 			goto no_inode;
 		if (lookup_flags & LOOKUP_DIRECTORY) {
 			err = -ENOTDIR; 
-			if (!inode->i_op || !inode->i_op->lookup)
+			if (!inode->i_op || (!inode->i_op->lookup && 
+					     !inode->i_op->lookup2))
 				break;
 		}
 		goto return_base;
@@ -638,6 +664,7 @@
 		else if (this.len == 2 && this.name[1] == '.')
 			nd->last_type = LAST_DOTDOT;
 return_base:
+                nd->dentry->d_it = it;
 		return 0;
 out_dput:
 		dput(dentry);
@@ -645,15 +672,29 @@
 	}
 	path_release(nd);
 return_err:
+        if (!err)
+                nd->dentry->d_it = it;
 	return err;
 }
 
+int link_path_walk(const char * name, struct nameidata *nd)
+{
+	return link_path_walk_it(name, nd, NULL);
+}
+
+int path_walk_it(const char * name, struct nameidata *nd, struct lookup_intent *it)
+{
+	current->total_link_count = 0;
+	return link_path_walk_it(name, nd, it);
+}
+
 int path_walk(const char * name, struct nameidata *nd)
 {
 	current->total_link_count = 0;
-	return link_path_walk(name, nd);
+	return link_path_walk_it(name, nd, NULL);
 }
 
+
 /* SMP-safe */
 /* returns 1 if everything is done */
 static int __emul_lookup_dentry(const char *name, struct nameidata *nd)
@@ -754,7 +795,8 @@
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+struct dentry * lookup_hash_it(struct qstr *name, struct dentry * base, 
+			    struct lookup_intent *it)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -777,13 +819,16 @@
 			goto out;
 	}
 
-	dentry = cached_lookup(base, name, 0);
+	dentry = cached_lookup(base, name, 0, it);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
 		lock_kernel();
+		if (inode->i_op->lookup2) 
+			dentry = inode->i_op->lookup2(inode, new, it);
+		else 
 		dentry = inode->i_op->lookup(inode, new);
 		unlock_kernel();
 		if (!dentry)
@@ -795,6 +840,12 @@
 	return dentry;
 }
 
+struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
+{
+	return lookup_hash_it(name, base, NULL);
+}
+
+
 /* SMP-safe */
 struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
 {
@@ -816,7 +867,7 @@
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return lookup_hash_it(&this, base, NULL);
 access:
 	return ERR_PTR(-EACCES);
 }
@@ -848,6 +899,22 @@
 	return err;
 }
 
+int __user_walk_it(const char *name, unsigned flags, struct nameidata *nd, struct lookup_intent *it)
+{
+	char *tmp;
+	int err;
+
+	tmp = getname(name);
+	err = PTR_ERR(tmp);
+	if (!IS_ERR(tmp)) {
+		err = 0;
+		if (path_init(tmp, flags, nd))
+			err = path_walk_it(tmp, nd, it);
+		putname(tmp);
+	}
+	return err;
+}
+
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -984,7 +1051,8 @@
  * for symlinks (where the permissions are checked later).
  * SMP-safe
  */
-int open_namei(const char * pathname, int flag, int mode, struct nameidata *nd)
+int open_namei_it(const char * pathname, int flag, int mode, struct nameidata *nd, 
+		struct lookup_intent *it)
 {
 	int acc_mode, error = 0;
 	struct inode *inode;
@@ -998,17 +1066,21 @@
 	 * The simplest case - just a plain lookup.
 	 */
 	if (!(flag & O_CREAT)) {
+
 		if (path_init(pathname, lookup_flags(flag), nd))
-			error = path_walk(pathname, nd);
+			error = path_walk_it(pathname, nd, it);
 		if (error)
 			return error;
 		dentry = nd->dentry;
+                dentry->d_it = it;
 		goto ok;
 	}
 
 	/*
 	 * Create - we need to know the parent.
 	 */
+	if (it) 
+		it->it_op |= IT_CREAT;
 	if (path_init(pathname, LOOKUP_PARENT, nd))
 		error = path_walk(pathname, nd);
 	if (error)
@@ -1025,7 +1097,7 @@
 
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1034,6 +1106,7 @@
 		goto exit;
 	}
 
+        dentry->d_it = it;
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		error = vfs_create(dir->d_inode, dentry,
@@ -1150,9 +1223,11 @@
 		if (flag & FMODE_WRITE)
 			DQUOT_INIT(inode);
 
+        intent_release(dentry);
 	return 0;
 
 exit_dput:
+        intent_release(dentry);
 	dput(dentry);
 exit:
 	path_release(nd);
@@ -1195,13 +1270,20 @@
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, NULL);
 	putname(nd->last.name);
 	goto do_last;
 }
 
+int open_namei(const char * pathname, int flag, int mode, struct nameidata *nd)
+{
+	return open_namei_it(pathname, flag, mode, nd, NULL); 
+}
+
+
 /* SMP-safe */
-static struct dentry *lookup_create(struct nameidata *nd, int is_dir)
+static struct dentry *lookup_create(struct nameidata *nd, int is_dir, 
+				    struct lookup_intent *it)
 {
 	struct dentry *dentry;
 
@@ -1209,7 +1291,7 @@
 	dentry = ERR_PTR(-EEXIST);
 	if (nd->last_type != LAST_NORM)
 		goto fail;
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = lookup_hash_it(&nd->last, nd->dentry, it);
 	if (IS_ERR(dentry))
 		goto fail;
 	if (!is_dir && nd->last.name[nd->last.len] && !dentry->d_inode)
@@ -1255,6 +1337,7 @@
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
+	struct lookup_intent it = { IT_MKNOD , mode };
 
 	if (S_ISDIR(mode))
 		return -EPERM;
@@ -1266,11 +1349,12 @@
 		error = path_walk(tmp, &nd);
 	if (error)
 		goto out;
-	dentry = lookup_create(&nd, 0);
+	dentry = lookup_create(&nd, 0, &it);
 	error = PTR_ERR(dentry);
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		dentry->d_it = &it;
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
@@ -1284,6 +1368,7 @@
 		default:
 			error = -EINVAL;
 		}
+                intent_release(dentry); 
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1324,6 +1409,7 @@
 {
 	int error = 0;
 	char * tmp;
+	struct lookup_intent it = { IT_MKDIR, mode };
 
 	tmp = getname(pathname);
 	error = PTR_ERR(tmp);
@@ -1335,11 +1421,13 @@
 			error = path_walk(tmp, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 1);
+		dentry = lookup_create(&nd, 1, &it);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
+			dentry->d_it = &it;
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
 					  mode & ~current->fs->umask);
+                        intent_release(dentry); 
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1421,6 +1509,7 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	struct lookup_intent it = { IT_RMDIR, 0 };
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1443,10 +1532,12 @@
 			goto exit1;
 	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, &it);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
+		dentry->d_it = &it; 
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
+		intent_release(dentry); 
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1490,6 +1581,7 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	struct lookup_intent it = { IT_UNLINK, 0 };
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1503,14 +1595,16 @@
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = lookup_hash_it(&nd.last, nd.dentry, &it);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
+		dentry->d_it = &it;
 		/* Why not before? Because we want correct error value */
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
+		intent_release(dentry); 
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
@@ -1557,6 +1651,7 @@
 	int error = 0;
 	char * from;
 	char * to;
+	struct lookup_intent it = { IT_SYMLINK, 0 };
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1571,11 +1666,13 @@
 			error = path_walk(to, &nd);
 		if (error)
 			goto out;
-		dentry = lookup_create(&nd, 0);
+		dentry = lookup_create(&nd, 0, &it);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
+			dentry->d_it = &it;
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
-			dput(dentry);
+                        intent_release(dentry); 
+                        dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
 		path_release(&nd);
@@ -1640,6 +1737,7 @@
 	int error;
 	char * from;
 	char * to;
+	struct lookup_intent it = { IT_LINK, 0 };
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1662,10 +1760,12 @@
 		error = -EXDEV;
 		if (old_nd.mnt != nd.mnt)
 			goto out_release;
-		new_dentry = lookup_create(&nd, 0);
+		new_dentry = lookup_create(&nd, 0, &it);
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
+			new_dentry->d_it = &it;
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
+                        intent_release(new_dentry); 
 			dput(new_dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
@@ -1708,7 +1808,8 @@
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		   struct inode *new_dir, struct dentry *new_dentry,
+		   struct lookup_intent *it)
 {
 	int error;
 	struct inode *target;
@@ -1762,12 +1863,14 @@
 	} else
 		double_down(&old_dir->i_zombie,
 			    &new_dir->i_zombie);
+	new_dentry->d_it = it;
 	if (IS_DEADDIR(old_dir)||IS_DEADDIR(new_dir))
 		error = -ENOENT;
 	else if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))
 		error = -EBUSY;
 	else 
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry); 
 	if (target) {
 		if (!error)
 			target->i_flags |= S_DEAD;
@@ -1789,7 +1892,8 @@
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		struct inode *new_dir, struct dentry *new_dentry, 
+		     struct lookup_intent *it)
 {
 	int error;
 
@@ -1816,10 +1920,12 @@
 	DQUOT_INIT(old_dir);
 	DQUOT_INIT(new_dir);
 	double_down(&old_dir->i_zombie, &new_dir->i_zombie);
+	new_dentry->d_it = it;
 	if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))
 		error = -EBUSY;
 	else
 		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
+	intent_release(new_dentry); 
 	double_up(&old_dir->i_zombie, &new_dir->i_zombie);
 	if (error)
 		return error;
@@ -1831,13 +1937,14 @@
 }
 
 int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+		struct inode *new_dir, struct dentry *new_dentry, 
+		struct lookup_intent *it)
 {
 	int error;
 	if (S_ISDIR(old_dentry->d_inode->i_mode))
-		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry, it);
 	else
-		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
+		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry, it);
 	if (!error) {
 		if (old_dir == new_dir)
 			inode_dir_notify(old_dir, DN_RENAME);
@@ -1855,6 +1962,7 @@
 	struct dentry * old_dir, * new_dir;
 	struct dentry * old_dentry, *new_dentry;
 	struct nameidata oldnd, newnd;
+	struct lookup_intent it = {IT_RENAME, 0};
 
 	if (path_init(oldname, LOOKUP_PARENT, &oldnd))
 		error = path_walk(oldname, &oldnd);
@@ -1882,7 +1990,9 @@
 
 	double_lock(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	it.it_op = IT_RENAME;
+	it.it_mode = 0;
+	old_dentry = lookup_hash_it(&oldnd.last, old_dir, &it);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -1898,14 +2008,15 @@
 		if (newnd.last.name[newnd.last.len])
 			goto exit4;
 	}
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	it.it_op = IT_RENAME2;
+	new_dentry = lookup_hash_it(&newnd.last, new_dir, &it);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
 	lock_kernel();
 	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+				   new_dir->d_inode, new_dentry, &it);
 	unlock_kernel();
 
 	dput(new_dentry);
--- kernel-rh-2.4.18-pristine/fs/open.c	Thu Jun 13 12:27:08 2002
+++ kernel-rh-2.4.18/fs/open.c	Thu Jun 20 11:42:48 2002
@@ -19,6 +19,8 @@
 #include <asm/uaccess.h>
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
+extern int path_walk_it(const char * name, struct nameidata *nd, struct lookup_intent *it);
+extern void intent_release(struct dentry *de);
 
 int vfs_statfs(struct super_block *sb, struct statfs *buf)
 {
@@ -94,14 +96,19 @@
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
+	struct lookup_intent it;
+	
+	it.it_op = IT_SETATTR;
+
 
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path_walk(path, &nd);
+	error = user_path_walk_it(path, &nd, &it);
 	if (error)
 		goto out;
+	nd.dentry->d_it = &it;
 	inode = nd.dentry->d_inode;
 
 	/* For directories it's -EISDIR, for other non-regulars - -EINVAL */
@@ -144,6 +151,7 @@
 	put_write_access(inode);
 
 dput_and_out:
+	intent_release(nd.dentry);
 	path_release(&nd);
 out:
 	return error;
@@ -235,10 +243,14 @@
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
+	struct lookup_intent it;
+
+	it.it_op = IT_SETATTR;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (error)
 		goto out;
+	nd.dentry->d_it = &it;
 	inode = nd.dentry->d_inode;
 
 	error = -EROFS;
@@ -262,6 +274,7 @@
 	}
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
+	intent_release(nd.dentry);
 	path_release(&nd);
 out:
 	return error;
@@ -279,11 +292,15 @@
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
+	struct lookup_intent it;
+	
+	it.it_op = IT_SETATTR;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 
 	if (error)
 		goto out;
+	nd.dentry->d_it = &it;
 	inode = nd.dentry->d_inode;
 
 	error = -EROFS;
@@ -306,6 +323,7 @@
 	}
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
+	intent_release(nd.dentry);
 	path_release(&nd);
 out:
 	return error;
@@ -322,6 +340,9 @@
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	struct lookup_intent it;
+	
+	it.it_op = IT_GETATTR;
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -339,13 +360,14 @@
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = user_path_walk(filename, &nd);
+	res = user_path_walk_it(filename, &nd, &it);
 	if (!res) {
 		res = permission(nd.dentry->d_inode, mode);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+                intent_release(nd.dentry);
 		path_release(&nd);
 	}
 
@@ -361,6 +383,9 @@
 	int error;
 	struct nameidata nd;
 	char *name;
+	struct lookup_intent it;
+	
+	it.it_op = IT_GETATTR;
 
 	name = getname(filename);
 	error = PTR_ERR(name);
@@ -369,11 +394,12 @@
 
 	error = 0;
 	if (path_init(name,LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,&nd))
-		error = path_walk(name, &nd);
+		error = path_walk_it(name, &nd, &it);
 	putname(name);
 	if (error)
 		goto out;
 
+	nd.dentry->d_it = &it;
 	error = permission(nd.dentry->d_inode,MAY_EXEC);
 	if (error)
 		goto dput_and_out;
@@ -381,6 +407,7 @@
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
+	intent_release(nd.dentry);
 	path_release(&nd);
 out:
 	return error;
@@ -421,6 +448,9 @@
 	int error;
 	struct nameidata nd;
 	char *name;
+	struct lookup_intent it;
+ 
+	it.it_op = IT_GETATTR;
 
 	name = getname(filename);
 	error = PTR_ERR(name);
@@ -429,11 +459,12 @@
 
 	path_init(name, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
 		      LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
-	error = path_walk(name, &nd);	
+	error = path_walk_it(name, &nd, &it);   
 	putname(name);
 	if (error)
 		goto out;
 
+	nd.dentry->d_it = &it;
 	error = permission(nd.dentry->d_inode,MAY_EXEC);
 	if (error)
 		goto dput_and_out;
@@ -446,6 +477,7 @@
 	set_fs_altroot();
 	error = 0;
 dput_and_out:
+	intent_release(nd.dentry);
 	path_release(&nd);
 out:
 	return error;
@@ -490,12 +522,15 @@
 	struct inode * inode;
 	int error;
 	struct iattr newattrs;
+	struct lookup_intent it;
 
-	error = user_path_walk(filename, &nd);
+	it.it_op = IT_SETATTR;
+	error = user_path_walk_it(filename, &nd, &it);
 	if (error)
 		goto out;
 	inode = nd.dentry->d_inode;
 
+	nd.dentry->d_it = &it;
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
@@ -511,6 +546,7 @@
 	error = notify_change(nd.dentry, &newattrs);
 
 dput_and_out:
+	intent_release(nd.dentry);
 	path_release(&nd);
 out:
 	return error;
@@ -580,10 +616,15 @@
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it;
+	
+	it.it_op = IT_SETATTR;
 
-	error = user_path_walk(filename, &nd);
+	error = user_path_walk_it(filename, &nd, &it);
 	if (!error) {
+		nd.dentry->d_it = &it;
 		error = chown_common(nd.dentry, user, group);
+		intent_release(nd.dentry);
 		path_release(&nd);
 	}
 	return error;
@@ -593,10 +634,15 @@
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it;
 
-	error = user_path_walk_link(filename, &nd);
+	it.it_op = IT_SETATTR;
+
+	error = user_path_walk_link_it(filename, &nd, &it);
 	if (!error) {
+		nd.dentry->d_it = &it;
 		error = chown_common(nd.dentry, user, group);
+		intent_release(nd.dentry);
 		path_release(&nd);
 	}
 	return error;
@@ -630,10 +676,15 @@
  * for the internal routines (ie open_namei()/follow_link() etc). 00 is
  * used by symlinks.
  */
+extern int open_namei_it(const char *filename, int namei_flags, int mode, 
+			 struct nameidata *nd, struct lookup_intent *it);
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt, int flags, struct lookup_intent *it);
+
 struct file *filp_open(const char * filename, int flags, int mode)
 {
 	int namei_flags, error;
 	struct nameidata nd;
+	struct lookup_intent it = {IT_OPEN, 0};
 
 	namei_flags = flags;
 	if ((namei_flags+1) & O_ACCMODE)
@@ -641,14 +692,14 @@
 	if (namei_flags & O_TRUNC)
 		namei_flags |= 2;
 
-	error = open_namei(filename, namei_flags, mode, &nd);
+	error = open_namei_it(filename, namei_flags, mode, &nd, &it);
 	if (!error)
-		return dentry_open(nd.dentry, nd.mnt, flags);
+		return dentry_open_it(nd.dentry, nd.mnt, flags, &it);
 
 	return ERR_PTR(error);
 }
 
-struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt, int flags, struct lookup_intent *it)
 {
 	struct file * f;
 	struct inode *inode;
@@ -705,11 +756,19 @@
 cleanup_file:
 	put_filp(f);
 cleanup_dentry:
+        intent_release(dentry);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
 }
 
+struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+{
+	return dentry_open_it(dentry, mnt, flags, NULL);
+
+}
+
+
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
--- kernel-rh-2.4.18-pristine/fs/stat.c	Thu Jun 13 12:27:08 2002
+++ kernel-rh-2.4.18/fs/stat.c	Thu Jun 20 11:24:56 2002
@@ -117,10 +117,14 @@
 {
 	struct nameidata nd;
 	int error;
+ 	struct lookup_intent it;
+ 	it.it_op = IT_GETATTR;
 
-	error = user_path_walk_link(name, &nd);
+
+	error = user_path_walk_link_it(name, &nd, &it);
 	if (!error) {
 		error = do_getattr(nd.mnt, nd.dentry, stat);
+		intent_release(nd.dentry);
 		path_release(&nd);
 	}
 	return error;
@@ -269,20 +273,23 @@
 {
 	struct nameidata nd;
 	int error;
+	struct lookup_intent it;
+	it.it_op = IT_READLINK;
 
 	if (bufsiz <= 0)
 		return -EINVAL;
 
-	error = user_path_walk_link(path, &nd);
+	error = user_path_walk_link_it(path, &nd, &it);
 	if (!error) {
 		struct inode * inode = nd.dentry->d_inode;
-
+		nd.dentry->d_it = &it;
 		error = -EINVAL;
 		if (inode->i_op && inode->i_op->readlink &&
 		    !(error = do_revalidate(nd.dentry))) {
 			UPDATE_ATIME(inode);
 			error = inode->i_op->readlink(nd.dentry, buf, bufsiz);
 		}
+		intent_release(nd.dentry);
 		path_release(&nd);
 	}
 	return error;
--- linux-2.4.18-chaos2-pristine/kernel/panic.c	Fri Jun 14 09:33:02 2002
+++ linux-2.4.18-chaos2/kernel/panic.c	Fri Jun 21 16:49:27 2002
@@ -9,6 +9,7 @@
  * to indicate a major problem.
  */
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/delay.h>
 #include <linux/reboot.h>
@@ -24,9 +25,23 @@
 asmlinkage void sys_sync(void);	/* it's really int */
 
 int panic_timeout;
-
+static void (*dumplustre)(void);
 struct notifier_block *panic_notifier_list;
 
+static void register_dumplog(void)
+{
+	dumplustre = inter_module_get_request("portals_debug_dumplog", "portals");
+}
+
+static void unregister_dumplog(void)
+{
+  if(dumplustre)
+	inter_module_put("portals_debug_dumplog");
+}
+
+EXPORT_SYMBOL(register_dumplog);
+EXPORT_SYMBOL(unregister_dumplog);
+
 static int __init panic_setup(char *str)
 {
 	panic_timeout = simple_strtoul(str, NULL, 0);
@@ -49,10 +64,17 @@
 {
 	static char buf[1024];
 	va_list args;
+
 #if defined(CONFIG_ARCH_S390)
         unsigned long caller = (unsigned long) __builtin_return_address(0);
 #endif
 
+	if(dumplustre) { 
+	        void (*dodump)(void) = dumplustre;
+		dumplustre = NULL;
+		dodump();
+	}
+
 #ifdef CONFIG_MCL_COREDUMP
 	crash_save_regs();
 #endif
@@ -63,6 +85,7 @@
 	va_end(args);
 	printk(KERN_EMERG "Kernel panic: %s\n",buf);
 
+
 #ifdef CONFIG_MCL_COREDUMP
 	if (!panicmsg) {
 		panicmsg = buf;
--- linux-2.4.18-chaos2-pristine/kernel/Makefile	Fri Jun 14 09:33:02 2002
+++ linux-2.4.18-chaos2/kernel/Makefile	Fri Jun 21 15:04:01 2002
@@ -9,7 +9,7 @@
 
 O_TARGET := kernel.o
 
-export-objs = signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o printk.o \
+export-objs = panic.o signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o printk.o \
 	      syscall_ksyms.o
 
 obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o \
