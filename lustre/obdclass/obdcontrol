#!/usr/bin/perl

#
# This code is issued under the GNU General Public License.
# See the file COPYING in this distribution
#
# Copyright (C) 1998, Stelias Computing
# 
# Modified for InterMezzo from Gordian's HSM bcache device/jcm module
# Copyright (C) 1999, Carnegie Mellon University
#
# Derived from InterMezzo's incontrol, modified for OBD's
# Copyright (C) 1999, Stelias Computing
#
#

#use strict;
BEGIN { require "asm/errno.ph" };
BEGIN { require "asm/ioctl.ph" };

# p2ph generated invalid macros for ioctl stuff, so I override some of it here
eval 'sub OBD_IOC_CREATE () { &_IOC(2, ord(\'f\'), 3, 4);}' unless
  defined(&OBD_IOC_CREATE);
eval 'sub OBD_IOC_SETUP_SUPER () { &_IOC(1, ord(\'f\'), 4, 4);}' unless
  defined(&OBD_IOC_SETUP_SUPER);
eval 'sub OBD_IOC_CLEANUP_SUPER () { &_IOC(0, ord(\'f\'), 5, 0);}' unless
  defined(&OBD_IOC_CLEANUP_SUPER);
eval 'sub OBD_IOC_DESTROY () { &_IOC(1, ord(\'f\'), 6, 4);}' unless
  defined(&OBD_IOC_DESTROY);
eval 'sub OBD_IOC_PREALLOCATE () { &_IOC(3, ord(\'f\'), 7, 4);}' unless
  defined(&OBD_IOC_PREALLOCATE);
eval 'sub OBD_IOC_DEC_USE_COUNT () { &_IOC(0, ord(\'f\'), 8, 0);}' unless
  defined(&OBD_IOC_DEC_USE_COUNT);
eval 'sub OBD_IOC_SETATTR () { &_IOC(1, ord(\'f\'), 9, 4);}' unless
  defined(&OBD_IOC_SETATTR);
eval 'sub OBD_IOC_GETATTR () { &_IOC(2, ord(\'f\'), 10, 4);}' unless
  defined(&OBD_IOC_GETATTR);
eval 'sub OBD_IOC_READ () { &_IOC(3, ord(\'f\'), 11, 4);}' unless
  defined(&OBD_IOC_READ);
eval 'sub OBD_IOC_WRITE () { &_IOC(3, ord(\'f\'), 12, 4);}' unless
  defined(&OBD_IOC_WRITE);
eval 'sub OBD_IOC_CONNECT () { &_IOC(2, ord(\'f\'), 13, 4);}' unless
  defined(&OBD_IOC_CONNECT);
eval 'sub OBD_IOC_DISCONNECT () { &_IOC(1, ord(\'f\'), 14, 4);}' unless
  defined(&OBD_IOC_DISCONNECT);
eval 'sub OBD_IOC_STATFS () { &_IOC(3, ord(\'f\'), 15, 4);}' unless
  defined(&OBD_IOC_STATFS);
eval 'sub OBD_IOC_SYNC () { &_IOC(2, ord(\'f\'), 5, 4);}' unless
  defined(&OBD_IOC_SYNC);

eval 'sub ATTR_MODE () {1;}' unless defined(&ATTR_MODE);
eval 'sub ATTR_UID () {2;}' unless defined(&ATTR_UID);
eval 'sub ATTR_GID () {4;}' unless defined(&ATTR_GID);
eval 'sub ATTR_SIZE () {8;}' unless defined(&ATTR_SIZE);
eval 'sub ATTR_ATIME () {16;}' unless defined(&ATTR_ATIME);
eval 'sub ATTR_MTIME () {32;}' unless defined(&ATTR_MTIME);
eval 'sub ATTR_CTIME () {64;}' unless defined(&ATTR_CTIME);

use Getopt::Long;
use File::stat;
use Storable;
use Carp;
use Term::ReadLine;
use IO::Handle;

my ($device, $filesystem);
# startup options (I'll replace these when I have some to replace with)
GetOptions("device=s" => \$device, "fs=s" => $filesystem) || die "Getoptions";

# genuine new simulated OBD device
$device = "/dev/obd" unless $device;
# object store in the ext2 formatted block device
$filesystem = "/dev/loop0" unless $filesystem;

# get a console for the app
my $term = new Term::ReadLine 'obdcontrol ';
my $attribs = $term->Attribs;
$term->ornaments('md,me,,');	# bold face prompt

# make sure stdout is not buffered
STDOUT->autoflush(1);

my $line;
my $command;
my $arg;

my %commands =
    ('create' => {func => "Create", doc => "create: creates a new inode"},
     'setup' => {func => "Setup", doc => "setup: link the ext2 partition (default /dev/loop0) to this obddev"},
     'connect' => {func => "Connect", doc => "connect: allocates client ID for this session"},
     'disconnect' => {func => "Disconnect", doc => "disconnect [id]: frees client resources"},
     'sync' => {func => "Sync", doc => "sync: flushes buffers to disk"},
     'destroy' => {func => "Destroy", doc => "setup: destroys an inode"},
     'cleanup' => {func => "Cleanup", doc => "detach the superblock from this minor obd dev"},
     'dec_use_count' => {func => "Decusecount", doc => "decreases the module use count so that the module can be removed following an oops"},
     'read' => {func => "Read", doc => "read <inode> <count> [offset]"},
     'write' => {func => "Write", doc => "write <inode> <offset> <text>"},
     'setattr' => {func => "Setattr", doc => "setattr <inode> [mode [uid [gid [size [atime [mtime [ctime]]]]]]]"},
     'getattr' => {func => "Getattr", doc => "getattr <inode>: displays inode object attributes"},
     'preallocate' => {func => "Preallocate", doc => "preallocate [num]: requests preallocation of num inodes."},
     'statfs' => {func => "Statfs", doc => "statfs: filesystem status information"},
     'help' => {func => \&Help,  doc => "help: this message"},
     'quit' => {func => \&Quit,  doc => "see \"exit\""},
     'exit' => {func => \&Quit,  doc => "see \"quit\""}
    );

#
#	setup completion function
#
my @jcm_cmd_list = keys %commands;

$attribs->{attempted_completion_function} = \&completeme;
#------------------------------------------------------------------------------
# Open the device, as we need an FD for the ioctl
sysopen(DEV_OBD, $device, 0) || die "Cannot open $device";

if (!defined($::st = stat($filesystem))) {
    die "Unable to stat $filesystem.\n";
}

# Get on with the show
process_line();

#------------------------------------------------------------------------------
sub completeme {
    my ($text, $line, $start, $end) = @_;
    if (substr($line, 0, $start) =~ /^\s*$/) {
	$attribs->{completion_word} = \@jcm_cmd_list;
	return $term->completion_matches($text,
					 $attribs->{'list_completion_function'});
    }
}

sub find_command {
    my $given = shift;
    my $name;
    my @completions = completeme($given, $given, 0, length($given));
    if ($#completions == 0) {
	$name = shift @completions;
    }

    return $name;
}

# start making requests
sub process_line {
  foo:
    $line = $term->readline("obdcontrol > ");
    execute_line($line);
    goto foo;
}

sub execute_line {
    my $line = shift;

    my @arg = split(' ', $line);
    my $word = shift @arg;

    my $cmd = find_command($word);
    unless ($cmd) {
	printf STDERR "$word: No such command, or not unique.\n";
	return (-1);
    }

    if ($cmd eq "help" || $cmd eq "exit" || $cmd eq "quit") {
	return (&{$commands{$cmd}->{func}}(@arg));
    }

    # Call the function.
    return (&{$commands{$cmd}->{func}}(@arg));
}

sub Setup {
    my $err = 0;
    my $packed = pack("L", $::st->rdev());
    my $rc = ioctl(DEV_OBD, &OBD_IOC_SETUP_SUPER, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Cleanup {
    my $err = "0";
    my $rc = ioctl(DEV_OBD, &OBD_IOC_CLEANUP_SUPER, $err);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}


sub Connect {
    my $id = 0;
    my $ino = 0;
    my $bs = 0;
    my $bs_b = 0;
    my $rc;

    # unsigned int conn_id;
    # unsigned long conn_ino;
    # unsigned long conn_blocksize;
    # unsigned char conn_blocksize_bits;

    my $packed = pack("ILLC", $id, $ino, $bs, $bs_b);
    $rc = ioctl(DEV_OBD, &OBD_IOC_CONNECT, $packed);
    ($id, $ino, $bs, $bs_b) = unpack("ILLC", $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	$::client_id = $id;
	print "Client ID     : $id\n";
	print "Root inode    : $ino\n";
	print "Blocksize     : $bs\n";
	print "Blocksize bits: $bs_b\n";
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Disconnect {
    my $id = shift;

    if (!defined($id)) {
	$id = $::client_id;
    }

    if (!defined($id)) {
	print "syntax: disconnect [client ID]\n";
	print "When client ID is not given, the last valid client ID to be returned by a\n";
	print "connect command this session is used; there is no such ID.\n";
	return;
    }

    my $packed = pack("L", $id);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_DISCONNECT, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	$::client_id = undef;
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Create {
    my $arg = shift;
    my $quiet = shift;
    my $rc;

    if (defined($quiet) && !($quiet eq "quiet")) {
	print "syntax: create [number of objects [quiet]]\n";
	return;
    }

    my $packed = pack("I", $::client_id);
    if (!defined($arg) || scalar($arg) < 2) {
	print "Creating 1 object...\n";
	my $packed = pack("I", 0);
	$rc = ioctl(DEV_OBD, &OBD_IOC_CREATE, $packed);
	if (!defined($quiet)) {
	    my $ino = unpack("L", $packed);
	    print "Created object #$ino.\n";
	}
    } else {
	my $i;

	print "Creating " . scalar($arg) . " objects...\n";
	for ($i = 0; $i < scalar($arg); $i++) {
	    $rc = ioctl(DEV_OBD, &OBD_IOC_CREATE, $packed);
	    my $ino = unpack("L", $packed);
	    if (!($rc eq "0 but true") || $packed == 0) {
		last;
	    } elsif (!defined($quiet)) {
		print "Created object #$ino.\n";
	    }
	}
    }

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Sync {
    my $err = "0";
    my $rc = ioctl(DEV_OBD, &OBD_IOC_SYNC, $err);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Destroy {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $arg = shift;

    if (!defined($arg) || scalar($arg) < 1) {
	print "destroy requires the object number to destroy.\n";
	return;
    }

    print "Destroying object $arg...\n";
    my $packed = pack("IL", $::client_id, $arg);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_DESTROY, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Getattr {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;

    if (!defined($inode) || scalar($inode) < 1) {
	print "invalid arguments; type \"help getattr\" for a synopsis\n";
	return;
    }

    # see Setattr
    my $packed = pack("ILsx2lLLLI", $::client_id, $inode, 0, 0, 0, 0, 0, 0, 0,
		      0);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_GETATTR, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	my ($valid, $mode, $uid, $gid, $size, $atime, $mtime, $ctime, $flags);
	($valid, $mode, $uid, $gid, $size, $atime, $mtime, $ctime, $flags) =
	  unpack("ISssx2lLLLI", $packed);

	printf("Inode: %d  Mode:  %o\n", $inode, $mode);
	printf("User: %6d   Group: %6d   Size: %d\n", $uid, $gid, $size);
	printf("ctime: %08lx -- %s\n", $ctime, scalar(gmtime($ctime)));
	printf("atime: %08lx -- %s\n", $atime, scalar(gmtime($atime)));
	printf("mtime: %08lx -- %s\n", $mtime, scalar(gmtime($mtime)));
	printf("flags: %08x\n", $flags);
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Setattr {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;
    my $valid = 0;
    my $mode = oct(shift);
    my $uid = shift;
    my $gid = shift;
    my $size = shift;
    my $atime = shift;
    my $mtime = shift;
    my $ctime = shift;

    if (defined($uid)) {
	$valid |= &ATTR_UID;
    }
    if (defined($gid)) {
	$valid |= &ATTR_GID;
    }
    if (defined($size)) {
	$valid |= &ATTR_SIZE;
    }
    if (defined($atime)) {
	$valid |= &ATTR_ATIME;
    }
    if (defined($mtime)) {
	$valid |= &ATTR_MTIME;
    }
    if (defined($ctime)) {
	$valid |= &ATTR_CTIME;
    }
    if (defined($mode)) {
	$valid |= &ATTR_MODE;
    }

    if (!defined($inode) || scalar($inode) < 1) {
	print "invalid arguments; type \"help setattr\" for a synopsis\n";
	return;
    }

    #struct iattr {
    #        unsigned int    ia_valid; (32)
    #        umode_t         ia_mode; (16)
    #        uid_t           ia_uid; (16)
    #        gid_t           ia_gid; (16)
    # -- 16 bit alignment here! --
    #        off_t           ia_size; (32)
    #        time_t          ia_atime; (32)
    #        time_t          ia_mtime; (32)
    #        time_t          ia_ctime; (32)
    #        unsigned int    ia_attr_flags; (32)
    #};

    printf "valid is %x, mode is %o\n", $valid, $mode;
    my $packed = pack("ILLSssx2ILLLL", $::client_id, $inode, $valid, $mode,
		      $uid, $gid, $size, $atime, $mtime, $ctime, 0);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_SETATTR, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Read {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;
    my $count = shift;
    my $offset = shift;
  
    if (!defined($inode) || scalar($inode) < 1 || !defined($count) ||
	$count < 1 || (defined($offset) && $offset < 0)) {
	print "invalid arguments; type \"help read\" for a synopsis\n";
	return;
    }

    if (!defined($offset)) {
	$offset = 0;
    }

    print("Reading $count bytes starting at byte $offset from object " .
	  "$inode...\n");

    # "allocate" a large enough buffer
    my $buf = sprintf("%${count}s", " ");
    die "suck" if (length($buf) != $count);

    # the perl we're using doesn't support pack type Q, and offset is 64 bits
    my $packed = pack("ILpLLL", $::client_id, $inode, $buf, $count, 0, $offset);

    my $rc = ioctl(DEV_OBD, &OBD_IOC_READ, $packed);

    $retval = unpack("l", $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	if ($retval >= 0) {
		print substr($buf, 0, $retval);
		print "\nRead $retval of an attempted $count bytes.\n";
		print "Finished (success)\n";
	} else {
		print "Finished (error $retval)\n";
	}
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Write {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;
    my $offset = shift;
    my $text = join(' ', @_);
    my $count = length($text);

    if (!defined($inode) || scalar($inode) < 1 || !defined($offset) ||
	scalar($offset) < 0) {
	print "invalid arguments; type \"help write\" for a synopsis\n";
	return;
    }

    if (!defined($text)) {
	$text = "";
	$count = 0;
    }

    print("Writing $count bytes starting at byte $offset to object " .
	  "$inode...\n");

    # the perl we're using doesn't support pack type Q
    my $packed = pack("ILpLLL", $::client_id, $inode, $text, $count, 0, $offset);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_WRITE, $packed);

    $retval = unpack("l", $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	if ($retval >= 0) {
		print "\nWrote $retval of an attempted $count bytes.\n";
		print "Finished (success)\n";
	} else {
		print "Finished (error $retval)\n";
	}
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Preallocate {
    my $arg = shift;

    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    if (!defined($arg) || scalar($arg) < 1 || scalar($arg) > 32) {
	$arg = 32;
    }

    print "Preallocating $arg inodes...\n";
    my $packed = pack("LLx128", $::client_id, $arg);
    # client id, alloc, inodes[32]

    my $rc = ioctl(DEV_OBD, &OBD_IOC_PREALLOCATE, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	my $alloc = unpack("x4L", $packed);
	my @inodes = unpack("x8L32", $packed);
	my $i;

	print "Got $alloc inodes: ";
	foreach $i (@inodes) {
	    print $i . " ";
	}
	print "\nFinished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Decusecount {
    my $rc = ioctl(DEV_OBD, &OBD_IOC_DEC_USE_COUNT, 0);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Statfs {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    # struct statfs {
    #         long f_type;
    #         long f_bsize;
    #         long f_blocks;
    #         long f_bfree;
    #         long f_bavail;
    #         long f_files;
    #         long f_ffree;
    #         __kernel_fsid_t f_fsid; (64 bits)
    #         long f_namelen;
    #         long f_spare[6];
    # };

    my $packed = pack("LLLLLLLIILL6", $::client_id, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		      0, 0, 0, 0, 0, 0);

    my $rc = ioctl(DEV_OBD, &OBD_IOC_STATFS, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	my ($bsize, $blocks, $bfree, $bavail, $files, $ffree) =
	    unpack("x4LLLLLL", $packed);
	print("$bsize byte blocks: $blocks, " . ($blocks - $bfree) . " used, " .
	      "$bfree free ($bavail available).\n");
	print "$files files, " . ($files - $ffree) . " used, $ffree free.\n";
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Help {
    my $arg = shift;

    if ( !$arg || !$commands{$arg} ) {
	print "Comands: ", join( ' ', @jcm_cmd_list), "\n";
    } else {
	print "Usage: " .  $commands{$arg}->{doc} . "\n";
    }
}

sub Quit {
    if ($::client_id) {
	print "Disconnecting active session ($::client_id)...";
	Disconnect($::client_id);
    }
    exit;
}
