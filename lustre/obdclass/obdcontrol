#!/usr/bin/perl

#
# This code is issued under the GNU General Public License.
# See the file COPYING in this distribution
#
# Copyright (C) 1998, Stelias Computing
# 
# Modified for InterMezzo from Gordian's HSM bcache device/jcm module
# Copyright (C) 1999, Carnegie Mellon University
#
# Derived from InterMezzo's incontrol, modified for OBD's
# Copyright (C) 1999, Stelias Computing
#
#

#use strict;
BEGIN { require "asm/errno.ph" };
BEGIN { require "asm/ioctl.ph" };

# p2ph generated invalid macros for ioctl stuff, so I override some of it here
eval 'sub OBD_IOC_CREATE () { &_IOC(2, ord(\'f\'), 3, 4);}' unless
  defined(&OBD_IOC_CREATE);
eval 'sub OBD_IOC_SETUP () { &_IOC(1, ord(\'f\'), 4, 4);}' unless
  defined(&OBD_IOC_SETUP);
eval 'sub OBD_IOC_CLEANUP () { &_IOC(0, ord(\'f\'), 5, 0);}' unless
  defined(&OBD_IOC_CLEANUP);
eval 'sub OBD_IOC_DESTROY () { &_IOC(1, ord(\'f\'), 6, 4);}' unless
  defined(&OBD_IOC_DESTROY);
eval 'sub OBD_IOC_PREALLOCATE () { &_IOC(3, ord(\'f\'), 7, 4);}' unless
  defined(&OBD_IOC_PREALLOCATE);
eval 'sub OBD_IOC_DEC_USE_COUNT () { &_IOC(0, ord(\'f\'), 8, 0);}' unless
  defined(&OBD_IOC_DEC_USE_COUNT);
eval 'sub OBD_IOC_SETATTR () { &_IOC(1, ord(\'f\'), 9, 4);}' unless
  defined(&OBD_IOC_SETATTR);
eval 'sub OBD_IOC_GETATTR () { &_IOC(2, ord(\'f\'), 10, 4);}' unless
  defined(&OBD_IOC_GETATTR);
eval 'sub OBD_IOC_READ () { &_IOC(3, ord(\'f\'), 11, 4);}' unless
  defined(&OBD_IOC_READ);
eval 'sub OBD_IOC_WRITE () { &_IOC(3, ord(\'f\'), 12, 4);}' unless
  defined(&OBD_IOC_WRITE);
eval 'sub OBD_IOC_CONNECT () { &_IOC(2, ord(\'f\'), 13, 4);}' unless
  defined(&OBD_IOC_CONNECT);
eval 'sub OBD_IOC_DISCONNECT () { &_IOC(1, ord(\'f\'), 14, 4);}' unless
  defined(&OBD_IOC_DISCONNECT);
eval 'sub OBD_IOC_STATFS () { &_IOC(3, ord(\'f\'), 15, 4);}' unless
  defined(&OBD_IOC_STATFS);
eval 'sub OBD_IOC_SYNC () { &_IOC(2, ord(\'f\'), 16, 4);}' unless
  defined(&OBD_IOC_SYNC);
eval 'sub OBD_IOC_READ2 () { &_IOC(3, ord(\'f\'), 17, 4);}' unless
  defined(&OBD_IOC_READ2);
eval 'sub OBD_IOC_FORMATOBD () { &_IOC(3, ord(\'f\'), 18, 4);}' unless
  defined(&OBD_IOC_FORMATOBD);
eval 'sub OBD_IOC_PARTITION () { &_IOC(3, ord(\'f\'), 19, 4);}' unless
  defined(&OBD_IOC_PARTITION);
eval 'sub OBD_IOC_ATTACH () { &_IOC(3, ord(\'f\'), 20, 4);}' unless
  defined(&OBD_IOC_ATTACH);
eval 'sub OBD_IOC_DETACH () { &_IOC(3, ord(\'f\'), 21, 4);}' unless
  defined(&OBD_IOC_DETACH);
eval 'sub OBD_IOC_COPY () { &_IOC(3, ord(\'f\'), 22, 4);}' unless
  defined(&OBD_IOC_COPY);
eval 'sub OBD_IOC_MIGR () { &_IOC(3, ord(\'f\'), 23, 4);}' unless
  defined(&OBD_IOC_MIGR);
eval 'sub OBD_SNAP_SETTABLE () { &_IOC(3, ord(\'f\'), 40, 4);}' unless
  defined(&OBD_SNAP_SETTABLE);
eval 'sub OBD_SNAP_PRINTTABLE () { &_IOC(3, ord(\'f\'), 41, 4);}' unless
  defined(&OBD_SNAP_PRINTTABLE);
eval 'sub OBD_SNAP_DELETE() { &_IOC(3, ord(\'f\'), 42, 4);}' unless
  defined(&OBD_SNAP_DELETE);
eval 'sub OBD_SNAP_RESTORE() { &_IOC(3, ord(\'f\'), 43, 4);}' unless
  defined(&OBD_SNAP_RESTORE);

eval 'sub OBD_EXT2_RUNIT () { &_IOC(3, ord(\'f\'), 61, 4);}' unless
  defined(&OBD_EXT2_RUNIT);

eval 'sub ATTR_MODE () {1;}' unless defined(&ATTR_MODE);
eval 'sub ATTR_UID () {2;}' unless defined(&ATTR_UID);
eval 'sub ATTR_GID () {4;}' unless defined(&ATTR_GID);
eval 'sub ATTR_SIZE () {8;}' unless defined(&ATTR_SIZE);
eval 'sub ATTR_ATIME () {16;}' unless defined(&ATTR_ATIME);
eval 'sub ATTR_MTIME () {32;}' unless defined(&ATTR_MTIME);
eval 'sub ATTR_CTIME () {64;}' unless defined(&ATTR_CTIME);

use Getopt::Long;
use File::stat;
use Storable;
use Carp;
use Term::ReadLine;
use IO::Handle;


my ($file);

GetOptions("f!" => \$file, "device=s" => \$::device, ) || die "Getoptions";


# get a console for the app

my $line;
my $command;
my $arg;

my %commands =
    ('device' => {func => "Device", doc => "device <dev>: open another OBD device"},
     'create' => {func => "Create", doc => "create: creates a new inode"},
     'attach' => {func => "Attach", doc => "attach { ext2_obd | snap_obd snapdev snapidx tableno | scsi_obd adapter bus tid lun }" },
     'detach' => {func => "Detach", doc => "detach this device"},
     'testext2iterator' => {func => "TestExt2Iterator", doc => "test ext2 iterator function"},
     'snapset' => {func => "SnapSetTable", doc => "snapset <tableno> <file>: set the table (created with snaptable) as table #tableno" },
     'snapprint' => {func => "SnapPrint", doc => "snapprint <tableno>: output the contents of table #tableno to the syslog"},
     'snapdelete' => {func => "SnapDelete", doc => "snapdelete: delete connected snap obd objects from disk"},
     'snaprestore' => {func => "SnapRestore", doc => "snaprestore : restore connected old snap objects to be current"},
     'snaptable' => {func => "SnapShotTable", doc => "snaptable: build a snapshot table (interactive)"},
     'copy' => {func => "Copy", doc => "copy <srcid> <tgtid>: copy objects"},
     'migrate' => {func => "Migrate", doc => "migrate <srcid> <tgtid>: migrate data from one object to another"},
     'format' => {func => "Format", doc => "format type adapter bus tid lun size"},
     'partition' => {func => "Partition", doc => "partition type adapter bus tid lun partition size"},
     'setup' => {func => "Setup", doc => "setup [type]: link this OBD device to the underlying device (default type ext2_obd)"},
     'connect' => {func => "Connect", doc => "connect: allocates client ID for this session"},
     'disconnect' => {func => "Disconnect", doc => "disconnect [id]: frees client resources"},
     'sync' => {func => "Sync", doc => "sync: flushes buffers to disk"},
     'destroy' => {func => "Destroy", doc => "destroy <inode>: destroys an inode"},
     'cleanup' => {func => "Cleanup", doc => "cleanup the minor obd device"},
     'dec_use_count' => {func => "Decusecount", doc => "decreases the module use count so that the module can be removed following an oops"},
     'read' => {func => "Read", doc => "read <inode> <count> [offset]"},
     'fsread' => {func => "Read2", doc => "read <inode> <count> [offset]"},
     'write' => {func => "Write", doc => "write <inode> <offset> <text>"},
     'setattr' => {func => "Setattr", doc => "setattr <inode> [mode [uid [gid [size [atime [mtime [ctime]]]]]]]"},
     'getattr' => {func => "Getattr", doc => "getattr <inode>: displays inode object attributes"},
     'preallocate' => {func => "Preallocate", doc => "preallocate [num]: requests preallocation of num inodes."},
     'statfs' => {func => "Statfs", doc => "statfs: filesystem status information"},
     'help' => {func => \&Help,  doc => "help: this message"},
     'quit' => {func => \&Quit,  doc => "see \"exit\""},
     'exit' => {func => \&Quit,  doc => "see \"quit\""}
    );

#
#	setup completion function
#
my @jcm_cmd_list = keys %commands;

my $term, $attribs;


# Get going....

Device($::device);

sub readl {
    if ( $file ) {
	my $str = <STDIN>;
	chop($str);
	return $str;
    } else {
        return $term->readline(@_);
    }
}



if ( $file ) {
    while ( <STDIN> ) {
        print $_;
        execute_line($_);
    }
    exit 0;
} else {
    $term = new Term::ReadLine 'obdcontrol ';
    $attribs = $term->Attribs;
    $attribs->{attempted_completion_function} = \&completeme;
    $term->ornaments('md,me,,');	# bold face prompt
    
    # make sure stdout is not buffered
    STDOUT->autoflush(1);


    # Get on with the show
    process_line();
}

#------------------------------------------------------------------------------
sub completeme {
    my ($text, $line, $start, $end) = @_;
    if (substr($line, 0, $start) =~ /^\s*$/) {
	$attribs->{completion_word} = \@jcm_cmd_list;
	return $term->completion_matches($text,
					 $attribs->{'list_completion_function'});
    }
}

sub find_command {
    my $given = shift;
    my $name;
    my @completions = completeme($given, $given, 0, length($given));
    if ($#completions == 0) {
	$name = shift @completions;
    }

    return $name;
}

# start making requests
sub process_line {
  foo:
    $line = $term->readline("obdcontrol > ");
    execute_line($line);
    goto foo;
}

sub execute_line {
    my $line = shift;

    my @arg = split(' ', $line);
    my $word = shift @arg;

    my $cmd;
    if ( $file ) {
	$cmd = $word;
    } else {
	$cmd = find_command($word);
    }
    unless ($cmd) {
	printf STDERR "$word: No such command, or not unique.\n";
	return (-1);
    }

    if ($cmd eq "help" || $cmd eq "exit" || $cmd eq "quit") {
	return (&{$commands{$cmd}->{func}}(@arg));
    }

    # Call the function.
    return (&{$commands{$cmd}->{func}}(@arg));
}


# select the OBD device we talk to
sub Device {
    my $device = shift;

    if ($::client_id) {
	print "Disconnecting active session ($::client_id)...";
	Disconnect($::client_id);
    }
    if (! $device ) {
	$device = "/dev/obd0";
    }
    $::device = $device;
    # Open the device, as we need an FD for the ioctl
    sysopen(DEV_OBD, $device, 0) || die "Cannot open $device";
    print "Device now $device\n";
}



sub Attach {
    my $err = 0;
    my $type = shift;
    my $data;
    my $datalen = 0;

    if ( ! $type ) {
	print "error: missing type\n";
usage:
	print "usage: attach {ext2_obd | snap_obd | scsi_obd}\n";
	return;
    }

    if ($type eq "scsi_obd" ) {
	my $adapter = shift;
	my $bus = shift;
	my $tid = shift;
	my $lun = shift;

	$data = pack("iiii", $adapter, $bus, $tid, $lun);
	$datalen = 4 * 4;
    } elsif ($type eq "snap_obd" ) {
	my $snapdev = shift;
	my $snapidx = shift;
	my $tableno = shift;

	$data = pack("iii", $snapdev, $snapidx, $tableno);
	$datalen = 3 * 4;
    } elsif ($type eq "ext2_obd") {
	1;
    } else {
	print "error: unknown attach type $type\n";
	goto usage;
    }

    my $len = length($type);
    my $cl = length($data);

    print "type $type (len $len), datalen $datalen ($cl)\n";
    my $packed = pack("Lipip", $::client_id, length($type), $type, $datalen, $data);

    my $rc = ioctl(DEV_OBD, &OBD_IOC_ATTACH, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Detach {
    my $err = 0;
    my $data = "";
    my $rc = ioctl(DEV_OBD, &OBD_IOC_DETACH, $data);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}


sub TestExt2Iterator { 
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $err = 0;
    my $type = "ext2_obd";
 
    $data = pack("i", 4711); # bogus data
    $datalen = 4;

    my $len = length($type);
    my $cl = length($data);
    my $add = pack("p", $data);
    print "type $type (len $len), datalen $datalen ($cl)\n";
    my $packed = pack("Lipip", $::client_id, length($type), $type, $datalen, $data);

    my $rc = ioctl(DEV_OBD, &OBD_EXT2_RUNIT, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}


sub SnapDelete { 
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $err = 0;
    my $type = "snap_obd";
 
    $data = pack("i", 4711); # bogus data
    $datalen = 4;

    my $len = length($type);
    my $cl = length($data);
    my $add = pack("p", $data);
    print "type $type (len $len), datalen $datalen ($cl)\n";
    my $packed = pack("Lipip", $::client_id, length($type), $type, $datalen, $data);

    # XXX We need to fix this up so that after the objects in this snapshot
    #     are deleted, the snapshot itself is also removed from the table.
    my $rc = ioctl(DEV_OBD, &OBD_SNAP_DELETE, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}


#      this routine does the whole job
sub SnapRestore { 
    my $restoreto = shift;
    my $snaptable = shift;
    my $tableno = shift;
    my $restoretime;

    # don't do anything until connected
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    if ( ! $snaptable || ! defined $restoreto ) {
	print "Usage: snaprestore \"restore to slot\" \"snaptable\" \"tableno\"\n";
	return;
    }

    if ( ! -f $snaptable ) {
	print "Table $snaptable doesn't exist\n";
	return;
    }
   
    my $table = ReadSnapShotTable($snaptable);
    $restoretime = FindSnapInTable($table, $restoreto);
    if ( ! defined $table->{0} || ! defined $restoretime ) {
	PrintSnapShotTable($table);
	print "No current or $restoreto slot in this table\n";
	return;
    }

    my $currentindex = $table->{0};
    if (  $table->{$restoretime} == $currentindex ) {
	print "You should not restore to the current snapshot\n";
	return;
    }
    
    # swap the entries for 0 and $restoreto
    my $tmp = $table->{$restoretime};
    $table->{$restoretime} = $table->{0};
    $table->{0} = $tmp;
    # PrintSnapShotTable($table);

    # write it back
    WriteSnapShotTable($snaptable, $table);

    # set it in the kernel
    SnapSetTable($tableno, $snaptable);

    # ready for the ioctl
    my $err = 0;
    my $type = "snap_obd";
    $data = pack("i", $currentindex); # slot of previous current snapshot 
    $datalen = 4;

    my $len = length($type);
    my $cl = length($data);
    my $packed = pack("Lipip", $::client_id, length($type), $type, $datalen, $data);

    my $rc = ioctl(DEV_OBD, &OBD_SNAP_RESTORE, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Snaprestore finished (success)\n";
	delete $table->{$restoretime} if defined $restoretime;
	# write it back
	WriteSnapShotTable($snaptable, $table);
	
	# set it in the kernel
	SnapSetTable($tableno, $snaptable);
	# PrintSnapShotTable($table);

    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub FindSnapInTable { 
    my $table = shift;
    my $snapno =shift;

    foreach my $restoretime ( keys %{$table} ) {
	if ( $table->{$restoretime} == $snapno) { 
	    print "Found key $restoretime for snapno $snapno\n";
	    return $restoretime;
	}
    }
    undef;
}
	    

sub SnapPrint { 
    my $err = 0;
    my $type = "snap_obd";
    my $snaptableno = shift;

    $data = pack("i", $snaptableno);
    $datalen = 4;

    my $len = length($type);
    my $cl = length($data);
    my $add = pack("p", $data);
    print "type $type (len $len), datalen $datalen ($cl)\n";
    my $packed = pack("Lipip", $::client_id, length($type), $type, $datalen, $data);

    my $rc = ioctl(DEV_OBD, &OBD_SNAP_PRINTTABLE, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub SnapSetTable {
    my $err = 0;
    my $type = "snap_obd";
    my $snaptableno = shift;
    my $file = shift;
    my $snapcount;
    my $table = {};
    my $data;
    my $datalen = 0;

    if ( ! -f $file ) {
	print "No such file $file\n";
    }

    $table = ReadSnapShotTable($file);

    $snapcount = keys %{$table};
    print "Snapcount $snapcount\n";

    if ( ! defined $table->{0} ) {
	print "No current snapshot in table! First make one\n";
	return ;
    }
    $data = pack("ii", $snaptableno, $snapcount);
    $datalen = 2 * 4;
    foreach my $time (sort keys %{$table}) {
	$data .= pack("Ii", $time, $table->{$time});
	$datalen += 8;
    }

    my $len = length($type);
    my $cl = length($data);
    my $add = pack("p", $data);
    print "type $type (len $len), datalen $datalen ($cl)\n";
    my $packed = pack("Lipip", $::client_id, length($type), $type, $datalen, $data);

    my $rc = ioctl(DEV_OBD, &OBD_SNAP_SETTABLE, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}


sub SnapShotTable  {

    my $file = &readl("enter file name: ");
    if ( ! -f $file ) {
	`touch $file`;
    }
    my $table = ReadSnapShotTable($file);
  
  again:
    PrintSnapShotTable($table);
    my $action = &readl("Add, Delete or Quit [adq]: ");
    goto done if ($action  =~ "^q.*" );
    goto add if ($action =~ "^a.*");
    goto del  if ($action =~ "^d.*");
    goto again;

  add:
    my $idx = &readl("enter index where you want this snapshot: ");
    my $time = &readl("enter time or 'now' or 'current': ");
    my $oldtime = SnapFindTimeFromIdx($idx, $table);
    if (defined $oldtime) {
	print "This already exists, first clean up\n";
	goto again;
    }

    if ( $time  eq 'now' ) {
	$time = time;
    } elsif ( $time eq 'current' ) { 
	$time = 0;
    }
    $table->{$time} = $idx;
    goto again;

  del:
    $didx = &readl("Enter index to delete: ");
    my $deltime = SnapFindTimeFromIdx($didx, $table);
    delete $table->{$deltime} if defined $deltime;
    goto again;

  done:
    my $ok = &readl("OK with new table? [Yn]: ");
    unless ( $ok eq "n" )  {
	WriteSnapShotTable($file, $table);
    }
}

sub SnapFindTimeFromIdx {
    my $idx = shift;
    my $table = shift;

    foreach my $time ( keys %{$table} ) {
	if ( $table->{$time} == $idx ) {
	    return $time;
	}
    }
    undef;
}

sub PrintSnapShotTable {
    my $table = shift;
    my $time;
    
    foreach  $time ( sort keys %{$table} ) {
	my $stime = localtime($time);
	if ( ! $time ) { 
	    $stime = "current";
	}
	printf "Time: %s -- Index %d\n", $stime, $table->{$time};
    }
}

sub ReadSnapShotTable {

    my $file = shift;
    my $table = {};

    open FH, "<$file";
    while ( <FH> ) {
	my ($time, $index) = split ;
	$table->{$time} = $index;
    }
    close FH;

    PrintSnapShotTable($table);

    return $table;
}

sub WriteSnapShotTable {
    my $file = shift;
    my $table = shift;

    open FH, ">$file";
    foreach my $time ( sort keys %{$table}  ) {
	print FH "$time $table->{$time}\n";
    }
    close FH;
}

sub Copy {
    my $err = 0;
    my $srcid = shift;
    my $dstid = shift;

    # Note: _copy IOCTL takes parameters as dst, src.
    #       Copy function takes parameters as src, dst.
    my $data = pack("III", $::client_id, $dstid, $srcid);
    my $datalen = 12;

    my $packed = pack("ip", $datalen, $data);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_COPY, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Migrate {
    my $err = 0;
    my $srcid = shift;
    my $dstid = shift;

    # Note: _migr IOCTL takes parameters as dst, src.
    #       Migrate function takes parameters as src, dst.
    my $data = pack("III", $::client_id, $dstid, $srcid);
    my $datalen = 12;

    my $packed = pack("ip", $datalen, $data);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_MIGR, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}


sub Format {
    my $err = 0;
    my $size = shift;
    my $data = pack("i", $size);
    my $datalen = 4;

    my $packed = pack("ip", $datalen, $data);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_FORMATOBD, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Partition {
    my $err = 0;
    my $partno = shift;
    my $size = shift;
    my $data = pack("ii", $partno, $size);
    my $datalen = 2 * 4;

    my $packed = pack("ip", $datalen, $data);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_PARTITION, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Setup {
    my $err = 0;
    my $arg = shift;
    my $data;
    my $datalen = 0;

    # XXX we need a getinfo ioctl to validate parameters 
    # by type here

    if ($arg  && !defined($::st = stat($arg))) {
	    print "$arg is not a valid device\n";
	    return;
    }
    
    if ( $arg ) {
	$dev = $::st->rdev() unless $dev;
	$data = pack("i", $dev);
	$datalen = 4;
    }

    my $packed = pack("ip", $datalen, $data);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_SETUP, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Cleanup {
    my $err = "0";
    my $rc = ioctl(DEV_OBD, &OBD_IOC_CLEANUP, $err);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
	$::client_id = 0;
    } else {
	print "ioctl returned error code $rc.\n";
    }
}


sub Connect {
    my $rc;

    my $packed = "";
    $rc = ioctl(DEV_OBD, &OBD_IOC_CONNECT, $packed);
    $id = unpack("I", $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	$::client_id = $id;
	print "Client ID     : $id\n";
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Disconnect {
    my $id = shift;

    if (!defined($id)) {
	$id = $::client_id;
    }

    if (!defined($id)) {
	print "syntax: disconnect [client ID]\n";
	print "When client ID is not given, the last valid client ID to be returned by a\n";
	print "connect command this session is used; there is no such ID.\n";
	return;
    }

    my $packed = pack("L", $id);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_DISCONNECT, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	$::client_id = undef;
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Create {
    my $arg = shift;
    my $quiet = shift;
    my $rc;
    my $prealloc = 0;

    if (defined($quiet) && $quiet ne "quiet") {
	print "syntax: create [number of objects [quiet]]\n";
	return;
    }

    my $packed = pack("IL", $::client_id, $prealloc);
    if (!defined($arg) || scalar($arg) < 2) {
	print "Creating 1 object...\n";
	$rc = ioctl(DEV_OBD, &OBD_IOC_CREATE, $packed);
	if (!defined($quiet)) {
	    my $ino = unpack("L", $packed);
	    print "Created object #$ino.\n";
	}
    } else {
	my $i;

	print "Creating " . scalar($arg) . " objects...\n";
	for ($i = 0; $i < scalar($arg); $i++) {
	    $rc = ioctl(DEV_OBD, &OBD_IOC_CREATE, $packed);
	    my $ino = unpack("L", $packed);
	    if ($rc ne "0 but true") {
		last;
		$packed = pack("IL", $::client_id, $prealloc);
	    } elsif (!defined($quiet)) {
		$packed = pack("IL", $::client_id, $prealloc);
		print "Created object #$ino.\n";
	    }
	}
    }

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Sync {
    my $err = "0";
    my $rc = ioctl(DEV_OBD, &OBD_IOC_SYNC, $err);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Destroy {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $arg = shift;

    if (!defined($arg) || scalar($arg) < 1) {
	print "destroy requires the object number to destroy.\n";
	return;
    }

    print "Destroying object $arg...\n";
    my $packed = pack("IL", $::client_id, $arg);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_DESTROY, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Getattr {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;

    if (!defined($inode) || scalar($inode) < 1) {
	print "invalid arguments; type \"help getattr\" for a synopsis\n";
	return;
    }

    # see Setattr
    my $packed = pack("ILsx2lLLLI", $::client_id, $inode, 0, 0, 0, 0, 0, 0, 0,
		      0);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_GETATTR, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	my ($valid, $mode, $uid, $gid, $size, $atime, $mtime, $ctime, $flags);
	($valid, $mode, $uid, $gid, $size, $atime, $mtime, $ctime, $flags) =
	  unpack("ISssx2lLLLI", $packed);

	printf("Inode: %d  Mode:  %o\n", $inode, $mode);
	printf("User: %6d   Group: %6d   Size: %d\n", $uid, $gid, $size);
	printf("ctime: %08lx -- %s\n", $ctime, scalar(gmtime($ctime)));
	printf("atime: %08lx -- %s\n", $atime, scalar(gmtime($atime)));
	printf("mtime: %08lx -- %s\n", $mtime, scalar(gmtime($mtime)));
	printf("flags: %08x\n", $flags);
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Setattr {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;
    my $valid = 0;
    my $mode = oct(shift);
    my $uid = shift;
    my $gid = shift;
    my $size = shift;
    my $atime = shift;
    my $mtime = shift;
    my $ctime = shift;

    if (defined($uid)) {
	$valid |= &ATTR_UID;
    }
    if (defined($gid)) {
	$valid |= &ATTR_GID;
    }
    if (defined($size)) {
	$valid |= &ATTR_SIZE;
    }
    if (defined($atime)) {
	$valid |= &ATTR_ATIME;
    }
    if (defined($mtime)) {
	$valid |= &ATTR_MTIME;
    }
    if (defined($ctime)) {
	$valid |= &ATTR_CTIME;
    }
    if (defined($mode)) {
	$valid |= &ATTR_MODE;
    }

    if (!defined($inode) || scalar($inode) < 1) {
	print "invalid arguments; type \"help setattr\" for a synopsis\n";
	return;
    }

    #struct iattr {
    #        unsigned int    ia_valid; (32)
    #        umode_t         ia_mode; (16)
    #        uid_t           ia_uid; (16)
    #        gid_t           ia_gid; (16)
    # -- 16 bit alignment here! --
    #        off_t           ia_size; (32)
    #        time_t          ia_atime; (32)
    #        time_t          ia_mtime; (32)
    #        time_t          ia_ctime; (32)
    #        unsigned int    ia_attr_flags; (32)
    #};

    printf "valid is %x, mode is %o\n", $valid, $mode;
    my $packed = pack("ILLSssx2ILLLL", $::client_id, $inode, $valid, $mode,
		      $uid, $gid, $size, $atime, $mtime, $ctime, 0);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_SETATTR, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Read {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;
    my $count = shift;
    my $offset = shift;
  
    if (!defined($inode) || scalar($inode) < 1 || !defined($count) ||
	$count < 1 || (defined($offset) && $offset < 0)) {
	print "invalid arguments; type \"help read\" for a synopsis\n";
	return;
    }

    if (!defined($offset)) {
	$offset = 0;
    }

    print("Reading $count bytes starting at byte $offset from object " .
	  "$inode...\n");

    # "allocate" a large enough buffer
    my $buf = sprintf("%${count}s", " ");
    die "suck" if (length($buf) != $count);

    # the perl we're using doesn't support pack type Q, and offset is 64 bits
    my $packed = pack("ILpLLL", $::client_id, $inode, $buf, $count, $offset, 0);

    my $rc = ioctl(DEV_OBD, &OBD_IOC_READ, $packed);

    $retval = unpack("l", $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	if ($retval >= 0) {
		print substr($buf, 0, $retval);
		print "\nRead $retval of an attempted $count bytes.\n";
		print "Finished (success)\n";
	} else {
		print "Finished (error $retval)\n";
	}
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Read2 {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;
    my $count = shift;
    my $offset = shift;
  
    if (!defined($inode) || scalar($inode) < 1 || !defined($count) ||
	$count < 1 || (defined($offset) && $offset < 0)) {
	print "invalid arguments; type \"help read\" for a synopsis\n";
	return;
    }

    if (!defined($offset)) {
	$offset = 0;
    }

    print("Reading $count bytes starting at byte $offset from object " .
	  "$inode...\n");

    # "allocate" a large enough buffer
    my $buf = sprintf("%${count}s", " ");
    die "suck" if (length($buf) != $count);

    # the perl we're using doesn't support pack type Q, and offset is 64 bits
    my $packed = pack("ILpLLL", $::client_id, $inode, $buf, $count, $offset, 0);

    my $rc = ioctl(DEV_OBD, &OBD_IOC_READ2, $packed);

    $retval = unpack("l", $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	if ($retval >= 0) {
		print substr($buf, 0, $retval);
		print "\nRead $retval of an attempted $count bytes.\n";
		print "Finished (success)\n";
	} else {
		print "Finished (error $retval)\n";
	}
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Write {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    my $inode = shift;
    my $offset = shift;
    my $text = join(' ', @_);
    my $count = length($text);

    if (!defined($inode) || scalar($inode) < 1 || !defined($offset) ||
	scalar($offset) < 0) {
	print "invalid arguments; type \"help write\" for a synopsis\n";
	return;
    }

    if (!defined($text)) {
	$text = "";
	$count = 0;
    }

    print("Writing $count bytes starting at byte $offset to object " .
	  "$inode...\n");

    # the perl we're using doesn't support pack type Q
    my $packed = pack("ILpLLL", $::client_id, $inode, $text, $count, $offset, 0);
    my $rc = ioctl(DEV_OBD, &OBD_IOC_WRITE, $packed);

    $retval = unpack("l", $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	if ($retval >= 0) {
		print "\nWrote $retval of an attempted $count bytes.\n";
		print "Finished (success)\n";
	} else {
		print "Finished (error $retval)\n";
	}
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Preallocate {
    my $arg = shift;

    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    if (!defined($arg) || scalar($arg) < 1 || scalar($arg) > 32) {
	$arg = 32;
    }

    print "Preallocating $arg inodes...\n";
    my $packed = pack("LLx128", $::client_id, $arg);
    # client id, alloc, inodes[32]

    my $rc = ioctl(DEV_OBD, &OBD_IOC_PREALLOCATE, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	my $alloc = unpack("x4L", $packed);
	my @inodes = unpack("x8L32", $packed);
	my $i;

	print "Got $alloc inodes: ";
	foreach $i (@inodes) {
	    print $i . " ";
	}
	print "\nFinished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Decusecount {
    my $rc = ioctl(DEV_OBD, &OBD_IOC_DEC_USE_COUNT, 0);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Statfs {
    if (!defined($::client_id)) {
	print "You must first ``connect''.\n";
	return;
    }

    # struct statfs {
    #         long f_type;
    #         long f_bsize;
    #         long f_blocks;
    #         long f_bfree;
    #         long f_bavail;
    #         long f_files;
    #         long f_ffree;
    #         __kernel_fsid_t f_fsid; (64 bits)
    #         long f_namelen;
    #         long f_spare[6];
    # };

    my $packed = pack("LLLLLLLIILL6", $::client_id, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		      0, 0, 0, 0, 0, 0);

    my $rc = ioctl(DEV_OBD, &OBD_IOC_STATFS, $packed);

    if (!defined $rc) {
	print STDERR "ioctl failed: $!\n";
    } elsif ($rc eq "0 but true") {
	# skip both the conn_id and the fs_type in the buffer
	my ($bsize, $blocks, $bfree, $bavail, $files, $ffree) =
	    unpack("x4x4LLLLLL", $packed);
	print("$bsize byte blocks: $blocks, " . ($blocks - $bfree) . " used, " .
	      "$bfree free ($bavail available).\n");
	print "$files files, " . ($files - $ffree) . " used, $ffree free.\n";
	print "Finished (success)\n";
    } else {
	print "ioctl returned error code $rc.\n";
    }
}

sub Help {
    my $arg = shift;

    if ( !$arg || !$commands{$arg} ) {
	print "Comands: ", join( ' ', @jcm_cmd_list), "\n";
    } else {
	print "Usage: " .  $commands{$arg}->{doc} . "\n";
    }
}

sub Quit {
    if ($::client_id) {
	print "Disconnecting active session ($::client_id)...";
	Disconnect($::client_id);
    }
    exit;
}
